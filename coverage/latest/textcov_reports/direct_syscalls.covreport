_RINvXs_NtCs8HwUKyRtzLJ_6anyhow7contextINtNtCshM4Il2Z0i4R_4core6option6OptionRINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EEINtB7_7ContextB1c_NtNtBF_7convert10InfallibleE7contextReECsitTtQF8ArIt_8fvm_fuzz:
   91|  1.22k|    fn context<C>(self, context: C) -> Result<T, Error>
   92|  1.22k|    where
   93|  1.22k|        C: Display + Send + Sync + 'static,
   94|  1.22k|    {
   95|  1.22k|        self.ok_or_else(|| Error::from_display(context, backtrace!()))
   96|  1.22k|    }
_RINvXNtCs8HwUKyRtzLJ_6anyhow7contextINtNtCshM4Il2Z0i4R_4core6result6ResultNtNtNtCs7Ei498kZF3p_3fvm7machine8manifest8ManifestNtB5_5ErrorEINtB5_7ContextB1a_B1Y_E7contextNtNtCs6UoH8pR2orC_21fvm_integration_tests5error5ErrorECsitTtQF8ArIt_8fvm_fuzz:
   46|    102|    fn context<C>(self, context: C) -> Result<T, Error>
   47|    102|    where
   48|    102|        C: Display + Send + Sync + 'static,
   49|    102|    {
   50|    102|        // Not using map_err to save 2 useless frames off the captured backtrace
   51|    102|        // in ext_context.
   52|    102|        match self {
   53|    102|            Ok(ok) => Ok(ok),
   54|      0|            Err(error) => Err(error.ext_context(context)),
   55|       |        }
   56|    102|    }
_RINvXs_NtCs8HwUKyRtzLJ_6anyhow7contextINtNtCshM4Il2Z0i4R_4core6option6OptionTmINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EEEINtB7_7ContextB1c_NtNtBF_7convert10InfallibleE7contextReECsitTtQF8ArIt_8fvm_fuzz:
   91|    102|    fn context<C>(self, context: C) -> Result<T, Error>
   92|    102|    where
   93|    102|        C: Display + Send + Sync + 'static,
   94|    102|    {
   95|    102|        self.ok_or_else(|| Error::from_display(context, backtrace!()))
   96|    102|    }
_RINvXNtCs8HwUKyRtzLJ_6anyhow7contextINtNtCshM4Il2Z0i4R_4core6result6ResultINtNtCshRBVfIqfJKm_13fvm_ipld_hamt4hamt4HamtINtNtNtCs7Ei498kZF3p_3fvm10blockstore8buffered18BufferedBlockstoreNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreENtNtB1Z_10state_tree10ActorStateENtNtB1f_5error5ErrorEINtB5_7ContextB1a_B4w_E7contextReECsitTtQF8ArIt_8fvm_fuzz:
   46|    102|    fn context<C>(self, context: C) -> Result<T, Error>
   47|    102|    where
   48|    102|        C: Display + Send + Sync + 'static,
   49|    102|    {
   50|    102|        // Not using map_err to save 2 useless frames off the captured backtrace
   51|    102|        // in ext_context.
   52|    102|        match self {
   53|    102|            Ok(ok) => Ok(ok),
   54|      0|            Err(error) => Err(error.ext_context(context)),
   55|       |        }
   56|    102|    }
_RINvXNtCs8HwUKyRtzLJ_6anyhow7contextINtNtCshM4Il2Z0i4R_4core6result6ResultbNtB5_5ErrorEINtB5_7ContextbB1b_E7contextReECsitTtQF8ArIt_8fvm_fuzz:
   46|    102|    fn context<C>(self, context: C) -> Result<T, Error>
   47|    102|    where
   48|    102|        C: Display + Send + Sync + 'static,
   49|    102|    {
   50|    102|        // Not using map_err to save 2 useless frames off the captured backtrace
   51|    102|        // in ext_context.
   52|    102|        match self {
   53|    102|            Ok(ok) => Ok(ok),
   54|      0|            Err(error) => Err(error.ext_context(context)),
   55|       |        }
   56|    102|    }
_RINvXNtCs8HwUKyRtzLJ_6anyhow7contextINtNtCshM4Il2Z0i4R_4core6result6ResultINtNtCs1slUOa8tBso_3cid3cid3CidKj40_ENtB5_5ErrorEINtB5_7ContextB1a_B1L_E7contextNtNtCs6UoH8pR2orC_21fvm_integration_tests5error5ErrorECsitTtQF8ArIt_8fvm_fuzz:
   46|    408|    fn context<C>(self, context: C) -> Result<T, Error>
   47|    408|    where
   48|    408|        C: Display + Send + Sync + 'static,
   49|    408|    {
   50|    408|        // Not using map_err to save 2 useless frames off the captured backtrace
   51|    408|        // in ext_context.
   52|    408|        match self {
   53|    408|            Ok(ok) => Ok(ok),
   54|      0|            Err(error) => Err(error.ext_context(context)),
   55|       |        }
   56|    408|    }
_RINvXNtCs8HwUKyRtzLJ_6anyhow7contextINtNtCshM4Il2Z0i4R_4core6result6ResultuNtB5_5ErrorEINtB5_7ContextuB1b_E7contextNtNtCs6UoH8pR2orC_21fvm_integration_tests5error5ErrorECsitTtQF8ArIt_8fvm_fuzz:
   46|    306|    fn context<C>(self, context: C) -> Result<T, Error>
   47|    306|    where
   48|    306|        C: Display + Send + Sync + 'static,
   49|    306|    {
   50|    306|        // Not using map_err to save 2 useless frames off the captured backtrace
   51|    306|        // in ext_context.
   52|    306|        match self {
   53|    306|            Ok(ok) => Ok(ok),
   54|      0|            Err(error) => Err(error.ext_context(context)),
   55|       |        }
   56|    306|    }
_RINvXNtCs8HwUKyRtzLJ_6anyhow7contextINtNtCshM4Il2Z0i4R_4core6result6ResultINtNtCs1slUOa8tBso_3cid3cid3CidKj40_ENtB5_5ErrorEINtB5_7ContextB1a_B1L_E7contextReECsitTtQF8ArIt_8fvm_fuzz:
   46|    102|    fn context<C>(self, context: C) -> Result<T, Error>
   47|    102|    where
   48|    102|        C: Display + Send + Sync + 'static,
   49|    102|    {
   50|    102|        // Not using map_err to save 2 useless frames off the captured backtrace
   51|    102|        // in ext_context.
   52|    102|        match self {
   53|    102|            Ok(ok) => Ok(ok),
   54|      0|            Err(error) => Err(error.ext_context(context)),
   55|       |        }
   56|    102|    }
_RINvXs_NtCs8HwUKyRtzLJ_6anyhow7contextINtNtCshM4Il2Z0i4R_4core6option6OptionRNtNtCs7Ei498kZF3p_3fvm10state_tree14StateSnapLayerEINtB7_7ContextB1c_NtNtBF_7convert10InfallibleE7contextReEB1h_:
   91|    306|    fn context<C>(self, context: C) -> Result<T, Error>
   92|    306|    where
   93|    306|        C: Display + Send + Sync + 'static,
   94|    306|    {
   95|    306|        self.ok_or_else(|| Error::from_display(context, backtrace!()))
   96|    306|    }
_RINvXNtCs8HwUKyRtzLJ_6anyhow7contextINtNtCshM4Il2Z0i4R_4core6result6ResultNtNtCsa8j9dqGMVk5_16wasmtime_runtime4mmap4MmapNtB5_5ErrorEINtB5_7ContextB1a_B1U_E7contextReEB1e_:
   46|    612|    fn context<C>(self, context: C) -> Result<T, Error>
   47|    612|    where
   48|    612|        C: Display + Send + Sync + 'static,
   49|    612|    {
   50|    612|        // Not using map_err to save 2 useless frames off the captured backtrace
   51|    612|        // in ext_context.
   52|    612|        match self {
   53|    612|            Ok(ok) => Ok(ok),
   54|      0|            Err(error) => Err(error.ext_context(context)),
   55|       |        }
   56|    612|    }
_RINvXNtCs8HwUKyRtzLJ_6anyhow7contextINtNtCshM4Il2Z0i4R_4core6result6ResultONtNtBD_3ffi6c_voidNtNtNtNtCs4szf3uycwns_6rustix7backend2io5errno5ErrnoEINtB5_7ContextB1a_B1t_E7contextNtNtCsjYc3JqMxxfa_5alloc6string6StringECsa8j9dqGMVk5_16wasmtime_runtime:
   46|    816|    fn context<C>(self, context: C) -> Result<T, Error>
   47|    816|    where
   48|    816|        C: Display + Send + Sync + 'static,
   49|    816|    {
   50|    816|        // Not using map_err to save 2 useless frames off the captured backtrace
   51|    816|        // in ext_context.
   52|    816|        match self {
   53|    816|            Ok(ok) => Ok(ok),
   54|      0|            Err(error) => Err(error.ext_context(context)),
   55|       |        }
   56|    816|    }

_RNvXsa_Cs8SlWPWBlk0j_9arbitraryINtNtCsjYc3JqMxxfa_5alloc3vec3VechENtB5_9Arbitrary9arbitraryCsitTtQF8ArIt_8fvm_fuzz:
  679|    102|        u.arbitrary_iter()?.collect()
  680|    102|    }
_RNvXsK_Cs8SlWPWBlk0j_9arbitraryjNtB5_9Arbitrary9arbitrary:
  309|   127k|                fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  310|   127k|                    let mut buf = [0; mem::size_of::<$ty>()];
  311|   127k|                    u.fill_buffer(&mut buf)?;
  312|   127k|                    let mut x: $unsigned = 0;
  313|  1.01M|                    for i in 0..mem::size_of::<$ty>() {
  314|  1.01M|                        x |= buf[i] as $unsigned << (i * 8);
  315|  1.01M|                    }
  316|   127k|                    Ok(x as $ty)
  317|   127k|                }
_RNvXsJ_Cs8SlWPWBlk0j_9arbitraryoNtB5_9Arbitrary9arbitrary:
  309|    204|                fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  310|    204|                    let mut buf = [0; mem::size_of::<$ty>()];
  311|    204|                    u.fill_buffer(&mut buf)?;
  312|    204|                    let mut x: $unsigned = 0;
  313|  3.26k|                    for i in 0..mem::size_of::<$ty>() {
  314|  3.26k|                        x |= buf[i] as $unsigned << (i * 8);
  315|  3.26k|                    }
  316|    204|                    Ok(x as $ty)
  317|    204|                }
_RNvXsF_Cs8SlWPWBlk0j_9arbitraryhNtB5_9Arbitrary9arbitrary:
  309|  1.13k|                fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  310|  1.13k|                    let mut buf = [0; mem::size_of::<$ty>()];
  311|  1.13k|                    u.fill_buffer(&mut buf)?;
  312|  1.13k|                    let mut x: $unsigned = 0;
  313|  1.13k|                    for i in 0..mem::size_of::<$ty>() {
  314|  1.13k|                        x |= buf[i] as $unsigned << (i * 8);
  315|  1.13k|                    }
  316|  1.13k|                    Ok(x as $ty)
  317|  1.13k|                }
_RNvXsH_Cs8SlWPWBlk0j_9arbitrarymNtB5_9Arbitrary9arbitrary:
  309|  65.2k|                fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  310|  65.2k|                    let mut buf = [0; mem::size_of::<$ty>()];
  311|  65.2k|                    u.fill_buffer(&mut buf)?;
  312|  65.2k|                    let mut x: $unsigned = 0;
  313|   261k|                    for i in 0..mem::size_of::<$ty>() {
  314|   261k|                        x |= buf[i] as $unsigned << (i * 8);
  315|   261k|                    }
  316|  65.2k|                    Ok(x as $ty)
  317|  65.2k|                }
_RNvXsI_Cs8SlWPWBlk0j_9arbitraryyNtB5_9Arbitrary9arbitrary:
  309|    700|                fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  310|    700|                    let mut buf = [0; mem::size_of::<$ty>()];
  311|    700|                    u.fill_buffer(&mut buf)?;
  312|    700|                    let mut x: $unsigned = 0;
  313|  5.60k|                    for i in 0..mem::size_of::<$ty>() {
  314|  5.60k|                        x |= buf[i] as $unsigned << (i * 8);
  315|  5.60k|                    }
  316|    700|                    Ok(x as $ty)
  317|    700|                }
_RNvXsO_Cs8SlWPWBlk0j_9arbitraryxNtB5_9Arbitrary9arbitrary:
  309|  31.8k|                fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  310|  31.8k|                    let mut buf = [0; mem::size_of::<$ty>()];
  311|  31.8k|                    u.fill_buffer(&mut buf)?;
  312|  31.8k|                    let mut x: $unsigned = 0;
  313|   255k|                    for i in 0..mem::size_of::<$ty>() {
  314|   255k|                        x |= buf[i] as $unsigned << (i * 8);
  315|   255k|                    }
  316|  31.8k|                    Ok(x as $ty)
  317|  31.8k|                }
_RNvXs_Cs8SlWPWBlk0j_9arbitrarybNtB4_9Arbitrary9arbitrary:
  295|    620|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  296|    620|        Ok(<u8 as Arbitrary<'a>>::arbitrary(u)? & 1 == 1)
  297|    620|    }

_RINvMNtCs8SlWPWBlk0j_9arbitrary12unstructuredNtB3_12Unstructured9arbitrarymECsbTo8XeKCRZK_15direct_syscalls:
  167|    102|    pub fn arbitrary<A>(&mut self) -> Result<A>
  168|    102|    where
  169|    102|        A: Arbitrary<'a>,
  170|    102|    {
  171|    102|        <A as Arbitrary<'a>>::arbitrary(self)
  172|    102|    }
_RINvMNtCs8SlWPWBlk0j_9arbitrary12unstructuredNtB3_12Unstructured12int_in_rangeyECsitTtQF8ArIt_8fvm_fuzz:
  293|    102|    pub fn int_in_range<T>(&mut self, range: ops::RangeInclusive<T>) -> Result<T>
  294|    102|    where
  295|    102|        T: Int,
  296|    102|    {
  297|    102|        let (result, bytes_consumed) = Self::int_in_range_impl(range, self.data.iter().cloned())?;
  298|    102|        self.data = &self.data[bytes_consumed..];
  299|    102|        Ok(result)
  300|    102|    }
_RINvMNtCs8SlWPWBlk0j_9arbitrary12unstructuredNtB3_12Unstructured9arbitraryINtNtCsjYc3JqMxxfa_5alloc3vec3VechEECsitTtQF8ArIt_8fvm_fuzz:
  167|    102|    pub fn arbitrary<A>(&mut self) -> Result<A>
  168|    102|    where
  169|    102|        A: Arbitrary<'a>,
  170|    102|    {
  171|    102|        <A as Arbitrary<'a>>::arbitrary(self)
  172|    102|    }
_RINvMNtCs8SlWPWBlk0j_9arbitrary12unstructuredNtB3_12Unstructured17int_in_range_impljINtNtNtNtCshM4Il2Z0i4R_4core4iter8adapters6cloned6ClonedINtNtNtB1t_5slice4iter4IterhEEECsitTtQF8ArIt_8fvm_fuzz:
  302|  64.1k|    fn int_in_range_impl<T>(
  303|  64.1k|        range: ops::RangeInclusive<T>,
  304|  64.1k|        mut bytes: impl Iterator<Item = u8>,
  305|  64.1k|    ) -> Result<(T, usize)>
  306|  64.1k|    where
  307|  64.1k|        T: Int,
  308|  64.1k|    {
  309|  64.1k|        let start = *range.start();
  310|  64.1k|        let end = *range.end();
  311|  64.1k|        assert!(
  312|  64.1k|            start <= end,
  313|  64.1k|            "`arbitrary::Unstructured::int_in_range` requires a non-empty range"
  314|  64.1k|        );
  315|       |
  316|       |        // When there is only one possible choice, don't waste any entropy from
  317|       |        // the underlying data.
  318|  64.1k|        if start == end {
  319|  63.6k|            return Ok((start, 0));
  320|    543|        }
  321|    543|
  322|    543|        // From here on out we work with the unsigned representation. All of the
  323|    543|        // operations performed below work out just as well whether or not `T`
  324|    543|        // is a signed or unsigned integer.
  325|    543|        let start = start.to_unsigned();
  326|    543|        let end = end.to_unsigned();
  327|    543|
  328|    543|        let delta = end.wrapping_sub(start);
  329|    543|        debug_assert_ne!(delta, T::Unsigned::ZERO);
  330|       |
  331|       |        // Compute an arbitrary integer offset from the start of the range. We
  332|       |        // do this by consuming `size_of(T)` bytes from the input to create an
  333|       |        // arbitrary integer and then clamping that int into our range bounds
  334|       |        // with a modulo operation.
  335|    543|        let mut arbitrary_int = T::Unsigned::ZERO;
  336|    543|        let mut bytes_consumed: usize = 0;
  337|       |
  338|    552|        while (bytes_consumed < mem::size_of::<T>())
  339|    552|            && (delta >> T::Unsigned::from_usize(bytes_consumed * 8)) > T::Unsigned::ZERO
  340|       |        {
  341|    543|            let byte = match bytes.next() {
  342|    534|                None => break,
  343|      9|                Some(b) => b,
  344|      9|            };
  345|      9|            bytes_consumed += 1;
  346|      9|
  347|      9|            // Combine this byte into our arbitrary integer, but avoid
  348|      9|            // overflowing the shift for `u8` and `i8`.
  349|      9|            arbitrary_int = if mem::size_of::<T>() == 1 {
  350|      0|                T::Unsigned::from_u8(byte)
  351|       |            } else {
  352|      9|                (arbitrary_int << 8) | T::Unsigned::from_u8(byte)
  353|       |            };
  354|       |        }
  355|       |
  356|    543|        let offset = if delta == T::Unsigned::MAX {
  357|      0|            arbitrary_int
  358|       |        } else {
  359|    543|            arbitrary_int % (delta.checked_add(T::Unsigned::ONE).unwrap())
  360|       |        };
  361|       |
  362|       |        // Finally, we add `start` to our offset from `start` to get the result
  363|       |        // actual value within the range.
  364|    543|        let result = start.wrapping_add(offset);
  365|    543|
  366|    543|        // And convert back to our maybe-signed representation.
  367|    543|        let result = T::from_unsigned(result);
  368|    543|        debug_assert!(*range.start() <= result);
  369|    543|        debug_assert!(result <= *range.end());
  370|       |
  371|    543|        Ok((result, bytes_consumed))
  372|  64.1k|    }
_RINvMNtCs8SlWPWBlk0j_9arbitrary12unstructuredNtB3_12Unstructured17int_in_range_implmINtNtNtNtCshM4Il2Z0i4R_4core4iter8adapters6cloned6ClonedINtNtNtB1t_5slice4iter4IterhEEECsitTtQF8ArIt_8fvm_fuzz:
  302|    102|    fn int_in_range_impl<T>(
  303|    102|        range: ops::RangeInclusive<T>,
  304|    102|        mut bytes: impl Iterator<Item = u8>,
  305|    102|    ) -> Result<(T, usize)>
  306|    102|    where
  307|    102|        T: Int,
  308|    102|    {
  309|    102|        let start = *range.start();
  310|    102|        let end = *range.end();
  311|    102|        assert!(
  312|    102|            start <= end,
  313|    102|            "`arbitrary::Unstructured::int_in_range` requires a non-empty range"
  314|    102|        );
  315|       |
  316|       |        // When there is only one possible choice, don't waste any entropy from
  317|       |        // the underlying data.
  318|    102|        if start == end {
  319|     11|            return Ok((start, 0));
  320|     91|        }
  321|     91|
  322|     91|        // From here on out we work with the unsigned representation. All of the
  323|     91|        // operations performed below work out just as well whether or not `T`
  324|     91|        // is a signed or unsigned integer.
  325|     91|        let start = start.to_unsigned();
  326|     91|        let end = end.to_unsigned();
  327|     91|
  328|     91|        let delta = end.wrapping_sub(start);
  329|     91|        debug_assert_ne!(delta, T::Unsigned::ZERO);
  330|       |
  331|       |        // Compute an arbitrary integer offset from the start of the range. We
  332|       |        // do this by consuming `size_of(T)` bytes from the input to create an
  333|       |        // arbitrary integer and then clamping that int into our range bounds
  334|       |        // with a modulo operation.
  335|     91|        let mut arbitrary_int = T::Unsigned::ZERO;
  336|     91|        let mut bytes_consumed: usize = 0;
  337|       |
  338|    158|        while (bytes_consumed < mem::size_of::<T>())
  339|    142|            && (delta >> T::Unsigned::from_usize(bytes_consumed * 8)) > T::Unsigned::ZERO
  340|       |        {
  341|    141|            let byte = match bytes.next() {
  342|     74|                None => break,
  343|     67|                Some(b) => b,
  344|     67|            };
  345|     67|            bytes_consumed += 1;
  346|     67|
  347|     67|            // Combine this byte into our arbitrary integer, but avoid
  348|     67|            // overflowing the shift for `u8` and `i8`.
  349|     67|            arbitrary_int = if mem::size_of::<T>() == 1 {
  350|      0|                T::Unsigned::from_u8(byte)
  351|       |            } else {
  352|     67|                (arbitrary_int << 8) | T::Unsigned::from_u8(byte)
  353|       |            };
  354|       |        }
  355|       |
  356|     91|        let offset = if delta == T::Unsigned::MAX {
  357|      0|            arbitrary_int
  358|       |        } else {
  359|     91|            arbitrary_int % (delta.checked_add(T::Unsigned::ONE).unwrap())
  360|       |        };
  361|       |
  362|       |        // Finally, we add `start` to our offset from `start` to get the result
  363|       |        // actual value within the range.
  364|     91|        let result = start.wrapping_add(offset);
  365|     91|
  366|     91|        // And convert back to our maybe-signed representation.
  367|     91|        let result = T::from_unsigned(result);
  368|     91|        debug_assert!(*range.start() <= result);
  369|     91|        debug_assert!(result <= *range.end());
  370|       |
  371|     91|        Ok((result, bytes_consumed))
  372|    102|    }
_RINvMNtCs8SlWPWBlk0j_9arbitrary12unstructuredNtB3_12Unstructured9arbitraryoECsitTtQF8ArIt_8fvm_fuzz:
  167|    204|    pub fn arbitrary<A>(&mut self) -> Result<A>
  168|    204|    where
  169|    204|        A: Arbitrary<'a>,
  170|    204|    {
  171|    204|        <A as Arbitrary<'a>>::arbitrary(self)
  172|    204|    }
_RINvMNtCs8SlWPWBlk0j_9arbitrary12unstructuredNtB3_12Unstructured12int_in_rangemECsitTtQF8ArIt_8fvm_fuzz:
  293|    102|    pub fn int_in_range<T>(&mut self, range: ops::RangeInclusive<T>) -> Result<T>
  294|    102|    where
  295|    102|        T: Int,
  296|    102|    {
  297|    102|        let (result, bytes_consumed) = Self::int_in_range_impl(range, self.data.iter().cloned())?;
  298|    102|        self.data = &self.data[bytes_consumed..];
  299|    102|        Ok(result)
  300|    102|    }
_RINvMNtCs8SlWPWBlk0j_9arbitrary12unstructuredNtB3_12Unstructured9arbitraryyECsitTtQF8ArIt_8fvm_fuzz:
  167|    700|    pub fn arbitrary<A>(&mut self) -> Result<A>
  168|    700|    where
  169|    700|        A: Arbitrary<'a>,
  170|    700|    {
  171|    700|        <A as Arbitrary<'a>>::arbitrary(self)
  172|    700|    }
_RINvMNtCs8SlWPWBlk0j_9arbitrary12unstructuredNtB3_12Unstructured9arbitrarybECsitTtQF8ArIt_8fvm_fuzz:
  167|    620|    pub fn arbitrary<A>(&mut self) -> Result<A>
  168|    620|    where
  169|    620|        A: Arbitrary<'a>,
  170|    620|    {
  171|    620|        <A as Arbitrary<'a>>::arbitrary(self)
  172|    620|    }
_RINvMNtCs8SlWPWBlk0j_9arbitrary12unstructuredNtB3_12Unstructured14arbitrary_iterhECsitTtQF8ArIt_8fvm_fuzz:
  606|    102|    pub fn arbitrary_iter<'b, ElementType: Arbitrary<'a>>(
  607|    102|        &'b mut self,
  608|    102|    ) -> Result<ArbitraryIter<'a, 'b, ElementType>> {
  609|    102|        Ok(ArbitraryIter {
  610|    102|            u: &mut *self,
  611|    102|            _marker: PhantomData,
  612|    102|        })
  613|    102|    }
_RINvMNtCs8SlWPWBlk0j_9arbitrary12unstructuredNtB3_12Unstructured9arbitrarymECsitTtQF8ArIt_8fvm_fuzz:
  167|  65.1k|    pub fn arbitrary<A>(&mut self) -> Result<A>
  168|  65.1k|    where
  169|  65.1k|        A: Arbitrary<'a>,
  170|  65.1k|    {
  171|  65.1k|        <A as Arbitrary<'a>>::arbitrary(self)
  172|  65.1k|    }
_RINvMNtCs8SlWPWBlk0j_9arbitrary12unstructuredNtB3_12Unstructured14arbitrary_loopNCNvNtCsitTtQF8ArIt_8fvm_fuzz15stress_syscalls15stress_syscalls0EB1m_:
  698|    102|    pub fn arbitrary_loop(
  699|    102|        &mut self,
  700|    102|        min: Option<u32>,
  701|    102|        max: Option<u32>,
  702|    102|        mut f: impl FnMut(&mut Self) -> Result<ControlFlow<(), ()>>,
  703|    102|    ) -> Result<()> {
  704|    102|        let min = min.unwrap_or(0);
  705|    102|        let max = max.unwrap_or(u32::MAX);
  706|    102|
  707|    102|        for _ in 0..self.int_in_range(min..=max)? {
  708|  33.1k|            match f(self)? {
  709|  33.1k|                ControlFlow::Continue(_) => continue,
  710|      0|                ControlFlow::Break(_) => break,
  711|       |            }
  712|       |        }
  713|       |
  714|    102|        Ok(())
  715|    102|    }
_RINvMNtCs8SlWPWBlk0j_9arbitrary12unstructuredNtB3_12Unstructured6chooseyECsitTtQF8ArIt_8fvm_fuzz:
  408|     88|    pub fn choose<'b, T>(&mut self, choices: &'b [T]) -> Result<&'b T> {
  409|     88|        let idx = self.choose_index(choices.len())?;
  410|     88|        Ok(&choices[idx])
  411|     88|    }
_RINvMNtCs8SlWPWBlk0j_9arbitrary12unstructuredNtB3_12Unstructured9arbitraryxECsitTtQF8ArIt_8fvm_fuzz:
  167|  31.8k|    pub fn arbitrary<A>(&mut self) -> Result<A>
  168|  31.8k|    where
  169|  31.8k|        A: Arbitrary<'a>,
  170|  31.8k|    {
  171|  31.8k|        <A as Arbitrary<'a>>::arbitrary(self)
  172|  31.8k|    }
_RINvMNtCs8SlWPWBlk0j_9arbitrary12unstructuredNtB3_12Unstructured9arbitraryjECsitTtQF8ArIt_8fvm_fuzz:
  167|   127k|    pub fn arbitrary<A>(&mut self) -> Result<A>
  168|   127k|    where
  169|   127k|        A: Arbitrary<'a>,
  170|   127k|    {
  171|   127k|        <A as Arbitrary<'a>>::arbitrary(self)
  172|   127k|    }
_RNvXs_NtCs8SlWPWBlk0j_9arbitrary12unstructuredINtB4_13ArbitraryIterhENtNtNtNtCshM4Il2Z0i4R_4core4iter6traits8iterator8Iterator4nextCsitTtQF8ArIt_8fvm_fuzz:
  726|    620|    fn next(&mut self) -> Option<Result<ElementType>> {
  727|    620|        let keep_going = self.u.arbitrary().unwrap_or(false);
  728|    620|        if keep_going {
  729|    518|            Some(Arbitrary::arbitrary(self.u))
  730|       |        } else {
  731|    102|            None
  732|       |        }
  733|    620|    }
_RINvMNtCs8SlWPWBlk0j_9arbitrary12unstructuredNtB3_12Unstructured12int_in_rangejECsitTtQF8ArIt_8fvm_fuzz:
  293|  64.1k|    pub fn int_in_range<T>(&mut self, range: ops::RangeInclusive<T>) -> Result<T>
  294|  64.1k|    where
  295|  64.1k|        T: Int,
  296|  64.1k|    {
  297|  64.1k|        let (result, bytes_consumed) = Self::int_in_range_impl(range, self.data.iter().cloned())?;
  298|  64.1k|        self.data = &self.data[bytes_consumed..];
  299|  64.1k|        Ok(result)
  300|  64.1k|    }
_RINvMNtCs8SlWPWBlk0j_9arbitrary12unstructuredNtB3_12Unstructured17int_in_range_implyINtNtNtNtCshM4Il2Z0i4R_4core4iter8adapters6cloned6ClonedINtNtNtB1t_5slice4iter4IterhEEECsitTtQF8ArIt_8fvm_fuzz:
  302|    102|    fn int_in_range_impl<T>(
  303|    102|        range: ops::RangeInclusive<T>,
  304|    102|        mut bytes: impl Iterator<Item = u8>,
  305|    102|    ) -> Result<(T, usize)>
  306|    102|    where
  307|    102|        T: Int,
  308|    102|    {
  309|    102|        let start = *range.start();
  310|    102|        let end = *range.end();
  311|    102|        assert!(
  312|    102|            start <= end,
  313|    102|            "`arbitrary::Unstructured::int_in_range` requires a non-empty range"
  314|    102|        );
  315|       |
  316|       |        // When there is only one possible choice, don't waste any entropy from
  317|       |        // the underlying data.
  318|    102|        if start == end {
  319|      0|            return Ok((start, 0));
  320|    102|        }
  321|    102|
  322|    102|        // From here on out we work with the unsigned representation. All of the
  323|    102|        // operations performed below work out just as well whether or not `T`
  324|    102|        // is a signed or unsigned integer.
  325|    102|        let start = start.to_unsigned();
  326|    102|        let end = end.to_unsigned();
  327|    102|
  328|    102|        let delta = end.wrapping_sub(start);
  329|    102|        debug_assert_ne!(delta, T::Unsigned::ZERO);
  330|       |
  331|       |        // Compute an arbitrary integer offset from the start of the range. We
  332|       |        // do this by consuming `size_of(T)` bytes from the input to create an
  333|       |        // arbitrary integer and then clamping that int into our range bounds
  334|       |        // with a modulo operation.
  335|    102|        let mut arbitrary_int = T::Unsigned::ZERO;
  336|    102|        let mut bytes_consumed: usize = 0;
  337|       |
  338|    126|        while (bytes_consumed < mem::size_of::<T>())
  339|    126|            && (delta >> T::Unsigned::from_usize(bytes_consumed * 8)) > T::Unsigned::ZERO
  340|       |        {
  341|    102|            let byte = match bytes.next() {
  342|     78|                None => break,
  343|     24|                Some(b) => b,
  344|     24|            };
  345|     24|            bytes_consumed += 1;
  346|     24|
  347|     24|            // Combine this byte into our arbitrary integer, but avoid
  348|     24|            // overflowing the shift for `u8` and `i8`.
  349|     24|            arbitrary_int = if mem::size_of::<T>() == 1 {
  350|      0|                T::Unsigned::from_u8(byte)
  351|       |            } else {
  352|     24|                (arbitrary_int << 8) | T::Unsigned::from_u8(byte)
  353|       |            };
  354|       |        }
  355|       |
  356|    102|        let offset = if delta == T::Unsigned::MAX {
  357|      0|            arbitrary_int
  358|       |        } else {
  359|    102|            arbitrary_int % (delta.checked_add(T::Unsigned::ONE).unwrap())
  360|       |        };
  361|       |
  362|       |        // Finally, we add `start` to our offset from `start` to get the result
  363|       |        // actual value within the range.
  364|    102|        let result = start.wrapping_add(offset);
  365|    102|
  366|    102|        // And convert back to our maybe-signed representation.
  367|    102|        let result = T::from_unsigned(result);
  368|    102|        debug_assert!(*range.start() <= result);
  369|    102|        debug_assert!(result <= *range.end());
  370|       |
  371|    102|        Ok((result, bytes_consumed))
  372|    102|    }
_RNvXs4_NtCs8SlWPWBlk0j_9arbitrary12unstructuredyNtB5_3Int12wrapping_sub:
  852|    102|                fn wrapping_sub(self, rhs: Self) -> Self {
  853|    102|                    <$ty>::wrapping_sub(self, rhs)
  854|    102|                }
_RNvXs6_NtCs8SlWPWBlk0j_9arbitrary12unstructuredjNtB5_3Int12wrapping_add:
  848|    631|                fn wrapping_add(self, rhs: Self) -> Self {
  849|    631|                    <$ty>::wrapping_add(self, rhs)
  850|    631|                }
_RINvMNtCs8SlWPWBlk0j_9arbitrary12unstructuredNtB3_12Unstructured17int_in_range_impljINtNtNtNtCshM4Il2Z0i4R_4core4iter8adapters6cloned6ClonedINtNtNtB1t_5slice4iter4IterhEEEB5_:
  302|     88|    fn int_in_range_impl<T>(
  303|     88|        range: ops::RangeInclusive<T>,
  304|     88|        mut bytes: impl Iterator<Item = u8>,
  305|     88|    ) -> Result<(T, usize)>
  306|     88|    where
  307|     88|        T: Int,
  308|     88|    {
  309|     88|        let start = *range.start();
  310|     88|        let end = *range.end();
  311|     88|        assert!(
  312|     88|            start <= end,
  313|     88|            "`arbitrary::Unstructured::int_in_range` requires a non-empty range"
  314|     88|        );
  315|       |
  316|       |        // When there is only one possible choice, don't waste any entropy from
  317|       |        // the underlying data.
  318|     88|        if start == end {
  319|      0|            return Ok((start, 0));
  320|     88|        }
  321|     88|
  322|     88|        // From here on out we work with the unsigned representation. All of the
  323|     88|        // operations performed below work out just as well whether or not `T`
  324|     88|        // is a signed or unsigned integer.
  325|     88|        let start = start.to_unsigned();
  326|     88|        let end = end.to_unsigned();
  327|     88|
  328|     88|        let delta = end.wrapping_sub(start);
  329|     88|        debug_assert_ne!(delta, T::Unsigned::ZERO);
  330|       |
  331|       |        // Compute an arbitrary integer offset from the start of the range. We
  332|       |        // do this by consuming `size_of(T)` bytes from the input to create an
  333|       |        // arbitrary integer and then clamping that int into our range bounds
  334|       |        // with a modulo operation.
  335|     88|        let mut arbitrary_int = T::Unsigned::ZERO;
  336|     88|        let mut bytes_consumed: usize = 0;
  337|       |
  338|     95|        while (bytes_consumed < mem::size_of::<T>())
  339|     95|            && (delta >> T::Unsigned::from_usize(bytes_consumed * 8)) > T::Unsigned::ZERO
  340|       |        {
  341|     88|            let byte = match bytes.next() {
  342|     81|                None => break,
  343|      7|                Some(b) => b,
  344|      7|            };
  345|      7|            bytes_consumed += 1;
  346|      7|
  347|      7|            // Combine this byte into our arbitrary integer, but avoid
  348|      7|            // overflowing the shift for `u8` and `i8`.
  349|      7|            arbitrary_int = if mem::size_of::<T>() == 1 {
  350|      0|                T::Unsigned::from_u8(byte)
  351|       |            } else {
  352|      7|                (arbitrary_int << 8) | T::Unsigned::from_u8(byte)
  353|       |            };
  354|       |        }
  355|       |
  356|     88|        let offset = if delta == T::Unsigned::MAX {
  357|      0|            arbitrary_int
  358|       |        } else {
  359|     88|            arbitrary_int % (delta.checked_add(T::Unsigned::ONE).unwrap())
  360|       |        };
  361|       |
  362|       |        // Finally, we add `start` to our offset from `start` to get the result
  363|       |        // actual value within the range.
  364|     88|        let result = start.wrapping_add(offset);
  365|     88|
  366|     88|        // And convert back to our maybe-signed representation.
  367|     88|        let result = T::from_unsigned(result);
  368|     88|        debug_assert!(*range.start() <= result);
  369|     88|        debug_assert!(result <= *range.end());
  370|       |
  371|     88|        Ok((result, bytes_consumed))
  372|     88|    }
_RNvXs3_NtCs8SlWPWBlk0j_9arbitrary12unstructuredmNtB5_3Int13from_unsigned:
  860|     91|                fn from_unsigned(unsigned: $unsigned_ty) -> Self {
  861|     91|                    unsigned as Self
  862|     91|                }
_RNvXs6_NtCs8SlWPWBlk0j_9arbitrary12unstructuredjNtB5_3Int13from_unsigned:
  860|    631|                fn from_unsigned(unsigned: $unsigned_ty) -> Self {
  861|    631|                    unsigned as Self
  862|    631|                }
_RNvXs3_NtCs8SlWPWBlk0j_9arbitrary12unstructuredmNtB5_3Int11checked_add:
  844|     91|                fn checked_add(self, rhs: Self) -> Option<Self> {
  845|     91|                    <$ty>::checked_add(self, rhs)
  846|     91|                }
_RNvXs6_NtCs8SlWPWBlk0j_9arbitrary12unstructuredjNtB5_3Int11checked_add:
  844|    631|                fn checked_add(self, rhs: Self) -> Option<Self> {
  845|    631|                    <$ty>::checked_add(self, rhs)
  846|    631|                }
_RNvXs3_NtCs8SlWPWBlk0j_9arbitrary12unstructuredmNtB5_3Int11to_unsigned:
  856|    182|                fn to_unsigned(self) -> Self::Unsigned {
  857|    182|                    self as $unsigned_ty
  858|    182|                }
_RNvXs4_NtCs8SlWPWBlk0j_9arbitrary12unstructuredyNtB5_3Int11to_unsigned:
  856|    204|                fn to_unsigned(self) -> Self::Unsigned {
  857|    204|                    self as $unsigned_ty
  858|    204|                }
_RINvMNtCs8SlWPWBlk0j_9arbitrary12unstructuredNtB3_12Unstructured12int_in_rangejEB5_:
  293|     88|    pub fn int_in_range<T>(&mut self, range: ops::RangeInclusive<T>) -> Result<T>
  294|     88|    where
  295|     88|        T: Int,
  296|     88|    {
  297|     88|        let (result, bytes_consumed) = Self::int_in_range_impl(range, self.data.iter().cloned())?;
  298|     88|        self.data = &self.data[bytes_consumed..];
  299|     88|        Ok(result)
  300|     88|    }
_RNvXs6_NtCs8SlWPWBlk0j_9arbitrary12unstructuredjNtB5_3Int7from_u8:
  836|     16|                fn from_u8(b: u8) -> Self {
  837|     16|                    b as Self
  838|     16|                }
_RNvXs3_NtCs8SlWPWBlk0j_9arbitrary12unstructuredmNtB5_3Int12wrapping_add:
  848|     91|                fn wrapping_add(self, rhs: Self) -> Self {
  849|     91|                    <$ty>::wrapping_add(self, rhs)
  850|     91|                }
_RNvXs6_NtCs8SlWPWBlk0j_9arbitrary12unstructuredjNtB5_3Int12wrapping_sub:
  852|    631|                fn wrapping_sub(self, rhs: Self) -> Self {
  853|    631|                    <$ty>::wrapping_sub(self, rhs)
  854|    631|                }
_RNvMNtCs8SlWPWBlk0j_9arbitrary12unstructuredNtB2_12Unstructured3new:
   85|    102|    pub fn new(data: &'a [u8]) -> Self {
   86|    102|        Unstructured { data }
   87|    102|    }
_RNvMNtCs8SlWPWBlk0j_9arbitrary12unstructuredNtB2_12Unstructured12choose_index:
  450|     88|    pub fn choose_index(&mut self, len: usize) -> Result<usize> {
  451|     88|        if len == 0 {
  452|      0|            return Err(Error::EmptyChoose);
  453|     88|        }
  454|     88|        let idx = self.int_in_range(0..=len - 1)?;
  455|     88|        Ok(idx)
  456|     88|    }
_RNvXs4_NtCs8SlWPWBlk0j_9arbitrary12unstructuredyNtB5_3Int11checked_add:
  844|    102|                fn checked_add(self, rhs: Self) -> Option<Self> {
  845|    102|                    <$ty>::checked_add(self, rhs)
  846|    102|                }
_RNvXs4_NtCs8SlWPWBlk0j_9arbitrary12unstructuredyNtB5_3Int13from_unsigned:
  860|    102|                fn from_unsigned(unsigned: $unsigned_ty) -> Self {
  861|    102|                    unsigned as Self
  862|    102|                }
_RNvXs3_NtCs8SlWPWBlk0j_9arbitrary12unstructuredmNtB5_3Int10from_usize:
  840|    142|                fn from_usize(u: usize) -> Self {
  841|    142|                    u as Self
  842|    142|                }
_RNvXs3_NtCs8SlWPWBlk0j_9arbitrary12unstructuredmNtB5_3Int12wrapping_sub:
  852|     91|                fn wrapping_sub(self, rhs: Self) -> Self {
  853|     91|                    <$ty>::wrapping_sub(self, rhs)
  854|     91|                }
_RNvXs4_NtCs8SlWPWBlk0j_9arbitrary12unstructuredyNtB5_3Int7from_u8:
  836|     24|                fn from_u8(b: u8) -> Self {
  837|     24|                    b as Self
  838|     24|                }
_RNvXs3_NtCs8SlWPWBlk0j_9arbitrary12unstructuredmNtB5_3Int7from_u8:
  836|     67|                fn from_u8(b: u8) -> Self {
  837|     67|                    b as Self
  838|     67|                }
_RNvXs4_NtCs8SlWPWBlk0j_9arbitrary12unstructuredyNtB5_3Int12wrapping_add:
  848|    102|                fn wrapping_add(self, rhs: Self) -> Self {
  849|    102|                    <$ty>::wrapping_add(self, rhs)
  850|    102|                }
_RNvMNtCs8SlWPWBlk0j_9arbitrary12unstructuredNtB2_12Unstructured11fill_buffer:
  521|   226k|    pub fn fill_buffer(&mut self, buffer: &mut [u8]) -> Result<()> {
  522|   226k|        let n = std::cmp::min(buffer.len(), self.data.len());
  523|   226k|        buffer[..n].copy_from_slice(&self.data[..n]);
  524|  1.53M|        for byte in buffer[n..].iter_mut() {
  525|  1.53M|            *byte = 0;
  526|  1.53M|        }
  527|   226k|        self.data = &self.data[n..];
  528|   226k|        Ok(())
  529|   226k|    }
_RNvXs6_NtCs8SlWPWBlk0j_9arbitrary12unstructuredjNtB5_3Int11to_unsigned:
  856|  1.26k|                fn to_unsigned(self) -> Self::Unsigned {
  857|  1.26k|                    self as $unsigned_ty
  858|  1.26k|                }
_RNvXs4_NtCs8SlWPWBlk0j_9arbitrary12unstructuredyNtB5_3Int10from_usize:
  840|    126|                fn from_usize(u: usize) -> Self {
  841|    126|                    u as Self
  842|    126|                }
_RNvXs6_NtCs8SlWPWBlk0j_9arbitrary12unstructuredjNtB5_3Int10from_usize:
  840|    647|                fn from_usize(u: usize) -> Self {
  841|    647|                    u as Self
  842|    647|                }

_RINvNvNtCshBpGUmeBfYm_12blake2b_simd4avx214compress_block9as_arraysyEB6_:
  240|    918|            unsafe fn as_arrays<T>(a: &mut [T; $( $len + )* 0 ]) -> ( $( &mut [T; $len], )* ) {
  241|    918|                let mut p = a.as_mut_ptr();
  242|    918|                ( $( {
  243|    918|                    let aref = &mut *(p as *mut [T; $len]);
  244|    918|                    p = p.offset($len as isize);
  245|    918|                    aref
  246|    918|                } ),* )
  247|    918|            }
_RINvNvNtCshBpGUmeBfYm_12blake2b_simd4avx214compress_blocks_9as_arraysyEB6_:
  143|    918|            unsafe fn as_arrays<T>(a: &[T; $( $len + )* 0 ]) -> ( $( &[T; $len], )* ) {
  144|    918|                let mut p = a.as_ptr();
  145|    918|                ( $( {
  146|    918|                    let aref = &*(p as *const [T; $len]);
  147|    918|                    p = p.offset($len as isize);
  148|    918|                    aref
  149|    918|                } ),* )
  150|    918|            }
_RINvNvCshBpGUmeBfYm_12blake2b_simd20state_words_to_bytes9as_arrayshEB4_:
  240|    714|            unsafe fn as_arrays<T>(a: &mut [T; $( $len + )* 0 ]) -> ( $( &mut [T; $len], )* ) {
  241|    714|                let mut p = a.as_mut_ptr();
  242|    714|                ( $( {
  243|    714|                    let aref = &mut *(p as *mut [T; $len]);
  244|    714|                    p = p.offset($len as isize);
  245|    714|                    aref
  246|    714|                } ),* )
  247|    714|            }
_RINvNvNtCshBpGUmeBfYm_12blake2b_simd4avx214compress_blocks0_9as_arrayshEB6_:
  143|    918|            unsafe fn as_arrays<T>(a: &[T; $( $len + )* 0 ]) -> ( $( &[T; $len], )* ) {
  144|    918|                let mut p = a.as_ptr();
  145|    918|                ( $( {
  146|    918|                    let aref = &*(p as *const [T; $len]);
  147|    918|                    p = p.offset($len as isize);
  148|    918|                    aref
  149|    918|                } ),* )
  150|    918|            }
_RINvNvNtCshBpGUmeBfYm_12blake2b_simd4guts11final_block8as_arrayhEB6_:
   61|    102|            unsafe fn as_array<T>(slice: &[T]) -> &[T; $len] {
   62|    102|                &*(slice.as_ptr() as *const [_; $len])
   63|    102|            }
_RINvNvMCshBpGUmeBfYm_12blake2b_simdNtB5_6Params8to_wordss_9as_arrayshEB5_:
  143|    714|            unsafe fn as_arrays<T>(a: &[T; $( $len + )* 0 ]) -> ( $( &[T; $len], )* ) {
  144|    714|                let mut p = a.as_ptr();
  145|    714|                ( $( {
  146|    714|                    let aref = &*(p as *const [T; $len]);
  147|    714|                    p = p.offset($len as isize);
  148|    714|                    aref
  149|    714|                } ),* )
  150|    714|            }
_RINvNvMCshBpGUmeBfYm_12blake2b_simdNtB5_6Params8to_words9as_arrayshEB5_:
  143|    714|            unsafe fn as_arrays<T>(a: &[T; $( $len + )* 0 ]) -> ( $( &[T; $len], )* ) {
  144|    714|                let mut p = a.as_ptr();
  145|    714|                ( $( {
  146|    714|                    let aref = &*(p as *const [T; $len]);
  147|    714|                    p = p.offset($len as isize);
  148|    714|                    aref
  149|    714|                } ),* )
  150|    714|            }

_RNvCslI6ackC4kjr_4atty2is:
   40|    102|pub fn is(stream: Stream) -> bool {
   41|       |    extern crate libc;
   42|       |
   43|    102|    let fd = match stream {
   44|      0|        Stream::Stdout => libc::STDOUT_FILENO,
   45|    102|        Stream::Stderr => libc::STDERR_FILENO,
   46|      0|        Stream::Stdin => libc::STDIN_FILENO,
   47|       |    };
   48|    102|    unsafe { libc::isatty(fd) != 0 }
   49|    102|}

_RNvMs13_NtNtNtCs4szf3uycwns_6rustix7backend2mm5typesNtB6_8MapFlags4bits:
  545|    816|            pub const fn bits(&self) -> $T {
  546|    816|                self.bits
  547|    816|            }
_RNvXse_NtNtNtCs4szf3uycwns_6rustix7backend2mm5typesNtB5_9ProtFlagsNtNtNtCshM4Il2Z0i4R_4core3ops3bit5BitOr5bitor:
  731|    408|            fn bitor(self, other: $BitFlags) -> Self {
  732|    408|                Self { bits: self.bits | other.bits }
  733|    408|            }
_RNvMsd_NtNtNtCs4szf3uycwns_6rustix7backend2mm5typesNtB5_9ProtFlags5empty:
  526|    408|            pub const fn empty() -> Self {
  527|    408|                Self { bits: 0 }
  528|    408|            }
_RNvMsd_NtNtNtCs4szf3uycwns_6rustix7backend2mm5typesNtB5_9ProtFlags4bits:
  545|    816|            pub const fn bits(&self) -> $T {
  546|    816|                self.bits
  547|    816|            }

_RNvNtCshBpGUmeBfYm_12blake2b_simd4avx23add:
   35|   132k|unsafe fn add(a: __m256i, b: __m256i) -> __m256i {
   36|   132k|    _mm256_add_epi64(a, b)
   37|   132k|}
_RNvNtCshBpGUmeBfYm_12blake2b_simd4avx25rot32:
   87|  22.0k|unsafe fn rot32(x: __m256i) -> __m256i {
   88|  22.0k|    _mm256_or_si256(_mm256_srli_epi64(x, 32), _mm256_slli_epi64(x, 64 - 32))
   89|  22.0k|}
_RNvNtCshBpGUmeBfYm_12blake2b_simd4avx26storeu:
   24|  1.83k|unsafe fn storeu(src: __m256i, dest: *mut [Word; DEGREE]) {
   25|  1.83k|    // This is an unaligned store, so the pointer cast is allowed.
   26|  1.83k|    _mm256_storeu_si256(dest as *mut __m256i, src)
   27|  1.83k|}
_RNvNtCshBpGUmeBfYm_12blake2b_simd4avx214compress1_loop:
  427|    816|pub unsafe fn compress1_loop(
  428|    816|    input: &[u8],
  429|    816|    words: &mut [Word; 8],
  430|    816|    mut count: Count,
  431|    816|    last_node: LastNode,
  432|    816|    finalize: Finalize,
  433|    816|    stride: Stride,
  434|    816|) {
  435|    816|    input_debug_asserts(input, finalize);
  436|    816|
  437|    816|    let mut local_words = *words;
  438|    816|
  439|    816|    let mut fin_offset = input.len().saturating_sub(1);
  440|    816|    fin_offset -= fin_offset % stride.padded_blockbytes();
  441|    816|    let mut buf = [0; BLOCKBYTES];
  442|    816|    let (fin_block, fin_len, _) = final_block(input, fin_offset, &mut buf, stride);
  443|    816|    let fin_last_block = flag_word(finalize.yes());
  444|    816|    let fin_last_node = flag_word(finalize.yes() && last_node.yes());
  445|       |
  446|    816|    let mut offset = 0;
  447|       |    loop {
  448|       |        let block;
  449|       |        let count_delta;
  450|       |        let last_block;
  451|       |        let last_node;
  452|    918|        if offset == fin_offset {
  453|    816|            block = fin_block;
  454|    816|            count_delta = fin_len;
  455|    816|            last_block = fin_last_block;
  456|    816|            last_node = fin_last_node;
  457|    816|        } else {
  458|    102|            // This unsafe cast avoids bounds checks. There's guaranteed to be
  459|    102|            // enough input because `offset < fin_offset`.
  460|    102|            block = &*(input.as_ptr().add(offset) as *const [u8; BLOCKBYTES]);
  461|    102|            count_delta = BLOCKBYTES;
  462|    102|            last_block = flag_word(false);
  463|    102|            last_node = flag_word(false);
  464|    102|        };
  465|       |
  466|    918|        count = count.wrapping_add(count_delta as Count);
  467|    918|        compress_block(block, &mut local_words, count, last_block, last_node);
  468|    918|
  469|    918|        // Check for termination before bumping the offset, to avoid overflow.
  470|    918|        if offset == fin_offset {
  471|    816|            break;
  472|    102|        }
  473|    102|
  474|    102|        offset += stride.padded_blockbytes();
  475|       |    }
  476|       |
  477|    816|    *words = local_words;
  478|    816|}
_RNvNtCshBpGUmeBfYm_12blake2b_simd4avx22g1:
  107|  22.0k|unsafe fn g1(a: &mut __m256i, b: &mut __m256i, c: &mut __m256i, d: &mut __m256i, m: &mut __m256i) {
  108|  22.0k|    *a = add(*a, *m);
  109|  22.0k|    *a = add(*a, *b);
  110|  22.0k|    *d = xor(*d, *a);
  111|  22.0k|    *d = rot32(*d);
  112|  22.0k|    *c = add(*c, *d);
  113|  22.0k|    *b = xor(*b, *c);
  114|  22.0k|    *b = rot24(*b);
  115|  22.0k|}
_RNvNtCshBpGUmeBfYm_12blake2b_simd4avx213undiagonalize:
  139|  11.0k|unsafe fn undiagonalize(a: &mut __m256i, _b: &mut __m256i, c: &mut __m256i, d: &mut __m256i) {
  140|  11.0k|    *a = _mm256_permute4x64_epi64(*a, _MM_SHUFFLE!(0, 3, 2, 1));
  141|  11.0k|    *d = _mm256_permute4x64_epi64(*d, _MM_SHUFFLE!(1, 0, 3, 2));
  142|  11.0k|    *c = _mm256_permute4x64_epi64(*c, _MM_SHUFFLE!(2, 1, 0, 3));
  143|  11.0k|}
_RNvNtCshBpGUmeBfYm_12blake2b_simd4avx25rot63:
  102|  22.0k|unsafe fn rot63(x: __m256i) -> __m256i {
  103|  22.0k|    _mm256_or_si256(_mm256_srli_epi64(x, 63), _mm256_slli_epi64(x, 64 - 63))
  104|  22.0k|}
_RNvNtCshBpGUmeBfYm_12blake2b_simd4avx211diagonalize:
  132|  11.0k|unsafe fn diagonalize(a: &mut __m256i, _b: &mut __m256i, c: &mut __m256i, d: &mut __m256i) {
  133|  11.0k|    *a = _mm256_permute4x64_epi64(*a, _MM_SHUFFLE!(2, 1, 0, 3));
  134|  11.0k|    *d = _mm256_permute4x64_epi64(*d, _MM_SHUFFLE!(1, 0, 3, 2));
  135|  11.0k|    *c = _mm256_permute4x64_epi64(*c, _MM_SHUFFLE!(0, 3, 2, 1));
  136|  11.0k|}
_RNvNtCshBpGUmeBfYm_12blake2b_simd4avx22g2:
  118|  22.0k|unsafe fn g2(a: &mut __m256i, b: &mut __m256i, c: &mut __m256i, d: &mut __m256i, m: &mut __m256i) {
  119|  22.0k|    *a = add(*a, *m);
  120|  22.0k|    *a = add(*a, *b);
  121|  22.0k|    *d = xor(*d, *a);
  122|  22.0k|    *d = rot16(*d);
  123|  22.0k|    *c = add(*c, *d);
  124|  22.0k|    *b = xor(*b, *c);
  125|  22.0k|    *b = rot63(*b);
  126|  22.0k|}
_RNvNtCshBpGUmeBfYm_12blake2b_simd4avx23xor:
   56|  92.7k|unsafe fn xor(a: __m256i, b: __m256i) -> __m256i {
   57|  92.7k|    _mm256_xor_si256(a, b)
   58|  92.7k|}
_RNvNtCshBpGUmeBfYm_12blake2b_simd4avx214compress_block:
  146|    918|unsafe fn compress_block(
  147|    918|    block: &[u8; BLOCKBYTES],
  148|    918|    words: &mut [Word; 8],
  149|    918|    count: Count,
  150|    918|    last_block: Word,
  151|    918|    last_node: Word,
  152|    918|) {
  153|    918|    let (words_low, words_high) = mut_array_refs!(words, DEGREE, DEGREE);
  154|    918|    let (iv_low, iv_high) = array_refs!(&IV, DEGREE, DEGREE);
  155|    918|    let mut a = loadu(words_low);
  156|    918|    let mut b = loadu(words_high);
  157|    918|    let mut c = loadu(iv_low);
  158|    918|    let flags = set4(count_low(count), count_high(count), last_block, last_node);
  159|    918|    let mut d = xor(loadu(iv_high), flags);
  160|    918|
  161|    918|    let msg_chunks = array_refs!(block, 16, 16, 16, 16, 16, 16, 16, 16);
  162|    918|    let m0 = _mm256_broadcastsi128_si256(loadu_128(msg_chunks.0));
  163|    918|    let m1 = _mm256_broadcastsi128_si256(loadu_128(msg_chunks.1));
  164|    918|    let m2 = _mm256_broadcastsi128_si256(loadu_128(msg_chunks.2));
  165|    918|    let m3 = _mm256_broadcastsi128_si256(loadu_128(msg_chunks.3));
  166|    918|    let m4 = _mm256_broadcastsi128_si256(loadu_128(msg_chunks.4));
  167|    918|    let m5 = _mm256_broadcastsi128_si256(loadu_128(msg_chunks.5));
  168|    918|    let m6 = _mm256_broadcastsi128_si256(loadu_128(msg_chunks.6));
  169|    918|    let m7 = _mm256_broadcastsi128_si256(loadu_128(msg_chunks.7));
  170|    918|
  171|    918|    let iv0 = a;
  172|    918|    let iv1 = b;
  173|    918|    let mut t0;
  174|    918|    let mut t1;
  175|    918|    let mut b0;
  176|    918|
  177|    918|    // round 1
  178|    918|    t0 = _mm256_unpacklo_epi64(m0, m1);
  179|    918|    t1 = _mm256_unpacklo_epi64(m2, m3);
  180|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  181|    918|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  182|    918|    t0 = _mm256_unpackhi_epi64(m0, m1);
  183|    918|    t1 = _mm256_unpackhi_epi64(m2, m3);
  184|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  185|    918|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  186|    918|    diagonalize(&mut a, &mut b, &mut c, &mut d);
  187|    918|    t0 = _mm256_unpacklo_epi64(m7, m4);
  188|    918|    t1 = _mm256_unpacklo_epi64(m5, m6);
  189|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  190|    918|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  191|    918|    t0 = _mm256_unpackhi_epi64(m7, m4);
  192|    918|    t1 = _mm256_unpackhi_epi64(m5, m6);
  193|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  194|    918|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  195|    918|    undiagonalize(&mut a, &mut b, &mut c, &mut d);
  196|    918|
  197|    918|    // round 2
  198|    918|    t0 = _mm256_unpacklo_epi64(m7, m2);
  199|    918|    t1 = _mm256_unpackhi_epi64(m4, m6);
  200|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  201|    918|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  202|    918|    t0 = _mm256_unpacklo_epi64(m5, m4);
  203|    918|    t1 = _mm256_alignr_epi8(m3, m7, 8);
  204|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  205|    918|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  206|    918|    diagonalize(&mut a, &mut b, &mut c, &mut d);
  207|    918|    t0 = _mm256_unpackhi_epi64(m2, m0);
  208|    918|    t1 = _mm256_blend_epi32(m5, m0, 0x33);
  209|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  210|    918|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  211|    918|    t0 = _mm256_alignr_epi8(m6, m1, 8);
  212|    918|    t1 = _mm256_blend_epi32(m3, m1, 0x33);
  213|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  214|    918|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  215|    918|    undiagonalize(&mut a, &mut b, &mut c, &mut d);
  216|    918|
  217|    918|    // round 3
  218|    918|    t0 = _mm256_alignr_epi8(m6, m5, 8);
  219|    918|    t1 = _mm256_unpackhi_epi64(m2, m7);
  220|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  221|    918|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  222|    918|    t0 = _mm256_unpacklo_epi64(m4, m0);
  223|    918|    t1 = _mm256_blend_epi32(m6, m1, 0x33);
  224|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  225|    918|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  226|    918|    diagonalize(&mut a, &mut b, &mut c, &mut d);
  227|    918|    t0 = _mm256_alignr_epi8(m5, m4, 8);
  228|    918|    t1 = _mm256_unpackhi_epi64(m1, m3);
  229|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  230|    918|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  231|    918|    t0 = _mm256_unpacklo_epi64(m2, m7);
  232|    918|    t1 = _mm256_blend_epi32(m0, m3, 0x33);
  233|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  234|    918|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  235|    918|    undiagonalize(&mut a, &mut b, &mut c, &mut d);
  236|    918|
  237|    918|    // round 4
  238|    918|    t0 = _mm256_unpackhi_epi64(m3, m1);
  239|    918|    t1 = _mm256_unpackhi_epi64(m6, m5);
  240|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  241|    918|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  242|    918|    t0 = _mm256_unpackhi_epi64(m4, m0);
  243|    918|    t1 = _mm256_unpacklo_epi64(m6, m7);
  244|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  245|    918|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  246|    918|    diagonalize(&mut a, &mut b, &mut c, &mut d);
  247|    918|    t0 = _mm256_alignr_epi8(m1, m7, 8);
  248|    918|    t1 = _mm256_shuffle_epi32(m2, _MM_SHUFFLE!(1, 0, 3, 2));
  249|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  250|    918|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  251|    918|    t0 = _mm256_unpacklo_epi64(m4, m3);
  252|    918|    t1 = _mm256_unpacklo_epi64(m5, m0);
  253|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  254|    918|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  255|    918|    undiagonalize(&mut a, &mut b, &mut c, &mut d);
  256|    918|
  257|    918|    // round 5
  258|    918|    t0 = _mm256_unpackhi_epi64(m4, m2);
  259|    918|    t1 = _mm256_unpacklo_epi64(m1, m5);
  260|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  261|    918|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  262|    918|    t0 = _mm256_blend_epi32(m3, m0, 0x33);
  263|    918|    t1 = _mm256_blend_epi32(m7, m2, 0x33);
  264|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  265|    918|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  266|    918|    diagonalize(&mut a, &mut b, &mut c, &mut d);
  267|    918|    t0 = _mm256_alignr_epi8(m7, m1, 8);
  268|    918|    t1 = _mm256_alignr_epi8(m3, m5, 8);
  269|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  270|    918|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  271|    918|    t0 = _mm256_unpackhi_epi64(m6, m0);
  272|    918|    t1 = _mm256_unpacklo_epi64(m6, m4);
  273|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  274|    918|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  275|    918|    undiagonalize(&mut a, &mut b, &mut c, &mut d);
  276|    918|
  277|    918|    // round 6
  278|    918|    t0 = _mm256_unpacklo_epi64(m1, m3);
  279|    918|    t1 = _mm256_unpacklo_epi64(m0, m4);
  280|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  281|    918|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  282|    918|    t0 = _mm256_unpacklo_epi64(m6, m5);
  283|    918|    t1 = _mm256_unpackhi_epi64(m5, m1);
  284|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  285|    918|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  286|    918|    diagonalize(&mut a, &mut b, &mut c, &mut d);
  287|    918|    t0 = _mm256_alignr_epi8(m2, m0, 8);
  288|    918|    t1 = _mm256_unpackhi_epi64(m3, m7);
  289|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  290|    918|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  291|    918|    t0 = _mm256_unpackhi_epi64(m4, m6);
  292|    918|    t1 = _mm256_alignr_epi8(m7, m2, 8);
  293|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  294|    918|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  295|    918|    undiagonalize(&mut a, &mut b, &mut c, &mut d);
  296|    918|
  297|    918|    // round 7
  298|    918|    t0 = _mm256_blend_epi32(m0, m6, 0x33);
  299|    918|    t1 = _mm256_unpacklo_epi64(m7, m2);
  300|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  301|    918|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  302|    918|    t0 = _mm256_unpackhi_epi64(m2, m7);
  303|    918|    t1 = _mm256_alignr_epi8(m5, m6, 8);
  304|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  305|    918|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  306|    918|    diagonalize(&mut a, &mut b, &mut c, &mut d);
  307|    918|    t0 = _mm256_unpacklo_epi64(m4, m0);
  308|    918|    t1 = _mm256_blend_epi32(m4, m3, 0x33);
  309|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  310|    918|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  311|    918|    t0 = _mm256_unpackhi_epi64(m5, m3);
  312|    918|    t1 = _mm256_shuffle_epi32(m1, _MM_SHUFFLE!(1, 0, 3, 2));
  313|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  314|    918|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  315|    918|    undiagonalize(&mut a, &mut b, &mut c, &mut d);
  316|    918|
  317|    918|    // round 8
  318|    918|    t0 = _mm256_unpackhi_epi64(m6, m3);
  319|    918|    t1 = _mm256_blend_epi32(m1, m6, 0x33);
  320|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  321|    918|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  322|    918|    t0 = _mm256_alignr_epi8(m7, m5, 8);
  323|    918|    t1 = _mm256_unpackhi_epi64(m0, m4);
  324|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  325|    918|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  326|    918|    diagonalize(&mut a, &mut b, &mut c, &mut d);
  327|    918|    t0 = _mm256_blend_epi32(m2, m1, 0x33);
  328|    918|    t1 = _mm256_alignr_epi8(m4, m7, 8);
  329|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  330|    918|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  331|    918|    t0 = _mm256_unpacklo_epi64(m5, m0);
  332|    918|    t1 = _mm256_unpacklo_epi64(m2, m3);
  333|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  334|    918|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  335|    918|    undiagonalize(&mut a, &mut b, &mut c, &mut d);
  336|    918|
  337|    918|    // round 9
  338|    918|    t0 = _mm256_unpacklo_epi64(m3, m7);
  339|    918|    t1 = _mm256_alignr_epi8(m0, m5, 8);
  340|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  341|    918|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  342|    918|    t0 = _mm256_unpackhi_epi64(m7, m4);
  343|    918|    t1 = _mm256_alignr_epi8(m4, m1, 8);
  344|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  345|    918|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  346|    918|    diagonalize(&mut a, &mut b, &mut c, &mut d);
  347|    918|    t0 = _mm256_unpacklo_epi64(m5, m6);
  348|    918|    t1 = _mm256_unpackhi_epi64(m6, m0);
  349|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  350|    918|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  351|    918|    t0 = _mm256_alignr_epi8(m1, m2, 8);
  352|    918|    t1 = _mm256_alignr_epi8(m2, m3, 8);
  353|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  354|    918|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  355|    918|    undiagonalize(&mut a, &mut b, &mut c, &mut d);
  356|    918|
  357|    918|    // round 10
  358|    918|    t0 = _mm256_unpacklo_epi64(m5, m4);
  359|    918|    t1 = _mm256_unpackhi_epi64(m3, m0);
  360|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  361|    918|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  362|    918|    t0 = _mm256_unpacklo_epi64(m1, m2);
  363|    918|    t1 = _mm256_blend_epi32(m2, m3, 0x33);
  364|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  365|    918|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  366|    918|    diagonalize(&mut a, &mut b, &mut c, &mut d);
  367|    918|    t0 = _mm256_unpackhi_epi64(m6, m7);
  368|    918|    t1 = _mm256_unpackhi_epi64(m4, m1);
  369|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  370|    918|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  371|    918|    t0 = _mm256_blend_epi32(m5, m0, 0x33);
  372|    918|    t1 = _mm256_unpacklo_epi64(m7, m6);
  373|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  374|    918|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  375|    918|    undiagonalize(&mut a, &mut b, &mut c, &mut d);
  376|    918|
  377|    918|    // round 11
  378|    918|    t0 = _mm256_unpacklo_epi64(m0, m1);
  379|    918|    t1 = _mm256_unpacklo_epi64(m2, m3);
  380|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  381|    918|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  382|    918|    t0 = _mm256_unpackhi_epi64(m0, m1);
  383|    918|    t1 = _mm256_unpackhi_epi64(m2, m3);
  384|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  385|    918|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  386|    918|    diagonalize(&mut a, &mut b, &mut c, &mut d);
  387|    918|    t0 = _mm256_unpacklo_epi64(m7, m4);
  388|    918|    t1 = _mm256_unpacklo_epi64(m5, m6);
  389|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  390|    918|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  391|    918|    t0 = _mm256_unpackhi_epi64(m7, m4);
  392|    918|    t1 = _mm256_unpackhi_epi64(m5, m6);
  393|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  394|    918|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  395|    918|    undiagonalize(&mut a, &mut b, &mut c, &mut d);
  396|    918|
  397|    918|    // round 12
  398|    918|    t0 = _mm256_unpacklo_epi64(m7, m2);
  399|    918|    t1 = _mm256_unpackhi_epi64(m4, m6);
  400|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  401|    918|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  402|    918|    t0 = _mm256_unpacklo_epi64(m5, m4);
  403|    918|    t1 = _mm256_alignr_epi8(m3, m7, 8);
  404|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  405|    918|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  406|    918|    diagonalize(&mut a, &mut b, &mut c, &mut d);
  407|    918|    t0 = _mm256_unpackhi_epi64(m2, m0);
  408|    918|    t1 = _mm256_blend_epi32(m5, m0, 0x33);
  409|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  410|    918|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  411|    918|    t0 = _mm256_alignr_epi8(m6, m1, 8);
  412|    918|    t1 = _mm256_blend_epi32(m3, m1, 0x33);
  413|    918|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  414|    918|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  415|    918|    undiagonalize(&mut a, &mut b, &mut c, &mut d);
  416|    918|
  417|    918|    a = xor(a, c);
  418|    918|    b = xor(b, d);
  419|    918|    a = xor(a, iv0);
  420|    918|    b = xor(b, iv1);
  421|    918|
  422|    918|    storeu(a, words_low);
  423|    918|    storeu(b, words_high);
  424|    918|}
_RNvNtCshBpGUmeBfYm_12blake2b_simd4avx24set4:
   66|    918|unsafe fn set4(a: u64, b: u64, c: u64, d: u64) -> __m256i {
   67|    918|    _mm256_setr_epi64x(a as i64, b as i64, c as i64, d as i64)
   68|    918|}
_RNvNtCshBpGUmeBfYm_12blake2b_simd4avx25loadu:
   18|  3.67k|unsafe fn loadu(src: *const [Word; DEGREE]) -> __m256i {
   19|  3.67k|    // This is an unaligned load, so the pointer cast is allowed.
   20|  3.67k|    _mm256_loadu_si256(src as *const __m256i)
   21|  3.67k|}
_RNvNtCshBpGUmeBfYm_12blake2b_simd4avx25rot24:
   92|  22.0k|unsafe fn rot24(x: __m256i) -> __m256i {
   93|  22.0k|    _mm256_or_si256(_mm256_srli_epi64(x, 24), _mm256_slli_epi64(x, 64 - 24))
   94|  22.0k|}
_RNvNtCshBpGUmeBfYm_12blake2b_simd4avx29loadu_128:
   30|  7.34k|unsafe fn loadu_128(mem_addr: &[u8; 16]) -> __m128i {
   31|  7.34k|    _mm_loadu_si128(mem_addr.as_ptr() as *const __m128i)
   32|  7.34k|}
_RNvNtCshBpGUmeBfYm_12blake2b_simd4avx25rot16:
   97|  22.0k|unsafe fn rot16(x: __m256i) -> __m256i {
   98|  22.0k|    _mm256_or_si256(_mm256_srli_epi64(x, 16), _mm256_slli_epi64(x, 64 - 16))
   99|  22.0k|}

_RNvNtCshBpGUmeBfYm_12blake2b_simd4guts11final_block:
  232|    816|pub fn final_block<'a>(
  233|    816|    input: &'a [u8],
  234|    816|    offset: usize,
  235|    816|    buffer: &'a mut [u8; BLOCKBYTES],
  236|    816|    stride: Stride,
  237|    816|) -> (&'a [u8; BLOCKBYTES], usize, bool) {
  238|    816|    let capped_offset = cmp::min(offset, input.len());
  239|    816|    let offset_slice = &input[capped_offset..];
  240|    816|    if offset_slice.len() >= BLOCKBYTES {
  241|    102|        let block = array_ref!(offset_slice, 0, BLOCKBYTES);
  242|    102|        let should_finalize = offset_slice.len() <= stride.padded_blockbytes();
  243|    102|        (block, BLOCKBYTES, should_finalize)
  244|       |    } else {
  245|       |        // Copy the final block to the front of the block buffer. The rest of
  246|       |        // the buffer is assumed to be initialized to zero.
  247|    714|        buffer[..offset_slice.len()].copy_from_slice(offset_slice);
  248|    714|        (buffer, offset_slice.len(), true)
  249|       |    }
  250|    816|}
_RNvMNtCshBpGUmeBfYm_12blake2b_simd4gutsNtB2_14Implementation6detect:
   33|    714|            if let Some(avx2_impl) = Self::avx2_if_supported() {
   34|    714|                return avx2_impl;
   35|      0|            }
   36|       |        }
   37|       |        #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
   38|       |        {
   39|      0|            if let Some(sse41_impl) = Self::sse41_if_supported() {
   40|      0|                return sse41_impl;
   41|      0|            }
   42|      0|        }
   43|      0|        Self::portable()
   44|    714|    }
_RNvMs1_NtCshBpGUmeBfYm_12blake2b_simd4gutsNtB5_8LastNode3yes:
  181|    714|    pub fn yes(&self) -> bool {
  182|    714|        match self {
  183|      0|            LastNode::Yes => true,
  184|    714|            LastNode::No => false,
  185|       |        }
  186|    714|    }
_RNvMNtCshBpGUmeBfYm_12blake2b_simd4gutsNtB2_14Implementation14compress1_loop:
   96|    816|    pub fn compress1_loop(
   97|    816|        &self,
   98|    816|        input: &[u8],
   99|    816|        words: &mut [Word; 8],
  100|    816|        count: Count,
  101|    816|        last_node: LastNode,
  102|    816|        finalize: Finalize,
  103|    816|        stride: Stride,
  104|    816|    ) {
  105|    816|        match self.0 {
  106|       |            #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
  107|    816|            Platform::AVX2 => unsafe {
  108|    816|                avx2::compress1_loop(input, words, count, last_node, finalize, stride);
  109|    816|            },
  110|       |            // Note that there's an SSE version of compress1 in the official C
  111|       |            // implementation, but I haven't ported it yet.
  112|      0|            _ => {
  113|      0|                portable::compress1_loop(input, words, count, last_node, finalize, stride);
  114|      0|            }
  115|       |        }
  116|    816|    }
_RNvNtCshBpGUmeBfYm_12blake2b_simd4guts19input_debug_asserts:
  252|    816|pub fn input_debug_asserts(input: &[u8], finalize: Finalize) {
  253|    816|    // If we're not finalizing, the input must not be empty, and it must be an
  254|    816|    // even multiple of the block size.
  255|    816|    if !finalize.yes() {
  256|    102|        debug_assert!(!input.is_empty());
  257|    102|        debug_assert_eq!(0, input.len() % BLOCKBYTES);
  258|    714|    }
  259|    816|}
_RNvMs2_NtCshBpGUmeBfYm_12blake2b_simd4gutsNtB5_6Stride17padded_blockbytes:
  196|  1.02k|    pub fn padded_blockbytes(&self) -> usize {
  197|  1.02k|        match self {
  198|  1.02k|            Stride::Serial => BLOCKBYTES,
  199|      0|            Stride::Parallel => blake2bp::DEGREE * BLOCKBYTES,
  200|       |        }
  201|  1.02k|    }
_RNvMs0_NtCshBpGUmeBfYm_12blake2b_simd4gutsNtB5_8Finalize3yes:
  165|  2.44k|    pub fn yes(&self) -> bool {
  166|  2.44k|        match self {
  167|  2.14k|            Finalize::Yes => true,
  168|    306|            Finalize::No => false,
  169|       |        }
  170|  2.44k|    }
_RNvMNtCshBpGUmeBfYm_12blake2b_simd4gutsNtB2_14Implementation17avx2_if_supported:
   70|    714|    pub fn avx2_if_supported() -> Option<Self> {
   71|       |        // Check whether AVX2 support is assumed by the build.
   72|       |        #[cfg(target_feature = "avx2")]
   73|       |        {
   74|       |            return Some(Implementation(Platform::AVX2));
   75|       |        }
   76|       |        // Otherwise dynamically check for support if we can.
   77|       |        #[cfg(feature = "std")]
   78|       |        {
   79|      0|            if is_x86_feature_detected!("avx2") {
   80|    714|                return Some(Implementation(Platform::AVX2));
   81|      0|            }
   82|      0|        }
   83|      0|        None
   84|    714|    }
_RNvNtCshBpGUmeBfYm_12blake2b_simd4guts9count_low:
  204|    918|pub(crate) fn count_low(count: Count) -> Word {
  205|    918|    count as Word
  206|    918|}
_RNvNtCshBpGUmeBfYm_12blake2b_simd4guts9flag_word:
  217|  1.83k|pub(crate) fn flag_word(flag: bool) -> Word {
  218|  1.83k|    if flag {
  219|    714|        !0
  220|       |    } else {
  221|  1.12k|        0
  222|       |    }
  223|  1.83k|}
_RNvNtCshBpGUmeBfYm_12blake2b_simd4guts10count_high:
  208|    918|pub(crate) fn count_high(count: Count) -> Word {
  209|    918|    (count >> 8 * size_of::<Word>()) as Word
  210|    918|}

_RNvMCshBpGUmeBfYm_12blake2b_simdNtB2_6Params3new:
  165|    714|    pub fn new() -> Self {
  166|    714|        Self {
  167|    714|            hash_length: OUTBYTES as u8,
  168|    714|            key_length: 0,
  169|    714|            key_block: [0; BLOCKBYTES],
  170|    714|            salt: [0; SALTBYTES],
  171|    714|            personal: [0; PERSONALBYTES],
  172|    714|            // NOTE: fanout and max_depth don't default to zero!
  173|    714|            fanout: 1,
  174|    714|            max_depth: 1,
  175|    714|            max_leaf_length: 0,
  176|    714|            node_offset: 0,
  177|    714|            node_depth: 0,
  178|    714|            inner_hash_length: 0,
  179|    714|            last_node: guts::LastNode::No,
  180|    714|            implementation: guts::Implementation::detect(),
  181|    714|        }
  182|    714|    }
_RNvMCshBpGUmeBfYm_12blake2b_simdNtB2_6Params11hash_length:
  238|    714|    pub fn hash_length(&mut self, length: usize) -> &mut Self {
  239|    714|        assert!(
  240|    714|            1 <= length && length <= OUTBYTES,
  241|      0|            "Bad hash length: {}",
  242|       |            length
  243|       |        );
  244|    714|        self.hash_length = length as u8;
  245|    714|        self
  246|    714|    }
_RNvMs1_CshBpGUmeBfYm_12blake2b_simdNtB5_5State11with_params:
  406|    714|    fn with_params(params: &Params) -> Self {
  407|    714|        let mut state = Self {
  408|    714|            words: params.to_words(),
  409|    714|            count: 0,
  410|    714|            buf: [0; BLOCKBYTES],
  411|    714|            buflen: 0,
  412|    714|            last_node: params.last_node,
  413|    714|            hash_length: params.hash_length,
  414|    714|            implementation: params.implementation,
  415|    714|            is_keyed: params.key_length > 0,
  416|    714|        };
  417|    714|        if state.is_keyed {
  418|      0|            state.buf = params.key_block;
  419|      0|            state.buflen = state.buf.len() as u8;
  420|    714|        }
  421|    714|        state
  422|    714|    }
_RNvMCshBpGUmeBfYm_12blake2b_simdNtB2_6Params8to_state:
  230|    714|    pub fn to_state(&self) -> State {
  231|    714|        State::with_params(self)
  232|    714|    }
_RNvMs1_CshBpGUmeBfYm_12blake2b_simdNtB5_5State27compress_buffer_if_possible:
  434|    714|    fn compress_buffer_if_possible(&mut self, input: &mut &[u8]) {
  435|    714|        if self.buflen > 0 {
  436|      0|            self.fill_buf(input);
  437|      0|            if !input.is_empty() {
  438|      0|                self.implementation.compress1_loop(
  439|      0|                    &self.buf,
  440|      0|                    &mut self.words,
  441|      0|                    self.count,
  442|      0|                    self.last_node,
  443|      0|                    guts::Finalize::No,
  444|      0|                    guts::Stride::Serial,
  445|      0|                );
  446|      0|                self.count = self.count.wrapping_add(BLOCKBYTES as Count);
  447|      0|                self.buflen = 0;
  448|      0|            }
  449|    714|        }
  450|    714|    }
_RNvMs5_CshBpGUmeBfYm_12blake2b_simdNtB5_4Hash8as_bytes:
  589|    714|    pub fn as_bytes(&self) -> &[u8] {
  590|    714|        &self.bytes[..self.len as usize]
  591|    714|    }
_RNvCshBpGUmeBfYm_12blake2b_simd20state_words_to_bytes:
  529|    714|fn state_words_to_bytes(state_words: &[Word; 8]) -> [u8; OUTBYTES] {
  530|    714|    let mut bytes = [0; OUTBYTES];
  531|    714|    {
  532|    714|        const W: usize = size_of::<Word>();
  533|    714|        let refs = mut_array_refs!(&mut bytes, W, W, W, W, W, W, W, W);
  534|    714|        *refs.0 = state_words[0].to_le_bytes();
  535|    714|        *refs.1 = state_words[1].to_le_bytes();
  536|    714|        *refs.2 = state_words[2].to_le_bytes();
  537|    714|        *refs.3 = state_words[3].to_le_bytes();
  538|    714|        *refs.4 = state_words[4].to_le_bytes();
  539|    714|        *refs.5 = state_words[5].to_le_bytes();
  540|    714|        *refs.6 = state_words[6].to_le_bytes();
  541|    714|        *refs.7 = state_words[7].to_le_bytes();
  542|    714|    }
  543|    714|    bytes
  544|    714|}
_RNvMs1_CshBpGUmeBfYm_12blake2b_simdNtB5_5State6update:
  453|    714|    pub fn update(&mut self, mut input: &[u8]) -> &mut Self {
  454|    714|        // If we have a partial buffer, try to complete it.
  455|    714|        self.compress_buffer_if_possible(&mut input);
  456|    714|        // While there's more than a block of input left (which also means we cleared the buffer
  457|    714|        // above), compress blocks directly without copying.
  458|    714|        let mut end = input.len().saturating_sub(1);
  459|    714|        end -= end % BLOCKBYTES;
  460|    714|        if end > 0 {
  461|    102|            self.implementation.compress1_loop(
  462|    102|                &input[..end],
  463|    102|                &mut self.words,
  464|    102|                self.count,
  465|    102|                self.last_node,
  466|    102|                guts::Finalize::No,
  467|    102|                guts::Stride::Serial,
  468|    102|            );
  469|    102|            self.count = self.count.wrapping_add(end as Count);
  470|    102|            input = &input[end..];
  471|    612|        }
  472|       |        // Buffer any remaining input, to be either compressed or finalized in a subsequent call.
  473|       |        // Note that this represents some copying overhead, which in theory we could avoid in
  474|       |        // all-at-once setting. A function hardcoded for exactly BLOCKSIZE input bytes is about 10%
  475|       |        // faster than using this implementation for the same input.
  476|    714|        self.fill_buf(&mut input);
  477|    714|        self
  478|    714|    }
_RNvMCshBpGUmeBfYm_12blake2b_simdNtB2_6Params8to_words:
  185|    714|    fn to_words(&self) -> [Word; 8] {
  186|    714|        let (salt_left, salt_right) = array_refs!(&self.salt, SALTBYTES / 2, SALTBYTES / 2);
  187|    714|        let (personal_left, personal_right) =
  188|    714|            array_refs!(&self.personal, PERSONALBYTES / 2, PERSONALBYTES / 2);
  189|    714|        [
  190|    714|            IV[0]
  191|    714|                ^ self.hash_length as u64
  192|    714|                ^ (self.key_length as u64) << 8
  193|    714|                ^ (self.fanout as u64) << 16
  194|    714|                ^ (self.max_depth as u64) << 24
  195|    714|                ^ (self.max_leaf_length as u64) << 32,
  196|    714|            IV[1] ^ self.node_offset,
  197|    714|            IV[2] ^ self.node_depth as u64 ^ (self.inner_hash_length as u64) << 8,
  198|    714|            IV[3],
  199|    714|            IV[4] ^ Word::from_le_bytes(*salt_left),
  200|    714|            IV[5] ^ Word::from_le_bytes(*salt_right),
  201|    714|            IV[6] ^ Word::from_le_bytes(*personal_left),
  202|    714|            IV[7] ^ Word::from_le_bytes(*personal_right),
  203|    714|        ]
  204|    714|    }
_RNvMs1_CshBpGUmeBfYm_12blake2b_simdNtB5_5State8finalize:
  482|    714|    pub fn finalize(&self) -> Hash {
  483|    714|        let mut words_copy = self.words;
  484|    714|        self.implementation.compress1_loop(
  485|    714|            &self.buf[..self.buflen as usize],
  486|    714|            &mut words_copy,
  487|    714|            self.count,
  488|    714|            self.last_node,
  489|    714|            guts::Finalize::Yes,
  490|    714|            guts::Stride::Serial,
  491|    714|        );
  492|    714|        Hash {
  493|    714|            bytes: state_words_to_bytes(&words_copy),
  494|    714|            len: self.hash_length,
  495|    714|        }
  496|    714|    }
_RNvMs1_CshBpGUmeBfYm_12blake2b_simdNtB5_5State8fill_buf:
  424|    714|    fn fill_buf(&mut self, input: &mut &[u8]) {
  425|    714|        let take = cmp::min(BLOCKBYTES - self.buflen as usize, input.len());
  426|    714|        self.buf[self.buflen as usize..self.buflen as usize + take].copy_from_slice(&input[..take]);
  427|    714|        self.buflen += take as u8;
  428|    714|        *input = &input[take..];
  429|    714|    }

_RNvMs3_CsfHI3Vi76JtG_12block_bufferINtB5_11BlockBufferINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIBR_IBR_IBR_IBR_IBR_IBR_NtBT_5UTermNtNtBV_3bit2B1ENtB22_2B0EB2f_EB2f_EB2f_EB2f_EB2f_ENtB5_5EagerE4sizeCsitTtQF8ArIt_8fvm_fuzz:
  220|    612|    pub fn size(&self) -> usize {
  221|    612|        BlockSize::USIZE
  222|    612|    }
_RNvMs3_CsfHI3Vi76JtG_12block_bufferINtB5_11BlockBufferINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIBR_IBR_IBR_IBR_IBR_IBR_NtBT_5UTermNtNtBV_3bit2B1ENtB22_2B0EB2f_EB2f_EB2f_EB2f_EB2f_ENtB5_5EagerE7get_posCsitTtQF8ArIt_8fvm_fuzz:
  189|    612|    pub fn get_pos(&self) -> usize {
  190|    612|        let pos = self.pos as usize;
  191|    612|        if !Kind::invariant(pos, BlockSize::USIZE) {
  192|      0|            debug_assert!(false);
  193|       |            // SAFETY: `pos` never breaks the invariant
  194|       |            unsafe {
  195|      0|                core::hint::unreachable_unchecked();
  196|       |            }
  197|    612|        }
  198|    612|        pos
  199|    612|    }
_RNvMs3_CsfHI3Vi76JtG_12block_bufferINtB5_11BlockBufferINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIBR_IBR_IBR_IBR_IBR_IBR_NtBT_5UTermNtNtBV_3bit2B1ENtB22_2B0EB2f_EB2f_EB2f_EB2f_EB2f_ENtB5_5EagerE17set_pos_uncheckedCsitTtQF8ArIt_8fvm_fuzz:
  231|    306|    fn set_pos_unchecked(&mut self, pos: usize) {
  232|    306|        debug_assert!(Kind::invariant(pos, BlockSize::USIZE));
  233|    306|        self.pos = pos as u8;
  234|    306|    }
_RNvXs1_CsfHI3Vi76JtG_12block_bufferINtB5_11BlockBufferINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIBR_IBR_IBR_IBR_IBR_IBR_NtBT_5UTermNtNtBV_3bit2B1ENtB22_2B0EB2f_EB2f_EB2f_EB2f_EB2f_ENtB5_5EagerENtNtCshM4Il2Z0i4R_4core7default7Default7defaultCsitTtQF8ArIt_8fvm_fuzz:
   72|    306|    fn default() -> Self {
   73|    306|        Self {
   74|    306|            buffer: Default::default(),
   75|    306|            pos: 0,
   76|    306|            _pd: PhantomData,
   77|    306|        }
   78|    306|    }
_RINvMs4_CsfHI3Vi76JtG_12block_bufferINtB6_11BlockBufferINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIBS_IBS_IBS_IBS_IBS_IBS_NtBU_5UTermNtNtBW_3bit2B1ENtB23_2B0EB2g_EB2g_EB2g_EB2g_EB2g_ENtB6_5EagerE16len64_padding_beNCNvXs3_NtCsbCQy5qVcCrD_4sha28core_apiNtB3r_13Sha256VarCoreNtNtCs9gofsZWUQeH_6digest8core_api18VariableOutputCore22finalize_variable_core0ECsitTtQF8ArIt_8fvm_fuzz:
  315|    306|    pub fn len64_padding_be(&mut self, data_len: u64, compress: impl FnMut(&Block<BlockSize>)) {
  316|    306|        self.digest_pad(0x80, &data_len.to_be_bytes(), compress);
  317|    306|    }
_RINvMs4_CsfHI3Vi76JtG_12block_bufferINtB6_11BlockBufferINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIBS_IBS_IBS_IBS_IBS_IBS_NtBU_5UTermNtNtBW_3bit2B1ENtB23_2B0EB2g_EB2g_EB2g_EB2g_EB2g_ENtB6_5EagerE10digest_padNCNvXs3_NtCsbCQy5qVcCrD_4sha28core_apiNtB3l_13Sha256VarCoreNtNtCs9gofsZWUQeH_6digest8core_api18VariableOutputCore22finalize_variable_core0ECsitTtQF8ArIt_8fvm_fuzz:
  284|    306|    pub fn digest_pad(
  285|    306|        &mut self,
  286|    306|        delim: u8,
  287|    306|        suffix: &[u8],
  288|    306|        mut compress: impl FnMut(&Block<BlockSize>),
  289|    306|    ) {
  290|    306|        if suffix.len() > BlockSize::USIZE {
  291|      0|            panic!("suffix is too long");
  292|    306|        }
  293|    306|        let pos = self.get_pos();
  294|    306|        self.buffer[pos] = delim;
  295|  18.6k|        for b in &mut self.buffer[pos + 1..] {
  296|  18.6k|            *b = 0;
  297|  18.6k|        }
  298|       |
  299|    306|        let n = self.size() - suffix.len();
  300|    306|        if self.size() - pos - 1 < suffix.len() {
  301|      0|            compress(&self.buffer);
  302|      0|            let mut block = Block::<BlockSize>::default();
  303|      0|            block[n..].copy_from_slice(suffix);
  304|      0|            compress(&block);
  305|    306|        } else {
  306|    306|            self.buffer[n..].copy_from_slice(suffix);
  307|    306|            compress(&self.buffer);
  308|    306|        }
  309|    306|        self.set_pos_unchecked(0)
  310|    306|    }
_RNvMs3_CsfHI3Vi76JtG_12block_bufferINtB5_11BlockBufferINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIBR_IBR_IBR_IBR_IBR_IBR_NtBT_5UTermNtNtBV_3bit2B1ENtB22_2B0EB2f_EB2f_EB2f_EB2f_EB2f_ENtB5_5EagerE17set_pos_uncheckedCshRBVfIqfJKm_13fvm_ipld_hamt:
  231|    306|    fn set_pos_unchecked(&mut self, pos: usize) {
  232|    306|        debug_assert!(Kind::invariant(pos, BlockSize::USIZE));
  233|    306|        self.pos = pos as u8;
  234|    306|    }
_RINvMs3_CsfHI3Vi76JtG_12block_bufferINtB6_11BlockBufferINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIBS_IBS_IBS_IBS_IBS_IBS_NtBU_5UTermNtNtBW_3bit2B1ENtB23_2B0EB2g_EB2g_EB2g_EB2g_EB2g_ENtB6_5EagerE13digest_blocksNCNvXs6_NtNtCs9gofsZWUQeH_6digest8core_api7wrapperINtB3o_11CoreWrapperINtNtB3q_11ct_variable21CtVariableCoreWrapperNtNtCsbCQy5qVcCrD_4sha28core_api13Sha256VarCoreB1s_NtB5b_9OidSha256EENtB3s_6Update6update0ECshRBVfIqfJKm_13fvm_ipld_hamt:
  132|    306|    pub fn digest_blocks(
  133|    306|        &mut self,
  134|    306|        mut input: &[u8],
  135|    306|        mut compress: impl FnMut(&[Block<BlockSize>]),
  136|    306|    ) {
  137|    306|        let pos = self.get_pos();
  138|    306|        // using `self.remaining()` for some reason
  139|    306|        // prevents panic elimination
  140|    306|        let rem = self.size() - pos;
  141|    306|        let n = input.len();
  142|    306|        // Note that checking condition `pos + n < BlockSize` is
  143|    306|        // equivalent to checking `n < rem`, where `rem` is equal
  144|    306|        // to `BlockSize - pos`. Using the latter allows us to work
  145|    306|        // around compiler accounting for possible overflow of
  146|    306|        // `pos + n` which results in it inserting unreachable
  147|    306|        // panic branches. Using `unreachable_unchecked` in `get_pos`
  148|    306|        // we convince compiler that `BlockSize - pos` never underflows.
  149|    306|        if Kind::invariant(n, rem) {
  150|       |            // double slicing allows to remove panic branches
  151|    306|            self.buffer[pos..][..n].copy_from_slice(input);
  152|    306|            self.set_pos_unchecked(pos + n);
  153|    306|            return;
  154|      0|        }
  155|      0|        if pos != 0 {
  156|      0|            let (left, right) = input.split_at(rem);
  157|      0|            input = right;
  158|      0|            self.buffer[pos..].copy_from_slice(left);
  159|      0|            compress(slice::from_ref(&self.buffer));
  160|      0|        }
  161|       |
  162|      0|        let (blocks, leftover) = Kind::split_blocks(input);
  163|      0|        if !blocks.is_empty() {
  164|      0|            compress(blocks);
  165|      0|        }
  166|       |
  167|      0|        let n = leftover.len();
  168|      0|        self.buffer[..n].copy_from_slice(leftover);
  169|      0|        self.set_pos_unchecked(n);
  170|    306|    }
_RNvMs3_CsfHI3Vi76JtG_12block_bufferINtB5_11BlockBufferINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIBR_IBR_IBR_IBR_IBR_IBR_NtBT_5UTermNtNtBV_3bit2B1ENtB22_2B0EB2f_EB2f_EB2f_EB2f_EB2f_ENtB5_5EagerE7get_posCshRBVfIqfJKm_13fvm_ipld_hamt:
  189|    306|    pub fn get_pos(&self) -> usize {
  190|    306|        let pos = self.pos as usize;
  191|    306|        if !Kind::invariant(pos, BlockSize::USIZE) {
  192|      0|            debug_assert!(false);
  193|       |            // SAFETY: `pos` never breaks the invariant
  194|       |            unsafe {
  195|      0|                core::hint::unreachable_unchecked();
  196|       |            }
  197|    306|        }
  198|    306|        pos
  199|    306|    }
_RNvMs3_CsfHI3Vi76JtG_12block_bufferINtB5_11BlockBufferINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIBR_IBR_IBR_IBR_IBR_IBR_NtBT_5UTermNtNtBV_3bit2B1ENtB22_2B0EB2f_EB2f_EB2f_EB2f_EB2f_ENtB5_5EagerE4sizeCshRBVfIqfJKm_13fvm_ipld_hamt:
  220|    306|    pub fn size(&self) -> usize {
  221|    306|        BlockSize::USIZE
  222|    306|    }

_RNvXNtCsfHI3Vi76JtG_12block_buffer6sealedNtB4_5EagerNtB2_6Sealed9invariant:
   16|  1.83k|    fn invariant(pos: usize, block_size: usize) -> bool {
   17|  1.83k|        pos < block_size
   18|  1.83k|    }

_RNvXs0_CsaraggtY4BS1_9byteorderNtB5_9BigEndianNtB5_9ByteOrder9write_u64:
 2032|    816|    fn write_u64(buf: &mut [u8], n: u64) {
 2033|    816|        unsafe_write_num_bytes!(u64, 8, n, buf, to_be);
 2034|    816|    }
_RNvXs0_CsaraggtY4BS1_9byteorderNtB5_9BigEndianNtB5_9ByteOrder8read_u64:
 1982|    408|    fn read_u64(buf: &[u8]) -> u64 {
 1983|    408|        u64::from_be_bytes(buf[..8].try_into().unwrap())
 1984|    408|    }

_RINvYNtNtNtCsda7B5SchGu_7cbor4ii4core3dec8TagStartNtB5_6Decode6decodeNtNtB7_5utils11SliceReaderECsitTtQF8ArIt_8fvm_fuzz:
   73|  4.18k|    fn decode<R: Read<'a>>(reader: &mut R) -> Result<Self, Error<R::Error>> {
   74|  4.18k|        let byte = pull_one(reader)?;
   75|  4.18k|        Self::decode_with(byte, reader)
   76|  4.18k|    }
_RINvMs0_NtNtCsda7B5SchGu_7cbor4ii4core3decNtB6_7TypeNum10decode_u32NtNtB8_5utils11SliceReaderECsitTtQF8ArIt_8fvm_fuzz:
  204|    204|    fn decode_u32<'a, R: Read<'a>>(self, reader: &mut R) -> Result<u32, Error<R::Error>> {
  205|    204|        match self.byte & self.major_limit {
  206|    204|            x @ 0 ..= 0x17 => Ok(x.into()),
  207|      0|            0x18 => pull_one(reader).map(Into::into),
  208|       |            0x19 => {
  209|      0|                let mut buf = [0; 2];
  210|      0|                pull_exact(reader, &mut buf)?;
  211|      0|                Ok(u16::from_be_bytes(buf).into())
  212|       |            },
  213|       |            0x1a => {
  214|      0|                let mut buf = [0; 4];
  215|      0|                pull_exact(reader, &mut buf)?;
  216|      0|                Ok(u32::from_be_bytes(buf))
  217|       |            }
  218|      0|            _ => Err(Error::mismatch(self.major_limit, self.byte))
  219|       |        }
  220|    204|    }
_RINvMs0_NtNtCsda7B5SchGu_7cbor4ii4core3decNtB6_7TypeNum10decode_u64NtNtB8_5utils11SliceReaderECsitTtQF8ArIt_8fvm_fuzz:
  223|  17.7k|    pub(crate) fn decode_u64<'a, R: Read<'a>>(self, reader: &mut R) -> Result<u64, Error<R::Error>> {
  224|  17.7k|        match self.byte & self.major_limit {
  225|  17.7k|            x @ 0 ..= 0x17 => Ok(x.into()),
  226|  8.36k|            0x18 => pull_one(reader).map(Into::into),
  227|       |            0x19 => {
  228|      0|                let mut buf = [0; 2];
  229|      0|                pull_exact(reader, &mut buf)?;
  230|      0|                Ok(u16::from_be_bytes(buf).into())
  231|       |            },
  232|       |            0x1a => {
  233|      0|                let mut buf = [0; 4];
  234|      0|                pull_exact(reader, &mut buf)?;
  235|      0|                Ok(u32::from_be_bytes(buf).into())
  236|       |            },
  237|       |            0x1b => {
  238|      0|                let mut buf = [0; 8];
  239|      0|                pull_exact(reader, &mut buf)?;
  240|      0|                Ok(u64::from_be_bytes(buf))
  241|       |            },
  242|      0|            _ => Err(Error::mismatch(self.major_limit, self.byte))
  243|       |        }
  244|  17.7k|    }
_RNvMNtNtCsda7B5SchGu_7cbor4ii4core3decNtB2_9Reference6as_ref:
   81|  58.0k|    pub(crate) const fn as_ref(&self) -> &[u8] {
   82|  58.0k|        match self {
   83|  58.0k|            Reference::Long(buf) => buf,
   84|      0|            Reference::Short(buf) => buf
   85|       |        }
   86|  58.0k|    }
_RINvXsc_NtNtCsda7B5SchGu_7cbor4ii4core3decNtB6_10ArrayStartNtB6_6Decode11decode_withNtNtB8_5utils11SliceReaderECsitTtQF8ArIt_8fvm_fuzz:
  611|  4.79k|    fn decode_with<R: Read<'a>>(byte: u8, reader: &mut R) -> Result<Self, Error<R::Error>> {
  612|  4.79k|        decode_len(major::ARRAY, byte, reader).map(ArrayStart)
  613|  4.79k|    }
_RINvNtNtCsda7B5SchGu_7cbor4ii4core3dec10decode_bufNtNtB4_5utils11SliceReaderECsitTtQF8ArIt_8fvm_fuzz:
  427|  8.16k|fn decode_buf<'a, R: Read<'a>>(major: u8, byte: u8, reader: &mut R, buf: &mut Vec<u8>)
  428|  8.16k|    -> Result<Option<&'a [u8]>, Error<R::Error>>
  429|  8.16k|{
  430|       |    const CAP_LIMIT: usize = 16 * 1024;
  431|       |
  432|  8.16k|    if let Some(mut len) = decode_len(major, byte, reader)? {
  433|       |        // try long lifetime buffer
  434|  8.16k|        if let Reference::Long(buf) = reader.fill(len)? {
  435|  8.16k|            if buf.len() >= len {
  436|  8.16k|                reader.advance(len);
  437|  8.16k|                return Ok(Some(&buf[..len]));
  438|      0|            }
  439|      0|        }
  440|       |
  441|      0|        buf.reserve(core::cmp::min(len, CAP_LIMIT)); // TODO try_reserve ?
  442|       |
  443|      0|        while len != 0 {
  444|      0|            let readbuf = reader.fill(len)?;
  445|      0|            let readbuf = readbuf.as_ref();
  446|      0|
  447|      0|            if readbuf.is_empty() {
  448|      0|                return Err(Error::Eof);
  449|      0|            }
  450|      0|
  451|      0|            let readlen = core::cmp::min(readbuf.len(), len);
  452|      0|
  453|      0|            buf.extend_from_slice(&readbuf[..readlen]);
  454|      0|            reader.advance(readlen);
  455|      0|            len -= readlen;
  456|       |        }
  457|       |
  458|      0|        Ok(None)
  459|       |    } else {
  460|       |        // bytes sequence
  461|       |        loop {
  462|      0|            let byte = pull_one(reader)?;
  463|       |
  464|      0|            if byte == marker::BREAK {
  465|      0|                break
  466|      0|            }
  467|      0|
  468|      0|            if !reader.step_in() {
  469|      0|                return Err(Error::DepthLimit);
  470|      0|            }
  471|      0|            let mut reader = ScopeGuard(reader, |reader| reader.step_out());
  472|      0|            let reader = &mut *reader;
  473|       |
  474|      0|            if let Some(longbuf) = decode_buf(major, byte, reader, buf)? {
  475|      0|                buf.extend_from_slice(longbuf);
  476|      0|            }
  477|       |        }
  478|       |
  479|      0|        Ok(None)
  480|       |    }
  481|  8.16k|}
_RINvXsr_NtNtCsda7B5SchGu_7cbor4ii4core3decmNtB6_6Decode11decode_withNtNtB8_5utils11SliceReaderECsitTtQF8ArIt_8fvm_fuzz:
  252|    204|                fn decode_with<R: Read<'a>>(byte: u8, reader: &mut R) -> Result<Self, Error<R::Error>> {
  253|    204|                    TypeNum::new(!(major::UNSIGNED << 5), byte).$decode_fn(reader)
  254|    204|                }
_RINvXse_NtNtCsda7B5SchGu_7cbor4ii4core3decNtB6_8MapStartNtB6_6Decode11decode_withNtNtB8_5utils11SliceReaderECsitTtQF8ArIt_8fvm_fuzz:
  656|    102|    fn decode_with<R: Read<'a>>(byte: u8, reader: &mut R) -> Result<Self, Error<R::Error>> {
  657|    102|        decode_len(major::MAP, byte, reader).map(MapStart)
  658|    102|    }
_RINvXs5_NtNtCsda7B5SchGu_7cbor4ii4core3decINtNtB8_5types5BytesINtNtCsjYc3JqMxxfa_5alloc6borrow3CowShEENtB6_6Decode11decode_withNtNtB8_5utils11SliceReaderECsitTtQF8ArIt_8fvm_fuzz:
  506|  4.89k|    fn decode_with<R: Read<'a>>(byte: u8, reader: &mut R) -> Result<Self, Error<R::Error>> {
  507|  4.89k|        use crate::alloc::borrow::Cow;
  508|  4.89k|
  509|  4.89k|        let mut buf = Vec::new();
  510|  4.89k|        Ok(types::Bytes(if let Some(longbuf) = decode_buf(major::BYTES, byte, reader, &mut buf)? {
  511|  4.89k|            Cow::Borrowed(longbuf)
  512|       |        } else {
  513|      0|            Cow::Owned(buf)
  514|       |        }))
  515|  4.89k|    }
_RINvYINtNtCsjYc3JqMxxfa_5alloc6borrow3CoweENtNtNtCsda7B5SchGu_7cbor4ii4core3dec6Decode6decodeNtNtBJ_5utils11SliceReaderECsitTtQF8ArIt_8fvm_fuzz:
   73|  3.26k|    fn decode<R: Read<'a>>(reader: &mut R) -> Result<Self, Error<R::Error>> {
   74|  3.26k|        let byte = pull_one(reader)?;
   75|  3.26k|        Self::decode_with(byte, reader)
   76|  3.26k|    }
_RINvYINtNtNtCsda7B5SchGu_7cbor4ii4core5types5BytesINtNtCsjYc3JqMxxfa_5alloc6borrow3CowShEENtNtB8_3dec6Decode6decodeNtNtB8_5utils11SliceReaderECsitTtQF8ArIt_8fvm_fuzz:
   73|  4.89k|    fn decode<R: Read<'a>>(reader: &mut R) -> Result<Self, Error<R::Error>> {
   74|  4.89k|        let byte = pull_one(reader)?;
   75|  4.89k|        Self::decode_with(byte, reader)
   76|  4.89k|    }
_RNvNtNtCsda7B5SchGu_7cbor4ii4core3dec8if_major:
  890|  6.93k|pub fn if_major(byte: u8) -> u8 {
  891|  6.93k|    byte >> 5
  892|  6.93k|}
_RINvYyNtNtNtCsda7B5SchGu_7cbor4ii4core3dec6Decode6decodeNtNtB8_5utils11SliceReaderECsitTtQF8ArIt_8fvm_fuzz:
   73|    510|    fn decode<R: Read<'a>>(reader: &mut R) -> Result<Self, Error<R::Error>> {
   74|    510|        let byte = pull_one(reader)?;
   75|    510|        Self::decode_with(byte, reader)
   76|    510|    }
_RINvNtNtCsda7B5SchGu_7cbor4ii4core3dec10decode_lenNtNtB4_5utils11SliceReaderECsitTtQF8ArIt_8fvm_fuzz:
  595|  13.0k|fn decode_len<'a, R: Read<'a>>(major: u8, byte: u8, reader: &mut R)
  596|  13.0k|    -> Result<Option<usize>, Error<R::Error>>
  597|  13.0k|{
  598|  13.0k|    if byte != (marker::START | (major << 5)) {
  599|  13.0k|        let len = TypeNum::new(!(major << 5), byte).decode_u64(reader)?;
  600|  13.0k|        let len = usize::try_from(len).map_err(Error::CastOverflow)?;
  601|  13.0k|        Ok(Some(len))
  602|       |    } else {
  603|      0|        Ok(None)
  604|       |    }
  605|  13.0k|}
_RINvXs8_NtNtCsda7B5SchGu_7cbor4ii4core3decINtNtCsjYc3JqMxxfa_5alloc6borrow3CoweENtB6_6Decode11decode_withNtNtB8_5utils11SliceReaderECsitTtQF8ArIt_8fvm_fuzz:
  545|  3.26k|    fn decode_with<R: Read<'a>>(byte: u8, reader: &mut R) -> Result<Self, Error<R::Error>> {
  546|  3.26k|        use crate::alloc::borrow::Cow;
  547|  3.26k|
  548|  3.26k|        let mut buf = Vec::new();
  549|  3.26k|        Ok(if let Some(longbuf) = decode_buf(major::STRING, byte, reader, &mut buf)? {
  550|  3.26k|            Cow::Borrowed(core::str::from_utf8(longbuf).map_err(Error::InvalidUtf8)?)
  551|       |        } else {
  552|      0|            let buf = String::from_utf8(buf)
  553|      0|                .map_err(|err| Error::InvalidUtf8(err.utf8_error()))?;
  554|      0|            Cow::Owned(buf)
  555|       |        })
  556|  3.26k|    }
_RINvYNtNtNtCsda7B5SchGu_7cbor4ii4core3dec8MapStartNtB5_6Decode6decodeNtNtB7_5utils11SliceReaderECsitTtQF8ArIt_8fvm_fuzz:
   73|    102|    fn decode<R: Read<'a>>(reader: &mut R) -> Result<Self, Error<R::Error>> {
   74|    102|        let byte = pull_one(reader)?;
   75|    102|        Self::decode_with(byte, reader)
   76|    102|    }
_RINvYmNtNtNtCsda7B5SchGu_7cbor4ii4core3dec6Decode6decodeNtNtB8_5utils11SliceReaderECsitTtQF8ArIt_8fvm_fuzz:
   73|    204|    fn decode<R: Read<'a>>(reader: &mut R) -> Result<Self, Error<R::Error>> {
   74|    204|        let byte = pull_one(reader)?;
   75|    204|        Self::decode_with(byte, reader)
   76|    204|    }
_RNvMs0_NtNtCsda7B5SchGu_7cbor4ii4core3decNtB5_7TypeNum3new:
  175|  17.9k|    pub(crate) const fn new(major_limit: u8, byte: u8) -> TypeNum {
  176|  17.9k|        TypeNum { major_limit, byte }
  177|  17.9k|    }
_RINvXsg_NtNtCsda7B5SchGu_7cbor4ii4core3decNtB6_8TagStartNtB6_6Decode11decode_withNtNtB8_5utils11SliceReaderECsitTtQF8ArIt_8fvm_fuzz:
  703|  4.18k|    fn decode_with<R: Read<'a>>(byte: u8, reader: &mut R) -> Result<Self, Error<R::Error>> {
  704|  4.18k|        TypeNum::new(!(major::TAG << 5), byte).decode_u64(reader).map(TagStart)
  705|  4.18k|    }
_RINvNtNtCsda7B5SchGu_7cbor4ii4core3dec8pull_oneNtNtB4_5utils11SliceReaderECsitTtQF8ArIt_8fvm_fuzz:
  125|  58.0k|pub(crate) fn pull_one<'a, R: Read<'a>>(reader: &mut R) -> Result<u8, Error<R::Error>> {
  126|  58.0k|    let b = reader.fill(1)?
  127|  58.0k|        .as_ref()
  128|  58.0k|        .get(0)
  129|  58.0k|        .copied()
  130|  58.0k|        .ok_or(Error::Eof)?;
  131|  26.3k|    reader.advance(1);
  132|  26.3k|    Ok(b)
  133|  58.0k|}
_RINvXss_NtNtCsda7B5SchGu_7cbor4ii4core3decyNtB6_6Decode11decode_withNtNtB8_5utils11SliceReaderECsitTtQF8ArIt_8fvm_fuzz:
  252|    510|                fn decode_with<R: Read<'a>>(byte: u8, reader: &mut R) -> Result<Self, Error<R::Error>> {
  253|    510|                    TypeNum::new(!(major::UNSIGNED << 5), byte).$decode_fn(reader)
  254|    510|                }
_RINvYNtNtNtCsda7B5SchGu_7cbor4ii4core3dec10ArrayStartNtB5_6Decode6decodeNtNtB7_5utils11SliceReaderECsitTtQF8ArIt_8fvm_fuzz:
   73|  36.5k|    fn decode<R: Read<'a>>(reader: &mut R) -> Result<Self, Error<R::Error>> {
   74|  36.5k|        let byte = pull_one(reader)?;
   75|  4.79k|        Self::decode_with(byte, reader)
   76|  36.5k|    }

_RINvXsi_NtNtCsda7B5SchGu_7cbor4ii4core3encINtNtB8_5types3TagINtBH_5BytesRShEENtB6_6Encode6encodeNtNtB8_5utils9BufWriterECsitTtQF8ArIt_8fvm_fuzz:
  317|  1.02k|        TypeNum::new(major::TAG << 5, self.0).encode(writer)?;
  318|  1.02k|        self.1.encode(writer)
  319|  1.02k|    }
_RNvMs0_NtNtCsda7B5SchGu_7cbor4ii4core3encINtB5_7TypeNumtE3newCsitTtQF8ArIt_8fvm_fuzz:
   52|  5.30k|    const fn new(type_: u8, value: V) -> TypeNum<V> {
   53|  5.30k|        TypeNum { type_, value }
   54|  5.30k|    }
_RINvXs9_NtNtCsda7B5SchGu_7cbor4ii4core3encReNtB6_6Encode6encodeNtNtB8_5utils9BufWriterECsitTtQF8ArIt_8fvm_fuzz:
  228|    102|        TypeNum::new(major::STRING << 5, self.len() as u64).encode(writer)?;
  229|    102|        writer.push(self.as_bytes())?;
  230|    102|        Ok(())
  231|    102|    }
_RNvMs0_NtNtCsda7B5SchGu_7cbor4ii4core3encINtB5_7TypeNumhE3newCsitTtQF8ArIt_8fvm_fuzz:
   52|  5.30k|    const fn new(type_: u8, value: V) -> TypeNum<V> {
   53|  5.30k|        TypeNum { type_, value }
   54|  5.30k|    }
_RINvXs7_NtNtCsda7B5SchGu_7cbor4ii4core3encINtNtB8_5types5BytesRShENtB6_6Encode6encodeNtNtB8_5utils9BufWriterECsitTtQF8ArIt_8fvm_fuzz:
  209|  1.83k|        TypeNum::new(major::BYTES << 5, self.0.len() as u64).encode(writer)?;
  210|  1.83k|        writer.push(self.0)?;
  211|  1.83k|        Ok(())
  212|  1.83k|    }
_RINvXs3_NtNtCsda7B5SchGu_7cbor4ii4core3encINtB6_7TypeNummENtB6_6Encode6encodeNtNtB8_5utils9BufWriterECsitTtQF8ArIt_8fvm_fuzz:
   84|  5.30k|    fn encode<W: Write>(&self, writer: &mut W) -> Result<(), Error<W::Error>> {
   85|  5.30k|        match u16::try_from(self.value) {
   86|  5.30k|            Ok(x) => TypeNum::new(self.type_, x).encode(writer)?,
   87|       |            Err(_) =>{
   88|      0|                let [x0, x1, x2, x3] = self.value.to_be_bytes();
   89|      0|                writer.push(&[self.type_ | 0x1a, x0, x1, x2, x3])?;
   90|       |            }
   91|       |        }
   92|  5.30k|        Ok(())
   93|  5.30k|    }
_RINvXs2_NtNtCsda7B5SchGu_7cbor4ii4core3encINtB6_7TypeNumtENtB6_6Encode6encodeNtNtB8_5utils9BufWriterECsitTtQF8ArIt_8fvm_fuzz:
   70|  5.30k|    fn encode<W: Write>(&self, writer: &mut W) -> Result<(), Error<W::Error>> {
   71|  5.30k|        match u8::try_from(self.value) {
   72|  5.30k|            Ok(x) => TypeNum::new(self.type_, x).encode(writer)?,
   73|       |            Err(_) => {
   74|      0|                let [x0, x1] = self.value.to_be_bytes();
   75|      0|                writer.push(&[self.type_ | 0x19, x0, x1])?
   76|       |            }
   77|       |        }
   78|  5.30k|        Ok(())
   79|  5.30k|    }
_RINvXs4_NtNtCsda7B5SchGu_7cbor4ii4core3encINtB6_7TypeNumyENtB6_6Encode6encodeNtNtB8_5utils9BufWriterECsitTtQF8ArIt_8fvm_fuzz:
   98|  5.30k|    fn encode<W: Write>(&self, writer: &mut W) -> Result<(), Error<W::Error>> {
   99|  5.30k|        match u32::try_from(self.value) {
  100|  5.30k|            Ok(x) => TypeNum::new(self.type_, x).encode(writer)?,
  101|       |            Err(_) => {
  102|      0|                let [x0, x1, x2, x3, x4, x5, x6, x7] = self.value.to_be_bytes();
  103|      0|                writer.push(&[self.type_ | 0x1b, x0, x1, x2, x3, x4, x5, x6, x7])?;
  104|       |            }
  105|       |        }
  106|  5.30k|        Ok(())
  107|  5.30k|    }
_RNvMs0_NtNtCsda7B5SchGu_7cbor4ii4core3encINtB5_7TypeNumyE3newCsitTtQF8ArIt_8fvm_fuzz:
   52|  5.30k|    const fn new(type_: u8, value: V) -> TypeNum<V> {
   53|  5.30k|        TypeNum { type_, value }
   54|  5.30k|    }
_RINvXsd_NtNtCsda7B5SchGu_7cbor4ii4core3encNtB6_17ArrayStartBoundedNtB6_6Encode6encodeNtNtB8_5utils9BufWriterECsitTtQF8ArIt_8fvm_fuzz:
  270|  1.83k|        TypeNum::new(major::ARRAY << 5, self.0 as u64).encode(writer)?;
  271|  1.83k|        Ok(())
  272|  1.83k|    }
_RINvXsl_NtNtCsda7B5SchGu_7cbor4ii4core3encNtNtB8_5types4NullNtB6_6Encode6encodeNtNtB8_5utils9BufWriterECsitTtQF8ArIt_8fvm_fuzz:
  343|    306|        writer.push(&[marker::NULL])?;
  344|    306|        Ok(())
  345|    306|    }
_RINvXs1_NtNtCsda7B5SchGu_7cbor4ii4core3encINtB6_7TypeNumhENtB6_6Encode6encodeNtNtB8_5utils9BufWriterECsitTtQF8ArIt_8fvm_fuzz:
   59|  5.30k|    fn encode<W: Write>(&self, writer: &mut W) -> Result<(), Error<W::Error>> {
   60|  5.30k|        match self.value {
   61|  5.30k|            x @ 0x00 ..= 0x17 => writer.push(&[self.type_ | x])?,
   62|  2.14k|            x => writer.push(&[self.type_ | 0x18, x])?
   63|       |        }
   64|  5.30k|        Ok(())
   65|  5.30k|    }
_RNvMs0_NtNtCsda7B5SchGu_7cbor4ii4core3encINtB5_7TypeNummE3newCsitTtQF8ArIt_8fvm_fuzz:
   52|  5.30k|    const fn new(type_: u8, value: V) -> TypeNum<V> {
   53|  5.30k|        TypeNum { type_, value }
   54|  5.30k|    }
_RINvXsu_NtNtCsda7B5SchGu_7cbor4ii4core3encyNtB6_6Encode6encodeNtNtB8_5utils9BufWriterECsitTtQF8ArIt_8fvm_fuzz:
  159|    510|                fn encode<W: Write>(&self, writer: &mut W) -> Result<(), Error<W::Error>> {
  160|    510|                    TypeNum::new(major::UNSIGNED << 5, *self).encode(writer)
  161|    510|                }

_RNvXs1_NtNtCsda7B5SchGu_7cbor4ii4core5utilsNtB5_11SliceReaderNtNtB7_3dec4Read7step_in:
   75|  39.4k|        if let Some(limit) = self.limit.checked_sub(1) {
   76|  39.4k|            self.limit = limit;
   77|  39.4k|            true
   78|       |        } else {
   79|      0|            false
   80|       |        }
   81|  39.4k|    }
_RNvXs1_NtNtCsda7B5SchGu_7cbor4ii4core5utilsNtB5_11SliceReaderNtNtB7_3dec4Read7advance:
   68|  34.7k|    fn advance(&mut self, n: usize) {
   69|  34.7k|        let len = core::cmp::min(self.buf.len(), n);
   70|  34.7k|        self.buf = &self.buf[len..];
   71|  34.7k|    }
_RNvXs1_NtNtCsda7B5SchGu_7cbor4ii4core5utilsNtB5_11SliceReaderNtNtB7_3dec4Read8step_out:
   84|  39.4k|    fn step_out(&mut self) {
   85|  39.4k|        self.limit += 1;
   86|  39.4k|    }
_RNvXs1_NtNtCsda7B5SchGu_7cbor4ii4core5utilsNtB5_11SliceReaderNtNtB7_3dec4Read4fill:
   62|  73.8k|    fn fill<'b>(&'b mut self, want: usize) -> Result<dec::Reference<'de, 'b>, Self::Error> {
   63|  73.8k|        let len = core::cmp::min(self.buf.len(), want);
   64|  73.8k|        Ok(dec::Reference::Long(&self.buf[..len]))
   65|  73.8k|    }
_RNvXs_NtNtCsda7B5SchGu_7cbor4ii4core5utilsNtB4_9BufWriterNtNtB6_3enc5Write4push:
   40|  7.54k|        self.0.try_reserve(input.len())?;
   41|  7.54k|        self.0.extend_from_slice(input);
   42|  7.54k|        Ok(())
   43|  7.54k|    }
_RNvMs0_NtNtCsda7B5SchGu_7cbor4ii4core5utilsNtB5_11SliceReader3new:
   53|  32.4k|    pub fn new(buf: &[u8]) -> SliceReader<'_> {
   54|  32.4k|        SliceReader { buf, limit: 256 }
   55|  32.4k|    }
_RNvMNtNtCsda7B5SchGu_7cbor4ii4core5utilsNtB2_9BufWriter3new:
   14|    714|    pub fn new(buf: Vec<u8>) -> Self {
   15|    714|       BufWriter(buf)
   16|    714|    }
_RNvMNtNtCsda7B5SchGu_7cbor4ii4core5utilsNtB2_9BufWriter10into_inner:
   24|    714|    pub fn into_inner(self) -> Vec<u8> {
   25|    714|        self.0
   26|    714|    }

_RINvMNtCs1slUOa8tBso_3cid3cidINtB3_3CidKj40_E10read_bytesQINtNtNtCsxnqwkJeFav_3std2io6cursor6CursorRINtNtCsjYc3JqMxxfa_5alloc3vec3VechEEECsitTtQF8ArIt_8fvm_fuzz:
  140|  1.73k|    pub fn read_bytes<R: io::Read>(mut r: R) -> Result<Self> {
  141|  1.73k|        let version = varint_read_u64(&mut r)?;
  142|  1.73k|        let codec = varint_read_u64(&mut r)?;
  143|       |
  144|       |        // CIDv0 has the fixed `0x12 0x20` prefix
  145|  1.73k|        if [version, codec] == [0x12, 0x20] {
  146|      0|            let mut digest = [0u8; 32];
  147|      0|            r.read_exact(&mut digest)?;
  148|      0|            let mh = Multihash::wrap(version, &digest).expect("Digest is always 32 bytes.");
  149|      0|            return Self::new_v0(mh);
  150|  1.73k|        }
  151|       |
  152|  1.73k|        let version = Version::try_from(version)?;
  153|  1.73k|        match version {
  154|      0|            Version::V0 => Err(Error::InvalidExplicitCidV0),
  155|       |            Version::V1 => {
  156|  1.73k|                let mh = Multihash::read(r)?;
  157|  1.73k|                Self::new(version, codec, mh)
  158|       |            }
  159|       |        }
  160|  1.73k|    }
_RNvXsh_NtCs1slUOa8tBso_3cid3cidINtB5_3CidKj40_ENtNtCshM4Il2Z0i4R_4core5clone5Clone5cloneCsitTtQF8ArIt_8fvm_fuzz:
   64|    918|#[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]
_RNvXs6_NtCs1slUOa8tBso_3cid3cidINtB5_3CidKj40_EINtNtCshM4Il2Z0i4R_4core7convert7TryFromRShE8try_fromCsitTtQF8ArIt_8fvm_fuzz:
  333|  4.79k|    fn try_from(mut bytes: &[u8]) -> Result<Self> {
  334|  4.79k|        Self::read_bytes(&mut bytes)
  335|  4.79k|    }
_RINvXsk_NtCs1slUOa8tBso_3cid3cidINtB6_3CidKj40_ENtNtCshM4Il2Z0i4R_4core4hash4Hash4hashNtNtNtNtCsxnqwkJeFav_3std11collections4hash3map13DefaultHasherECsitTtQF8ArIt_8fvm_fuzz:
   64|  7.95k|#[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]
_RNvMNtCs1slUOa8tBso_3cid3cidINtB2_3CidKj40_E8to_bytesCsitTtQF8ArIt_8fvm_fuzz:
  186|  1.73k|    pub fn to_bytes(&self) -> Vec<u8> {
  187|  1.73k|        let mut bytes = Vec::new();
  188|  1.73k|        self.write_bytes(&mut bytes).unwrap();
  189|  1.73k|        bytes
  190|  1.73k|    }
_RNvXse_NtCs1slUOa8tBso_3cid3cidINtB5_3CidKj40_ENtNtCshM4Il2Z0i4R_4core3cmp9PartialEq2eqCsitTtQF8ArIt_8fvm_fuzz:
   64|    163|#[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]
_RNvMNtCs1slUOa8tBso_3cid3cidINtB2_3CidKj40_E6new_v1CsitTtQF8ArIt_8fvm_fuzz:
   90|  7.24k|    pub const fn new_v1(codec: u64, hash: Multihash<S>) -> Self {
   91|  7.24k|        Self {
   92|  7.24k|            version: Version::V1,
   93|  7.24k|            codec,
   94|  7.24k|            hash,
   95|  7.24k|        }
   96|  7.24k|    }
_RINvMNtCs1slUOa8tBso_3cid3cidINtB3_3CidKj40_E14write_bytes_v1QINtNtCsjYc3JqMxxfa_5alloc3vec3VechEECsitTtQF8ArIt_8fvm_fuzz:
  162|  1.73k|    fn write_bytes_v1<W: io::Write>(&self, mut w: W) -> Result<()> {
  163|  1.73k|        let mut version_buf = varint_encode::u64_buffer();
  164|  1.73k|        let version = varint_encode::u64(self.version.into(), &mut version_buf);
  165|  1.73k|
  166|  1.73k|        let mut codec_buf = varint_encode::u64_buffer();
  167|  1.73k|        let codec = varint_encode::u64(self.codec, &mut codec_buf);
  168|  1.73k|
  169|  1.73k|        w.write_all(version)?;
  170|  1.73k|        w.write_all(codec)?;
  171|  1.73k|        self.hash.write(&mut w)?;
  172|  1.73k|        Ok(())
  173|  1.73k|    }
_RINvMNtCs1slUOa8tBso_3cid3cidINtB3_3CidKj40_E11write_bytesQINtNtCsjYc3JqMxxfa_5alloc3vec3VechEECsitTtQF8ArIt_8fvm_fuzz:
  176|  1.73k|    pub fn write_bytes<W: io::Write>(&self, w: W) -> Result<()> {
  177|  1.73k|        match self.version {
  178|      0|            Version::V0 => self.hash.write(w)?,
  179|  1.73k|            Version::V1 => self.write_bytes_v1(w)?,
  180|       |        }
  181|  1.73k|        Ok(())
  182|  1.73k|    }
_RINvMNtCs1slUOa8tBso_3cid3cidINtB3_3CidKj40_E10read_bytesQRShECsitTtQF8ArIt_8fvm_fuzz:
  140|  4.79k|    pub fn read_bytes<R: io::Read>(mut r: R) -> Result<Self> {
  141|  4.79k|        let version = varint_read_u64(&mut r)?;
  142|  4.79k|        let codec = varint_read_u64(&mut r)?;
  143|       |
  144|       |        // CIDv0 has the fixed `0x12 0x20` prefix
  145|  4.79k|        if [version, codec] == [0x12, 0x20] {
  146|      0|            let mut digest = [0u8; 32];
  147|      0|            r.read_exact(&mut digest)?;
  148|      0|            let mh = Multihash::wrap(version, &digest).expect("Digest is always 32 bytes.");
  149|      0|            return Self::new_v0(mh);
  150|  4.79k|        }
  151|       |
  152|  4.79k|        let version = Version::try_from(version)?;
  153|  4.79k|        match version {
  154|      0|            Version::V0 => Err(Error::InvalidExplicitCidV0),
  155|       |            Version::V1 => {
  156|  4.79k|                let mh = Multihash::read(r)?;
  157|  4.79k|                Self::new(version, codec, mh)
  158|       |            }
  159|       |        }
  160|  4.79k|    }
_RNvMNtCs1slUOa8tBso_3cid3cidINtB2_3CidKj40_E12to_string_v1CsitTtQF8ArIt_8fvm_fuzz:
  200|    102|    fn to_string_v1(&self) -> String {
  201|    102|        multibase::encode(Base::Base32Lower, self.to_bytes().as_slice())
  202|    102|    }
_RNvMNtCs1slUOa8tBso_3cid3cidINtB2_3CidKj40_E3newCsitTtQF8ArIt_8fvm_fuzz:
   99|  6.52k|    pub const fn new(version: Version, codec: u64, hash: Multihash<S>) -> Result<Self> {
  100|  6.52k|        match version {
  101|       |            Version::V0 => {
  102|      0|                if codec != DAG_PB {
  103|      0|                    return Err(Error::InvalidCidV0Codec);
  104|      0|                }
  105|      0|                Self::new_v0(hash)
  106|       |            }
  107|  6.52k|            Version::V1 => Ok(Self::new_v1(codec, hash)),
  108|       |        }
  109|  6.52k|    }
_RNvXs0_NtCs1slUOa8tBso_3cid3cidINtB5_3CidKj40_ENtNtCshM4Il2Z0i4R_4core3fmt7Display3fmtCsitTtQF8ArIt_8fvm_fuzz:
  248|    102|    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
  249|    102|        let output = match self.version {
  250|      0|            Version::V0 => self.to_string_v0(),
  251|    102|            Version::V1 => self.to_string_v1(),
  252|       |        };
  253|    102|        write!(f, "{}", output)
  254|    102|    }
_RNvXsh_NtCs1slUOa8tBso_3cid3cidINtB5_3CidKj40_ENtNtCshM4Il2Z0i4R_4core5clone5Clone5cloneCs7Ei498kZF3p_3fvm:
   64|    102|#[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]
_RINvMNtCs1slUOa8tBso_3cid3cidINtB3_3CidKj40_E10read_bytesRShECs7Ei498kZF3p_3fvm:
  140|    977|    pub fn read_bytes<R: io::Read>(mut r: R) -> Result<Self> {
  141|    977|        let version = varint_read_u64(&mut r)?;
  142|      0|        let codec = varint_read_u64(&mut r)?;
  143|       |
  144|       |        // CIDv0 has the fixed `0x12 0x20` prefix
  145|      0|        if [version, codec] == [0x12, 0x20] {
  146|      0|            let mut digest = [0u8; 32];
  147|      0|            r.read_exact(&mut digest)?;
  148|      0|            let mh = Multihash::wrap(version, &digest).expect("Digest is always 32 bytes.");
  149|      0|            return Self::new_v0(mh);
  150|      0|        }
  151|       |
  152|      0|        let version = Version::try_from(version)?;
  153|      0|        match version {
  154|      0|            Version::V0 => Err(Error::InvalidExplicitCidV0),
  155|       |            Version::V1 => {
  156|      0|                let mh = Multihash::read(r)?;
  157|      0|                Self::new(version, codec, mh)
  158|       |            }
  159|       |        }
  160|    977|    }
_RINvXsk_NtCs1slUOa8tBso_3cid3cidINtB6_3CidKj40_ENtNtCshM4Il2Z0i4R_4core4hash4Hash4hashNtNtNtNtCsxnqwkJeFav_3std11collections4hash3map13DefaultHasherECs6SqvG5Yde5c_19fvm_ipld_blockstore:
   64|  5.61k|#[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]
_RNvXse_NtCs1slUOa8tBso_3cid3cidINtB5_3CidKj40_ENtNtCshM4Il2Z0i4R_4core3cmp9PartialEq2eqCs6SqvG5Yde5c_19fvm_ipld_blockstore:
   64|    988|#[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]

_RNvXs3_NtCs1slUOa8tBso_3cid5errorNtB5_5ErrorINtNtCshM4Il2Z0i4R_4core7convert4FromNtNtCsahNQa9khuPr_15unsigned_varint2io9ReadErrorE4from:
   81|    977|    fn from(err: unsigned_varint::io::ReadError) -> Self {
   82|    977|        use unsigned_varint::io::ReadError::*;
   83|    977|        match err {
   84|    977|            Io(err) => Self::Io(err),
   85|      0|            _ => Self::VarIntDecodeError,
   86|       |        }
   87|    977|    }
_RNvXs_NtCs1slUOa8tBso_3cid5errorNtB4_5ErrorNtNtCshM4Il2Z0i4R_4core3fmt7Display3fmt:
   41|    977|    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
   42|       |        use self::Error::*;
   43|    977|        let error = match self {
   44|      0|            UnknownCodec => "Unknown codec",
   45|      0|            InputTooShort => "Input too short",
   46|      0|            ParsingError => "Failed to parse multihash",
   47|      0|            InvalidCidVersion => "Unrecognized CID version",
   48|      0|            InvalidCidV0Codec => "CIDv0 requires a DagPB codec",
   49|      0|            InvalidCidV0Multihash => "CIDv0 requires a Sha-256 multihash",
   50|      0|            InvalidCidV0Base => "CIDv0 requires a Base58 base",
   51|      0|            VarIntDecodeError => "Failed to decode unsigned varint format",
   52|    977|            Io(err) => return write!(f, "{}", err),
   53|      0|            InvalidExplicitCidV0 => "CIDv0 cannot be specified in CIDv1 format",
   54|       |        };
   55|       |
   56|      0|        f.write_str(error)
   57|    977|    }

_RINvXs0_NtCs1slUOa8tBso_3cid5serdeINtNtB8_3cid3CidKj40_ENtNtCslVZeVZySzLE_5serde2de11Deserialize11deserializeNtNtCsalhrieD8kwf_12libipld_core4ipld4IpldECsitTtQF8ArIt_8fvm_fuzz:
   79|    612|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
   80|    612|    where
   81|    612|        D: de::Deserializer<'de>,
   82|    612|    {
   83|    612|        /// Main visitor to deserialize a CID.
   84|    612|        ///
   85|    612|        /// This visitor has only a single entry point to deserialize CIDs, it's
   86|    612|        /// `visit_new_type_struct()`. This ensures that it isn't accidentally used to decode CIDs
   87|    612|        /// to bytes.
   88|    612|        struct MainEntryVisitor<const SIZE: usize>;
   89|    612|
   90|    612|        impl<'de, const SIZE: usize> de::Visitor<'de> for MainEntryVisitor<SIZE> {
   91|    612|            type Value = CidGeneric<SIZE>;
   92|    612|
   93|    612|            fn expecting(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
   94|    612|                write!(fmt, "a valid CID in bytes, wrapped in an newtype struct")
   95|    612|            }
   96|    612|
   97|    612|            fn visit_newtype_struct<D>(self, deserializer: D) -> Result<Self::Value, D::Error>
   98|    612|            where
   99|    612|                D: de::Deserializer<'de>,
  100|    612|            {
  101|    612|                deserializer.deserialize_bytes(BytesToCidVisitor)
  102|    612|            }
  103|    612|        }
  104|    612|
  105|    612|        deserializer.deserialize_newtype_struct(CID_SERDE_PRIVATE_IDENTIFIER, MainEntryVisitor)
  106|    612|    }
_RINvXNvXs0_NtCs1slUOa8tBso_3cid5serdeINtNtBb_3cid3CidKpENtNtCslVZeVZySzLE_5serde2de11Deserialize11deserializeINtB3_16MainEntryVisitorKj40_ENtBU_7Visitor20visit_newtype_structQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de15CidDeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
   97|  3.57k|            fn visit_newtype_struct<D>(self, deserializer: D) -> Result<Self::Value, D::Error>
   98|  3.57k|            where
   99|  3.57k|                D: de::Deserializer<'de>,
  100|  3.57k|            {
  101|  3.57k|                deserializer.deserialize_bytes(BytesToCidVisitor)
  102|  3.57k|            }
_RINvXNtCs1slUOa8tBso_3cid5serdeINtNtB5_3cid3CidKj40_ENtNtCslVZeVZySzLE_5serde3ser9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
   29|  1.02k|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   30|  1.02k|    where
   31|  1.02k|        S: ser::Serializer,
   32|  1.02k|    {
   33|  1.02k|        let value = ByteBuf::from(self.to_bytes());
   34|  1.02k|        serializer.serialize_newtype_struct(CID_SERDE_PRIVATE_IDENTIFIER, &value)
   35|  1.02k|    }
_RINvXNvXs0_NtCs1slUOa8tBso_3cid5serdeINtNtBb_3cid3CidKpENtNtCslVZeVZySzLE_5serde2de11Deserialize11deserializeINtB3_16MainEntryVisitorKj40_ENtBU_7Visitor20visit_newtype_structNtNtNtCsalhrieD8kwf_12libipld_core5serde2de15CidDeserializerECsitTtQF8ArIt_8fvm_fuzz:
   97|    612|            fn visit_newtype_struct<D>(self, deserializer: D) -> Result<Self::Value, D::Error>
   98|    612|            where
   99|    612|                D: de::Deserializer<'de>,
  100|    612|            {
  101|    612|                deserializer.deserialize_bytes(BytesToCidVisitor)
  102|    612|            }
_RINvXs_NtCs1slUOa8tBso_3cid5serdeNtB5_17BytesToCidVisitorNtNtCslVZeVZySzLE_5serde2de7Visitor11visit_bytesNtNtCsalhrieD8kwf_12libipld_core5error10SerdeErrorECsitTtQF8ArIt_8fvm_fuzz:
   48|    612|    fn visit_bytes<E>(self, value: &[u8]) -> Result<Self::Value, E>
   49|    612|    where
   50|    612|        E: de::Error,
   51|    612|    {
   52|    612|        CidGeneric::<SIZE>::try_from(value)
   53|    612|            .map_err(|err| de::Error::custom(format!("Failed to deserialize CID: {}", err)))
   54|    612|    }
_RINvXs_NtCs1slUOa8tBso_3cid5serdeNtB5_17BytesToCidVisitorNtNtCslVZeVZySzLE_5serde2de7Visitor11visit_bytesINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor5error11DecodeErrorNtNtCshM4Il2Z0i4R_4core7convert10InfallibleEECsitTtQF8ArIt_8fvm_fuzz:
   48|  4.18k|    fn visit_bytes<E>(self, value: &[u8]) -> Result<Self::Value, E>
   49|  4.18k|    where
   50|  4.18k|        E: de::Error,
   51|  4.18k|    {
   52|  4.18k|        CidGeneric::<SIZE>::try_from(value)
   53|  4.18k|            .map_err(|err| de::Error::custom(format!("Failed to deserialize CID: {}", err)))
   54|  4.18k|    }
_RINvXs0_NtCs1slUOa8tBso_3cid5serdeINtNtB8_3cid3CidKj40_ENtNtCslVZeVZySzLE_5serde2de11Deserialize11deserializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
   79|  3.57k|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
   80|  3.57k|    where
   81|  3.57k|        D: de::Deserializer<'de>,
   82|  3.57k|    {
   83|  3.57k|        /// Main visitor to deserialize a CID.
   84|  3.57k|        ///
   85|  3.57k|        /// This visitor has only a single entry point to deserialize CIDs, it's
   86|  3.57k|        /// `visit_new_type_struct()`. This ensures that it isn't accidentally used to decode CIDs
   87|  3.57k|        /// to bytes.
   88|  3.57k|        struct MainEntryVisitor<const SIZE: usize>;
   89|  3.57k|
   90|  3.57k|        impl<'de, const SIZE: usize> de::Visitor<'de> for MainEntryVisitor<SIZE> {
   91|  3.57k|            type Value = CidGeneric<SIZE>;
   92|  3.57k|
   93|  3.57k|            fn expecting(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
   94|  3.57k|                write!(fmt, "a valid CID in bytes, wrapped in an newtype struct")
   95|  3.57k|            }
   96|  3.57k|
   97|  3.57k|            fn visit_newtype_struct<D>(self, deserializer: D) -> Result<Self::Value, D::Error>
   98|  3.57k|            where
   99|  3.57k|                D: de::Deserializer<'de>,
  100|  3.57k|            {
  101|  3.57k|                deserializer.deserialize_bytes(BytesToCidVisitor)
  102|  3.57k|            }
  103|  3.57k|        }
  104|  3.57k|
  105|  3.57k|        deserializer.deserialize_newtype_struct(CID_SERDE_PRIVATE_IDENTIFIER, MainEntryVisitor)
  106|  3.57k|    }

_RINvXsa_NtCs1slUOa8tBso_3cid7versionNtB6_7VersionNtNtCshM4Il2Z0i4R_4core4hash4Hash4hashNtNtNtNtCsxnqwkJeFav_3std11collections4hash3map13DefaultHasherECsitTtQF8ArIt_8fvm_fuzz:
    6|  7.95k|#[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Debug, Hash)]
_RNvXs2_NtCs1slUOa8tBso_3cid7versionNtB5_7VersionNtNtCshM4Il2Z0i4R_4core3cmp9PartialEq2eq:
    6|  1.15k|#[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Debug, Hash)]
_RINvXsa_NtCs1slUOa8tBso_3cid7versionNtB6_7VersionNtNtCshM4Il2Z0i4R_4core4hash4Hash4hashNtNtNtNtCsxnqwkJeFav_3std11collections4hash3map13DefaultHasherECs6SqvG5Yde5c_19fvm_ipld_blockstore:
    6|  5.61k|#[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Debug, Hash)]
_RNvXs0_NtCs1slUOa8tBso_3cid7versionyINtNtCshM4Il2Z0i4R_4core7convert4FromNtB5_7VersionE4from:
   44|  1.73k|    fn from(ver: Version) -> u64 {
   45|  1.73k|        match ver {
   46|      0|            Version::V0 => 0,
   47|  1.73k|            Version::V1 => 1,
   48|       |        }
   49|  1.73k|    }
_RNvXs_NtCs1slUOa8tBso_3cid7versionNtB4_7VersionINtNtCshM4Il2Z0i4R_4core7convert7TryFromyE8try_from:
   34|  6.52k|    fn try_from(raw: u64) -> Result<Self> {
   35|  6.52k|        match raw {
   36|      0|            0 => Ok(Self::V0),
   37|  6.52k|            1 => Ok(Self::V1),
   38|      0|            _ => Err(Error::InvalidCidVersion),
   39|       |        }
   40|  6.52k|    }

_RNvNtNtNtCsbCQy5qVcCrD_4sha26sha2563x8611shani_cpuid3get:
  135|    306|            pub fn get() -> bool {
  136|    306|                init_get().1
  137|    306|            }
_RNvNtNtNtCsbCQy5qVcCrD_4sha26sha2563x8611shani_cpuid8init_get:
  106|    306|            pub fn init_get() -> (InitToken, bool) {
  107|    306|                let res = $crate::__unless_target_features! {
  108|       |                    $($tf),+ => {
  109|       |                        // Relaxed ordering is fine, as we only have a single atomic variable.
  110|    306|                        let val = STORAGE.load(Relaxed);
  111|    306|
  112|    306|                        if val == UNINIT {
  113|      1|                            let res = $crate::__detect_target_features!($($tf),+);
  114|      1|                            STORAGE.store(res as u8, Relaxed);
  115|      1|                            res
  116|       |                        } else {
  117|    305|                            val == 1
  118|       |                        }
  119|       |                    }
  120|       |                };
  121|       |
  122|    306|                (InitToken(()), res)
  123|    306|            }

_RNvNvNtNtNtCsbCQy5qVcCrD_4sha26sha2563x8611shani_cpuid8init_get11cpuid_count:
   51|      1|        unsafe fn cpuid_count(leaf: u32, sub_leaf: u32) -> CpuidResult {
   52|      1|            __cpuid_count(leaf, sub_leaf)
   53|      1|        }
_RNvNvNtNtNtCsbCQy5qVcCrD_4sha26sha2563x8611shani_cpuid8init_get5cpuid:
   46|      1|        unsafe fn cpuid(leaf: u32) -> CpuidResult {
   47|      1|            __cpuid(leaf)
   48|      1|        }

_RINvNtCsaCEcwVhukSb_17cranelift_codegen13constant_hash5probeReNtNtNtB4_8settings6detail8TemplateEB4_:
   33|  4.89k|pub fn probe<K: Copy + Eq, T: Table<K> + ?Sized>(
   34|  4.89k|    table: &T,
   35|  4.89k|    key: K,
   36|  4.89k|    hash: usize,
   37|  4.89k|) -> Result<usize, usize> {
   38|  4.89k|    debug_assert!(table.len().is_power_of_two());
   39|  4.89k|    let mask = table.len() - 1;
   40|  4.89k|
   41|  4.89k|    let mut idx = hash;
   42|  4.89k|    let mut step = 0;
   43|       |
   44|       |    loop {
   45|  5.50k|        idx &= mask;
   46|  5.50k|
   47|  5.50k|        match table.key(idx) {
   48|      0|            None => return Err(idx),
   49|  5.50k|            Some(k) if k == key => return Ok(idx),
   50|    612|            _ => {}
   51|    612|        }
   52|    612|
   53|    612|        // Quadratic probing.
   54|    612|        step += 1;
   55|       |
   56|       |        // When `table.len()` is a power of two, it can be proven that `idx` will visit all
   57|       |        // entries. This means that this loop will always terminate if the hash table has even
   58|       |        // one unused entry.
   59|    612|        debug_assert!(step < table.len());
   60|    612|        idx += step;
   61|       |    }
   62|  4.89k|}

_RNvXsc_NtCsaCEcwVhukSb_17cranelift_codegen3isaNtB5_7BuilderNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
  138|    204|#[derive(Clone)]
_RNvMs0_NtCsaCEcwVhukSb_17cranelift_codegen3isaNtB5_7Builder6finish:
  163|    204|    pub fn finish(self, shared_flags: settings::Flags) -> CodegenResult<Box<dyn TargetIsa>> {
  164|    204|        (self.constructor)(self.triple, shared_flags, self.setup)
  165|    204|    }
_RNvXs1_NtCsaCEcwVhukSb_17cranelift_codegen3isaNtB5_7BuilderNtNtB7_8settings12Configurable6enable:
  173|  2.85k|    fn enable(&mut self, name: &str) -> SetResult<()> {
  174|  2.85k|        self.setup.enable(name)
  175|  2.85k|    }
_RNvNtCsaCEcwVhukSb_17cranelift_codegen3isa6lookup:
   93|    204|pub fn lookup(triple: Triple) -> Result<Builder, LookupError> {
   94|    204|    match triple.architecture {
   95|       |        Architecture::X86_64 => {
   96|    204|            isa_builder!(x64, (feature = "x86"), triple)
   97|       |        }
   98|      0|        Architecture::Aarch64 { .. } => isa_builder!(aarch64, (feature = "arm64"), triple),
   99|      0|        Architecture::S390x { .. } => isa_builder!(s390x, (feature = "s390x"), triple),
  100|      0|        _ => Err(LookupError::Unsupported),
  101|       |    }
  102|    204|}
_RNvXs1_NtCsaCEcwVhukSb_17cranelift_codegen3isaNtB5_7BuilderNtNtB7_8settings12Configurable3set:
  169|    816|    fn set(&mut self, name: &str, value: &str) -> SetResult<()> {
  170|    816|        self.setup.set(name, value)
  171|    816|    }

_RNvNtNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x644inst4regs3r11:
   67|    204|pub(crate) fn r11() -> Reg {
   68|    204|    gpr(ENC_R11)
   69|    204|}
_RNvNtNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x644inst4regs3r15:
   83|    612|pub(crate) fn r15() -> Reg {
   84|    612|    gpr(ENC_R15)
   85|    612|}
_RNvNtNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x644inst4regs4xmm7:
  131|    204|pub(crate) fn xmm7() -> Reg {
  132|    204|    fpr(7)
  133|    204|}
_RNvNtNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x644inst4regs4xmm2:
  116|    204|pub(crate) fn xmm2() -> Reg {
  117|    204|    fpr(2)
  118|    204|}
_RNvNtNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x644inst4regs3fpr:
  101|  3.26k|fn fpr(enc: u8) -> Reg {
  102|  3.26k|    let preg = fpr_preg(enc);
  103|  3.26k|    Reg::from(VReg::new(preg.index(), RegClass::Float))
  104|  3.26k|}
_RNvNtNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x644inst4regs22create_reg_env_systemv:
  160|    204|pub(crate) fn create_reg_env_systemv(flags: &settings::Flags) -> MachineEnv {
  161|    204|    fn preg(r: Reg) -> PReg {
  162|    204|        r.to_real_reg().unwrap().into()
  163|    204|    }
  164|    204|
  165|    204|    let mut env = MachineEnv {
  166|    204|        preferred_regs_by_class: [
  167|    204|            // Preferred GPRs: caller-saved in the SysV ABI.
  168|    204|            vec![
  169|    204|                preg(rsi()),
  170|    204|                preg(rdi()),
  171|    204|                preg(rax()),
  172|    204|                preg(rcx()),
  173|    204|                preg(rdx()),
  174|    204|                preg(r8()),
  175|    204|                preg(r9()),
  176|    204|                preg(r10()),
  177|    204|                preg(r11()),
  178|    204|            ],
  179|    204|            // Preferred XMMs: all of them.
  180|    204|            vec![
  181|    204|                preg(xmm0()),
  182|    204|                preg(xmm1()),
  183|    204|                preg(xmm2()),
  184|    204|                preg(xmm3()),
  185|    204|                preg(xmm4()),
  186|    204|                preg(xmm5()),
  187|    204|                preg(xmm6()),
  188|    204|                preg(xmm7()),
  189|    204|                preg(xmm8()),
  190|    204|                preg(xmm9()),
  191|    204|                preg(xmm10()),
  192|    204|                preg(xmm11()),
  193|    204|                preg(xmm12()),
  194|    204|                preg(xmm13()),
  195|    204|                preg(xmm14()),
  196|    204|                preg(xmm15()),
  197|    204|            ],
  198|    204|        ],
  199|    204|        non_preferred_regs_by_class: [
  200|    204|            // Non-preferred GPRs: callee-saved in the SysV ABI.
  201|    204|            vec![preg(rbx()), preg(r12()), preg(r13()), preg(r14())],
  202|    204|            // Non-preferred XMMs: none.
  203|    204|            vec![],
  204|    204|        ],
  205|    204|        fixed_stack_slots: vec![],
  206|    204|    };
  207|       |
  208|    204|    debug_assert_eq!(r15(), pinned_reg());
  209|    204|    if !flags.enable_pinned_reg() {
  210|    204|        env.non_preferred_regs_by_class[0].push(preg(r15()));
  211|    204|    }
  212|       |
  213|    204|    env
  214|    204|}
_RNvNtNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x644inst4regs8gpr_preg:
   39|  3.26k|pub(crate) const fn gpr_preg(enc: u8) -> PReg {
   40|  3.26k|    PReg::new(enc as usize, RegClass::Int)
   41|  3.26k|}
_RNvNtNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x644inst4regs3rcx:
   52|    204|pub(crate) fn rcx() -> Reg {
   53|    204|    gpr(ENC_RCX)
   54|    204|}
_RNvNtNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x644inst4regs2r9:
   61|    204|pub(crate) fn r9() -> Reg {
   62|    204|    gpr(ENC_R9)
   63|    204|}
_RNvNtNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x644inst4regs8fpr_preg:
  106|  3.26k|pub(crate) const fn fpr_preg(enc: u8) -> PReg {
  107|  3.26k|    PReg::new(enc as usize, RegClass::Float)
  108|  3.26k|}
_RNvNtNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x644inst4regs4xmm6:
  128|    204|pub(crate) fn xmm6() -> Reg {
  129|    204|    fpr(6)
  130|    204|}
_RNvNtNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x644inst4regs4xmm9:
  137|    204|pub(crate) fn xmm9() -> Reg {
  138|    204|    fpr(9)
  139|    204|}
_RNvNtNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x644inst4regs4xmm0:
  110|    204|pub(crate) fn xmm0() -> Reg {
  111|    204|    fpr(0)
  112|    204|}
_RNvNtNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x644inst4regs4xmm8:
  134|    204|pub(crate) fn xmm8() -> Reg {
  135|    204|    fpr(8)
  136|    204|}
_RNvNtNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x644inst4regs3rdx:
   55|    204|pub(crate) fn rdx() -> Reg {
   56|    204|    gpr(ENC_RDX)
   57|    204|}
_RNvNtNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x644inst4regs4xmm4:
  122|    204|pub(crate) fn xmm4() -> Reg {
  123|    204|    fpr(4)
  124|    204|}
_RNvNtNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x644inst4regs5xmm15:
  155|    204|pub(crate) fn xmm15() -> Reg {
  156|    204|    fpr(15)
  157|    204|}
_RNvNtNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x644inst4regs3rax:
   49|    204|pub(crate) fn rax() -> Reg {
   50|    204|    gpr(ENC_RAX)
   51|    204|}
_RNvNtNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x644inst4regs4xmm1:
  113|    204|pub(crate) fn xmm1() -> Reg {
  114|    204|    fpr(1)
  115|    204|}
_RNvNtNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x644inst4regs4xmm5:
  125|    204|pub(crate) fn xmm5() -> Reg {
  126|    204|    fpr(5)
  127|    204|}
_RNvNtNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x644inst4regs5xmm14:
  152|    204|pub(crate) fn xmm14() -> Reg {
  153|    204|    fpr(14)
  154|    204|}
_RNvNtNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x644inst4regs2r8:
   58|    204|pub(crate) fn r8() -> Reg {
   59|    204|    gpr(ENC_R8)
   60|    204|}
_RNvNtNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x644inst4regs3rdi:
   46|    204|pub(crate) fn rdi() -> Reg {
   47|    204|    gpr(ENC_RDI)
   48|    204|}
_RNvNtNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x644inst4regs3rbx:
   79|    204|pub(crate) fn rbx() -> Reg {
   80|    204|    gpr(ENC_RBX)
   81|    204|}
_RNvNtNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x644inst4regs3r13:
   73|    204|pub(crate) fn r13() -> Reg {
   74|    204|    gpr(ENC_R13)
   75|    204|}
_RNvNtNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x644inst4regs3gpr:
   35|  3.26k|fn gpr(enc: u8) -> Reg {
   36|  3.26k|    let preg = gpr_preg(enc);
   37|  3.26k|    Reg::from(VReg::new(preg.index(), RegClass::Int))
   38|  3.26k|}
_RNvNtNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x644inst4regs5xmm11:
  143|    204|pub(crate) fn xmm11() -> Reg {
  144|    204|    fpr(11)
  145|    204|}
_RNvNtNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x644inst4regs5xmm13:
  149|    204|pub(crate) fn xmm13() -> Reg {
  150|    204|    fpr(13)
  151|    204|}
_RNvNtNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x644inst4regs3r12:
   70|    204|pub(crate) fn r12() -> Reg {
   71|    204|    gpr(ENC_R12)
   72|    204|}
_RNvNtNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x644inst4regs3rsi:
   43|    204|pub(crate) fn rsi() -> Reg {
   44|    204|    gpr(ENC_RSI)
   45|    204|}
_RNvNtNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x644inst4regs3r14:
   76|    204|pub(crate) fn r14() -> Reg {
   77|    204|    gpr(ENC_R14)
   78|    204|}
_RNvNtNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x644inst4regs3r10:
   64|    204|pub(crate) fn r10() -> Reg {
   65|    204|    gpr(ENC_R10)
   66|    204|}
_RNvNtNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x644inst4regs5xmm12:
  146|    204|pub(crate) fn xmm12() -> Reg {
  147|    204|    fpr(12)
  148|    204|}
_RNvNtNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x644inst4regs4xmm3:
  119|    204|pub(crate) fn xmm3() -> Reg {
  120|    204|    fpr(3)
  121|    204|}
_RNvNtNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x644inst4regs10pinned_reg:
   97|    204|pub(crate) fn pinned_reg() -> Reg {
   98|    204|    r15()
   99|    204|}
_RNvNtNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x644inst4regs5xmm10:
  140|    204|pub(crate) fn xmm10() -> Reg {
  141|    204|    fpr(10)
  142|    204|}
_RNvNvNtNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x644inst4regs22create_reg_env_systemv4preg:
  161|  6.12k|    fn preg(r: Reg) -> PReg {
  162|  6.12k|        r.to_real_reg().unwrap().into()
  163|  6.12k|    }

_RNvNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x6415isa_constructor:
  189|    204|fn isa_constructor(
  190|    204|    triple: Triple,
  191|    204|    shared_flags: Flags,
  192|    204|    builder: shared_settings::Builder,
  193|    204|) -> CodegenResult<Box<dyn TargetIsa>> {
  194|    204|    let isa_flags = x64_settings::Flags::new(&shared_flags, builder);
  195|    204|
  196|    204|    // Check for compatibility between flags and ISA level
  197|    204|    // requested. In particular, SIMD support requires SSE4.2.
  198|    204|    if shared_flags.enable_simd() {
  199|      0|        if !isa_flags.has_sse3()
  200|      0|            || !isa_flags.has_ssse3()
  201|      0|            || !isa_flags.has_sse41()
  202|      0|            || !isa_flags.has_sse42()
  203|       |        {
  204|      0|            return Err(CodegenError::Unsupported(
  205|      0|                "SIMD support requires SSE3, SSSE3, SSE4.1, and SSE4.2 on x86_64.".into(),
  206|      0|            ));
  207|      0|        }
  208|    204|    }
  209|       |
  210|    204|    let backend = X64Backend::new_with_flags(triple, shared_flags, isa_flags);
  211|    204|    Ok(Box::new(backend))
  212|    204|}
_RNvMNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x64NtB2_10X64Backend14new_with_flags:
   38|    204|    fn new_with_flags(triple: Triple, flags: Flags, x64_flags: x64_settings::Flags) -> Self {
   39|    204|        let reg_env = create_reg_env_systemv(&flags);
   40|    204|        Self {
   41|    204|            triple,
   42|    204|            flags,
   43|    204|            x64_flags,
   44|    204|            reg_env,
   45|    204|        }
   46|    204|    }
_RNvNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x6411isa_builder:
  181|    204|pub(crate) fn isa_builder(triple: Triple) -> IsaBuilder {
  182|    204|    IsaBuilder {
  183|    204|        triple,
  184|    204|        setup: x64_settings::builder(),
  185|    204|        constructor: isa_constructor,
  186|    204|    }
  187|    204|}

_RNvNtNtCsaCEcwVhukSb_17cranelift_codegen8machinst3reg19pinned_vreg_to_preg:
   25|  6.12k|pub fn pinned_vreg_to_preg(vreg: VReg) -> Option<PReg> {
   26|  6.12k|    if vreg.vreg() < PINNED_VREGS {
   27|  6.12k|        Some(PReg::from_index(vreg.vreg()))
   28|       |    } else {
   29|      0|        None
   30|       |    }
   31|  6.12k|}
_RNvXsb_NtNtCsaCEcwVhukSb_17cranelift_codegen8machinst3regNtCs4eRjD9IvbzL_9regalloc24PRegINtNtCshM4Il2Z0i4R_4core7convert4FromNtB5_7RealRegE4from:
  236|  6.12k|    fn from(reg: RealReg) -> regalloc2::PReg {
  237|  6.12k|        PReg::from_index(reg.0.vreg())
  238|  6.12k|    }
_RNvXs5_NtNtCsaCEcwVhukSb_17cranelift_codegen8machinst3regNtB5_3RegINtNtCshM4Il2Z0i4R_4core7convert4FromNtCs4eRjD9IvbzL_9regalloc24VRegE4from:
  195|  6.52k|    fn from(vreg: regalloc2::VReg) -> Reg {
  196|  6.52k|        Reg(vreg)
  197|  6.52k|    }
_RNvXsm_NtNtCsaCEcwVhukSb_17cranelift_codegen8machinst3regNtB5_3RegNtNtCshM4Il2Z0i4R_4core3cmp9PartialEq2eq:
   48|    204|#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
_RNvMNtNtCsaCEcwVhukSb_17cranelift_codegen8machinst3regNtB2_3Reg11to_real_reg:
   55|  6.12k|    pub fn to_real_reg(self) -> Option<RealReg> {
   56|  6.12k|        if pinned_vreg_to_preg(self.0).is_some() {
   57|  6.12k|            Some(RealReg(self.0))
   58|       |        } else {
   59|      0|            None
   60|       |        }
   61|  6.12k|    }

_RNvXsh_NtCsaCEcwVhukSb_17cranelift_codegen8settingsNtB5_7BuilderNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
  148|    408|#[derive(Clone, Hash)]
_RNvXs1_NtCsaCEcwVhukSb_17cranelift_codegen8settingsNtB5_7BuilderNtB5_12Configurable6enable:
  253|  3.06k|    fn enable(&mut self, name: &str) -> SetResult<()> {
  254|       |        use self::detail::Detail;
  255|  3.06k|        let (offset, detail) = self.lookup(name)?;
  256|  3.06k|        match detail {
  257|  3.06k|            Detail::Bool { bit } => {
  258|  3.06k|                self.set_bit(offset, bit, true);
  259|  3.06k|                Ok(())
  260|       |            }
  261|       |            Detail::Preset => {
  262|      0|                self.apply_preset(&self.template.presets[offset..]);
  263|      0|                Ok(())
  264|       |            }
  265|      0|            _ => Err(SetError::BadType),
  266|       |        }
  267|  3.06k|    }
_RNvXs1_NtCsaCEcwVhukSb_17cranelift_codegen8settingsNtB5_7BuilderNtB5_12Configurable3set:
  269|  1.83k|    fn set(&mut self, name: &str, value: &str) -> SetResult<()> {
  270|       |        use self::detail::Detail;
  271|  1.83k|        let (offset, detail) = self.lookup(name)?;
  272|  1.83k|        match detail {
  273|  1.63k|            Detail::Bool { bit } => {
  274|  1.63k|                self.set_bit(offset, bit, parse_bool_value(value)?);
  275|       |            }
  276|      0|            Detail::Num => {
  277|      0|                self.bytes[offset] = value
  278|      0|                    .parse()
  279|      0|                    .map_err(|_| SetError::BadValue("number".to_string()))?;
  280|       |            }
  281|    204|            Detail::Enum { last, enumerators } => {
  282|    204|                self.bytes[offset] =
  283|    204|                    parse_enum_value(value, self.template.enums(last, enumerators))?;
  284|       |            }
  285|      0|            Detail::Preset => return Err(SetError::BadName(name.to_string())),
  286|       |        }
  287|  1.83k|        Ok(())
  288|  1.83k|    }
_RNCNvNtCsaCEcwVhukSb_17cranelift_codegen8settings16parse_enum_value0B5_:
  232|    408|    match choices.iter().position(|&tag| tag == value) {
_RNvXs_NtNtCsaCEcwVhukSb_17cranelift_codegen8settings6detailNtB4_8TemplateINtNtB8_13constant_hash5TableReE3len:
  406|  10.4k|        fn len(&self) -> usize {
  407|  10.4k|            self.hash_table.len()
  408|  10.4k|        }
_RNvNtCsaCEcwVhukSb_17cranelift_codegen8settings16parse_bool_value:
  223|  1.63k|fn parse_bool_value(value: &str) -> SetResult<bool> {
  224|  1.63k|    match value {
  225|  1.63k|        "true" | "on" | "yes" | "1" => Ok(true),
  226|  1.22k|        "false" | "off" | "no" | "0" => Ok(false),
  227|      0|        _ => Err(SetError::BadValue("bool".to_string())),
  228|       |    }
  229|  1.63k|}
_RNvMs0_NtCsaCEcwVhukSb_17cranelift_codegen8settingsNtB5_7Builder3new:
  156|    408|    pub fn new(tmpl: &'static detail::Template) -> Self {
  157|    408|        Self {
  158|    408|            template: tmpl,
  159|    408|            bytes: tmpl.defaults.into(),
  160|    408|        }
  161|    408|    }
_RNvNtCsaCEcwVhukSb_17cranelift_codegen8settings16parse_enum_value:
  231|    204|fn parse_enum_value(value: &str, choices: &[&str]) -> SetResult<u8> {
  232|    204|    match choices.iter().position(|&tag| tag == value) {
  233|    204|        Some(idx) => Ok(idx as u8),
  234|       |        None => {
  235|       |            // TODO: Use `join` instead of this code, once
  236|       |            // https://github.com/rust-lang/rust/issues/27747 is resolved.
  237|      0|            let mut all_choices = String::new();
  238|      0|            let mut first = true;
  239|      0|            for choice in choices {
  240|      0|                if first {
  241|      0|                    first = false
  242|      0|                } else {
  243|      0|                    all_choices += ", ";
  244|      0|                }
  245|      0|                all_choices += choice;
  246|       |            }
  247|      0|            Err(SetError::BadValue(format!("any among {}", all_choices)))
  248|       |        }
  249|       |    }
  250|    204|}
_RNvMs0_NtCsaCEcwVhukSb_17cranelift_codegen8settingsNtB5_7Builder7set_bit:
  194|  4.69k|    fn set_bit(&mut self, offset: usize, bit: u8, value: bool) {
  195|  4.69k|        let byte = &mut self.bytes[offset];
  196|  4.69k|        let mask = 1 << bit;
  197|  4.69k|        if value {
  198|  3.46k|            *byte |= mask;
  199|  3.46k|        } else {
  200|  1.22k|            *byte &= !mask;
  201|  1.22k|        }
  202|  4.69k|    }
_RNvMNtNtCsaCEcwVhukSb_17cranelift_codegen8settings6detailNtB2_8Template5enums:
  373|    204|        pub fn enums(&self, last: u8, enumerators: u16) -> &[&'static str] {
  374|    204|            let from = enumerators as usize;
  375|    204|            let len = usize::from(last) + 1;
  376|    204|            &self.enumerators[from..from + len]
  377|    204|        }
_RNvMs0_NtCsaCEcwVhukSb_17cranelift_codegen8settingsNtB5_7Builder9state_for:
  164|    408|    pub fn state_for(self, name: &str) -> Box<[u8]> {
  165|    408|        assert_eq!(name, self.template.name);
  166|    408|        self.bytes
  167|    408|    }
_RNvMs0_NtCsaCEcwVhukSb_17cranelift_codegen8settingsNtB5_7Builder6lookup:
  212|  4.89k|    fn lookup(&self, name: &str) -> SetResult<(usize, detail::Detail)> {
  213|  4.89k|        match probe(self.template, name, simple_hash(name)) {
  214|      0|            Err(_) => Err(SetError::BadName(name.to_string())),
  215|  4.89k|            Ok(entry) => {
  216|  4.89k|                let d = &self.template.descriptors[self.template.hash_table[entry] as usize];
  217|  4.89k|                Ok((d.offset as usize, d.detail))
  218|       |            }
  219|       |        }
  220|  4.89k|    }
_RNvXs_NtNtCsaCEcwVhukSb_17cranelift_codegen8settings6detailNtB4_8TemplateINtNtB8_13constant_hash5TableReE3key:
  410|  5.50k|        fn key(&self, idx: usize) -> Option<&'a str> {
  411|  5.50k|            let e = self.hash_table[idx] as usize;
  412|  5.50k|            if e < self.descriptors.len() {
  413|  5.50k|                Some(self.descriptors[e].name)
  414|       |            } else {
  415|      0|                None
  416|       |            }
  417|  5.50k|        }

_RNvNtCs6yQsP55HdkJ_24cranelift_codegen_shared13constant_hash11simple_hash:
    4|  4.89k|pub fn simple_hash(s: &str) -> usize {
    5|  4.89k|    let mut h: u32 = 5381;
    6|  54.6k|    for c in s.chars() {
    7|  54.6k|        h = (h ^ c as u32).wrapping_add(h.rotate_right(6));
    8|  54.6k|    }
    9|  4.89k|    h as usize
   10|  4.89k|}

_RNCNvXs_NtCsjOEpU6CGmht_16cranelift_entity4iterINtB6_4IterNtCsf9ABzndBH7D_14wasmtime_types11GlobalIndexNtBW_6GlobalENtNtNtNtCshM4Il2Z0i4R_4core4iter6traits8iterator8Iterator4next0Csa8j9dqGMVk5_16wasmtime_runtime:
   33|    408|        self.enumerate.next().map(|(i, v)| (K::new(i), v))
_RNvMNtCsjOEpU6CGmht_16cranelift_entity4iterINtB2_4IterNtCsf9ABzndBH7D_14wasmtime_types11GlobalIndexNtBS_6GlobalE3newCsa8j9dqGMVk5_16wasmtime_runtime:
   21|  1.22k|    pub fn new(iter: slice::Iter<'a, V>) -> Self {
   22|  1.22k|        Self {
   23|  1.22k|            enumerate: iter.enumerate(),
   24|  1.22k|            unused: PhantomData,
   25|  1.22k|        }
   26|  1.22k|    }
_RNvMNtCsjOEpU6CGmht_16cranelift_entity4iterINtB2_4IterNtCsf9ABzndBH7D_14wasmtime_types10TableIndexNtNtCshaNIPJAj9Ao_16wasmtime_environ6module9TablePlanE3newCsa8j9dqGMVk5_16wasmtime_runtime:
   21|    408|    pub fn new(iter: slice::Iter<'a, V>) -> Self {
   22|    408|        Self {
   23|    408|            enumerate: iter.enumerate(),
   24|    408|            unused: PhantomData,
   25|    408|        }
   26|    408|    }
_RNvXs_NtCsjOEpU6CGmht_16cranelift_entity4iterINtB4_4IterNtCsf9ABzndBH7D_14wasmtime_types10TableIndexNtNtCshaNIPJAj9Ao_16wasmtime_environ6module9TablePlanENtNtNtNtCshM4Il2Z0i4R_4core4iter6traits8iterator8Iterator4nextCsa8j9dqGMVk5_16wasmtime_runtime:
   32|    408|    fn next(&mut self) -> Option<Self::Item> {
   33|    408|        self.enumerate.next().map(|(i, v)| (K::new(i), v))
   34|    408|    }
_RNvXs_NtCsjOEpU6CGmht_16cranelift_entity4iterINtB4_4IterNtCsf9ABzndBH7D_14wasmtime_types11MemoryIndexNtNtCshaNIPJAj9Ao_16wasmtime_environ6module10MemoryPlanENtNtNtNtCshM4Il2Z0i4R_4core4iter6traits8iterator8Iterator4nextCsa8j9dqGMVk5_16wasmtime_runtime:
   32|  1.22k|    fn next(&mut self) -> Option<Self::Item> {
   33|  1.22k|        self.enumerate.next().map(|(i, v)| (K::new(i), v))
   34|  1.22k|    }
_RNCNvXs_NtCsjOEpU6CGmht_16cranelift_entity4iterINtB6_4IterNtCsf9ABzndBH7D_14wasmtime_types11MemoryIndexNtNtCshaNIPJAj9Ao_16wasmtime_environ6module10MemoryPlanENtNtNtNtCshM4Il2Z0i4R_4core4iter6traits8iterator8Iterator4next0Csa8j9dqGMVk5_16wasmtime_runtime:
   33|    204|        self.enumerate.next().map(|(i, v)| (K::new(i), v))
_RNvXs_NtCsjOEpU6CGmht_16cranelift_entity4iterINtB4_4IterNtCsf9ABzndBH7D_14wasmtime_types11GlobalIndexNtBU_6GlobalENtNtNtNtCshM4Il2Z0i4R_4core4iter6traits8iterator8Iterator4nextCsa8j9dqGMVk5_16wasmtime_runtime:
   32|  1.63k|    fn next(&mut self) -> Option<Self::Item> {
   33|  1.63k|        self.enumerate.next().map(|(i, v)| (K::new(i), v))
   34|  1.63k|    }
_RNvMNtCsjOEpU6CGmht_16cranelift_entity4iterINtB2_4IterNtCsf9ABzndBH7D_14wasmtime_types11MemoryIndexNtNtCshaNIPJAj9Ao_16wasmtime_environ6module10MemoryPlanE3newCsa8j9dqGMVk5_16wasmtime_runtime:
   21|  1.02k|    pub fn new(iter: slice::Iter<'a, V>) -> Self {
   22|  1.02k|        Self {
   23|  1.02k|            enumerate: iter.enumerate(),
   24|  1.02k|            unused: PhantomData,
   25|  1.02k|        }
   26|  1.02k|    }

_RNvXs2g_Csf9ABzndBH7D_14wasmtime_typesNtB6_11MemoryIndexNtCsjOEpU6CGmht_16cranelift_entity9EntityRef3new:
   74|    612|            fn new(index: usize) -> Self {
   75|    612|                debug_assert!(index < ($crate::__core::u32::MAX as usize));
   76|    612|                $entity(index as u32)
   77|    612|            }
_RNvMs25_Csf9ABzndBH7D_14wasmtime_typesNtB6_11GlobalIndex8from_u32:
  101|    204|            pub fn from_u32(x: u32) -> Self {
  102|    204|                debug_assert!(x < $crate::__core::u32::MAX);
  103|    204|                $entity(x)
  104|    204|            }
_RNvMs2i_Csf9ABzndBH7D_14wasmtime_typesNtB6_11MemoryIndex6as_u32:
  109|    204|            pub fn as_u32(self) -> u32 {
  110|    204|                self.0
  111|    204|            }
_RNvXs23_Csf9ABzndBH7D_14wasmtime_typesNtB6_11GlobalIndexNtCsjOEpU6CGmht_16cranelift_entity9EntityRef3new:
   74|    612|            fn new(index: usize) -> Self {
   75|    612|                debug_assert!(index < ($crate::__core::u32::MAX as usize));
   76|    612|                $entity(index as u32)
   77|    612|            }
_RNvMs2i_Csf9ABzndBH7D_14wasmtime_typesNtB6_11MemoryIndex8from_u32:
  101|    204|            pub fn from_u32(x: u32) -> Self {
  102|    204|                debug_assert!(x < $crate::__core::u32::MAX);
  103|    204|                $entity(x)
  104|    204|            }
_RNvXs2g_Csf9ABzndBH7D_14wasmtime_typesNtB6_11MemoryIndexNtCsjOEpU6CGmht_16cranelift_entity9EntityRef5index:
   80|    816|            fn index(self) -> usize {
   81|    816|                self.0 as usize
   82|    816|            }
_RNvMs1F_Csf9ABzndBH7D_14wasmtime_typesNtB6_18DefinedGlobalIndex6as_u32:
  109|    816|            pub fn as_u32(self) -> u32 {
  110|    816|                self.0
  111|    816|            }
_RNvXs1d_Csf9ABzndBH7D_14wasmtime_typesNtB6_18DefinedMemoryIndexNtCsjOEpU6CGmht_16cranelift_entity9EntityRef5index:
   80|    408|            fn index(self) -> usize {
   81|    408|                self.0 as usize
   82|    408|            }
_RNvMs1f_Csf9ABzndBH7D_14wasmtime_typesNtB6_18DefinedMemoryIndex6as_u32:
  109|    408|            pub fn as_u32(self) -> u32 {
  110|    408|                self.0
  111|    408|            }
_RNvXs23_Csf9ABzndBH7D_14wasmtime_typesNtB6_11GlobalIndexNtCsjOEpU6CGmht_16cranelift_entity9EntityRef5index:
   80|  1.42k|            fn index(self) -> usize {
   81|  1.42k|                self.0 as usize
   82|  1.42k|            }
_RNvXs1D_Csf9ABzndBH7D_14wasmtime_typesNtB6_18DefinedGlobalIndexNtCsjOEpU6CGmht_16cranelift_entity9EntityRef3new:
   74|    612|            fn new(index: usize) -> Self {
   75|    612|                debug_assert!(index < ($crate::__core::u32::MAX as usize));
   76|    612|                $entity(index as u32)
   77|    612|            }
_RNvXs1d_Csf9ABzndBH7D_14wasmtime_typesNtB6_18DefinedMemoryIndexNtCsjOEpU6CGmht_16cranelift_entity9EntityRef3new:
   74|    612|            fn new(index: usize) -> Self {
   75|    612|                debug_assert!(index < ($crate::__core::u32::MAX as usize));
   76|    612|                $entity(index as u32)
   77|    612|            }

_RNvMNtCsjOEpU6CGmht_16cranelift_entity7primaryINtB2_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types9TypeIndexNtNtCshaNIPJAj9Ao_16wasmtime_environ6module10ModuleTypeE3newCs7Ei498kZF3p_3fvm:
   45|    204|    pub fn new() -> Self {
   46|    204|        Self {
   47|    204|            elems: Vec::new(),
   48|    204|            unused: PhantomData,
   49|    204|        }
   50|    204|    }
_RNvXs_NtCsjOEpU6CGmht_16cranelift_entity7primaryINtB4_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types9FuncIndexNtNtCshaNIPJAj9Ao_16wasmtime_environ6module12FunctionTypeENtNtCshM4Il2Z0i4R_4core7default7Default7defaultCs7Ei498kZF3p_3fvm:
  188|    204|    fn default() -> PrimaryMap<K, V> {
  189|    204|        PrimaryMap::new()
  190|    204|    }
_RNvMNtCsjOEpU6CGmht_16cranelift_entity7primaryINtB2_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types9FuncIndexNtNtCshaNIPJAj9Ao_16wasmtime_environ6module12FunctionTypeE3newCs7Ei498kZF3p_3fvm:
   45|    204|    pub fn new() -> Self {
   46|    204|        Self {
   47|    204|            elems: Vec::new(),
   48|    204|            unused: PhantomData,
   49|    204|        }
   50|    204|    }
_RNvXs_NtCsjOEpU6CGmht_16cranelift_entity7primaryINtB4_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types9TypeIndexNtNtCshaNIPJAj9Ao_16wasmtime_environ6module10ModuleTypeENtNtCshM4Il2Z0i4R_4core7default7Default7defaultCs7Ei498kZF3p_3fvm:
  188|    204|    fn default() -> PrimaryMap<K, V> {
  189|    204|        PrimaryMap::new()
  190|    204|    }
_RNvMNtCsjOEpU6CGmht_16cranelift_entity7primaryINtB2_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types11GlobalIndexNtB12_6GlobalE3newCs7Ei498kZF3p_3fvm:
   45|    204|    pub fn new() -> Self {
   46|    204|        Self {
   47|    204|            elems: Vec::new(),
   48|    204|            unused: PhantomData,
   49|    204|        }
   50|    204|    }
_RNvXs_NtCsjOEpU6CGmht_16cranelift_entity7primaryINtB4_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types11GlobalIndexNtB14_6GlobalENtNtCshM4Il2Z0i4R_4core7default7Default7defaultCs7Ei498kZF3p_3fvm:
  188|    204|    fn default() -> PrimaryMap<K, V> {
  189|    204|        PrimaryMap::new()
  190|    204|    }
_RNvMNtCsjOEpU6CGmht_16cranelift_entity7primaryINtB2_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types10TableIndexNtNtCshaNIPJAj9Ao_16wasmtime_environ6module9TablePlanE3newCs7Ei498kZF3p_3fvm:
   45|    204|    pub fn new() -> Self {
   46|    204|        Self {
   47|    204|            elems: Vec::new(),
   48|    204|            unused: PhantomData,
   49|    204|        }
   50|    204|    }
_RNvXs_NtCsjOEpU6CGmht_16cranelift_entity7primaryINtB4_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types11MemoryIndexNtNtCshaNIPJAj9Ao_16wasmtime_environ6module10MemoryPlanENtNtCshM4Il2Z0i4R_4core7default7Default7defaultCs7Ei498kZF3p_3fvm:
  188|    204|    fn default() -> PrimaryMap<K, V> {
  189|    204|        PrimaryMap::new()
  190|    204|    }
_RNvMNtCsjOEpU6CGmht_16cranelift_entity7primaryINtB2_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types11MemoryIndexNtNtCshaNIPJAj9Ao_16wasmtime_environ6module10MemoryPlanE3newCs7Ei498kZF3p_3fvm:
   45|    204|    pub fn new() -> Self {
   46|    204|        Self {
   47|    204|            elems: Vec::new(),
   48|    204|            unused: PhantomData,
   49|    204|        }
   50|    204|    }
_RNvXs_NtCsjOEpU6CGmht_16cranelift_entity7primaryINtB4_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types10TableIndexNtNtCshaNIPJAj9Ao_16wasmtime_environ6module9TablePlanENtNtCshM4Il2Z0i4R_4core7default7Default7defaultCs7Ei498kZF3p_3fvm:
  188|    204|    fn default() -> PrimaryMap<K, V> {
  189|    204|        PrimaryMap::new()
  190|    204|    }
_RNvMNtCsjOEpU6CGmht_16cranelift_entity7primaryINtB2_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types11GlobalIndexNtB12_6GlobalE4pushCs3hbrbrmFUf_8wasmtime:
  121|    204|    pub fn push(&mut self, v: V) -> K {
  122|    204|        let k = self.next_key();
  123|    204|        self.elems.push(v);
  124|    204|        k
  125|    204|    }
_RNvXs_NtCsjOEpU6CGmht_16cranelift_entity7primaryINtB4_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types16DefinedFuncIndexNtNtCshaNIPJAj9Ao_16wasmtime_environ11compilation12FunctionInfoENtNtCshM4Il2Z0i4R_4core7default7Default7defaultCs3hbrbrmFUf_8wasmtime:
  188|    612|    fn default() -> PrimaryMap<K, V> {
  189|    612|        PrimaryMap::new()
  190|    612|    }
_RNvMNtCsjOEpU6CGmht_16cranelift_entity7primaryINtB2_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types11GlobalIndexNtB12_6GlobalE8next_keyCs3hbrbrmFUf_8wasmtime:
  116|    204|    pub fn next_key(&self) -> K {
  117|    204|        K::new(self.elems.len())
  118|    204|    }
_RNvMNtCsjOEpU6CGmht_16cranelift_entity7primaryINtB2_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types11MemoryIndexNtNtCshaNIPJAj9Ao_16wasmtime_environ6module10MemoryPlanE8next_keyCs3hbrbrmFUf_8wasmtime:
  116|    204|    pub fn next_key(&self) -> K {
  117|    204|        K::new(self.elems.len())
  118|    204|    }
_RNvMNtCsjOEpU6CGmht_16cranelift_entity7primaryINtB2_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types16DefinedFuncIndexNtNtCshaNIPJAj9Ao_16wasmtime_environ11compilation12FunctionInfoE3newCs3hbrbrmFUf_8wasmtime:
   45|    612|    pub fn new() -> Self {
   46|    612|        Self {
   47|    612|            elems: Vec::new(),
   48|    612|            unused: PhantomData,
   49|    612|        }
   50|    612|    }
_RNvMNtCsjOEpU6CGmht_16cranelift_entity7primaryINtB2_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types11MemoryIndexNtNtCshaNIPJAj9Ao_16wasmtime_environ6module10MemoryPlanE4pushCs3hbrbrmFUf_8wasmtime:
  121|    204|    pub fn push(&mut self, v: V) -> K {
  122|    204|        let k = self.next_key();
  123|    204|        self.elems.push(v);
  124|    204|        k
  125|    204|    }
_RNvMNtCsjOEpU6CGmht_16cranelift_entity7primaryINtB2_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types10TableIndexNtNtCshaNIPJAj9Ao_16wasmtime_environ6module9TablePlanE3lenCsa8j9dqGMVk5_16wasmtime_runtime:
   81|  1.63k|    pub fn len(&self) -> usize {
   82|  1.63k|        self.elems.len()
   83|  1.63k|    }
_RNvMNtCsjOEpU6CGmht_16cranelift_entity7primaryINtB2_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types18DefinedMemoryIndexNtNtCsa8j9dqGMVk5_16wasmtime_runtime6memory6MemoryE3newB1U_:
   45|    204|    pub fn new() -> Self {
   46|    204|        Self {
   47|    204|            elems: Vec::new(),
   48|    204|            unused: PhantomData,
   49|    204|        }
   50|    204|    }
_RNvMNtCsjOEpU6CGmht_16cranelift_entity7primaryINtB2_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types10TableIndexNtNtCshaNIPJAj9Ao_16wasmtime_environ6module9TablePlanE4iterCsa8j9dqGMVk5_16wasmtime_runtime:
  101|    408|    pub fn iter(&self) -> Iter<K, V> {
  102|    408|        Iter::new(self.elems.iter())
  103|    408|    }
_RNvMNtCsjOEpU6CGmht_16cranelift_entity7primaryINtB2_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types11GlobalIndexNtB12_6GlobalE3lenCsa8j9dqGMVk5_16wasmtime_runtime:
   81|    612|    pub fn len(&self) -> usize {
   82|    612|        self.elems.len()
   83|    612|    }
_RNvXs_NtCsjOEpU6CGmht_16cranelift_entity7primaryINtB4_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types17DefinedTableIndexNtNtCsa8j9dqGMVk5_16wasmtime_runtime5table5TableENtNtCshM4Il2Z0i4R_4core7default7Default7defaultB1V_:
  188|    204|    fn default() -> PrimaryMap<K, V> {
  189|    204|        PrimaryMap::new()
  190|    204|    }
_RNvXs0_NtCsjOEpU6CGmht_16cranelift_entity7primaryINtB5_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types11MemoryIndexNtNtCshaNIPJAj9Ao_16wasmtime_environ6module10MemoryPlanEINtNtNtCshM4Il2Z0i4R_4core3ops5index5IndexB13_E5indexCsa8j9dqGMVk5_16wasmtime_runtime:
  201|    408|    fn index(&self, k: K) -> &V {
  202|    408|        &self.elems[k.index()]
  203|    408|    }
_RNvXs0_NtCsjOEpU6CGmht_16cranelift_entity7primaryINtB5_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types11GlobalIndexNtB15_6GlobalEINtNtNtCshM4Il2Z0i4R_4core3ops5index5IndexB13_E5indexCsa8j9dqGMVk5_16wasmtime_runtime:
  201|    204|    fn index(&self, k: K) -> &V {
  202|    204|        &self.elems[k.index()]
  203|    204|    }
_RNvMNtCsjOEpU6CGmht_16cranelift_entity7primaryINtB2_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types18DefinedMemoryIndexNtNtCsa8j9dqGMVk5_16wasmtime_runtime6memory6MemoryE8next_keyB1U_:
  116|    204|    pub fn next_key(&self) -> K {
  117|    204|        K::new(self.elems.len())
  118|    204|    }
_RNvMNtCsjOEpU6CGmht_16cranelift_entity7primaryINtB2_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types11GlobalIndexNtB12_6GlobalE4iterCsa8j9dqGMVk5_16wasmtime_runtime:
  101|  1.22k|    pub fn iter(&self) -> Iter<K, V> {
  102|  1.22k|        Iter::new(self.elems.iter())
  103|  1.22k|    }
_RNvMNtCsjOEpU6CGmht_16cranelift_entity7primaryINtB2_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types11MemoryIndexNtNtCshaNIPJAj9Ao_16wasmtime_environ6module10MemoryPlanE3lenCsa8j9dqGMVk5_16wasmtime_runtime:
   81|  1.63k|    pub fn len(&self) -> usize {
   82|  1.63k|        self.elems.len()
   83|  1.63k|    }
_RNvXs_NtCsjOEpU6CGmht_16cranelift_entity7primaryINtB4_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types18DefinedMemoryIndexNtNtCsa8j9dqGMVk5_16wasmtime_runtime6memory6MemoryENtNtCshM4Il2Z0i4R_4core7default7Default7defaultB1W_:
  188|    204|    fn default() -> PrimaryMap<K, V> {
  189|    204|        PrimaryMap::new()
  190|    204|    }
_RNvMNtCsjOEpU6CGmht_16cranelift_entity7primaryINtB2_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types18DefinedMemoryIndexNtNtCsa8j9dqGMVk5_16wasmtime_runtime6memory6MemoryE13with_capacityB1U_:
   53|    408|    pub fn with_capacity(capacity: usize) -> Self {
   54|    408|        Self {
   55|    408|            elems: Vec::with_capacity(capacity),
   56|    408|            unused: PhantomData,
   57|    408|        }
   58|    408|    }
_RNvXs1_NtCsjOEpU6CGmht_16cranelift_entity7primaryINtB5_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types18DefinedMemoryIndexNtNtCsa8j9dqGMVk5_16wasmtime_runtime6memory6MemoryEINtNtNtCshM4Il2Z0i4R_4core3ops5index8IndexMutB13_E9index_mutB1X_:
  211|    204|    fn index_mut(&mut self, k: K) -> &mut V {
  212|    204|        &mut self.elems[k.index()]
  213|    204|    }
_RNvMNtCsjOEpU6CGmht_16cranelift_entity7primaryINtB2_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types17DefinedTableIndexNtNtCsa8j9dqGMVk5_16wasmtime_runtime5table5TableE3newB1T_:
   45|    204|    pub fn new() -> Self {
   46|    204|        Self {
   47|    204|            elems: Vec::new(),
   48|    204|            unused: PhantomData,
   49|    204|        }
   50|    204|    }
_RNvMNtCsjOEpU6CGmht_16cranelift_entity7primaryINtB2_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types17DefinedTableIndexNtNtCsa8j9dqGMVk5_16wasmtime_runtime5table5TableE13with_capacityB1T_:
   53|    408|    pub fn with_capacity(capacity: usize) -> Self {
   54|    408|        Self {
   55|    408|            elems: Vec::with_capacity(capacity),
   56|    408|            unused: PhantomData,
   57|    408|        }
   58|    408|    }
_RNvMNtCsjOEpU6CGmht_16cranelift_entity7primaryINtB2_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types18DefinedMemoryIndexNtNtCsa8j9dqGMVk5_16wasmtime_runtime6memory6MemoryE4pushB1U_:
  121|    204|    pub fn push(&mut self, v: V) -> K {
  122|    204|        let k = self.next_key();
  123|    204|        self.elems.push(v);
  124|    204|        k
  125|    204|    }
_RNvMNtCsjOEpU6CGmht_16cranelift_entity7primaryINtB2_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types11MemoryIndexNtNtCshaNIPJAj9Ao_16wasmtime_environ6module10MemoryPlanE4iterCsa8j9dqGMVk5_16wasmtime_runtime:
  101|  1.02k|    pub fn iter(&self) -> Iter<K, V> {
  102|  1.02k|        Iter::new(self.elems.iter())
  103|  1.02k|    }
_RNvXs_NtCsjOEpU6CGmht_16cranelift_entity7primaryINtB4_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types9FuncIndexNtNtCshaNIPJAj9Ao_16wasmtime_environ6module12FunctionTypeENtNtCshM4Il2Z0i4R_4core7default7Default7defaultB1M_:
  188|    408|    fn default() -> PrimaryMap<K, V> {
  189|    408|        PrimaryMap::new()
  190|    408|    }
_RNvMNtCsjOEpU6CGmht_16cranelift_entity7primaryINtB2_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types9TypeIndexNtNtCshaNIPJAj9Ao_16wasmtime_environ6module10ModuleTypeE3newB1K_:
   45|    408|    pub fn new() -> Self {
   46|    408|        Self {
   47|    408|            elems: Vec::new(),
   48|    408|            unused: PhantomData,
   49|    408|        }
   50|    408|    }
_RNvMNtCsjOEpU6CGmht_16cranelift_entity7primaryINtB2_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types11MemoryIndexNtNtCshaNIPJAj9Ao_16wasmtime_environ6module10MemoryPlanE3newB1N_:
   45|    408|    pub fn new() -> Self {
   46|    408|        Self {
   47|    408|            elems: Vec::new(),
   48|    408|            unused: PhantomData,
   49|    408|        }
   50|    408|    }
_RNvXs_NtCsjOEpU6CGmht_16cranelift_entity7primaryINtB4_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types9TypeIndexNtNtCshaNIPJAj9Ao_16wasmtime_environ6module10ModuleTypeENtNtCshM4Il2Z0i4R_4core7default7Default7defaultB1M_:
  188|    408|    fn default() -> PrimaryMap<K, V> {
  189|    408|        PrimaryMap::new()
  190|    408|    }
_RNvMNtCsjOEpU6CGmht_16cranelift_entity7primaryINtB2_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types11GlobalIndexNtB12_6GlobalE3newCshaNIPJAj9Ao_16wasmtime_environ:
   45|    408|    pub fn new() -> Self {
   46|    408|        Self {
   47|    408|            elems: Vec::new(),
   48|    408|            unused: PhantomData,
   49|    408|        }
   50|    408|    }
_RNvXs_NtCsjOEpU6CGmht_16cranelift_entity7primaryINtB4_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types11MemoryIndexNtNtCshaNIPJAj9Ao_16wasmtime_environ6module10MemoryPlanENtNtCshM4Il2Z0i4R_4core7default7Default7defaultB1P_:
  188|    408|    fn default() -> PrimaryMap<K, V> {
  189|    408|        PrimaryMap::new()
  190|    408|    }
_RNvXs_NtCsjOEpU6CGmht_16cranelift_entity7primaryINtB4_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types10TableIndexNtNtCshaNIPJAj9Ao_16wasmtime_environ6module9TablePlanENtNtCshM4Il2Z0i4R_4core7default7Default7defaultB1O_:
  188|    408|    fn default() -> PrimaryMap<K, V> {
  189|    408|        PrimaryMap::new()
  190|    408|    }
_RNvXs_NtCsjOEpU6CGmht_16cranelift_entity7primaryINtB4_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types11GlobalIndexNtB14_6GlobalENtNtCshM4Il2Z0i4R_4core7default7Default7defaultCshaNIPJAj9Ao_16wasmtime_environ:
  188|    408|    fn default() -> PrimaryMap<K, V> {
  189|    408|        PrimaryMap::new()
  190|    408|    }
_RNvMNtCsjOEpU6CGmht_16cranelift_entity7primaryINtB2_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types9FuncIndexNtNtCshaNIPJAj9Ao_16wasmtime_environ6module12FunctionTypeE3newB1K_:
   45|    408|    pub fn new() -> Self {
   46|    408|        Self {
   47|    408|            elems: Vec::new(),
   48|    408|            unused: PhantomData,
   49|    408|        }
   50|    408|    }
_RNvMNtCsjOEpU6CGmht_16cranelift_entity7primaryINtB2_10PrimaryMapNtCsf9ABzndBH7D_14wasmtime_types10TableIndexNtNtCshaNIPJAj9Ao_16wasmtime_environ6module9TablePlanE3newB1M_:
   45|    408|    pub fn new() -> Self {
   46|    408|        Self {
   47|    408|            elems: Vec::new(),
   48|    408|            unused: PhantomData,
   49|    408|        }
   50|    408|    }

_RNvMNtCsjOEpU6CGmht_16cranelift_entity3setINtB2_9EntitySetNtCsf9ABzndBH7D_14wasmtime_types9ElemIndexE13with_capacityCsa8j9dqGMVk5_16wasmtime_runtime:
   37|    612|    pub fn with_capacity(capacity: usize) -> Self {
   38|    612|        Self {
   39|    612|            elems: Vec::with_capacity((capacity + 7) / 8),
   40|    612|            ..Self::new()
   41|    612|        }
   42|    612|    }
_RNvMNtCsjOEpU6CGmht_16cranelift_entity3setINtB2_9EntitySetNtCsf9ABzndBH7D_14wasmtime_types9ElemIndexE3newCsa8j9dqGMVk5_16wasmtime_runtime:
   28|    612|    pub fn new() -> Self {
   29|    612|        Self {
   30|    612|            elems: Vec::new(),
   31|    612|            len: 0,
   32|    612|            unused: PhantomData,
   33|    612|        }
   34|    612|    }
_RNvMNtCsjOEpU6CGmht_16cranelift_entity3setINtB2_9EntitySetNtCsf9ABzndBH7D_14wasmtime_types9DataIndexE3newCsa8j9dqGMVk5_16wasmtime_runtime:
   28|    612|    pub fn new() -> Self {
   29|    612|        Self {
   30|    612|            elems: Vec::new(),
   31|    612|            len: 0,
   32|    612|            unused: PhantomData,
   33|    612|        }
   34|    612|    }
_RNvMNtCsjOEpU6CGmht_16cranelift_entity3setINtB2_9EntitySetNtCsf9ABzndBH7D_14wasmtime_types9DataIndexE13with_capacityCsa8j9dqGMVk5_16wasmtime_runtime:
   37|    612|    pub fn with_capacity(capacity: usize) -> Self {
   38|    612|        Self {
   39|    612|            elems: Vec::with_capacity((capacity + 7) / 8),
   40|    612|            ..Self::new()
   41|    612|        }
   42|    612|    }

_RNvCs5T1vYxCUvEZ_16cranelift_native7builder:
   32|    204|pub fn builder() -> Result<isa::Builder, &'static str> {
   33|    204|    builder_with_options(true)
   34|    204|}
_RNvCs5T1vYxCUvEZ_16cranelift_native20builder_with_options:
   43|    204|pub fn builder_with_options(infer_native_flags: bool) -> Result<isa::Builder, &'static str> {
   44|    204|    let mut isa_builder = isa::lookup(Triple::host()).map_err(|err| match err {
   45|       |        isa::LookupError::SupportDisabled => "support for architecture disabled at compile time",
   46|       |        isa::LookupError::Unsupported => "unsupported architecture",
   47|    204|    })?;
   48|       |
   49|       |    #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
   50|       |    {
   51|       |        use cranelift_codegen::settings::Configurable;
   52|       |
   53|    204|        if !std::is_x86_feature_detected!("sse2") {
   54|      0|            return Err("x86 support requires SSE2");
   55|    204|        }
   56|    204|
   57|    204|        if !infer_native_flags {
   58|      0|            return Ok(isa_builder);
   59|    204|        }
   60|    204|
   61|    204|        // These are temporarily enabled by default (see #3810 for
   62|    204|        // more) so that a default-constructed `Flags` can work with
   63|    204|        // default Wasmtime features. Otherwise, the user must
   64|    204|        // explicitly use native flags or turn these on when on x86-64
   65|    204|        // platforms to avoid a configuration panic. In order for the
   66|    204|        // "enable if detected" logic below to work, we must turn them
   67|    204|        // *off* (differing from the default) and then re-enable below
   68|    204|        // if present.
   69|    204|        isa_builder.set("has_sse3", "false").unwrap();
   70|    204|        isa_builder.set("has_ssse3", "false").unwrap();
   71|    204|        isa_builder.set("has_sse41", "false").unwrap();
   72|    204|        isa_builder.set("has_sse42", "false").unwrap();
   73|       |
   74|    204|        if std::is_x86_feature_detected!("sse3") {
   75|    204|            isa_builder.enable("has_sse3").unwrap();
   76|    204|        }
   77|    204|        if std::is_x86_feature_detected!("ssse3") {
   78|    204|            isa_builder.enable("has_ssse3").unwrap();
   79|    204|        }
   80|    204|        if std::is_x86_feature_detected!("sse4.1") {
   81|    204|            isa_builder.enable("has_sse41").unwrap();
   82|    204|        }
   83|    204|        if std::is_x86_feature_detected!("sse4.2") {
   84|    204|            isa_builder.enable("has_sse42").unwrap();
   85|    204|        }
   86|    204|        if std::is_x86_feature_detected!("popcnt") {
   87|    204|            isa_builder.enable("has_popcnt").unwrap();
   88|    204|        }
   89|    204|        if std::is_x86_feature_detected!("avx") {
   90|    204|            isa_builder.enable("has_avx").unwrap();
   91|    204|        }
   92|    204|        if std::is_x86_feature_detected!("avx2") {
   93|    204|            isa_builder.enable("has_avx2").unwrap();
   94|    204|        }
   95|    204|        if std::is_x86_feature_detected!("fma") {
   96|    204|            isa_builder.enable("has_fma").unwrap();
   97|    204|        }
   98|    204|        if std::is_x86_feature_detected!("bmi1") {
   99|    204|            isa_builder.enable("has_bmi1").unwrap();
  100|    204|        }
  101|    204|        if std::is_x86_feature_detected!("bmi2") {
  102|    204|            isa_builder.enable("has_bmi2").unwrap();
  103|    204|        }
  104|      0|        if std::is_x86_feature_detected!("avx512bitalg") {
  105|      0|            isa_builder.enable("has_avx512bitalg").unwrap();
  106|    204|        }
  107|    204|        if std::is_x86_feature_detected!("avx512dq") {
  108|    204|            isa_builder.enable("has_avx512dq").unwrap();
  109|    204|        }
  110|    204|        if std::is_x86_feature_detected!("avx512f") {
  111|    204|            isa_builder.enable("has_avx512f").unwrap();
  112|    204|        }
  113|    204|        if std::is_x86_feature_detected!("avx512vl") {
  114|    204|            isa_builder.enable("has_avx512vl").unwrap();
  115|    204|        }
  116|      0|        if std::is_x86_feature_detected!("avx512vbmi") {
  117|      0|            isa_builder.enable("has_avx512vbmi").unwrap();
  118|    204|        }
  119|    204|        if std::is_x86_feature_detected!("lzcnt") {
  120|    204|            isa_builder.enable("has_lzcnt").unwrap();
  121|    204|        }
  122|       |    }
  123|       |
  124|       |    #[cfg(target_arch = "aarch64")]
  125|       |    {
  126|       |        use cranelift_codegen::settings::Configurable;
  127|       |
  128|       |        if !infer_native_flags {
  129|       |            return Ok(isa_builder);
  130|       |        }
  131|       |
  132|       |        if std::arch::is_aarch64_feature_detected!("lse") {
  133|       |            isa_builder.enable("has_lse").unwrap();
  134|       |        }
  135|       |
  136|       |        if std::arch::is_aarch64_feature_detected!("paca") {
  137|       |            isa_builder.enable("has_pauth").unwrap();
  138|       |        }
  139|       |
  140|       |        if cfg!(target_os = "macos") {
  141|       |            // Pointer authentication is always available on Apple Silicon.
  142|       |            isa_builder.enable("sign_return_address").unwrap();
  143|       |            // macOS enforces the use of the B key for return addresses.
  144|       |            isa_builder.enable("sign_return_address_with_bkey").unwrap();
  145|       |        }
  146|       |    }
  147|       |
  148|       |    // There is no is_s390x_feature_detected macro yet, so for now
  149|       |    // we use getauxval from the libc crate directly.
  150|       |    #[cfg(all(target_arch = "s390x", target_os = "linux"))]
  151|       |    {
  152|       |        use cranelift_codegen::settings::Configurable;
  153|       |
  154|       |        if !infer_native_flags {
  155|       |            return Ok(isa_builder);
  156|       |        }
  157|       |
  158|       |        let v = unsafe { libc::getauxval(libc::AT_HWCAP) };
  159|       |        const HWCAP_S390X_VXRS_EXT2: libc::c_ulong = 32768;
  160|       |        if (v & HWCAP_S390X_VXRS_EXT2) != 0 {
  161|       |            isa_builder.enable("has_vxrs_ext2").unwrap();
  162|       |            // There is no separate HWCAP bit for mie2, so assume
  163|       |            // that any machine with vxrs_ext2 also has mie2.
  164|       |            isa_builder.enable("has_mie2").unwrap();
  165|       |        }
  166|       |    }
  167|       |
  168|       |    // squelch warnings about unused mut/variables on some platforms.
  169|    204|    drop(&mut isa_builder);
  170|    204|    drop(infer_native_flags);
  171|    204|
  172|    204|    Ok(isa_builder)
  173|    204|}

_RINvXsd_NtCskiMMfqUGwCy_14cs_serde_bytes7bytebufNtB6_14ByteBufVisitorNtNtCslVZeVZySzLE_5serde2de7Visitor14visit_byte_bufNtNtCsalhrieD8kwf_12libipld_core5error10SerdeErrorECsitTtQF8ArIt_8fvm_fuzz:
  208|    306|    fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<ByteBuf, E>
  209|    306|    where
  210|    306|        E: Error,
  211|    306|    {
  212|    306|        Ok(ByteBuf::from(v))
  213|    306|    }
_RINvXse_NtCskiMMfqUGwCy_14cs_serde_bytes7bytebufNtB6_7ByteBufNtNtCslVZeVZySzLE_5serde2de11Deserialize11deserializeNtNtCsalhrieD8kwf_12libipld_core4ipld4IpldECsitTtQF8ArIt_8fvm_fuzz:
  217|    306|    fn deserialize<D>(deserializer: D) -> Result<ByteBuf, D::Error>
  218|    306|    where
  219|    306|        D: Deserializer<'de>,
  220|    306|    {
  221|    306|        deserializer.deserialize_byte_buf(ByteBufVisitor)
  222|    306|    }
_RINvMNtCskiMMfqUGwCy_14cs_serde_bytes7bytebufNtB3_7ByteBuf4fromINtNtCsjYc3JqMxxfa_5alloc3vec3VechEECsitTtQF8ArIt_8fvm_fuzz:
   58|    306|    pub fn from<T: Into<Vec<u8>>>(bytes: T) -> Self {
   59|    306|        ByteBuf {
   60|    306|            bytes: bytes.into(),
   61|    306|        }
   62|    306|    }
_RNvMNtCskiMMfqUGwCy_14cs_serde_bytes7bytebufNtB2_7ByteBuf8into_vec:
   65|    306|    pub fn into_vec(self) -> Vec<u8> {
   66|    306|        self.bytes
   67|    306|    }

_RINvXs1_NtCskiMMfqUGwCy_14cs_serde_bytes2deNtNtB8_7bytebuf7ByteBufNtB6_11Deserialize11deserializeNtNtCsalhrieD8kwf_12libipld_core4ipld4IpldECsitTtQF8ArIt_8fvm_fuzz:
   59|    306|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
   60|    306|    where
   61|    306|        D: Deserializer<'de>,
   62|    306|    {
   63|    306|        // Via the serde::Deserialize impl for ByteBuf.
   64|    306|        serde::Deserialize::deserialize(deserializer)
   65|    306|    }
_RINvXs_NtCskiMMfqUGwCy_14cs_serde_bytes2deINtNtCsjYc3JqMxxfa_5alloc3vec3VechENtB5_11Deserialize11deserializeNtNtCsalhrieD8kwf_12libipld_core4ipld4IpldECsitTtQF8ArIt_8fvm_fuzz:
   40|    306|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
   41|    306|    where
   42|    306|        D: Deserializer<'de>,
   43|    306|    {
   44|    306|        Deserialize::deserialize(deserializer).map(ByteBuf::into_vec)
   45|    306|    }

_RINvCskiMMfqUGwCy_14cs_serde_bytes9serializeINtNtCsjYc3JqMxxfa_5alloc3vec3VechEQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
   76|    306|pub fn serialize<T, S>(bytes: &T, serializer: S) -> Result<S::Ok, S::Error>
   77|    306|where
   78|    306|    T: ?Sized + Serialize,
   79|    306|    S: Serializer,
   80|    306|{
   81|    306|    Serialize::serialize(bytes, serializer)
   82|    306|}
_RINvCskiMMfqUGwCy_14cs_serde_bytes11deserializeINtNtCsjYc3JqMxxfa_5alloc3vec3VechENtNtCsalhrieD8kwf_12libipld_core4ipld4IpldECsitTtQF8ArIt_8fvm_fuzz:
  102|    306|pub fn deserialize<'de, T, D>(deserializer: D) -> Result<T, D::Error>
  103|    306|where
  104|    306|    T: Deserialize<'de>,
  105|    306|    D: Deserializer<'de>,
  106|    306|{
  107|    306|    Deserialize::deserialize(deserializer)
  108|    306|}

_RINvXs_NtCskiMMfqUGwCy_14cs_serde_bytes3serINtNtCsjYc3JqMxxfa_5alloc3vec3VechENtB5_9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
   37|    306|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   38|    306|    where
   39|    306|        S: Serializer,
   40|    306|    {
   41|    306|        serializer.serialize_bytes(self)
   42|    306|    }

_RNvXCsetwwlQTL1Fd_13data_encodingNtB2_2OnINtB2_6StaticINtNtCshM4Il2Z0i4R_4core6option6OptionTjRShEEE3valB2_:
  199|    612|    fn val(self) -> Option<T> {
  200|    612|        None
  201|    612|    }
_RINvCsetwwlQTL1Fd_13data_encoding15encode_base_lenNtB2_2N5EB2_:
  481|    612|fn encode_base_len<B: Static<usize>>(bit: B, len: usize) -> usize {
  482|    612|    encode_len(bit, len)
  483|    612|}
_RNvMs4_CsetwwlQTL1Fd_13data_encodingNtB5_8Encoding4wrap:
 1250|    612|    fn wrap(&self) -> Option<(usize, &[u8])> {
 1251|    612|        if self.0.len() <= 515 {
 1252|    612|            return None;
 1253|      0|        }
 1254|      0|        Some((self.0[514] as usize, &self.0[515 ..]))
 1255|    612|    }
_RINvCsetwwlQTL1Fd_13data_encoding15encode_wrap_lenNtB2_2N5NtB2_2OnBU_EB2_:
  514|    408|fn encode_wrap_len<
  515|    408|    'a,
  516|    408|    B: Static<usize>,
  517|    408|    P: Static<Option<u8>>,
  518|    408|    W: Static<Option<(usize, &'a [u8])>>,
  519|    408|>(
  520|    408|    bit: B, pad: P, wrap: W, ilen: usize,
  521|    408|) -> usize {
  522|    408|    let olen = encode_pad_len(bit, pad, ilen);
  523|    408|    match wrap.val() {
  524|    408|        None => olen,
  525|      0|        Some((col, end)) => olen + end.len() * div_ceil(olen, col),
  526|       |    }
  527|    408|}
_RINvCsetwwlQTL1Fd_13data_encoding10encode_mutNtB2_2N5NtB2_2BtEB2_:
  390|    204|fn encode_mut<B: Static<usize>, M: Static<bool>>(
  391|    204|    bit: B, msb: M, symbols: &[u8; 256], input: &[u8], output: &mut [u8],
  392|    204|) {
  393|    204|    debug_assert_eq!(output.len(), encode_len(bit, input.len()));
  394|    204|    let enc = enc(bit.val());
  395|    204|    let dec = dec(bit.val());
  396|    204|    let n = input.len() / enc;
  397|    204|    let bs = match bit.val() {
  398|    204|        5 => 2,
  399|      0|        6 => 4,
  400|      0|        _ => 1,
  401|       |    };
  402|    204|    vectorize(n, bs, |i| {
  403|       |        let input = unsafe { chunk_unchecked(input, enc, i) };
  404|       |        let output = unsafe { chunk_mut_unchecked(output, dec, i) };
  405|       |        encode_block(bit, msb, symbols, input, output);
  406|    204|    });
  407|    204|    encode_block(bit, msb, symbols, &input[enc * n ..], &mut output[dec * n ..]);
  408|    204|}
_RNvCsetwwlQTL1Fd_13data_encoding8as_array:
  253|    204|unsafe fn as_array(x: &[u8]) -> &[u8; 256] {
  254|    204|    debug_assert_eq!(x.len(), 256);
  255|    204|    &*(x.as_ptr() as *const [u8; 256])
  256|    204|}
_RINvCsetwwlQTL1Fd_13data_encoding14encode_pad_lenNtB2_2N5NtB2_2OnEB2_:
  492|    408|fn encode_pad_len<B: Static<usize>, P: Static<Option<u8>>>(bit: B, pad: P, len: usize) -> usize {
  493|    408|    match pad.val() {
  494|    408|        None => encode_base_len(bit, len),
  495|      0|        Some(_) => div_ceil(len, enc(bit.val())) * dec(bit.val()),
  496|       |    }
  497|    408|}
_RNvMs4_CsetwwlQTL1Fd_13data_encodingNtB5_8Encoding3sym:
 1222|    204|    fn sym(&self) -> &[u8; 256] {
 1223|    204|        unsafe { as_array(&self.0[0 .. 256]) }
 1224|    204|    }
_RINvCsetwwlQTL1Fd_13data_encoding10encode_lenNtB2_2N5EB2_:
  369|  2.04k|fn encode_len<B: Static<usize>>(bit: B, len: usize) -> usize {
  370|  2.04k|    div_ceil(8 * len, bit.val())
  371|  2.04k|}
_RNvXCsetwwlQTL1Fd_13data_encodingNtB2_2OnINtB2_6StaticINtNtCshM4Il2Z0i4R_4core6option6OptionhEE3valB2_:
  199|    612|    fn val(self) -> Option<T> {
  200|    612|        None
  201|    612|    }
_RNvCsetwwlQTL1Fd_13data_encoding15chunk_unchecked:
  241|  1.02k|unsafe fn chunk_unchecked(x: &[u8], n: usize, i: usize) -> &[u8] {
  242|  1.02k|    debug_assert!((i + 1) * n <= x.len());
  243|  1.02k|    let ptr = x.as_ptr().add(n * i);
  244|  1.02k|    core::slice::from_raw_parts(ptr, n)
  245|  1.02k|}
_RNvCsetwwlQTL1Fd_13data_encoding5order:
  347|  14.3k|fn order(msb: bool, n: usize, i: usize) -> usize {
  348|  14.3k|    if msb {
  349|  14.3k|        n - 1 - i
  350|       |    } else {
  351|      0|        i
  352|       |    }
  353|  14.3k|}
_RINvCsetwwlQTL1Fd_13data_encoding9vectorizeNCINvB2_10encode_mutNtB2_2N5NtB2_2BtE0EB2_:
  266|    204|fn vectorize<F: FnMut(usize)>(n: usize, bs: usize, mut f: F) {
  267|    408|    for k in 0 .. n / bs {
  268|    816|        for i in k * bs .. (k + 1) * bs {
  269|    816|            f(i);
  270|    816|        }
  271|       |    }
  272|    204|    for i in floor(n, bs) .. n {
  273|    204|        f(i);
  274|    204|    }
  275|    204|}
_RNvCsetwwlQTL1Fd_13data_encoding3dec:
  365|  9.07k|fn dec(bit: usize) -> usize {
  366|  9.07k|    enc(bit) * 8 / bit
  367|  9.07k|}
_RINvCsetwwlQTL1Fd_13data_encoding12encode_blockNtB2_2N5NtB2_2BtEB2_:
  373|  1.22k|fn encode_block<B: Static<usize>, M: Static<bool>>(
  374|  1.22k|    bit: B, msb: M, symbols: &[u8; 256], input: &[u8], output: &mut [u8],
  375|  1.22k|) {
  376|  1.22k|    debug_assert!(input.len() <= enc(bit.val()));
  377|  1.22k|    debug_assert_eq!(output.len(), encode_len(bit, input.len()));
  378|  1.22k|    let bit = bit.val();
  379|  1.22k|    let msb = msb.val();
  380|  1.22k|    let mut x = 0u64;
  381|  5.50k|    for (i, input) in input.iter().enumerate() {
  382|  5.50k|        x |= u64::from(*input) << (8 * order(msb, enc(bit), i));
  383|  5.50k|    }
  384|  8.87k|    for (i, output) in output.iter_mut().enumerate() {
  385|  8.87k|        let y = x >> (bit * order(msb, dec(bit), i));
  386|  8.87k|        *output = symbols[y as usize % 256];
  387|  8.87k|    }
  388|  1.22k|}
_RNvMs4_CsetwwlQTL1Fd_13data_encodingNtB5_8Encoding10encode_mut:
 1295|    204|    pub fn encode_mut(&self, input: &[u8], output: &mut [u8]) {
 1296|    204|        assert_eq!(output.len(), self.encode_len(input.len()));
 1297|       |        dispatch! {
 1298|    204|            let bit: usize = self.bit();
 1299|    204|            let msb: bool = self.msb();
 1300|    204|            let pad: Option<u8> = self.pad();
 1301|    204|            let wrap: Option<(usize, &[u8])> = self.wrap();
 1302|    204|            encode_wrap_mut(bit, msb, self.sym(), pad, wrap, input, output)
 1303|       |        }
 1304|    204|    }
_RNvCsetwwlQTL1Fd_13data_encoding19chunk_mut_unchecked:
  247|  1.02k|unsafe fn chunk_mut_unchecked(x: &mut [u8], n: usize, i: usize) -> &mut [u8] {
  248|  1.02k|    debug_assert!((i + 1) * n <= x.len());
  249|  1.02k|    let ptr = x.as_mut_ptr().add(n * i);
  250|  1.02k|    core::slice::from_raw_parts_mut(ptr, n)
  251|  1.02k|}
_RNvCsetwwlQTL1Fd_13data_encoding3enc:
  355|  16.0k|fn enc(bit: usize) -> usize {
  356|  16.0k|    debug_assert!(1 <= bit && bit <= 6);
  357|  16.0k|    match bit {
  358|      0|        1 | 2 | 4 => 1,
  359|      0|        3 | 6 => 3,
  360|  16.0k|        5 => 5,
  361|      0|        _ => unreachable!(),
  362|       |    }
  363|  16.0k|}
_RINvCsetwwlQTL1Fd_13data_encoding10encode_padNtB2_2N5NtB2_2BtNtB2_2OnEB2_:
  499|    204|fn encode_pad<B: Static<usize>, M: Static<bool>, P: Static<Option<u8>>>(
  500|    204|    bit: B, msb: M, symbols: &[u8; 256], spad: P, input: &[u8], output: &mut [u8],
  501|    204|) {
  502|    204|    let pad = match spad.val() {
  503|    204|        None => return encode_base(bit, msb, symbols, input, output),
  504|      0|        Some(pad) => pad,
  505|       |    };
  506|      0|    debug_assert_eq!(output.len(), encode_pad_len(bit, spad, input.len()));
  507|      0|    let olen = encode_base_len(bit, input.len());
  508|      0|    encode_base(bit, msb, symbols, input, &mut output[.. olen]);
  509|      0|    for output in output.iter_mut().skip(olen) {
  510|      0|        *output = pad;
  511|      0|    }
  512|    204|}
_RNvXsb_CsetwwlQTL1Fd_13data_encodingNtB5_2BtINtB5_6StaticbE3val:
  179|  1.22k|            fn val(self) -> $type {
  180|  1.22k|                $val
  181|  1.22k|            }
_RNCINvCsetwwlQTL1Fd_13data_encoding10encode_mutNtB4_2N5NtB4_2BtE0B4_:
  402|  1.02k|    vectorize(n, bs, |i| {
  403|  1.02k|        let input = unsafe { chunk_unchecked(input, enc, i) };
  404|  1.02k|        let output = unsafe { chunk_mut_unchecked(output, dec, i) };
  405|  1.02k|        encode_block(bit, msb, symbols, input, output);
  406|  1.02k|    });
_RNvMs4_CsetwwlQTL1Fd_13data_encodingNtB5_8Encoding3bit:
 1246|    612|    fn bit(&self) -> usize {
 1247|    612|        (self.0[513] & 0x7) as usize
 1248|    612|    }
_RNvCsetwwlQTL1Fd_13data_encoding8div_ceil:
  258|  2.04k|fn div_ceil(x: usize, m: usize) -> usize {
  259|  2.04k|    (x + m - 1) / m
  260|  2.04k|}
_RNvMs4_CsetwwlQTL1Fd_13data_encodingNtB5_8Encoding3msb:
 1242|    204|    fn msb(&self) -> bool {
 1243|    204|        self.0[513] & 0x8 != 0
 1244|    204|    }
_RNvMs4_CsetwwlQTL1Fd_13data_encodingNtB5_8Encoding6encode:
 1343|    204|    pub fn encode(&self, input: &[u8]) -> String {
 1344|    204|        let mut output = vec![0u8; self.encode_len(input.len())];
 1345|    204|        self.encode_mut(input, &mut output);
 1346|    204|        unsafe { String::from_utf8_unchecked(output) }
 1347|    204|    }
_RNvCsetwwlQTL1Fd_13data_encoding5floor:
  262|    204|fn floor(x: usize, m: usize) -> usize {
  263|    204|    x / m * m
  264|    204|}
_RNvXsq_CsetwwlQTL1Fd_13data_encodingNtB5_2N5INtB5_6StaticjE3val:
  179|  5.10k|            fn val(self) -> $type {
  180|  5.10k|                $val
  181|  5.10k|            }
_RINvCsetwwlQTL1Fd_13data_encoding15encode_wrap_mutNtB2_2N5NtB2_2BtNtB2_2OnB12_EB2_:
  529|    204|fn encode_wrap_mut<
  530|    204|    'a,
  531|    204|    B: Static<usize>,
  532|    204|    M: Static<bool>,
  533|    204|    P: Static<Option<u8>>,
  534|    204|    W: Static<Option<(usize, &'a [u8])>>,
  535|    204|>(
  536|    204|    bit: B, msb: M, symbols: &[u8; 256], pad: P, wrap: W, input: &[u8], output: &mut [u8],
  537|    204|) {
  538|    204|    let (col, end) = match wrap.val() {
  539|    204|        None => return encode_pad(bit, msb, symbols, pad, input, output),
  540|      0|        Some((col, end)) => (col, end),
  541|       |    };
  542|      0|    debug_assert_eq!(output.len(), encode_wrap_len(bit, pad, wrap, input.len()));
  543|      0|    debug_assert_eq!(col % dec(bit.val()), 0);
  544|      0|    let col = col / dec(bit.val());
  545|      0|    let enc = col * enc(bit.val());
  546|      0|    let dec = col * dec(bit.val()) + end.len();
  547|      0|    let olen = dec - end.len();
  548|      0|    let n = input.len() / enc;
  549|      0|    for i in 0 .. n {
  550|      0|        let input = unsafe { chunk_unchecked(input, enc, i) };
  551|      0|        let output = unsafe { chunk_mut_unchecked(output, dec, i) };
  552|      0|        encode_base(bit, msb, symbols, input, &mut output[.. olen]);
  553|      0|        output[olen ..].copy_from_slice(end);
  554|      0|    }
  555|      0|    if input.len() > enc * n {
  556|      0|        let olen = dec * n + encode_pad_len(bit, pad, input.len() - enc * n);
  557|      0|        encode_pad(bit, msb, symbols, pad, &input[enc * n ..], &mut output[dec * n .. olen]);
  558|      0|        output[olen ..].copy_from_slice(end);
  559|      0|    }
  560|    204|}
_RNvMs4_CsetwwlQTL1Fd_13data_encodingNtB5_8Encoding10encode_len:
 1266|    408|    pub fn encode_len(&self, len: usize) -> usize {
 1267|    408|        dispatch! {
 1268|    408|            let bit: usize = self.bit();
 1269|    408|            let pad: Option<u8> = self.pad();
 1270|    408|            let wrap: Option<(usize, &[u8])> = self.wrap();
 1271|    408|            encode_wrap_len(bit, pad, wrap, len)
 1272|       |        }
 1273|    408|    }
_RNvMs4_CsetwwlQTL1Fd_13data_encodingNtB5_8Encoding3pad:
 1230|    612|    fn pad(&self) -> Option<u8> {
 1231|    612|        if self.0[512] < 128 {
 1232|      0|            Some(self.0[512])
 1233|       |        } else {
 1234|    612|            None
 1235|       |        }
 1236|    612|    }
_RINvCsetwwlQTL1Fd_13data_encoding11encode_baseNtB2_2N5NtB2_2BtEB2_:
  485|    204|fn encode_base<B: Static<usize>, M: Static<bool>>(
  486|    204|    bit: B, msb: M, symbols: &[u8; 256], input: &[u8], output: &mut [u8],
  487|    204|) {
  488|    204|    debug_assert_eq!(output.len(), encode_base_len(bit, input.len()));
  489|    204|    encode_mut(bit, msb, symbols, input, output);
  490|    204|}

_RNvXs5_NtNtCs9gofsZWUQeH_6digest8core_api11ct_variableINtB5_21CtVariableCoreWrapperNtNtCsbCQy5qVcCrD_4sha28core_api13Sha256VarCoreINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIB25_IB25_IB25_IB25_IB25_NtB27_5UTermNtNtB29_3bit2B1ENtB3i_2B0EB3w_EB3w_EB3w_EB3w_ENtB1n_9OidSha256ENtNtCshM4Il2Z0i4R_4core7default7Default7defaultCsitTtQF8ArIt_8fvm_fuzz:
  139|    306|    fn default() -> Self {
  140|    306|        Self {
  141|    306|            inner: T::new(OutSize::USIZE).unwrap(),
  142|    306|            _out: PhantomData,
  143|    306|        }
  144|    306|    }
_RNvXs4_NtNtCs9gofsZWUQeH_6digest8core_api11ct_variableINtB5_21CtVariableCoreWrapperNtNtCsbCQy5qVcCrD_4sha28core_api13Sha256VarCoreINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIB25_IB25_IB25_IB25_IB25_NtB27_5UTermNtNtB29_3bit2B1ENtB3i_2B0EB3w_EB3w_EB3w_EB3w_ENtB1n_9OidSha256ENtB7_15FixedOutputCore19finalize_fixed_coreCsitTtQF8ArIt_8fvm_fuzz:
  114|    306|    fn finalize_fixed_core(
  115|    306|        &mut self,
  116|    306|        buffer: &mut Buffer<Self>,
  117|    306|        out: &mut GenericArray<u8, Self::OutputSize>,
  118|    306|    ) {
  119|    306|        let mut full_res = Default::default();
  120|    306|        self.inner.finalize_variable_core(buffer, &mut full_res);
  121|    306|        let n = out.len();
  122|    306|        let m = full_res.len() - n;
  123|    306|        match T::TRUNC_SIDE {
  124|    306|            TruncSide::Left => out.copy_from_slice(&full_res[..n]),
  125|      0|            TruncSide::Right => out.copy_from_slice(&full_res[m..]),
  126|       |        }
  127|    306|    }

_RNvXs8_NtNtCs9gofsZWUQeH_6digest8core_api7wrapperINtB5_11CoreWrapperINtNtB7_11ct_variable21CtVariableCoreWrapperNtNtCsbCQy5qVcCrD_4sha28core_api13Sha256VarCoreINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIB2y_IB2y_IB2y_IB2y_IB2y_NtB2A_5UTermNtNtB2C_3bit2B1ENtB3L_2B0EB3Z_EB3Z_EB3Z_EB3Z_ENtB1Q_9OidSha256EENtB9_11FixedOutput13finalize_intoCsitTtQF8ArIt_8fvm_fuzz:
  170|    306|    fn finalize_into(mut self, out: &mut Output<Self>) {
  171|    306|        let Self { core, buffer } = &mut self;
  172|    306|        core.finalize_fixed_core(buffer, out);
  173|    306|    }
_RNvXsg_NtNtCs9gofsZWUQeH_6digest8core_api7wrapperINtB5_11CoreWrapperINtNtB7_11ct_variable21CtVariableCoreWrapperNtNtCsbCQy5qVcCrD_4sha28core_api13Sha256VarCoreINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIB2y_IB2y_IB2y_IB2y_IB2y_NtB2A_5UTermNtNtB2C_3bit2B1ENtB3L_2B0EB3Z_EB3Z_EB3Z_EB3Z_ENtB1Q_9OidSha256EENtNtCshM4Il2Z0i4R_4core7default7Default7defaultCsitTtQF8ArIt_8fvm_fuzz:
   23|    306|#[derive(Clone, Default)]
_RNvXs6_NtNtCs9gofsZWUQeH_6digest8core_api7wrapperINtB5_11CoreWrapperINtNtB7_11ct_variable21CtVariableCoreWrapperNtNtCsbCQy5qVcCrD_4sha28core_api13Sha256VarCoreINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIB2y_IB2y_IB2y_IB2y_IB2y_NtB2A_5UTermNtNtB2C_3bit2B1ENtB3L_2B0EB3Z_EB3Z_EB3Z_EB3Z_ENtB1Q_9OidSha256EENtB9_6Update6updateCshRBVfIqfJKm_13fvm_ipld_hamt:
  148|    306|    fn update(&mut self, input: &[u8]) {
  149|    306|        let Self { core, buffer } = self;
  150|    306|        buffer.digest_blocks(input, |blocks| core.update_blocks(blocks));
  151|    306|    }

_RNvXNtCs9gofsZWUQeH_6digest6digestINtNtNtB4_8core_api7wrapper11CoreWrapperINtNtBB_11ct_variable21CtVariableCoreWrapperNtNtCsbCQy5qVcCrD_4sha28core_api13Sha256VarCoreINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIB2E_IB2E_IB2E_IB2E_IB2E_NtB2G_5UTermNtNtB2I_3bit2B1ENtB3R_2B0EB45_EB45_EB45_EB45_ENtB1W_9OidSha256EENtB2_6Digest8finalizeCsitTtQF8ArIt_8fvm_fuzz:
   85|    306|    fn finalize(self) -> Output<Self> {
   86|    306|        FixedOutput::finalize_fixed(self)
   87|    306|    }
_RINvXNtCs9gofsZWUQeH_6digest6digestINtNtNtB5_8core_api7wrapper11CoreWrapperINtNtBC_11ct_variable21CtVariableCoreWrapperNtNtCsbCQy5qVcCrD_4sha28core_api13Sha256VarCoreINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIB2F_IB2F_IB2F_IB2F_IB2F_NtB2H_5UTermNtNtB2J_3bit2B1ENtB3S_2B0EB46_EB46_EB46_EB46_ENtB1X_9OidSha256EENtB3_6Digest6updateRShECshRBVfIqfJKm_13fvm_ipld_hamt:
   74|    306|    fn update(&mut self, data: impl AsRef<[u8]>) {
   75|    306|        Update::update(self, data.as_ref());
   76|    306|    }

_RNvYINtNtNtCs9gofsZWUQeH_6digest8core_api7wrapper11CoreWrapperINtNtB7_11ct_variable21CtVariableCoreWrapperNtNtCsbCQy5qVcCrD_4sha28core_api13Sha256VarCoreINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIB2s_IB2s_IB2s_IB2s_IB2s_NtB2u_5UTermNtNtB2w_3bit2B1ENtB3F_2B0EB3T_EB3T_EB3T_EB3T_ENtB1K_9OidSha256EENtB9_11FixedOutput14finalize_fixedCsitTtQF8ArIt_8fvm_fuzz:
   99|    306|    fn finalize_fixed(self) -> Output<Self> {
  100|    306|        let mut out = Default::default();
  101|    306|        self.finalize_into(&mut out);
  102|    306|        out
  103|    306|    }

_RNCNvNtCs4DcB2eWstN0_10env_logger6filter10parse_specs0_0B5_:
  344|    510|                name: name.map(|s| s.to_string()),
_RNvXs0_NtCs4DcB2eWstN0_10env_logger6filterNtB5_7BuilderNtNtCshM4Il2Z0i4R_4core7default7Default7default:
  263|    102|    fn default() -> Self {
  264|    102|        Builder::new()
  265|    102|    }
_RNCNvMNtCs4DcB2eWstN0_10env_logger6filterNtB4_6Filter6filter0B6_:
  142|    510|            .map(|d| d.level)
_RNCNvMs_NtCs4DcB2eWstN0_10env_logger6filterNtB6_7Builder5build0B8_:
  244|    510|                .map(|(name, level)| Directive { name, level })
_RNvMs_NtCs4DcB2eWstN0_10env_logger6filterNtB4_7Builder5parse:
  216|    102|    pub fn parse(&mut self, filters: &str) -> &mut Self {
  217|    102|        let (directives, filter) = parse_spec(filters);
  218|    102|
  219|    102|        self.filter = filter;
  220|       |
  221|    612|        for directive in directives {
  222|    510|            self.directives.insert(directive.name, directive.level);
  223|    510|        }
  224|    102|        self
  225|    102|    }
_RNCNCNvMs_NtCs4DcB2eWstN0_10env_logger6filterNtB8_7Builder5builds_0s_0Ba_:
  250|    799|                let blen = b.name.as_ref().map(|b| b.len()).unwrap_or(0);
_RNCNvNtCs4DcB2eWstN0_10env_logger6filter10parse_specs_0B5_:
  313|    204|                match (parts.next(), parts.next().map(|s| s.trim()), parts.next()) {
_RNCNvNtCs4DcB2eWstN0_10env_logger6filter10parse_spec0B5_:
  307|    510|        for s in m.split(',').map(|ss| ss.trim()) {
_RNvMNtCs4DcB2eWstN0_10env_logger6filterNtB2_6Filter6filter:
  139|    102|    pub fn filter(&self) -> LevelFilter {
  140|    102|        self.directives
  141|    102|            .iter()
  142|    102|            .map(|d| d.level)
  143|    102|            .max()
  144|    102|            .unwrap_or(LevelFilter::Off)
  145|    102|    }
_RNvMs_NtCs4DcB2eWstN0_10env_logger6filterNtB4_7Builder5build:
  228|    102|    pub fn build(&mut self) -> Filter {
  229|    102|        assert!(!self.built, "attempt to re-use consumed builder");
  230|    102|        self.built = true;
  231|    102|
  232|    102|        let mut directives = Vec::new();
  233|    102|        if self.directives.is_empty() {
  234|      0|            // Adds the default filter if none exist
  235|      0|            directives.push(Directive {
  236|      0|                name: None,
  237|      0|                level: LevelFilter::Error,
  238|      0|            });
  239|    102|        } else {
  240|    102|            // Consume map of directives.
  241|    102|            let directives_map = mem::take(&mut self.directives);
  242|    102|            directives = directives_map
  243|    102|                .into_iter()
  244|    102|                .map(|(name, level)| Directive { name, level })
  245|    102|                .collect();
  246|    102|            // Sort the directives by length of their name, this allows a
  247|    102|            // little more efficient lookup at runtime.
  248|    102|            directives.sort_by(|a, b| {
  249|       |                let alen = a.name.as_ref().map(|a| a.len()).unwrap_or(0);
  250|       |                let blen = b.name.as_ref().map(|b| b.len()).unwrap_or(0);
  251|       |                alen.cmp(&blen)
  252|    102|            });
  253|    102|        }
  254|       |
  255|    102|        Filter {
  256|    102|            directives: mem::take(&mut directives),
  257|    102|            filter: mem::replace(&mut self.filter, None),
  258|    102|        }
  259|    102|    }
_RNvMNtCs4DcB2eWstN0_10env_logger6filterNtB2_6Filter7enabled:
  163|  66.5k|    pub fn enabled(&self, metadata: &Metadata) -> bool {
  164|  66.5k|        let level = metadata.level();
  165|  66.5k|        let target = metadata.target();
  166|  66.5k|
  167|  66.5k|        enabled(&self.directives, level, target)
  168|  66.5k|    }
_RNvNtCs4DcB2eWstN0_10env_logger6filter10parse_spec:
  292|    102|fn parse_spec(spec: &str) -> (Vec<Directive>, Option<inner::Filter>) {
  293|    102|    let mut dirs = Vec::new();
  294|    102|
  295|    102|    let mut parts = spec.split('/');
  296|    102|    let mods = parts.next();
  297|    102|    let filter = parts.next();
  298|    102|    if parts.next().is_some() {
  299|      0|        eprintln!(
  300|      0|            "warning: invalid logging spec '{}', \
  301|      0|             ignoring it (too many '/'s)",
  302|      0|            spec
  303|      0|        );
  304|      0|        return (dirs, None);
  305|    102|    }
  306|    102|    if let Some(m) = mods {
  307|    510|        for s in m.split(',').map(|ss| ss.trim()) {
  308|    510|            if s.is_empty() {
  309|      0|                continue;
  310|    510|            }
  311|    510|            let mut parts = s.split('=');
  312|    510|            let (log_level, name) =
  313|    510|                match (parts.next(), parts.next().map(|s| s.trim()), parts.next()) {
  314|    306|                    (Some(part0), None, None) => {
  315|    306|                        // if the single argument is a log-level string or number,
  316|    306|                        // treat that as a global fallback
  317|    306|                        match part0.parse() {
  318|      0|                            Ok(num) => (num, None),
  319|    306|                            Err(_) => (LevelFilter::max(), Some(part0)),
  320|       |                        }
  321|       |                    }
  322|    204|                    (Some(part0), Some(""), None) => (LevelFilter::max(), Some(part0)),
  323|    204|                    (Some(part0), Some(part1), None) => match part1.parse() {
  324|    204|                        Ok(num) => (num, Some(part0)),
  325|       |                        _ => {
  326|      0|                            eprintln!(
  327|      0|                                "warning: invalid logging spec '{}', \
  328|      0|                                 ignoring it",
  329|      0|                                part1
  330|      0|                            );
  331|      0|                            continue;
  332|       |                        }
  333|       |                    },
  334|       |                    _ => {
  335|      0|                        eprintln!(
  336|      0|                            "warning: invalid logging spec '{}', \
  337|      0|                             ignoring it",
  338|      0|                            s
  339|      0|                        );
  340|      0|                        continue;
  341|       |                    }
  342|       |                };
  343|    510|            dirs.push(Directive {
  344|    510|                name: name.map(|s| s.to_string()),
  345|    510|                level: log_level,
  346|    510|            });
  347|       |        }
  348|      0|    }
  349|       |
  350|    102|    let filter = filter.and_then(|filter| match inner::Filter::new(filter) {
  351|       |        Ok(re) => Some(re),
  352|       |        Err(e) => {
  353|       |            eprintln!("warning: invalid regex filter - {}", e);
  354|       |            None
  355|       |        }
  356|    102|    });
  357|    102|
  358|    102|    (dirs, filter)
  359|    102|}
_RNvMNtCs4DcB2eWstN0_10env_logger6filterNtB2_6Filter7matches:
  148|  66.5k|    pub fn matches(&self, record: &Record) -> bool {
  149|  66.5k|        if !self.enabled(record.metadata()) {
  150|      0|            return false;
  151|  66.5k|        }
  152|       |
  153|  66.5k|        if let Some(filter) = self.filter.as_ref() {
  154|      0|            if !filter.is_match(&record.args().to_string()) {
  155|      0|                return false;
  156|      0|            }
  157|  66.5k|        }
  158|       |
  159|  66.5k|        true
  160|  66.5k|    }
_RNCNCNvMs_NtCs4DcB2eWstN0_10env_logger6filterNtB8_7Builder5builds_00Ba_:
  249|    799|                let alen = a.name.as_ref().map(|a| a.len()).unwrap_or(0);
_RNvMs_NtCs4DcB2eWstN0_10env_logger6filterNtB4_7Builder3new:
  173|    102|    pub fn new() -> Builder {
  174|    102|        Builder {
  175|    102|            directives: HashMap::new(),
  176|    102|            filter: None,
  177|    102|            built: false,
  178|    102|        }
  179|    102|    }
_RNvNtCs4DcB2eWstN0_10env_logger6filter7enabled:
  362|  66.5k|fn enabled(directives: &[Directive], level: Level, target: &str) -> bool {
  363|       |    // Search for the longest match, the vector is assumed to be pre-sorted.
  364|   200k|    for directive in directives.iter().rev() {
  365|   200k|        match directive.name {
  366|   200k|            Some(ref name) if !target.starts_with(&**name) => {}
  367|  66.5k|            Some(..) | None => return level <= directive.level,
  368|       |        }
  369|       |    }
  370|      0|    false
  371|  66.5k|}
_RNCNvMs_NtCs4DcB2eWstN0_10env_logger6filterNtB6_7Builder5builds_0B8_:
  248|    799|            directives.sort_by(|a, b| {
  249|    799|                let alen = a.name.as_ref().map(|a| a.len()).unwrap_or(0);
  250|    799|                let blen = b.name.as_ref().map(|b| b.len()).unwrap_or(0);
  251|    799|                alen.cmp(&blen)
  252|    799|            });

_RNvXs0_NtNtNtCs4DcB2eWstN0_10env_logger3fmt9humantime3impNtB5_9TimestampNtNtCshM4Il2Z0i4R_4core3fmt7Display3fmt:
  108|  66.5k|    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
  109|  66.5k|        let formatter = match self.precision {
  110|  66.5k|            TimestampPrecision::Seconds => format_rfc3339_seconds,
  111|      0|            TimestampPrecision::Millis => format_rfc3339_millis,
  112|      0|            TimestampPrecision::Micros => format_rfc3339_micros,
  113|      0|            TimestampPrecision::Nanos => format_rfc3339_nanos,
  114|       |        };
  115|       |
  116|  66.5k|        formatter(self.time).fmt(f)
  117|  66.5k|    }
_RNvMNtNtNtCs4DcB2eWstN0_10env_logger3fmt9humantime3impNtB6_9Formatter17timestamp_seconds:
   43|  66.5k|    pub fn timestamp_seconds(&self) -> Timestamp {
   44|  66.5k|        Timestamp {
   45|  66.5k|            time: SystemTime::now(),
   46|  66.5k|            precision: TimestampPrecision::Seconds,
   47|  66.5k|        }
   48|  66.5k|    }

_RNvMs4_NtCs4DcB2eWstN0_10env_logger3fmtNtB5_13DefaultFormat5write:
  226|  66.5k|        self.write_timestamp()?;
  227|  66.5k|        self.write_level(record)?;
  228|  66.5k|        self.write_module_path(record)?;
  229|  66.5k|        self.write_target(record)?;
  230|  66.5k|        self.finish_header()?;
  231|       |
  232|  66.5k|        self.write_args(record)
  233|  66.5k|    }
_RNCNvMs3_NtCs4DcB2eWstN0_10env_logger3fmtNtB7_7Builder5build0B9_:
  187|  66.5k|            Box::new(move |buf, record| {
  188|  66.5k|                let fmt = DefaultFormat {
  189|  66.5k|                    timestamp: built.format_timestamp,
  190|  66.5k|                    module_path: built.format_module_path,
  191|  66.5k|                    target: built.format_target,
  192|  66.5k|                    level: built.format_level,
  193|  66.5k|                    written_header_value: false,
  194|  66.5k|                    indent: built.format_indent,
  195|  66.5k|                    suffix: built.format_suffix,
  196|  66.5k|                    buf,
  197|  66.5k|                };
  198|  66.5k|
  199|  66.5k|                fmt.write(record)
  200|  66.5k|            })
_RNvXNvMs4_NtCs4DcB2eWstN0_10env_logger3fmtNtB8_13DefaultFormat10write_argsNtB2_13IndentWrapperNtNtCsxnqwkJeFav_3std2io5Write5write:
  353|   431k|                    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
  354|   431k|                        let mut first = true;
  355|   463k|                        for chunk in buf.split(|&x| x == b'\n') {
  356|   463k|                            if !first {
  357|  32.1k|                                write!(
  358|  32.1k|                                    self.fmt.buf,
  359|  32.1k|                                    "{}{:width$}",
  360|  32.1k|                                    self.fmt.suffix,
  361|  32.1k|                                    "",
  362|  32.1k|                                    width = self.indent_count
  363|  32.1k|                                )?;
  364|   431k|                            }
  365|   463k|                            self.fmt.buf.write_all(chunk)?;
  366|   463k|                            first = false;
  367|       |                        }
  368|       |
  369|   431k|                        Ok(buf.len())
  370|   431k|                    }
_RNvMs4_NtCs4DcB2eWstN0_10env_logger3fmtNtB5_13DefaultFormat15write_timestamp:
  284|  66.5k|    fn write_timestamp(&mut self) -> io::Result<()> {
  285|       |        #[cfg(feature = "humantime")]
  286|       |        {
  287|       |            use self::TimestampPrecision::*;
  288|  66.5k|            let ts = match self.timestamp {
  289|      0|                None => return Ok(()),
  290|  66.5k|                Some(Seconds) => self.buf.timestamp_seconds(),
  291|      0|                Some(Millis) => self.buf.timestamp_millis(),
  292|      0|                Some(Micros) => self.buf.timestamp_micros(),
  293|      0|                Some(Nanos) => self.buf.timestamp_nanos(),
  294|       |            };
  295|       |
  296|  66.5k|            self.write_header_value(ts)
  297|       |        }
  298|       |        #[cfg(not(feature = "humantime"))]
  299|       |        {
  300|       |            // Trick the compiler to think we have used self.timestamp
  301|       |            // Workaround for "field is never used: `timestamp`" compiler nag.
  302|       |            let _ = self.timestamp;
  303|       |            Ok(())
  304|       |        }
  305|  66.5k|    }
_RNvMs4_NtCs4DcB2eWstN0_10env_logger3fmtNtB5_13DefaultFormat13finish_header:
  330|  66.5k|    fn finish_header(&mut self) -> io::Result<()> {
  331|  66.5k|        if self.written_header_value {
  332|  66.5k|            let close_brace = self.subtle_style("]");
  333|  66.5k|            write!(self.buf, "{} ", close_brace)
  334|       |        } else {
  335|      0|            Ok(())
  336|       |        }
  337|  66.5k|    }
_RNvMs4_NtCs4DcB2eWstN0_10env_logger3fmtNtB5_13DefaultFormat11write_level:
  265|  66.5k|    fn write_level(&mut self, record: &Record) -> io::Result<()> {
  266|  66.5k|        if !self.level {
  267|      0|            return Ok(());
  268|  66.5k|        }
  269|  66.5k|
  270|  66.5k|        let level = {
  271|  66.5k|            #[cfg(feature = "termcolor")]
  272|  66.5k|            {
  273|  66.5k|                self.buf.default_styled_level(record.level())
  274|  66.5k|            }
  275|  66.5k|            #[cfg(not(feature = "termcolor"))]
  276|  66.5k|            {
  277|  66.5k|                record.level()
  278|  66.5k|            }
  279|  66.5k|        };
  280|  66.5k|
  281|  66.5k|        self.write_header_value(format_args!("{:<5}", level))
  282|  66.5k|    }
_RNvXs0_NtCs4DcB2eWstN0_10env_logger3fmtNtB5_9FormatterNtNtCsxnqwkJeFav_3std2io5Write5write:
  124|  1.25M|    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
  125|  1.25M|        self.buf.borrow_mut().write(buf)
  126|  1.25M|    }
_RNvMs4_NtCs4DcB2eWstN0_10env_logger3fmtNtB5_13DefaultFormat17write_module_path:
  307|  66.5k|    fn write_module_path(&mut self, record: &Record) -> io::Result<()> {
  308|  66.5k|        if !self.module_path {
  309|  66.5k|            return Ok(());
  310|      0|        }
  311|       |
  312|      0|        if let Some(module_path) = record.module_path() {
  313|      0|            self.write_header_value(module_path)
  314|       |        } else {
  315|      0|            Ok(())
  316|       |        }
  317|  66.5k|    }
_RNvXs2_NtCs4DcB2eWstN0_10env_logger3fmtNtB5_7BuilderNtNtCshM4Il2Z0i4R_4core7default7Default7default:
  153|    204|    fn default() -> Self {
  154|    204|        Builder {
  155|    204|            format_timestamp: Some(Default::default()),
  156|    204|            format_module_path: false,
  157|    204|            format_target: true,
  158|    204|            format_level: true,
  159|    204|            format_indent: Some(4),
  160|    204|            custom_format: None,
  161|    204|            format_suffix: "\n",
  162|    204|            built: false,
  163|    204|        }
  164|    204|    }
_RNvMs4_NtCs4DcB2eWstN0_10env_logger3fmtNtB5_13DefaultFormat12subtle_style:
  235|   133k|    fn subtle_style(&self, text: &'static str) -> SubtleStyle {
  236|   133k|        #[cfg(feature = "termcolor")]
  237|   133k|        {
  238|   133k|            self.buf
  239|   133k|                .style()
  240|   133k|                .set_color(Color::Black)
  241|   133k|                .set_intense(true)
  242|   133k|                .clone()
  243|   133k|                .into_value(text)
  244|   133k|        }
  245|   133k|        #[cfg(not(feature = "termcolor"))]
  246|   133k|        {
  247|   133k|            text
  248|   133k|        }
  249|   133k|    }
_RNvXNtCs4DcB2eWstN0_10env_logger3fmtNtB2_18TimestampPrecisionNtNtCshM4Il2Z0i4R_4core7default7Default7default:
   71|    204|    fn default() -> Self {
   72|    204|        TimestampPrecision::Seconds
   73|    204|    }
_RNCNvXNvMs4_NtCs4DcB2eWstN0_10env_logger3fmtNtBa_13DefaultFormat10write_argsNtB4_13IndentWrapperNtNtCsxnqwkJeFav_3std2io5Write5write0Bc_:
  355|  7.33M|                        for chunk in buf.split(|&x| x == b'\n') {
_RINvMs4_NtCs4DcB2eWstN0_10env_logger3fmtNtB6_13DefaultFormat18write_header_valueNtNtCshM4Il2Z0i4R_4core3fmt9ArgumentsEB8_:
  251|  66.5k|    fn write_header_value<T>(&mut self, value: T) -> io::Result<()>
  252|  66.5k|    where
  253|  66.5k|        T: Display,
  254|  66.5k|    {
  255|  66.5k|        if !self.written_header_value {
  256|      0|            self.written_header_value = true;
  257|      0|
  258|      0|            let open_brace = self.subtle_style("[");
  259|      0|            write!(self.buf, "{}{}", open_brace, value)
  260|       |        } else {
  261|  66.5k|            write!(self.buf, " {}", value)
  262|       |        }
  263|  66.5k|    }
_RNvMs_NtCs4DcB2eWstN0_10env_logger3fmtNtB4_9Formatter5print:
  114|  66.5k|    pub(crate) fn print(&self, writer: &Writer) -> io::Result<()> {
  115|  66.5k|        writer.print(&self.buf.borrow())
  116|  66.5k|    }
_RNvMs4_NtCs4DcB2eWstN0_10env_logger3fmtNtB5_13DefaultFormat10write_args:
  339|  66.5k|    fn write_args(&mut self, record: &Record) -> io::Result<()> {
  340|  66.5k|        match self.indent {
  341|       |            // Fast path for no indentation
  342|      0|            None => write!(self.buf, "{}{}", record.args(), self.suffix),
  343|       |
  344|  66.5k|            Some(indent_count) => {
  345|  66.5k|                // Create a wrapper around the buffer only if we have to actually indent the message
  346|  66.5k|
  347|  66.5k|                struct IndentWrapper<'a, 'b: 'a> {
  348|  66.5k|                    fmt: &'a mut DefaultFormat<'b>,
  349|  66.5k|                    indent_count: usize,
  350|  66.5k|                }
  351|  66.5k|
  352|  66.5k|                impl<'a, 'b> Write for IndentWrapper<'a, 'b> {
  353|  66.5k|                    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
  354|  66.5k|                        let mut first = true;
  355|  66.5k|                        for chunk in buf.split(|&x| x == b'\n') {
  356|  66.5k|                            if !first {
  357|  66.5k|                                write!(
  358|  66.5k|                                    self.fmt.buf,
  359|  66.5k|                                    "{}{:width$}",
  360|  66.5k|                                    self.fmt.suffix,
  361|  66.5k|                                    "",
  362|  66.5k|                                    width = self.indent_count
  363|  66.5k|                                )?;
  364|  66.5k|                            }
  365|  66.5k|                            self.fmt.buf.write_all(chunk)?;
  366|  66.5k|                            first = false;
  367|  66.5k|                        }
  368|  66.5k|
  369|  66.5k|                        Ok(buf.len())
  370|  66.5k|                    }
  371|  66.5k|
  372|  66.5k|                    fn flush(&mut self) -> io::Result<()> {
  373|  66.5k|                        self.fmt.buf.flush()
  374|  66.5k|                    }
  375|  66.5k|                }
  376|  66.5k|
  377|  66.5k|                // The explicit scope here is just to make older versions of Rust happy
  378|  66.5k|                {
  379|  66.5k|                    let mut wrapper = IndentWrapper {
  380|  66.5k|                        fmt: self,
  381|  66.5k|                        indent_count,
  382|  66.5k|                    };
  383|  66.5k|                    write!(wrapper, "{}", record.args())?;
  384|       |                }
  385|       |
  386|  66.5k|                write!(self.buf, "{}", self.suffix)?;
  387|       |
  388|  66.5k|                Ok(())
  389|       |            }
  390|       |        }
  391|  66.5k|    }
_RNvMs_NtCs4DcB2eWstN0_10env_logger3fmtNtB4_9Formatter3new:
  103|      1|    pub(crate) fn new(writer: &Writer) -> Self {
  104|      1|        Formatter {
  105|      1|            buf: Rc::new(RefCell::new(writer.buffer())),
  106|      1|            write_style: writer.write_style(),
  107|      1|        }
  108|      1|    }
_RNvMs4_NtCs4DcB2eWstN0_10env_logger3fmtNtB5_13DefaultFormat12write_target:
  319|  66.5k|    fn write_target(&mut self, record: &Record) -> io::Result<()> {
  320|  66.5k|        if !self.target {
  321|      0|            return Ok(());
  322|  66.5k|        }
  323|  66.5k|
  324|  66.5k|        match record.target() {
  325|  66.5k|            "" => Ok(()),
  326|  66.5k|            target => self.write_header_value(target),
  327|       |        }
  328|  66.5k|    }
_RNvMs3_NtCs4DcB2eWstN0_10env_logger3fmtNtB5_7Builder5build:
  173|    102|    pub fn build(&mut self) -> FormatFn {
  174|    102|        assert!(!self.built, "attempt to re-use consumed builder");
  175|       |
  176|    102|        let built = mem::replace(
  177|    102|            self,
  178|    102|            Builder {
  179|    102|                built: true,
  180|    102|                ..Default::default()
  181|    102|            },
  182|    102|        );
  183|       |
  184|    102|        if let Some(fmt) = built.custom_format {
  185|      0|            fmt
  186|       |        } else {
  187|    102|            Box::new(move |buf, record| {
  188|       |                let fmt = DefaultFormat {
  189|       |                    timestamp: built.format_timestamp,
  190|       |                    module_path: built.format_module_path,
  191|       |                    target: built.format_target,
  192|       |                    level: built.format_level,
  193|       |                    written_header_value: false,
  194|       |                    indent: built.format_indent,
  195|       |                    suffix: built.format_suffix,
  196|       |                    buf,
  197|       |                };
  198|       |
  199|       |                fmt.write(record)
  200|    102|            })
  201|       |        }
  202|    102|    }
_RNvMs_NtCs4DcB2eWstN0_10env_logger3fmtNtB4_9Formatter11write_style:
  110|  66.5k|    pub(crate) fn write_style(&self) -> WriteStyle {
  111|  66.5k|        self.write_style
  112|  66.5k|    }
_RINvMs4_NtCs4DcB2eWstN0_10env_logger3fmtNtB6_13DefaultFormat18write_header_valueNtNtNtB6_9humantime3imp9TimestampEB8_:
  251|  66.5k|    fn write_header_value<T>(&mut self, value: T) -> io::Result<()>
  252|  66.5k|    where
  253|  66.5k|        T: Display,
  254|  66.5k|    {
  255|  66.5k|        if !self.written_header_value {
  256|  66.5k|            self.written_header_value = true;
  257|  66.5k|
  258|  66.5k|            let open_brace = self.subtle_style("[");
  259|  66.5k|            write!(self.buf, "{}{}", open_brace, value)
  260|       |        } else {
  261|      0|            write!(self.buf, " {}", value)
  262|       |        }
  263|  66.5k|    }
_RINvMs4_NtCs4DcB2eWstN0_10env_logger3fmtNtB6_13DefaultFormat18write_header_valueReEB8_:
  251|  66.5k|    fn write_header_value<T>(&mut self, value: T) -> io::Result<()>
  252|  66.5k|    where
  253|  66.5k|        T: Display,
  254|  66.5k|    {
  255|  66.5k|        if !self.written_header_value {
  256|      0|            self.written_header_value = true;
  257|      0|
  258|      0|            let open_brace = self.subtle_style("[");
  259|      0|            write!(self.buf, "{}{}", open_brace, value)
  260|       |        } else {
  261|  66.5k|            write!(self.buf, " {}", value)
  262|       |        }
  263|  66.5k|    }
_RNvMs_NtCs4DcB2eWstN0_10env_logger3fmtNtB4_9Formatter5clear:
  118|  66.5k|    pub(crate) fn clear(&mut self) {
  119|  66.5k|        self.buf.borrow_mut().clear()
  120|  66.5k|    }

_RNvNtNtNtNtCs4DcB2eWstN0_10env_logger3fmt6writer4atty3imp9is_stderr:
   16|    102|    pub(in crate::fmt) fn is_stderr() -> bool {
   17|    102|        atty::is(atty::Stream::Stderr)
   18|    102|    }

_RNvMs5_NtNtCs4DcB2eWstN0_10env_logger3fmt6writerNtB5_7Builder5build:
  174|    102|    pub(crate) fn build(&mut self) -> Writer {
  175|    102|        assert!(!self.built, "attempt to re-use consumed builder");
  176|    102|        self.built = true;
  177|       |
  178|    102|        let color_choice = match self.write_style {
  179|       |            WriteStyle::Auto => {
  180|    102|                if match &self.target {
  181|    102|                    WritableTarget::Stderr => is_stderr(),
  182|      0|                    WritableTarget::Stdout => is_stdout(),
  183|      0|                    WritableTarget::Pipe(_) => false,
  184|       |                } {
  185|      0|                    WriteStyle::Auto
  186|       |                } else {
  187|    102|                    WriteStyle::Never
  188|       |                }
  189|       |            }
  190|      0|            color_choice => color_choice,
  191|       |        };
  192|       |
  193|    102|        let writer = match mem::take(&mut self.target) {
  194|    102|            WritableTarget::Stderr => BufferWriter::stderr(self.is_test, color_choice),
  195|      0|            WritableTarget::Stdout => BufferWriter::stdout(self.is_test, color_choice),
  196|      0|            WritableTarget::Pipe(pipe) => BufferWriter::pipe(color_choice, pipe),
  197|       |        };
  198|       |
  199|    102|        Writer {
  200|    102|            inner: writer,
  201|    102|            write_style: self.write_style,
  202|    102|        }
  203|    102|    }
_RNvMs4_NtNtCs4DcB2eWstN0_10env_logger3fmt6writerNtB5_6Writer11write_style:
  111|  66.5k|    pub fn write_style(&self) -> WriteStyle {
  112|  66.5k|        self.write_style
  113|  66.5k|    }
_RNvXs3_NtNtCs4DcB2eWstN0_10env_logger3fmt6writerNtB5_10WriteStyleNtNtCshM4Il2Z0i4R_4core7default7Default7default:
   99|    102|    fn default() -> Self {
  100|    102|        WriteStyle::Auto
  101|    102|    }
_RNvMs4_NtNtCs4DcB2eWstN0_10env_logger3fmt6writerNtB5_6Writer5print:
  119|  66.5k|    pub(super) fn print(&self, buf: &Buffer) -> io::Result<()> {
  120|  66.5k|        self.inner.print(buf)
  121|  66.5k|    }
_RNvMs5_NtNtCs4DcB2eWstN0_10env_logger3fmt6writerNtB5_7Builder3new:
  137|    102|    pub(crate) fn new() -> Self {
  138|    102|        Builder {
  139|    102|            target: Default::default(),
  140|    102|            write_style: Default::default(),
  141|    102|            is_test: false,
  142|    102|            built: false,
  143|    102|        }
  144|    102|    }
_RNvXsf_NtNtCs4DcB2eWstN0_10env_logger3fmt6writerNtB5_10WriteStyleNtNtCshM4Il2Z0i4R_4core3cmp9PartialEq2eq:
   88|  66.5k|#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
_RNvXs6_NtNtCs4DcB2eWstN0_10env_logger3fmt6writerNtB5_7BuilderNtNtCshM4Il2Z0i4R_4core7default7Default7default:
  207|    102|    fn default() -> Self {
  208|    102|        Builder::new()
  209|    102|    }
_RNvMs4_NtNtCs4DcB2eWstN0_10env_logger3fmt6writerNtB5_6Writer6buffer:
  115|      1|    pub(super) fn buffer(&self) -> Buffer {
  116|      1|        self.inner.buffer()
  117|      1|    }
_RNvXs0_NtNtCs4DcB2eWstN0_10env_logger3fmt6writerNtB5_14WritableTargetINtNtCshM4Il2Z0i4R_4core7convert4FromNtB5_6TargetE4from:
   59|    204|    fn from(target: Target) -> Self {
   60|    204|        match target {
   61|      0|            Target::Stdout => Self::Stdout,
   62|    204|            Target::Stderr => Self::Stderr,
   63|      0|            Target::Pipe(pipe) => Self::Pipe(Box::new(Mutex::new(pipe))),
   64|       |        }
   65|    204|    }
_RNvXs1_NtNtCs4DcB2eWstN0_10env_logger3fmt6writerNtB5_14WritableTargetNtNtCshM4Il2Z0i4R_4core7default7Default7default:
   69|    204|    fn default() -> Self {
   70|    204|        Self::from(Target::default())
   71|    204|    }
_RNvXNtNtCs4DcB2eWstN0_10env_logger3fmt6writerNtB2_6TargetNtNtCshM4Il2Z0i4R_4core7default7Default7default:
   27|    204|    fn default() -> Self {
   28|    204|        Target::Stderr
   29|    204|    }

_RINvMs2_NtNtNtNtCs4DcB2eWstN0_10env_logger3fmt6writer9termcolor3impNtB6_5Style10into_valueReEBe_:
  421|   133k|    pub(crate) fn into_value<T>(self, value: T) -> StyledValue<'static, T> {
  422|   133k|        StyledValue {
  423|   133k|            style: Cow::Owned(self),
  424|   133k|            value,
  425|   133k|        }
  426|   133k|    }
_RINvMs2_NtNtNtNtCs4DcB2eWstN0_10env_logger3fmt6writer9termcolor3impNtB6_5Style10into_valueNtCs6vrtZ9rvsjP_3log5LevelEBe_:
  421|  66.5k|    pub(crate) fn into_value<T>(self, value: T) -> StyledValue<'static, T> {
  422|  66.5k|        StyledValue {
  423|  66.5k|            style: Cow::Owned(self),
  424|  66.5k|            value,
  425|  66.5k|        }
  426|  66.5k|    }
_RNvXs8_NtNtNtNtCs4DcB2eWstN0_10env_logger3fmt6writer9termcolor3impINtB5_11StyledValueNtCs6vrtZ9rvsjP_3log5LevelENtNtCshM4Il2Z0i4R_4core3fmt7Display3fmtBd_:
  458|  66.5k|                fn fmt(&self, f: &mut fmt::Formatter)->fmt::Result {
  459|  66.5k|                    self.write_fmt(|| T::fmt(&self.value, f))
  460|  66.5k|                }
_RINvMs3_NtNtNtNtCs4DcB2eWstN0_10env_logger3fmt6writer9termcolor3impINtB6_11StyledValueReE9write_fmtNCNvXs8_B6_B13_NtNtCshM4Il2Z0i4R_4core3fmt7Display3fmt0EBe_:
  434|   133k|        self.style
  435|   133k|            .buf
  436|   133k|            .borrow_mut()
  437|   133k|            .set_color(&self.style.spec)
  438|   133k|            .map_err(|_| fmt::Error)?;
  439|       |
  440|       |        // Always try to reset the terminal style, even if writing failed
  441|   133k|        let write = f();
  442|   133k|        let reset = self.style.buf.borrow_mut().reset().map_err(|_| fmt::Error);
  443|   133k|
  444|   133k|        write.and(reset)
  445|   133k|    }
_RNvMs_NtNtNtNtCs4DcB2eWstN0_10env_logger3fmt6writer9termcolor3impNtB4_12BufferWriter6buffer:
  116|      1|    pub(in crate::fmt::writer) fn buffer(&self) -> Buffer {
  117|      1|        Buffer {
  118|      1|            inner: self.inner.buffer(),
  119|      1|            has_uncolored_target: self.uncolored_target.is_some(),
  120|      1|        }
  121|      1|    }
_RNvMs2_NtNtNtNtCs4DcB2eWstN0_10env_logger3fmt6writer9termcolor3impNtB5_5Style9set_color:
  278|   199k|    pub fn set_color(&mut self, color: Color) -> &mut Style {
  279|   199k|        self.spec.set_fg(Some(color.into_termcolor()));
  280|   199k|        self
  281|   199k|    }
_RNvMs0_NtNtNtNtCs4DcB2eWstN0_10env_logger3fmt6writer9termcolor3impNtB5_6Buffer5reset:
  169|   199k|    fn reset(&mut self) -> io::Result<()> {
  170|   199k|        // Ignore styles for test captured logs because they can't be printed
  171|   199k|        if !self.has_uncolored_target {
  172|   199k|            self.inner.reset()
  173|       |        } else {
  174|      0|            Ok(())
  175|       |        }
  176|   199k|    }
_RNvMs0_NtNtNtNtCs4DcB2eWstN0_10env_logger3fmt6writer9termcolor3impNtB5_6Buffer5write:
  148|  1.25M|    pub(in crate::fmt) fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
  149|  1.25M|        self.inner.write(buf)
  150|  1.25M|    }
_RNvMNtNtNtNtCs4DcB2eWstN0_10env_logger3fmt6writer9termcolor3impNtB8_9Formatter5style:
   42|   199k|    pub fn style(&self) -> Style {
   43|   199k|        Style {
   44|   199k|            buf: self.buf.clone(),
   45|   199k|            spec: ColorSpec::new(),
   46|   199k|        }
   47|   199k|    }
_RNvMs0_NtNtNtNtCs4DcB2eWstN0_10env_logger3fmt6writer9termcolor3impNtB5_6Buffer9set_color:
  160|   199k|    fn set_color(&mut self, spec: &ColorSpec) -> io::Result<()> {
  161|   199k|        // Ignore styles for test captured logs because they can't be printed
  162|   199k|        if !self.has_uncolored_target {
  163|   199k|            self.inner.set_color(spec)
  164|       |        } else {
  165|      0|            Ok(())
  166|       |        }
  167|   199k|    }
_RNvXs8_NtNtNtNtCs4DcB2eWstN0_10env_logger3fmt6writer9termcolor3impINtB5_11StyledValueReENtNtCshM4Il2Z0i4R_4core3fmt7Display3fmtBd_:
  458|   133k|                fn fmt(&self, f: &mut fmt::Formatter)->fmt::Result {
  459|   133k|                    self.write_fmt(|| T::fmt(&self.value, f))
  460|   133k|                }
_RNCNvXs8_NtNtNtNtCs4DcB2eWstN0_10env_logger3fmt6writer9termcolor3impINtB7_11StyledValueNtCs6vrtZ9rvsjP_3log5LevelENtNtCshM4Il2Z0i4R_4core3fmt7Display3fmt0Bf_:
  466|  66.5k|impl_styled_value_fmt!(
  467|  66.5k|    fmt::Debug,
  468|  66.5k|    fmt::Display,
  469|  66.5k|    fmt::Pointer,
  470|  66.5k|    fmt::Octal,
  471|  66.5k|    fmt::Binary,
  472|  66.5k|    fmt::UpperHex,
  473|  66.5k|    fmt::LowerHex,
  474|  66.5k|    fmt::UpperExp,
  475|  66.5k|    fmt::LowerExp
  476|  66.5k|);
_RINvMs3_NtNtNtNtCs4DcB2eWstN0_10env_logger3fmt6writer9termcolor3impINtB6_11StyledValueNtCs6vrtZ9rvsjP_3log5LevelE9write_fmtNCNvXs8_B6_B13_NtNtCshM4Il2Z0i4R_4core3fmt7Display3fmt0EBe_:
  434|  66.5k|        self.style
  435|  66.5k|            .buf
  436|  66.5k|            .borrow_mut()
  437|  66.5k|            .set_color(&self.style.spec)
  438|  66.5k|            .map_err(|_| fmt::Error)?;
  439|       |
  440|       |        // Always try to reset the terminal style, even if writing failed
  441|  66.5k|        let write = f();
  442|  66.5k|        let reset = self.style.buf.borrow_mut().reset().map_err(|_| fmt::Error);
  443|  66.5k|
  444|  66.5k|        write.and(reset)
  445|  66.5k|    }
_RNvMs1_NtNtNtNtCs4DcB2eWstN0_10env_logger3fmt6writer9termcolor3impNtB9_10WriteStyle17into_color_choice:
  180|    102|    fn into_color_choice(self) -> ColorChoice {
  181|    102|        match self {
  182|      0|            WriteStyle::Always => ColorChoice::Always,
  183|      0|            WriteStyle::Auto => ColorChoice::Auto,
  184|    102|            WriteStyle::Never => ColorChoice::Never,
  185|       |        }
  186|    102|    }
_RNvMs5_NtNtNtNtCs4DcB2eWstN0_10env_logger3fmt6writer9termcolor3impNtB5_5Color14into_termcolor:
  518|   199k|    fn into_termcolor(self) -> termcolor::Color {
  519|   199k|        match self {
  520|   133k|            Color::Black => termcolor::Color::Black,
  521|  33.3k|            Color::Blue => termcolor::Color::Blue,
  522|      0|            Color::Green => termcolor::Color::Green,
  523|      0|            Color::Red => termcolor::Color::Red,
  524|    111|            Color::Cyan => termcolor::Color::Cyan,
  525|      0|            Color::Magenta => termcolor::Color::Magenta,
  526|  33.1k|            Color::Yellow => termcolor::Color::Yellow,
  527|      0|            Color::White => termcolor::Color::White,
  528|      0|            Color::Ansi256(value) => termcolor::Color::Ansi256(value),
  529|      0|            Color::Rgb(r, g, b) => termcolor::Color::Rgb(r, g, b),
  530|       |        }
  531|   199k|    }
_RNvMNtNtNtNtCs4DcB2eWstN0_10env_logger3fmt6writer9termcolor3impNtB8_9Formatter20default_styled_level:
   67|  66.5k|    pub fn default_styled_level(&self, level: Level) -> StyledValue<'static, Level> {
   68|  66.5k|        self.default_level_style(level).into_value(level)
   69|  66.5k|    }
_RNCNvXs8_NtNtNtNtCs4DcB2eWstN0_10env_logger3fmt6writer9termcolor3impINtB7_11StyledValueReENtNtCshM4Il2Z0i4R_4core3fmt7Display3fmt0Bf_:
  466|   133k|impl_styled_value_fmt!(
  467|   133k|    fmt::Debug,
  468|   133k|    fmt::Display,
  469|   133k|    fmt::Pointer,
  470|   133k|    fmt::Octal,
  471|   133k|    fmt::Binary,
  472|   133k|    fmt::UpperHex,
  473|   133k|    fmt::LowerHex,
  474|   133k|    fmt::UpperExp,
  475|   133k|    fmt::LowerExp
  476|   133k|);
_RNvMs2_NtNtNtNtCs4DcB2eWstN0_10env_logger3fmt6writer9termcolor3impNtB5_5Style11set_intense:
  332|   133k|    pub fn set_intense(&mut self, yes: bool) -> &mut Style {
  333|   133k|        self.spec.set_intense(yes);
  334|   133k|        self
  335|   133k|    }
_RNvXs6_NtNtNtNtCs4DcB2eWstN0_10env_logger3fmt6writer9termcolor3impNtB5_5StyleNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
  241|   133k|#[derive(Clone)]
_RNvMs_NtNtNtNtCs4DcB2eWstN0_10env_logger3fmt6writer9termcolor3impNtB4_12BufferWriter5print:
  124|  66.5k|        if let Some(target) = &self.uncolored_target {
  125|       |            // This impl uses the `eprint` and `print` macros
  126|       |            // instead of `termcolor`'s buffer.
  127|       |            // This is so their output can be captured by `cargo test`
  128|      0|            let log = String::from_utf8_lossy(buf.bytes());
  129|      0|
  130|      0|            match target {
  131|      0|                WritableTarget::Stderr => eprint!("{}", log),
  132|      0|                WritableTarget::Stdout => print!("{}", log),
  133|      0|                WritableTarget::Pipe(pipe) => write!(pipe.lock().unwrap(), "{}", log)?,
  134|       |            }
  135|       |
  136|      0|            Ok(())
  137|       |        } else {
  138|  66.5k|            self.inner.print(&buf.inner)
  139|       |        }
  140|  66.5k|    }
_RNvMs_NtNtNtNtCs4DcB2eWstN0_10env_logger3fmt6writer9termcolor3impNtB4_12BufferWriter6stderr:
   83|    102|    pub(in crate::fmt::writer) fn stderr(is_test: bool, write_style: WriteStyle) -> Self {
   84|    102|        BufferWriter {
   85|    102|            inner: termcolor::BufferWriter::stderr(write_style.into_color_choice()),
   86|    102|            uncolored_target: if is_test {
   87|      0|                Some(WritableTarget::Stderr)
   88|       |            } else {
   89|    102|                None
   90|       |            },
   91|       |        }
   92|    102|    }
_RNvMNtNtNtNtCs4DcB2eWstN0_10env_logger3fmt6writer9termcolor3impNtB8_9Formatter19default_level_style:
   52|  66.5k|    pub fn default_level_style(&self, level: Level) -> Style {
   53|  66.5k|        let mut level_style = self.style();
   54|  66.5k|        match level {
   55|    111|            Level::Trace => level_style.set_color(Color::Cyan),
   56|  33.3k|            Level::Debug => level_style.set_color(Color::Blue),
   57|      0|            Level::Info => level_style.set_color(Color::Green),
   58|  33.1k|            Level::Warn => level_style.set_color(Color::Yellow),
   59|      0|            Level::Error => level_style.set_color(Color::Red).set_bold(true),
   60|       |        };
   61|  66.5k|        level_style
   62|  66.5k|    }
_RNvMs0_NtNtNtNtCs4DcB2eWstN0_10env_logger3fmt6writer9termcolor3impNtB5_6Buffer5clear:
  144|  66.5k|    pub(in crate::fmt) fn clear(&mut self) {
  145|  66.5k|        self.inner.clear()
  146|  66.5k|    }

_RINvMCs4DcB2eWstN0_10env_loggerNtB3_7Builder8from_envNtB3_3EnvEB3_:
  443|    102|    pub fn from_env<'a, E>(env: E) -> Self
  444|    102|    where
  445|    102|        E: Into<Env<'a>>,
  446|    102|    {
  447|    102|        let mut builder = Builder::new();
  448|    102|        builder.parse_env(env);
  449|    102|        builder
  450|    102|    }
_RNvMs_Cs4DcB2eWstN0_10env_loggerNtB4_6Logger6filter:
  892|    102|    pub fn filter(&self) -> LevelFilter {
  893|    102|        self.filter.filter()
  894|    102|    }
_RNvXs4_Cs4DcB2eWstN0_10env_loggerNtB5_3EnvNtNtCshM4Il2Z0i4R_4core7default7Default7default:
 1097|    102|    fn default() -> Self {
 1098|    102|        Env {
 1099|    102|            filter: Var::new(DEFAULT_FILTER_ENV),
 1100|    102|            write_style: Var::new(DEFAULT_WRITE_STYLE_ENV),
 1101|    102|        }
 1102|    102|    }
_RNCNCNvXs0_Cs4DcB2eWstN0_10env_loggerNtB9_6LoggerNtCs6vrtZ9rvsjP_3log3Log3log00B9_:
  924|  66.5k|                    (self.format)(formatter, record).and_then(|_| formatter.print(&self.writer));
_RNvMCs4DcB2eWstN0_10env_loggerNtB2_7Builder8try_init:
  792|    102|    pub fn try_init(&mut self) -> Result<(), SetLoggerError> {
  793|    102|        let logger = self.build();
  794|    102|
  795|    102|        let max_level = logger.filter();
  796|    102|        let r = log::set_boxed_logger(Box::new(logger));
  797|    102|
  798|    102|        if r.is_ok() {
  799|      1|            log::set_max_level(max_level);
  800|    101|        }
  801|       |
  802|    102|        r
  803|    102|    }
_RNvMs_Cs4DcB2eWstN0_10env_loggerNtB4_6Logger7matches:
  897|  66.5k|    pub fn matches(&self, record: &Record) -> bool {
  898|  66.5k|        self.filter.matches(record)
  899|  66.5k|    }
_RNvCs4DcB2eWstN0_10env_logger8try_init:
 1140|    102|pub fn try_init() -> Result<(), SetLoggerError> {
 1141|    102|    try_init_from_env(Env::default())
 1142|    102|}
_RINvMs2_Cs4DcB2eWstN0_10env_loggerNtB6_3Var3newReEB6_:
 1059|    204|    fn new<E>(name: E) -> Self
 1060|    204|    where
 1061|    204|        E: Into<Cow<'a, str>>,
 1062|    204|    {
 1063|    204|        Var {
 1064|    204|            name: name.into(),
 1065|    204|            default: None,
 1066|    204|        }
 1067|    204|    }
_RNCNvXs0_Cs4DcB2eWstN0_10env_loggerNtB7_6LoggerNtCs6vrtZ9rvsjP_3log3Log3logs_0B7_:
  931|  66.5k|                .try_with(|tl_buf| {
  932|  66.5k|                    match tl_buf.try_borrow_mut() {
  933|       |                        // There are no active borrows of the buffer
  934|  66.5k|                        Ok(mut tl_buf) => match *tl_buf {
  935|       |                            // We have a previously set formatter
  936|  66.5k|                            Some(ref mut formatter) => {
  937|  66.5k|                                // Check the buffer style. If it's different from the logger's
  938|  66.5k|                                // style then drop the buffer and recreate it.
  939|  66.5k|                                if formatter.write_style() != self.writer.write_style() {
  940|      0|                                    *formatter = Formatter::new(&self.writer);
  941|  66.5k|                                }
  942|       |
  943|  66.5k|                                print(formatter, record);
  944|       |                            }
  945|       |                            // We don't have a previously set formatter
  946|      1|                            None => {
  947|      1|                                let mut formatter = Formatter::new(&self.writer);
  948|      1|                                print(&mut formatter, record);
  949|      1|
  950|      1|                                *tl_buf = Some(formatter);
  951|      1|                            }
  952|       |                        },
  953|       |                        // There's already an active borrow of the buffer (due to re-entrancy)
  954|      0|                        Err(_) => {
  955|      0|                            print(&mut Formatter::new(&self.writer), record);
  956|      0|                        }
  957|       |                    }
  958|  66.5k|                })
_RNvXs7_Cs4DcB2eWstN0_10env_loggerNtB5_7BuilderNtNtCshM4Il2Z0i4R_4core7default7Default7default:
  376|    102|#[derive(Default)]
_RNvMCs4DcB2eWstN0_10env_loggerNtB2_7Builder13parse_filters:
  716|    102|    pub fn parse_filters(&mut self, filters: &str) -> &mut Self {
  717|    102|        self.filter.parse(filters);
  718|    102|        self
  719|    102|    }
_RNvMCs4DcB2eWstN0_10env_loggerNtB2_7Builder5build:
  823|    102|    pub fn build(&mut self) -> Logger {
  824|    102|        assert!(!self.built, "attempt to re-use consumed builder");
  825|    102|        self.built = true;
  826|    102|
  827|    102|        Logger {
  828|    102|            writer: self.writer.build(),
  829|    102|            filter: self.filter.build(),
  830|    102|            format: self.format.build(),
  831|    102|        }
  832|    102|    }
_RINvMCs4DcB2eWstN0_10env_loggerNtB3_7Builder9parse_envNtB3_3EnvEB3_:
  488|    102|    pub fn parse_env<'a, E>(&mut self, env: E) -> &mut Self
  489|    102|    where
  490|    102|        E: Into<Env<'a>>,
  491|    102|    {
  492|    102|        let env = env.into();
  493|       |
  494|    102|        if let Some(s) = env.get_filter() {
  495|    102|            self.parse_filters(&s);
  496|    102|        }
  497|       |
  498|    102|        if let Some(s) = env.get_write_style() {
  499|      0|            self.parse_write_style(&s);
  500|    102|        }
  501|       |
  502|    102|        self
  503|    102|    }
_RNCNvNvNvXs0_Cs4DcB2eWstN0_10env_loggerNtBb_6LoggerNtCs6vrtZ9rvsjP_3log3Log3log9FORMATTER7___getit0Bb_:
  918|      1|            thread_local! {
  919|      1|                static FORMATTER: RefCell<Option<Formatter>> = RefCell::new(None);
  920|      1|            }
_RNvMs1_Cs4DcB2eWstN0_10env_loggerNtB5_3Env15get_write_style:
 1053|    102|    fn get_write_style(&self) -> Option<String> {
 1054|    102|        self.write_style.get()
 1055|    102|    }
_RINvCs4DcB2eWstN0_10env_logger17try_init_from_envNtB2_3EnvEB2_:
 1185|    102|pub fn try_init_from_env<'a, E>(env: E) -> Result<(), SetLoggerError>
 1186|    102|where
 1187|    102|    E: Into<Env<'a>>,
 1188|    102|{
 1189|    102|    let mut builder = Builder::from_env(env);
 1190|    102|
 1191|    102|    builder.try_init()
 1192|    102|}
_RNCNvMs2_Cs4DcB2eWstN0_10env_loggerNtB7_3Var3get0B7_:
 1083|    102|            .or_else(|| self.default.to_owned().map(|v| v.into_owned()))
_RNvMCs4DcB2eWstN0_10env_loggerNtB2_7Builder3new:
  411|    102|    pub fn new() -> Builder {
  412|    102|        Default::default()
  413|    102|    }
_RNCNvXs0_Cs4DcB2eWstN0_10env_loggerNtB7_6LoggerNtCs6vrtZ9rvsjP_3log3Log3log0B7_:
  922|  66.5k|            let print = |formatter: &mut Formatter, record: &Record| {
  923|  66.5k|                let _ =
  924|  66.5k|                    (self.format)(formatter, record).and_then(|_| formatter.print(&self.writer));
  925|  66.5k|
  926|  66.5k|                // Always clear the buffer afterwards
  927|  66.5k|                formatter.clear();
  928|  66.5k|            };
_RNvMs1_Cs4DcB2eWstN0_10env_loggerNtB5_3Env10get_filter:
 1014|    102|    fn get_filter(&self) -> Option<String> {
 1015|    102|        self.filter.get()
 1016|    102|    }
_RNvMs2_Cs4DcB2eWstN0_10env_loggerNtB5_3Var3get:
 1080|    204|    fn get(&self) -> Option<String> {
 1081|    204|        env::var(&*self.name)
 1082|    204|            .ok()
 1083|    204|            .or_else(|| self.default.to_owned().map(|v| v.into_owned()))
 1084|    204|    }
_RNvXs0_Cs4DcB2eWstN0_10env_loggerNtB5_6LoggerNtCs6vrtZ9rvsjP_3log3Log3log:
  907|  66.5k|    fn log(&self, record: &Record) {
  908|  66.5k|        if self.matches(record) {
  909|       |            // Log records are written to a thread-local buffer before being printed
  910|       |            // to the terminal. We clear these buffers afterwards, but they aren't shrinked
  911|       |            // so will always at least have capacity for the largest log record formatted
  912|       |            // on that thread.
  913|       |            //
  914|       |            // If multiple `Logger`s are used by the same threads then the thread-local
  915|       |            // formatter might have different color support. If this is the case the
  916|       |            // formatter and its buffer are discarded and recreated.
  917|       |
  918|       |            thread_local! {
  919|       |                static FORMATTER: RefCell<Option<Formatter>> = RefCell::new(None);
  920|       |            }
  921|       |
  922|  66.5k|            let print = |formatter: &mut Formatter, record: &Record| {
  923|       |                let _ =
  924|       |                    (self.format)(formatter, record).and_then(|_| formatter.print(&self.writer));
  925|       |
  926|       |                // Always clear the buffer afterwards
  927|       |                formatter.clear();
  928|       |            };
  929|       |
  930|  66.5k|            let printed = FORMATTER
  931|  66.5k|                .try_with(|tl_buf| {
  932|       |                    match tl_buf.try_borrow_mut() {
  933|       |                        // There are no active borrows of the buffer
  934|       |                        Ok(mut tl_buf) => match *tl_buf {
  935|       |                            // We have a previously set formatter
  936|       |                            Some(ref mut formatter) => {
  937|       |                                // Check the buffer style. If it's different from the logger's
  938|       |                                // style then drop the buffer and recreate it.
  939|       |                                if formatter.write_style() != self.writer.write_style() {
  940|       |                                    *formatter = Formatter::new(&self.writer);
  941|       |                                }
  942|       |
  943|       |                                print(formatter, record);
  944|       |                            }
  945|       |                            // We don't have a previously set formatter
  946|       |                            None => {
  947|       |                                let mut formatter = Formatter::new(&self.writer);
  948|       |                                print(&mut formatter, record);
  949|       |
  950|       |                                *tl_buf = Some(formatter);
  951|       |                            }
  952|       |                        },
  953|       |                        // There's already an active borrow of the buffer (due to re-entrancy)
  954|       |                        Err(_) => {
  955|       |                            print(&mut Formatter::new(&self.writer), record);
  956|       |                        }
  957|       |                    }
  958|  66.5k|                })
  959|  66.5k|                .is_ok();
  960|  66.5k|
  961|  66.5k|            if !printed {
  962|      0|                // The thread-local storage was not available (because its
  963|      0|                // destructor has already run). Create a new single-use
  964|      0|                // Formatter on the stack for this call.
  965|      0|                print(&mut Formatter::new(&self.writer), record);
  966|  66.5k|            }
  967|      0|        }
  968|  66.5k|    }

_RNCINvXNvNtCslriq3Zp8obK_17forest_hash_utils3keys_1__NtB7_8BytesKeyNtNtCslVZeVZySzLE_5serde2de11Deserialize11deserializeNtNtCsalhrieD8kwf_12libipld_core4ipld4IpldE0CsitTtQF8ArIt_8fvm_fuzz:
   10|    306|#[derive(Eq, PartialOrd, Clone, Debug, Serialize, Deserialize)]
_RINvXNvNtCslriq3Zp8obK_17forest_hash_utils3keys_1__NtB5_8BytesKeyNtNtCslVZeVZySzLE_5serde2de11Deserialize11deserializeNtNtCsalhrieD8kwf_12libipld_core4ipld4IpldECsitTtQF8ArIt_8fvm_fuzz:
   10|    306|#[derive(Eq, PartialOrd, Clone, Debug, Serialize, Deserialize)]
_RINvXNvNtCslriq3Zp8obK_17forest_hash_utils3key1__NtB5_8BytesKeyNtNtCslVZeVZySzLE_5serde3ser9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
   10|    306|#[derive(Eq, PartialOrd, Clone, Debug, Serialize, Deserialize)]
_RINvXs_NtCslriq3Zp8obK_17forest_hash_utils3keyNtB5_8BytesKeyNtB7_4Hash4hashNtNtCshRBVfIqfJKm_13fvm_ipld_hamt14hash_algorithm17Sha2HasherWrapperECsitTtQF8ArIt_8fvm_fuzz:
   21|    306|    fn hash<H: Hasher>(&self, state: &mut H) {
   22|    306|        state.write(&self.0);
   23|    306|    }
_RNvXs3_NtCslriq3Zp8obK_17forest_hash_utils3keyNtB5_8BytesKeyINtNtCshM4Il2Z0i4R_4core7convert4FromINtNtCsjYc3JqMxxfa_5alloc3vec3VechEE4from:
   46|    306|    fn from(bz: Vec<u8>) -> Self {
   47|    306|        BytesKey(bz)
   48|    306|    }

_RNvNtCs69RocqTkFxx_16futures_executor5enter5enter:
   55|    102|pub fn enter() -> Result<Enter, EnterError> {
   56|    102|    ENTERED.with(|c| {
   57|       |        if c.get() {
   58|       |            Err(EnterError { _priv: () })
   59|       |        } else {
   60|       |            c.set(true);
   61|       |
   62|       |            Ok(Enter { _priv: () })
   63|       |        }
   64|    102|    })
   65|    102|}
_RNCNvXs2_NtCs69RocqTkFxx_16futures_executor5enterNtB7_5EnterNtNtNtCshM4Il2Z0i4R_4core3ops4drop4Drop4drop0B9_:
   75|    102|        ENTERED.with(|c| {
   76|    102|            assert!(c.get());
   77|    102|            c.set(false);
   78|    102|        });
_RNCNvNtCs69RocqTkFxx_16futures_executor5enter5enter0B5_:
   56|    102|    ENTERED.with(|c| {
   57|    102|        if c.get() {
   58|      0|            Err(EnterError { _priv: () })
   59|       |        } else {
   60|    102|            c.set(true);
   61|    102|
   62|    102|            Ok(Enter { _priv: () })
   63|       |        }
   64|    102|    })
_RNvXs2_NtCs69RocqTkFxx_16futures_executor5enterNtB5_5EnterNtNtNtCshM4Il2Z0i4R_4core3ops4drop4Drop4drop:
   74|    102|    fn drop(&mut self) {
   75|    102|        ENTERED.with(|c| {
   76|       |            assert!(c.get());
   77|       |            c.set(false);
   78|    102|        });
   79|    102|    }
_RNCNvNvNtCs69RocqTkFxx_16futures_executor5enter7ENTERED7___getit0B7_:
    4|      1|thread_local!(static ENTERED: Cell<bool> = Cell::new(false));

_RNCINvNtCs69RocqTkFxx_16futures_executor10local_pool12run_executorINtNtCshM4Il2Z0i4R_4core6result6ResultINtNtCsjYc3JqMxxfa_5alloc3vec3VecINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EENtNtCsFqKNUWW8VZ_12fvm_ipld_car5error5ErrorENCINvB4_8block_onNCINvNtCs6UoH8pR2orC_21fvm_integration_tests6bundle13import_bundleNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreE0E0E0CsitTtQF8ArIt_8fvm_fuzz:
   86|    102|    CURRENT_THREAD_NOTIFY.with(|thread_notify| {
   87|    102|        let waker = waker_ref(thread_notify);
   88|    102|        let mut cx = Context::from_waker(&waker);
   89|       |        loop {
   90|    102|            if let Poll::Ready(t) = f(&mut cx) {
   91|    102|                return t;
   92|      0|            }
   93|       |
   94|       |            // Wait for a wakeup.
   95|      0|            while !thread_notify.unparked.swap(false, Ordering::Acquire) {
   96|      0|                // No wakeup occurred. It may occur now, right before parking,
   97|      0|                // but in that case the token made available by `unpark()`
   98|      0|                // is guaranteed to still be available and `park()` is a no-op.
   99|      0|                thread::park();
  100|      0|            }
  101|       |        }
  102|    102|    })
_RNCINvNtCs69RocqTkFxx_16futures_executor10local_pool8block_onNCINvNtCs6UoH8pR2orC_21fvm_integration_tests6bundle13import_bundleNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreE0E0CsitTtQF8ArIt_8fvm_fuzz:
  317|    102|    run_executor(|cx| f.as_mut().poll(cx))
_RNCNvNvNtCs69RocqTkFxx_16futures_executor10local_pool21CURRENT_THREAD_NOTIFY7___getit0CsitTtQF8ArIt_8fvm_fuzz:
   56|      1|thread_local! {
   57|      1|    static CURRENT_THREAD_NOTIFY: Arc<ThreadNotify> = Arc::new(ThreadNotify {
   58|      1|        thread: thread::current(),
   59|      1|        unparked: AtomicBool::new(false),
   60|      1|    });
   61|      1|}
_RINvNtCs69RocqTkFxx_16futures_executor10local_pool8block_onNCINvNtCs6UoH8pR2orC_21fvm_integration_tests6bundle13import_bundleNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreE0ECsitTtQF8ArIt_8fvm_fuzz:
  315|    102|pub fn block_on<F: Future>(f: F) -> F::Output {
  316|    102|    pin_mut!(f);
  317|    102|    run_executor(|cx| f.as_mut().poll(cx))
  318|    102|}
_RINvNtCs69RocqTkFxx_16futures_executor10local_pool12run_executorINtNtCshM4Il2Z0i4R_4core6result6ResultINtNtCsjYc3JqMxxfa_5alloc3vec3VecINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EENtNtCsFqKNUWW8VZ_12fvm_ipld_car5error5ErrorENCINvB2_8block_onNCINvNtCs6UoH8pR2orC_21fvm_integration_tests6bundle13import_bundleNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreE0E0ECsitTtQF8ArIt_8fvm_fuzz:
   80|    102|fn run_executor<T, F: FnMut(&mut Context<'_>) -> Poll<T>>(mut f: F) -> T {
   81|    102|    let _enter = enter().expect(
   82|    102|        "cannot execute `LocalPool` executor from within \
   83|    102|         another executor",
   84|    102|    );
   85|    102|
   86|    102|    CURRENT_THREAD_NOTIFY.with(|thread_notify| {
   87|       |        let waker = waker_ref(thread_notify);
   88|       |        let mut cx = Context::from_waker(&waker);
   89|       |        loop {
   90|       |            if let Poll::Ready(t) = f(&mut cx) {
   91|       |                return t;
   92|       |            }
   93|       |
   94|       |            // Wait for a wakeup.
   95|       |            while !thread_notify.unparked.swap(false, Ordering::Acquire) {
   96|       |                // No wakeup occurred. It may occur now, right before parking,
   97|       |                // but in that case the token made available by `unpark()`
   98|       |                // is guaranteed to still be available and `park()` is a no-op.
   99|       |                thread::park();
  100|       |            }
  101|       |        }
  102|    102|    })
  103|    102|}

_RNvXs_NtCsiqdZfiLvP1W_10futures_io6if_stdQRShNtB4_9AsyncRead9poll_readCsitTtQF8ArIt_8fvm_fuzz:
  302|  7.03k|            fn poll_read(
  303|  7.03k|                mut self: Pin<&mut Self>,
  304|  7.03k|                cx: &mut Context<'_>,
  305|  7.03k|                buf: &mut [u8],
  306|  7.03k|            ) -> Poll<Result<usize>> {
  307|  7.03k|                Pin::new(&mut **self).poll_read(cx, buf)
  308|  7.03k|            }
_RNvXs_NtCsiqdZfiLvP1W_10futures_io6if_stdQINtNtNtCsaySvaz5DPef_12futures_util2io4take4TakeQRShENtB4_9AsyncRead9poll_readCsitTtQF8ArIt_8fvm_fuzz:
  302|  3.77k|            fn poll_read(
  303|  3.77k|                mut self: Pin<&mut Self>,
  304|  3.77k|                cx: &mut Context<'_>,
  305|  3.77k|                buf: &mut [u8],
  306|  3.77k|            ) -> Poll<Result<usize>> {
  307|  3.77k|                Pin::new(&mut **self).poll_read(cx, buf)
  308|  3.77k|            }
_RNvXs_NtCsiqdZfiLvP1W_10futures_io6if_stdQQRShNtB4_9AsyncRead9poll_readCsitTtQF8ArIt_8fvm_fuzz:
  302|  5.10k|            fn poll_read(
  303|  5.10k|                mut self: Pin<&mut Self>,
  304|  5.10k|                cx: &mut Context<'_>,
  305|  5.10k|                buf: &mut [u8],
  306|  5.10k|            ) -> Poll<Result<usize>> {
  307|  5.10k|                Pin::new(&mut **self).poll_read(cx, buf)
  308|  5.10k|            }
_RNvXs1_NtCsiqdZfiLvP1W_10futures_io6if_stdRShNtB5_9AsyncRead9poll_read:
  352|  7.03k|            fn poll_read(
  353|  7.03k|                mut self: Pin<&mut Self>,
  354|  7.03k|                _: &mut Context<'_>,
  355|  7.03k|                buf: &mut [u8],
  356|  7.03k|            ) -> Poll<Result<usize>> {
  357|  7.03k|                Poll::Ready(io::Read::read(&mut *self, buf))
  358|  7.03k|            }

_RINvNtCs7mY4K30D2kT_12futures_task5waker12waker_vtableNtNtCs69RocqTkFxx_16futures_executor10local_pool12ThreadNotifyECsitTtQF8ArIt_8fvm_fuzz:
    6|    102|pub(super) fn waker_vtable<W: ArcWake>() -> &'static RawWakerVTable {
    7|    102|    &RawWakerVTable::new(
    8|    102|        clone_arc_raw::<W>,
    9|    102|        wake_arc_raw::<W>,
   10|    102|        wake_by_ref_arc_raw::<W>,
   11|    102|        drop_arc_raw::<W>,
   12|    102|    )
   13|    102|}

_RNvXs_NtCs7mY4K30D2kT_12futures_task9waker_refNtB4_8WakerRefNtNtNtCshM4Il2Z0i4R_4core3ops5deref5Deref5deref:
   45|    102|    fn deref(&self) -> &Waker {
   46|    102|        &self.waker
   47|    102|    }
_RNvMNtCs7mY4K30D2kT_12futures_task9waker_refNtB2_8WakerRef11new_unowned:
   36|    102|    pub fn new_unowned(waker: ManuallyDrop<Waker>) -> Self {
   37|    102|        Self { waker, _marker: PhantomData }
   38|    102|    }
_RINvNtCs7mY4K30D2kT_12futures_task9waker_ref9waker_refNtNtCs69RocqTkFxx_16futures_executor10local_pool12ThreadNotifyECsitTtQF8ArIt_8fvm_fuzz:
   55|    102|pub fn waker_ref<W>(wake: &Arc<W>) -> WakerRef<'_>
   56|    102|where
   57|    102|    W: ArcWake,
   58|    102|{
   59|    102|    // simply copy the pointer instead of using Arc::into_raw,
   60|    102|    // as we don't actually keep a refcount by using ManuallyDrop.<
   61|    102|    let ptr = Arc::as_ptr(wake).cast::<()>();
   62|    102|
   63|    102|    let waker =
   64|    102|        ManuallyDrop::new(unsafe { Waker::from_raw(RawWaker::new(ptr, waker_vtable::<W>())) });
   65|    102|    WakerRef::new_unowned(waker)
   66|    102|}

_RINvNtCsaySvaz5DPef_12futures_util6future13assert_futureINtNtCshM4Il2Z0i4R_4core6result6ResultjNtNtNtCsxnqwkJeFav_3std2io5error5ErrorEINtNtNtB4_2io4read4ReadQRShEECsitTtQF8ArIt_8fvm_fuzz:
  126|  5.10k|pub(crate) fn assert_future<T, F>(future: F) -> F
  127|  5.10k|where
  128|  5.10k|    F: Future<Output = T>,
  129|  5.10k|{
  130|  5.10k|    future
  131|  5.10k|}
_RINvNtCsaySvaz5DPef_12futures_util6future13assert_futureINtNtCshM4Il2Z0i4R_4core6result6ResultjNtNtNtCsxnqwkJeFav_3std2io5error5ErrorEINtNtNtB4_2io11read_to_end9ReadToEndINtNtB2d_4take4TakeQRShEEECsitTtQF8ArIt_8fvm_fuzz:
  126|  1.83k|pub(crate) fn assert_future<T, F>(future: F) -> F
  127|  1.83k|where
  128|  1.83k|    F: Future<Output = T>,
  129|  1.83k|{
  130|  1.83k|    future
  131|  1.83k|}

_RNvYINtNtNtCsaySvaz5DPef_12futures_util2io4take4TakeQRShENtB7_12AsyncReadExt11read_to_endCsitTtQF8ArIt_8fvm_fuzz:
  286|  1.83k|    fn read_to_end<'a>(&'a mut self, buf: &'a mut Vec<u8>) -> ReadToEnd<'a, Self>
  287|  1.83k|    where
  288|  1.83k|        Self: Unpin,
  289|  1.83k|    {
  290|  1.83k|        assert_future::<Result<usize>, _>(ReadToEnd::new(self, buf))
  291|  1.83k|    }
_RINvNtCsaySvaz5DPef_12futures_util2io10initializeINtNtCshM4Il2Z0i4R_4core3pin3PinQQINtNtB2_4take4TakeQRShEEECsitTtQF8ArIt_8fvm_fuzz:
   41|  3.67k|unsafe fn initialize<R: AsyncRead>(_reader: &R, buf: &mut [u8]) {
   42|  3.67k|    ptr::write_bytes(buf.as_mut_ptr(), 0, buf.len())
   43|  3.67k|}
_RNvYQRShNtNtCsaySvaz5DPef_12futures_util2io12AsyncReadExt4readCsitTtQF8ArIt_8fvm_fuzz:
  204|  5.10k|    fn read<'a>(&'a mut self, buf: &'a mut [u8]) -> Read<'a, Self>
  205|  5.10k|    where
  206|  5.10k|        Self: Unpin,
  207|  5.10k|    {
  208|  5.10k|        assert_future::<Result<usize>, _>(Read::new(self, buf))
  209|  5.10k|    }
_RNvYQRShNtNtCsaySvaz5DPef_12futures_util2io12AsyncReadExt4takeCsitTtQF8ArIt_8fvm_fuzz:
  375|  1.83k|    fn take(self, limit: u64) -> Take<Self>
  376|  1.83k|    where
  377|  1.83k|        Self: Sized,
  378|  1.83k|    {
  379|  1.83k|        assert_read(Take::new(self, limit))
  380|  1.83k|    }
_RINvNtCsaySvaz5DPef_12futures_util2io11assert_readINtNtB2_4take4TakeQRShEECsitTtQF8ArIt_8fvm_fuzz:
  828|  1.83k|pub(crate) fn assert_read<R>(reader: R) -> R
  829|  1.83k|where
  830|  1.83k|    R: AsyncRead,
  831|  1.83k|{
  832|  1.83k|    reader
  833|  1.83k|}

_RNvXs0_NtNtCsaySvaz5DPef_12futures_util2io4readINtB5_4ReadQRShENtNtNtCshM4Il2Z0i4R_4core6future6future6Future4pollCsitTtQF8ArIt_8fvm_fuzz:
   26|  5.10k|    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
   27|  5.10k|        let this = &mut *self;
   28|  5.10k|        Pin::new(&mut this.reader).poll_read(cx, this.buf)
   29|  5.10k|    }
_RNvMs_NtNtCsaySvaz5DPef_12futures_util2io4readINtB4_4ReadQRShE3newCsitTtQF8ArIt_8fvm_fuzz:
   18|  5.10k|    pub(super) fn new(reader: &'a mut R, buf: &'a mut [u8]) -> Self {
   19|  5.10k|        Self { reader, buf }
   20|  5.10k|    }

_RINvNtNtCsaySvaz5DPef_12futures_util2io11read_to_end20read_to_end_internalQINtNtB4_4take4TakeQRShEECsitTtQF8ArIt_8fvm_fuzz:
   49|  1.83k|pub(super) fn read_to_end_internal<R: AsyncRead + ?Sized>(
   50|  1.83k|    mut rd: Pin<&mut R>,
   51|  1.83k|    cx: &mut Context<'_>,
   52|  1.83k|    buf: &mut Vec<u8>,
   53|  1.83k|    start_len: usize,
   54|  1.83k|) -> Poll<io::Result<usize>> {
   55|  1.83k|    let mut g = Guard { len: buf.len(), buf };
   56|  3.77k|    loop {
   57|  3.77k|        if g.len == g.buf.len() {
   58|  3.67k|            unsafe {
   59|  3.67k|                g.buf.reserve(32);
   60|  3.67k|                let capacity = g.buf.capacity();
   61|  3.67k|                g.buf.set_len(capacity);
   62|  3.67k|                super::initialize(&rd, &mut g.buf[g.len..]);
   63|  3.67k|            }
   64|    102|        }
   65|       |
   66|  3.77k|        let buf = &mut g.buf[g.len..];
   67|  3.77k|        match ready!(rd.as_mut().poll_read(cx, buf)) {
   68|  1.83k|            Ok(0) => return Poll::Ready(Ok(g.len - start_len)),
   69|  1.93k|            Ok(n) => {
   70|  1.93k|                // We can't allow bogus values from read. If it is too large, the returned vec could have its length
   71|  1.93k|                // set past its capacity, or if it overflows the vec could be shortened which could create an invalid
   72|  1.93k|                // string if this is called via read_to_string.
   73|  1.93k|                assert!(n <= buf.len());
   74|  1.93k|                g.len += n;
   75|       |            }
   76|      0|            Err(e) => return Poll::Ready(Err(e)),
   77|       |        }
   78|       |    }
   79|  1.83k|}
_RNvXs1_NtNtCsaySvaz5DPef_12futures_util2io11read_to_endINtB5_9ReadToEndINtNtB7_4take4TakeQRShEENtNtNtCshM4Il2Z0i4R_4core6future6future6Future4pollCsitTtQF8ArIt_8fvm_fuzz:
   87|  1.83k|    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
   88|  1.83k|        let this = &mut *self;
   89|  1.83k|        read_to_end_internal(Pin::new(&mut this.reader), cx, this.buf, this.start_len)
   90|  1.83k|    }
_RNvMs_NtNtCsaySvaz5DPef_12futures_util2io11read_to_endINtB4_9ReadToEndINtNtB6_4take4TakeQRShEE3newCsitTtQF8ArIt_8fvm_fuzz:
   21|  1.83k|    pub(super) fn new(reader: &'a mut R, buf: &'a mut Vec<u8>) -> Self {
   22|  1.83k|        let start_len = buf.len();
   23|  1.83k|        Self { reader, buf, start_len }
   24|  1.83k|    }
_RNvXs0_NtNtCsaySvaz5DPef_12futures_util2io11read_to_endNtB5_5GuardNtNtNtCshM4Il2Z0i4R_4core3ops4drop4Drop4drop:
   33|  1.83k|    fn drop(&mut self) {
   34|  1.83k|        unsafe {
   35|  1.83k|            self.buf.set_len(self.len);
   36|  1.83k|        }
   37|  1.83k|    }

_RNvMNtNtCsaySvaz5DPef_12futures_util2io4takeINtB2_4TakeQRShE3newCsitTtQF8ArIt_8fvm_fuzz:
   20|  1.83k|    pub(super) fn new(inner: R, limit: u64) -> Self {
   21|  1.83k|        Self { inner, limit }
   22|  1.83k|    }
_RNvXs_NtNtCsaySvaz5DPef_12futures_util2io4takeINtB4_4TakeQRShENtNtCsiqdZfiLvP1W_10futures_io6if_std9AsyncRead9poll_readCsitTtQF8ArIt_8fvm_fuzz:
   85|  3.77k|    fn poll_read(
   86|  3.77k|        self: Pin<&mut Self>,
   87|  3.77k|        cx: &mut Context<'_>,
   88|  3.77k|        buf: &mut [u8],
   89|  3.77k|    ) -> Poll<Result<usize, io::Error>> {
   90|  3.77k|        let this = self.project();
   91|  3.77k|
   92|  3.77k|        if *this.limit == 0 {
   93|  1.83k|            return Poll::Ready(Ok(0));
   94|  1.93k|        }
   95|  1.93k|
   96|  1.93k|        let max = cmp::min(buf.len() as u64, *this.limit) as usize;
   97|  1.93k|        let n = ready!(this.inner.poll_read(cx, &mut buf[..max]))?;
   98|  1.93k|        *this.limit -= n as u64;
   99|  1.93k|        Poll::Ready(Ok(n))
  100|  3.77k|    }

_RNvXNtCshcIQlq3itKa_13generic_array5implsINtB4_12GenericArrayhINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIBZ_IBZ_IBZ_IBZ_IBZ_NtB11_5UTermNtNtB13_3bit2B1ENtB27_2B0EB2l_EB2l_EB2l_EB2l_EENtNtCshM4Il2Z0i4R_4core7default7Default7defaultCsitTtQF8ArIt_8fvm_fuzz:
   16|    612|    fn default() -> Self {
   17|    612|        Self::generate(|_| T::default())
   18|    612|    }
_RNCNvXNtCshcIQlq3itKa_13generic_array5implsINtB6_12GenericArrayhINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIB11_IB11_IB11_IB11_IB11_IB11_NtB13_5UTermNtNtB15_3bit2B1ENtB2j_2B0EB2x_EB2x_EB2x_EB2x_EB2x_EENtNtCshM4Il2Z0i4R_4core7default7Default7default0CsitTtQF8ArIt_8fvm_fuzz:
   17|  19.5k|        Self::generate(|_| T::default())
_RNvXNtCshcIQlq3itKa_13generic_array5implsINtB4_12GenericArrayhINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIBZ_IBZ_IBZ_IBZ_IBZ_IBZ_NtB11_5UTermNtNtB13_3bit2B1ENtB2b_2B0EB2p_EB2p_EB2p_EB2p_EB2p_EENtNtCshM4Il2Z0i4R_4core7default7Default7defaultCsitTtQF8ArIt_8fvm_fuzz:
   16|    306|    fn default() -> Self {
   17|    306|        Self::generate(|_| T::default())
   18|    306|    }
_RNCNvXNtCshcIQlq3itKa_13generic_array5implsINtB6_12GenericArrayhINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIB11_IB11_IB11_IB11_IB11_NtB13_5UTermNtNtB15_3bit2B1ENtB2e_2B0EB2s_EB2s_EB2s_EB2s_EENtNtCshM4Il2Z0i4R_4core7default7Default7default0CsitTtQF8ArIt_8fvm_fuzz:
   17|  19.5k|        Self::generate(|_| T::default())
_RNvXs3c_NtCshcIQlq3itKa_13generic_array5implsAhj20_INtNtCshM4Il2Z0i4R_4core7convert4FromINtB8_12GenericArrayhINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIB1K_IB1K_IB1K_IB1K_IB1K_NtB1M_5UTermNtNtB1O_3bit2B1ENtB2X_2B0EB3b_EB3b_EB3b_EB3b_EEE4fromCsitTtQF8ArIt_8fvm_fuzz:
  139|    306|                fn from(sel: GenericArray<T, $ty>) -> [T; $n] {
  140|    306|                    unsafe { $crate::transmute(sel) }
  141|    306|                }

_RNvMs9_CshcIQlq3itKa_13generic_arrayINtB5_12ArrayBuilderhINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIBU_IBU_IBU_IBU_IBU_NtBW_5UTermNtNtBY_3bit2B1ENtB21_2B0EB2e_EB2e_EB2e_EB2e_EE13iter_positionCsitTtQF8ArIt_8fvm_fuzz:
  234|    612|    pub unsafe fn iter_position(&mut self) -> (slice::IterMut<T>, &mut usize) {
  235|    612|        ((&mut *self.array.as_mut_ptr()).iter_mut(), &mut self.position)
  236|    612|    }
_RNvXs7_CshcIQlq3itKa_13generic_arrayINtB5_12GenericArrayhINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIBU_IBU_IBU_IBU_IBU_NtBW_5UTermNtNtBY_3bit2B1ENtB21_2B0EB2e_EB2e_EB2e_EB2e_EENtNtNtCshM4Il2Z0i4R_4core3ops5deref5Deref5derefCsitTtQF8ArIt_8fvm_fuzz:
  192|    918|    fn deref(&self) -> &[T] {
  193|    918|        unsafe { slice::from_raw_parts(self as *const Self as *const T, N::USIZE) }
  194|    918|    }
_RNvMs9_CshcIQlq3itKa_13generic_arrayINtB5_12ArrayBuilderhINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIBU_IBU_IBU_IBU_IBU_IBU_NtBW_5UTermNtNtBY_3bit2B1ENtB25_2B0EB2i_EB2i_EB2i_EB2i_EB2i_EE3newCsitTtQF8ArIt_8fvm_fuzz:
  221|    306|    pub unsafe fn new() -> ArrayBuilder<T, N> {
  222|    306|        ArrayBuilder {
  223|    306|            array: MaybeUninit::uninit(),
  224|    306|            position: 0,
  225|    306|        }
  226|    306|    }
_RNvMs9_CshcIQlq3itKa_13generic_arrayINtB5_12ArrayBuilderhINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIBU_IBU_IBU_IBU_IBU_IBU_NtBW_5UTermNtNtBY_3bit2B1ENtB25_2B0EB2i_EB2i_EB2i_EB2i_EB2i_EE13iter_positionCsitTtQF8ArIt_8fvm_fuzz:
  234|    306|    pub unsafe fn iter_position(&mut self) -> (slice::IterMut<T>, &mut usize) {
  235|    306|        ((&mut *self.array.as_mut_ptr()).iter_mut(), &mut self.position)
  236|    306|    }
_RNvMs9_CshcIQlq3itKa_13generic_arrayINtB5_12ArrayBuilderhINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIBU_IBU_IBU_IBU_IBU_IBU_NtBW_5UTermNtNtBY_3bit2B1ENtB25_2B0EB2i_EB2i_EB2i_EB2i_EB2i_EE10into_innerCsitTtQF8ArIt_8fvm_fuzz:
  242|    306|    pub unsafe fn into_inner(self) -> GenericArray<T, N> {
  243|    306|        let array = ptr::read(&self.array);
  244|    306|
  245|    306|        mem::forget(self);
  246|    306|
  247|    306|        array.assume_init()
  248|    306|    }
_RINvXsg_CshcIQlq3itKa_13generic_arrayINtB6_12GenericArrayhINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIBV_IBV_IBV_IBV_IBV_IBV_NtBX_5UTermNtNtBZ_3bit2B1ENtB26_2B0EB2j_EB2j_EB2j_EB2j_EB2j_EEINtNtB6_8sequence15GenericSequencehE8generateNCNvXNtB6_5implsBz_NtNtCshM4Il2Z0i4R_4core7default7Default7default0ECsitTtQF8ArIt_8fvm_fuzz:
  379|    306|    fn generate<F>(mut f: F) -> GenericArray<T, N>
  380|    306|    where
  381|    306|        F: FnMut(usize) -> T,
  382|    306|    {
  383|    306|        unsafe {
  384|    306|            let mut destination = ArrayBuilder::new();
  385|    306|
  386|    306|            {
  387|    306|                let (destination_iter, position) = destination.iter_position();
  388|    306|
  389|    306|                destination_iter.enumerate().for_each(|(i, dst)| {
  390|       |                    ptr::write(dst, f(i));
  391|       |
  392|       |                    *position += 1;
  393|    306|                });
  394|    306|            }
  395|    306|
  396|    306|            destination.into_inner()
  397|    306|        }
  398|    306|    }
_RNCINvXsg_CshcIQlq3itKa_13generic_arrayINtB8_12GenericArrayhINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIBX_IBX_IBX_IBX_IBX_IBX_NtBZ_5UTermNtNtB11_3bit2B1ENtB28_2B0EB2m_EB2m_EB2m_EB2m_EB2m_EEINtNtB8_8sequence15GenericSequencehE8generateNCNvXNtB8_5implsBB_NtNtCshM4Il2Z0i4R_4core7default7Default7default0E0CsitTtQF8ArIt_8fvm_fuzz:
  389|  19.5k|                destination_iter.enumerate().for_each(|(i, dst)| {
  390|  19.5k|                    ptr::write(dst, f(i));
  391|  19.5k|
  392|  19.5k|                    *position += 1;
  393|  19.5k|                });
_RINvXsg_CshcIQlq3itKa_13generic_arrayINtB6_12GenericArrayhINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIBV_IBV_IBV_IBV_IBV_NtBX_5UTermNtNtBZ_3bit2B1ENtB22_2B0EB2f_EB2f_EB2f_EB2f_EEINtNtB6_8sequence15GenericSequencehE8generateNCNvXNtB6_5implsBz_NtNtCshM4Il2Z0i4R_4core7default7Default7default0ECsitTtQF8ArIt_8fvm_fuzz:
  379|    612|    fn generate<F>(mut f: F) -> GenericArray<T, N>
  380|    612|    where
  381|    612|        F: FnMut(usize) -> T,
  382|    612|    {
  383|    612|        unsafe {
  384|    612|            let mut destination = ArrayBuilder::new();
  385|    612|
  386|    612|            {
  387|    612|                let (destination_iter, position) = destination.iter_position();
  388|    612|
  389|    612|                destination_iter.enumerate().for_each(|(i, dst)| {
  390|       |                    ptr::write(dst, f(i));
  391|       |
  392|       |                    *position += 1;
  393|    612|                });
  394|    612|            }
  395|    612|
  396|    612|            destination.into_inner()
  397|    612|        }
  398|    612|    }
_RINvCshcIQlq3itKa_13generic_array9transmuteINtB2_12GenericArrayhINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIB11_IB11_IB11_IB11_IB11_NtB13_5UTermNtNtB15_3bit2B1ENtB2e_2B0EB2s_EB2s_EB2s_EB2s_EEAhj20_ECsitTtQF8ArIt_8fvm_fuzz:
  642|    306|pub unsafe fn transmute<A, B>(a: A) -> B {
  643|    306|    let a = ManuallyDrop::new(a);
  644|    306|    ::core::ptr::read(&*a as *const A as *const B)
  645|    306|}
_RNvMs9_CshcIQlq3itKa_13generic_arrayINtB5_12ArrayBuilderhINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIBU_IBU_IBU_IBU_IBU_NtBW_5UTermNtNtBY_3bit2B1ENtB21_2B0EB2e_EB2e_EB2e_EB2e_EE10into_innerCsitTtQF8ArIt_8fvm_fuzz:
  242|    612|    pub unsafe fn into_inner(self) -> GenericArray<T, N> {
  243|    612|        let array = ptr::read(&self.array);
  244|    612|
  245|    612|        mem::forget(self);
  246|    612|
  247|    612|        array.assume_init()
  248|    612|    }
_RNCINvXsg_CshcIQlq3itKa_13generic_arrayINtB8_12GenericArrayhINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIBX_IBX_IBX_IBX_IBX_NtBZ_5UTermNtNtB11_3bit2B1ENtB24_2B0EB2i_EB2i_EB2i_EB2i_EEINtNtB8_8sequence15GenericSequencehE8generateNCNvXNtB8_5implsBB_NtNtCshM4Il2Z0i4R_4core7default7Default7default0E0CsitTtQF8ArIt_8fvm_fuzz:
  389|  19.5k|                destination_iter.enumerate().for_each(|(i, dst)| {
  390|  19.5k|                    ptr::write(dst, f(i));
  391|  19.5k|
  392|  19.5k|                    *position += 1;
  393|  19.5k|                });
_RNvXs8_CshcIQlq3itKa_13generic_arrayINtB5_12GenericArrayhINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIBU_IBU_IBU_IBU_IBU_IBU_NtBW_5UTermNtNtBY_3bit2B1ENtB25_2B0EB2i_EB2i_EB2i_EB2i_EB2i_EENtNtNtCshM4Il2Z0i4R_4core3ops5deref8DerefMut9deref_mutCsitTtQF8ArIt_8fvm_fuzz:
  202|  1.22k|    fn deref_mut(&mut self) -> &mut [T] {
  203|  1.22k|        unsafe { slice::from_raw_parts_mut(self as *mut Self as *mut T, N::USIZE) }
  204|  1.22k|    }
_RNvMs9_CshcIQlq3itKa_13generic_arrayINtB5_12ArrayBuilderhINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIBU_IBU_IBU_IBU_IBU_NtBW_5UTermNtNtBY_3bit2B1ENtB21_2B0EB2e_EB2e_EB2e_EB2e_EE3newCsitTtQF8ArIt_8fvm_fuzz:
  221|    612|    pub unsafe fn new() -> ArrayBuilder<T, N> {
  222|    612|        ArrayBuilder {
  223|    612|            array: MaybeUninit::uninit(),
  224|    612|            position: 0,
  225|    612|        }
  226|    612|    }
_RNvXs8_CshcIQlq3itKa_13generic_arrayINtB5_12GenericArrayhINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIBU_IBU_IBU_IBU_IBU_NtBW_5UTermNtNtBY_3bit2B1ENtB21_2B0EB2e_EB2e_EB2e_EB2e_EENtNtNtCshM4Il2Z0i4R_4core3ops5deref8DerefMut9deref_mutCsitTtQF8ArIt_8fvm_fuzz:
  202|  1.22k|    fn deref_mut(&mut self) -> &mut [T] {
  203|  1.22k|        unsafe { slice::from_raw_parts_mut(self as *mut Self as *mut T, N::USIZE) }
  204|  1.22k|    }
_RNvXs8_CshcIQlq3itKa_13generic_arrayINtB5_12GenericArrayhINtNtCs73OYmUaS3Ch_7typenum4uint4UIntIBU_IBU_IBU_IBU_IBU_IBU_NtBW_5UTermNtNtBY_3bit2B1ENtB25_2B0EB2i_EB2i_EB2i_EB2i_EB2i_EENtNtNtCshM4Il2Z0i4R_4core3ops5deref8DerefMut9deref_mutCshRBVfIqfJKm_13fvm_ipld_hamt:
  202|    306|    fn deref_mut(&mut self) -> &mut [T] {
  203|    306|        unsafe { slice::from_raw_parts_mut(self as *mut Self as *mut T, N::USIZE) }
  204|    306|    }

_RNvCscH7n3KCfRFF_9getrandom9getrandom:
  286|      1|pub fn getrandom(dest: &mut [u8]) -> Result<(), Error> {
  287|      1|    if dest.is_empty() {
  288|      0|        return Ok(());
  289|      1|    }
  290|      1|    imp::getrandom_inner(dest)
  291|      1|}

_RNCNvNtCscH7n3KCfRFF_9getrandom3imp15getrandom_inner0B5_:
   20|      1|        sys_fill_exact(dest, |buf| unsafe {
   21|      1|            getrandom(buf.as_mut_ptr() as *mut libc::c_void, buf.len(), 0)
   22|      1|        })
_RNvNtCscH7n3KCfRFF_9getrandom3imp22is_getrandom_available:
   28|      1|fn is_getrandom_available() -> bool {
   29|      1|    let res = unsafe { getrandom(core::ptr::null_mut(), 0, libc::GRND_NONBLOCK) };
   30|      1|    if res < 0 {
   31|      0|        match last_os_error().raw_os_error() {
   32|      0|            Some(libc::ENOSYS) => false, // No kernel support
   33|      0|            Some(libc::EPERM) => false,  // Blocked by seccomp
   34|      0|            _ => true,
   35|       |        }
   36|       |    } else {
   37|      1|        true
   38|       |    }
   39|      1|}
_RNvNtCscH7n3KCfRFF_9getrandom3imp15getrandom_inner:
   16|      1|pub fn getrandom_inner(dest: &mut [u8]) -> Result<(), Error> {
   17|      1|    // getrandom(2) was introduced in Linux 3.17
   18|      1|    static HAS_GETRANDOM: LazyBool = LazyBool::new();
   19|      1|    if HAS_GETRANDOM.unsync_init(is_getrandom_available) {
   20|      1|        sys_fill_exact(dest, |buf| unsafe {
   21|       |            getrandom(buf.as_mut_ptr() as *mut libc::c_void, buf.len(), 0)
   22|      1|        })
   23|       |    } else {
   24|      0|        use_file::getrandom_inner(dest)
   25|       |    }
   26|      1|}
_RNvNtCscH7n3KCfRFF_9getrandom3imp9getrandom:
   41|      2|unsafe fn getrandom(
   42|      2|    buf: *mut libc::c_void,
   43|      2|    buflen: libc::size_t,
   44|      2|    flags: libc::c_uint,
   45|      2|) -> libc::ssize_t {
   46|      2|    libc::syscall(libc::SYS_getrandom, buf, buflen, flags) as libc::ssize_t
   47|      2|}

_RINvMNtCscH7n3KCfRFF_9getrandom4utilNtB3_9LazyUsize11unsync_initNCINvMs_B3_NtB3_8LazyBool11unsync_initNvNtB5_3imp22is_getrandom_availableE0EB5_:
   42|      1|    pub fn unsync_init(&self, init: impl FnOnce() -> usize) -> usize {
   43|      1|        // Relaxed ordering is fine, as we only have a single atomic variable.
   44|      1|        let mut val = self.0.load(Relaxed);
   45|      1|        if val == Self::UNINIT {
   46|      1|            val = init();
   47|      1|            self.0.store(val, Relaxed);
   48|      1|        }
   49|      1|        val
   50|      1|    }
_RINvMs_NtCscH7n3KCfRFF_9getrandom4utilNtB5_8LazyBool11unsync_initNvNtB7_3imp22is_getrandom_availableEB7_:
   61|      1|    pub fn unsync_init(&self, init: impl FnOnce() -> bool) -> bool {
   62|      1|        self.0.unsync_init(|| init() as usize) != 0
   63|      1|    }
_RNCINvMs_NtCscH7n3KCfRFF_9getrandom4utilNtB7_8LazyBool11unsync_initNvNtB9_3imp22is_getrandom_availableE0B9_:
   62|      1|        self.0.unsync_init(|| init() as usize) != 0

_RINvNtCscH7n3KCfRFF_9getrandom9util_libc14sys_fill_exactNCNvNtB4_3imp15getrandom_inner0EB4_:
   61|      1|pub fn sys_fill_exact(
   62|      1|    mut buf: &mut [u8],
   63|      1|    sys_fill: impl Fn(&mut [u8]) -> libc::ssize_t,
   64|      1|) -> Result<(), Error> {
   65|      2|    while !buf.is_empty() {
   66|      1|        let res = sys_fill(buf);
   67|      1|        if res < 0 {
   68|      0|            let err = last_os_error();
   69|      0|            // We should try again if the call was interrupted.
   70|      0|            if err.raw_os_error() != Some(libc::EINTR) {
   71|      0|                return Err(err);
   72|      0|            }
   73|      1|        } else {
   74|      1|            // We don't check for EOF (ret = 0) as the data we are reading
   75|      1|            // should be an infinite stream of random bytes.
   76|      1|            buf = &mut buf[(res as usize)..];
   77|      1|        }
   78|       |    }
   79|      1|    Ok(())
   80|      1|}

_RNvXNtNtNtNtCse0eIYbiiGGk_9hashbrown3raw5inner5alloc5innerNtB2_6GlobalNtB2_9Allocator10deallocate:
   50|    408|        unsafe fn deallocate(&self, ptr: NonNull<u8>, layout: Layout) {
   51|    408|            dealloc(ptr.as_ptr(), layout);
   52|    408|        }
_RNvXNtNtNtNtCse0eIYbiiGGk_9hashbrown3raw5inner5alloc5innerNtB2_6GlobalNtB2_9Allocator8allocate:
   46|    408|        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {
   47|    408|            unsafe { NonNull::new(alloc(layout)).ok_or(()) }
   48|    408|        }
_RNvXs1_NtNtNtNtCse0eIYbiiGGk_9hashbrown3raw5inner5alloc5innerNtB5_6GlobalNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
   42|    408|    #[derive(Copy, Clone)]
_RINvNtNtNtNtCse0eIYbiiGGk_9hashbrown3raw5inner5alloc5inner8do_allocNtB2_6GlobalECs3hbrbrmFUf_8wasmtime:
   61|    408|    pub fn do_alloc<A: Allocator>(alloc: &A, layout: Layout) -> Result<NonNull<u8>, ()> {
   62|    408|        alloc.allocate(layout)
   63|    408|    }

_RNvMNtNtNtCse0eIYbiiGGk_9hashbrown3raw5inner7bitmaskNtB2_7BitMask14trailing_zeros:
   79|    816|    pub fn trailing_zeros(self) -> usize {
   80|       |        // ARM doesn't have a trailing_zeroes instruction, and instead uses
   81|       |        // reverse_bits (RBIT) + leading_zeroes (CLZ). However older ARM
   82|       |        // versions (pre-ARMv7) don't have RBIT and need to emulate it
   83|       |        // instead. Since we only have 1 bit set in each byte on ARM, we can
   84|       |        // use swap_bytes (REV) + leading_zeroes instead.
   85|      0|        if cfg!(target_arch = "arm") && BITMASK_STRIDE % 8 == 0 {
   86|      0|            self.0.swap_bytes().leading_zeros() as usize / BITMASK_STRIDE
   87|       |        } else {
   88|    816|            self.0.trailing_zeros() as usize / BITMASK_STRIDE
   89|       |        }
   90|    816|    }
_RNvMNtNtNtCse0eIYbiiGGk_9hashbrown3raw5inner7bitmaskNtB2_7BitMask14lowest_set_bit:
   56|  1.22k|    pub fn lowest_set_bit(self) -> Option<usize> {
   57|  1.22k|        if self.0 == 0 {
   58|    408|            None
   59|       |        } else {
   60|    816|            Some(unsafe { self.lowest_set_bit_nonzero() })
   61|       |        }
   62|  1.22k|    }
_RNvMNtNtNtCse0eIYbiiGGk_9hashbrown3raw5inner7bitmaskNtB2_7BitMask22lowest_set_bit_nonzero:
   73|    816|    pub unsafe fn lowest_set_bit_nonzero(self) -> usize {
   74|    816|        self.trailing_zeros()
   75|    816|    }
_RNvMNtNtNtCse0eIYbiiGGk_9hashbrown3raw5inner7bitmaskNtB2_7BitMask11any_bit_set:
   50|    408|    pub fn any_bit_set(self) -> bool {
   51|    408|        self.0 != 0
   52|    408|    }
_RNvXs_NtNtNtCse0eIYbiiGGk_9hashbrown3raw5inner7bitmaskNtB4_7BitMaskNtNtNtNtCshM4Il2Z0i4R_4core4iter6traits7collect12IntoIterator9into_iter:
  104|    408|    fn into_iter(self) -> BitMaskIter {
  105|    408|        BitMaskIter(self)
  106|    408|    }
_RNvXs0_NtNtNtCse0eIYbiiGGk_9hashbrown3raw5inner7bitmaskNtB5_11BitMaskIterNtNtNtNtCshM4Il2Z0i4R_4core4iter6traits8iterator8Iterator4next:
  117|    408|    fn next(&mut self) -> Option<usize> {
  118|    408|        let bit = self.0.lowest_set_bit()?;
  119|      0|        self.0 = self.0.remove_lowest_bit();
  120|      0|        Some(bit)
  121|    408|    }

_RNvMs0_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerNtB5_11TableLayout20calculate_layout_for:
  242|    816|    fn calculate_layout_for(self, buckets: usize) -> Option<(Layout, usize)> {
  243|    816|        debug_assert!(buckets.is_power_of_two());
  244|       |
  245|    816|        let TableLayout { size, ctrl_align } = self;
  246|       |        // Manual layout calculation since Layout methods are not yet stable.
  247|    816|        let ctrl_offset =
  248|    816|            size.checked_mul(buckets)?.checked_add(ctrl_align - 1)? & !(ctrl_align - 1);
  249|    816|        let len = ctrl_offset.checked_add(buckets + Group::WIDTH)?;
  250|       |
  251|    816|        Some((
  252|    816|            unsafe { Layout::from_size_align_unchecked(len, ctrl_align) },
  253|    816|            ctrl_offset,
  254|    816|        ))
  255|    816|    }
_RNvNtNtCse0eIYbiiGGk_9hashbrown3raw5inner23bucket_mask_to_capacity:
  212|    816|fn bucket_mask_to_capacity(bucket_mask: usize) -> usize {
  213|    816|    if bucket_mask < 8 {
  214|       |        // For tables with 1/2/4/8 buckets, we always reserve one empty slot.
  215|       |        // Keep in mind that the bucket mask is one less than the bucket count.
  216|    816|        bucket_mask
  217|       |    } else {
  218|       |        // For larger tables we reserve 12.5% of the slots as empty.
  219|      0|        ((bucket_mask + 1) / 8) * 7
  220|       |    }
  221|    816|}
_RNvNtNtCse0eIYbiiGGk_9hashbrown3raw5inner19capacity_to_buckets:
  185|    408|fn capacity_to_buckets(cap: usize) -> Option<usize> {
  186|    408|    debug_assert_ne!(cap, 0);
  187|       |
  188|       |    // For small tables we require at least 1 empty bucket so that lookups are
  189|       |    // guaranteed to terminate if an element doesn't exist in the table.
  190|    408|    if cap < 8 {
  191|       |        // We don't bother with a table size of 2 buckets since that can only
  192|       |        // hold a single element. Instead we skip directly to a 4 bucket table
  193|       |        // which can hold 3 elements.
  194|    408|        return Some(if cap < 4 { 4 } else { 8 });
  195|      0|    }
  196|       |
  197|       |    // Otherwise require 1/8 buckets to be empty (87.5% load)
  198|       |    //
  199|       |    // Be careful when modifying this, calculate_layout relies on the
  200|       |    // overflow check here.
  201|      0|    let adjusted_cap = cap.checked_mul(8)? / 7;
  202|       |
  203|       |    // Any overflows will have been caught by the checked_mul. Also, any
  204|       |    // rounding errors from the division above will be cleaned up by
  205|       |    // next_power_of_two (which can't overflow because of the previous division).
  206|      0|    Some(adjusted_cap.next_power_of_two())
  207|    408|}
_RNvNtNtCse0eIYbiiGGk_9hashbrown3raw5inner2h1:
  132|  1.22k|fn h1(hash: u64) -> usize {
  133|  1.22k|    // On 32-bit platforms we simply ignore the higher hash bits.
  134|  1.22k|    hash as usize
  135|  1.22k|}
_RNvNtNtCse0eIYbiiGGk_9hashbrown3raw5inner6likely:
   57|    408|fn likely(b: bool) -> bool {
   58|    408|    if !b {
   59|      0|        cold();
   60|    408|    }
   61|    408|    b
   62|    408|}
_RNvNtNtCse0eIYbiiGGk_9hashbrown3raw5inner2h2:
  140|    816|fn h2(hash: u64) -> u8 {
  141|    816|    // Grab the top 7 bits of the hash. While the hash is normally a full 64-bit
  142|    816|    // value, some hash functions (such as FxHash) produce a usize result
  143|    816|    // instead, which means that the top 32 bits are 0 on 32-bit platforms.
  144|    816|    let hash_len = usize::min(mem::size_of::<usize>(), mem::size_of::<u64>());
  145|    816|    let top7 = hash >> (hash_len * 8 - 7);
  146|    816|    (top7 & 0x7f) as u8 // truncation
  147|    816|}
_RNvNtNtCse0eIYbiiGGk_9hashbrown3raw5inner10is_special:
  118|    816|fn is_special(ctrl: u8) -> bool {
  119|    816|    ctrl & 0x80 != 0
  120|    816|}
_RNvNtNtCse0eIYbiiGGk_9hashbrown3raw5inner16special_is_empty:
  124|    816|fn special_is_empty(ctrl: u8) -> bool {
  125|    816|    debug_assert!(is_special(ctrl));
  126|    816|    ctrl & 0x01 != 0
  127|    816|}
_RNvNtNtCse0eIYbiiGGk_9hashbrown3raw5inner4cold:
   53|    408|fn cold() {}
_RNvNtNtCse0eIYbiiGGk_9hashbrown3raw5inner8unlikely:
   65|  1.22k|fn unlikely(b: bool) -> bool {
   66|  1.22k|    if b {
   67|    408|        cold();
   68|    816|    }
   69|  1.22k|    b
   70|  1.22k|}
_RNvNtNtCse0eIYbiiGGk_9hashbrown3raw5inner7is_full:
  112|  1.22k|fn is_full(ctrl: u8) -> bool {
  113|  1.22k|    ctrl & 0x80 == 0
  114|  1.22k|}
_RNvMs4_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerINtB5_8RawTablejE3newCs7Ei498kZF3p_3fvm:
  394|    204|    pub const fn new() -> Self {
  395|    204|        Self {
  396|    204|            table: RawTableInner::new_in(Global),
  397|    204|            marker: PhantomData,
  398|    204|        }
  399|    204|    }
_RNvMs8_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE6new_inCs7Ei498kZF3p_3fvm:
 1043|    204|    const fn new_in(alloc: A) -> Self {
 1044|    204|        Self {
 1045|    204|            // Be careful to cast the entire slice to a raw pointer.
 1046|    204|            ctrl: unsafe { NonNull::new_unchecked(Group::static_empty() as *const _ as *mut u8) },
 1047|    204|            bucket_mask: 0,
 1048|    204|            items: 0,
 1049|    204|            growth_left: 0,
 1050|    204|            alloc,
 1051|    204|        }
 1052|    204|    }
_RNvMs5_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerINtB5_8RawTablejE13drop_elementsCs3hbrbrmFUf_8wasmtime:
  595|    408|    unsafe fn drop_elements(&mut self) {
  596|    408|        if mem::needs_drop::<T>() && !self.is_empty() {
  597|      0|            for item in self.iter() {
  598|      0|                item.drop();
  599|      0|            }
  600|    408|        }
  601|    408|    }
_RNvMs9_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE10find_innerCs3hbrbrmFUf_8wasmtime:
 1169|    408|    fn find_inner(&self, hash: u64, eq: &mut dyn FnMut(usize) -> bool) -> Option<usize> {
 1170|    408|        let h2_hash = h2(hash);
 1171|    408|        let mut probe_seq = self.probe_seq(hash);
 1172|       |
 1173|       |        loop {
 1174|    408|            let group = unsafe { Group::load(self.ctrl(probe_seq.pos)) };
 1175|       |
 1176|    408|            for bit in group.match_byte(h2_hash) {
 1177|      0|                let index = (probe_seq.pos + bit) & self.bucket_mask;
 1178|      0|
 1179|      0|                if likely(eq(index)) {
 1180|      0|                    return Some(index);
 1181|      0|                }
 1182|       |            }
 1183|       |
 1184|    408|            if likely(group.match_empty().any_bit_set()) {
 1185|    408|                return None;
 1186|      0|            }
 1187|      0|
 1188|      0|            probe_seq.move_next(self.bucket_mask);
 1189|       |        }
 1190|    408|    }
_RINvMs5_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerINtB6_8RawTablejE3getNCINvNtNtCs3roF1RhYbpt_8indexmap3map4core10equivalentNtNtCsjYc3JqMxxfa_5alloc6string6StringNtCsf9ABzndBH7D_14wasmtime_types11EntityIndexB1U_E0ECs3hbrbrmFUf_8wasmtime:
  829|    408|    pub fn get(&self, hash: u64, eq: impl FnMut(&T) -> bool) -> Option<&T> {
  830|    408|        // Avoid `Option::map` because it bloats LLVM IR.
  831|    408|        match self.find(hash, eq) {
  832|      0|            Some(bucket) => Some(unsafe { bucket.as_ref() }),
  833|    408|            None => None,
  834|       |        }
  835|    408|    }
_RNvMs9_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE18is_empty_singletonCs3hbrbrmFUf_8wasmtime:
 1338|  1.02k|    fn is_empty_singleton(&self) -> bool {
 1339|  1.02k|        self.bucket_mask == 0
 1340|  1.02k|    }
_RNvMs3_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerINtB5_6BucketjE5writeCs3hbrbrmFUf_8wasmtime:
  342|    408|    pub unsafe fn write(&self, val: T) {
  343|    408|        self.as_ptr().write(val);
  344|    408|    }
_RINvMs5_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerINtB6_8RawTablejE7reserveNCINvNtNtCs3roF1RhYbpt_8indexmap3map4core8get_hashNtNtCsjYc3JqMxxfa_5alloc6string6StringNtCsf9ABzndBH7D_14wasmtime_types11EntityIndexE0ECs3hbrbrmFUf_8wasmtime:
  643|    408|    pub fn reserve(&mut self, additional: usize, hasher: impl Fn(&T) -> u64) {
  644|    408|        if additional > self.table.growth_left {
  645|       |            // Avoid `Result::unwrap_or_else` because it bloats LLVM IR.
  646|    408|            if self
  647|    408|                .reserve_rehash(additional, hasher, Fallibility::Infallible)
  648|    408|                .is_err()
  649|       |            {
  650|      0|                unsafe { hint::unreachable_unchecked() }
  651|    408|            }
  652|      0|        }
  653|    408|    }
_RNvMs9_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE12resize_innerCs3hbrbrmFUf_8wasmtime:
 1419|    408|    unsafe fn resize_inner(
 1420|    408|        &mut self,
 1421|    408|        capacity: usize,
 1422|    408|        hasher: &dyn Fn(&mut Self, usize) -> u64,
 1423|    408|        fallibility: Fallibility,
 1424|    408|        layout: TableLayout,
 1425|    408|    ) -> Result<(), TryReserveError> {
 1426|    408|        let mut new_table = self.prepare_resize(layout, capacity, fallibility)?;
 1427|       |
 1428|       |        // Copy all elements to the new table.
 1429|    408|        for i in 0..self.buckets() {
 1430|    408|            if !is_full(*self.ctrl(i)) {
 1431|    408|                continue;
 1432|      0|            }
 1433|      0|
 1434|      0|            // This may panic.
 1435|      0|            let hash = hasher(self, i);
 1436|      0|
 1437|      0|            // We can use a simpler version of insert() here since:
 1438|      0|            // - there are no DELETED entries.
 1439|      0|            // - we know there is enough space in the table.
 1440|      0|            // - all elements are unique.
 1441|      0|            let (index, _) = new_table.prepare_insert_slot(hash);
 1442|      0|
 1443|      0|            ptr::copy_nonoverlapping(
 1444|      0|                self.bucket_ptr(i, layout.size),
 1445|      0|                new_table.bucket_ptr(index, layout.size),
 1446|      0|                layout.size,
 1447|      0|            );
 1448|       |        }
 1449|       |
 1450|       |        // We successfully copied all elements without panicking. Now replace
 1451|       |        // self with the new table. The old table will have its memory freed but
 1452|       |        // the items will not be dropped (since they have been moved into the
 1453|       |        // new table).
 1454|    408|        mem::swap(self, &mut new_table);
 1455|    408|
 1456|    408|        Ok(())
 1457|    408|    }
_RNvMs3_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerINtB5_6BucketjE15from_base_indexCs3hbrbrmFUf_8wasmtime:
  294|    408|    unsafe fn from_base_index(base: NonNull<T>, index: usize) -> Self {
  295|    408|        let ptr = if mem::size_of::<T>() == 0 {
  296|       |            // won't overflow because index must be less than length
  297|      0|            (index + 1) as *mut T
  298|       |        } else {
  299|    408|            base.as_ptr().sub(index)
  300|       |        };
  301|    408|        Self {
  302|    408|            ptr: NonNull::new_unchecked(ptr),
  303|    408|        }
  304|    408|    }
_RNvMs5_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerINtB5_8RawTablejE7bucketsCs3hbrbrmFUf_8wasmtime:
  927|    408|    pub fn buckets(&self) -> usize {
  928|    408|        self.table.bucket_mask + 1
  929|    408|    }
_RNvMs5_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerINtB5_8RawTablejE6bucketCs3hbrbrmFUf_8wasmtime:
  520|    408|    pub unsafe fn bucket(&self, index: usize) -> Bucket<T> {
  521|    408|        debug_assert_ne!(self.table.bucket_mask, 0);
  522|    408|        debug_assert!(index < self.buckets());
  523|    408|        Bucket::from_base_index(self.data_end(), index)
  524|    408|    }
_RNvMs9_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE21record_item_insert_atCs3hbrbrmFUf_8wasmtime:
 1264|    408|    unsafe fn record_item_insert_at(&mut self, index: usize, old_ctrl: u8, hash: u64) {
 1265|    408|        self.growth_left -= usize::from(special_is_empty(old_ctrl));
 1266|    408|        self.set_ctrl_h2(index, hash);
 1267|    408|        self.items += 1;
 1268|    408|    }
_RNvMs9_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE22fallible_with_capacityCs3hbrbrmFUf_8wasmtime:
 1096|    408|    fn fallible_with_capacity(
 1097|    408|        alloc: A,
 1098|    408|        table_layout: TableLayout,
 1099|    408|        capacity: usize,
 1100|    408|        fallibility: Fallibility,
 1101|    408|    ) -> Result<Self, TryReserveError> {
 1102|    408|        if capacity == 0 {
 1103|      0|            Ok(Self::new_in(alloc))
 1104|       |        } else {
 1105|       |            unsafe {
 1106|    408|                let buckets =
 1107|    408|                    capacity_to_buckets(capacity).ok_or_else(|| fallibility.capacity_overflow())?;
 1108|       |
 1109|    408|                let result = Self::new_uninitialized(alloc, table_layout, buckets, fallibility)?;
 1110|    408|                result.ctrl(0).write_bytes(EMPTY, result.num_ctrl_bytes());
 1111|    408|
 1112|    408|                Ok(result)
 1113|       |            }
 1114|       |        }
 1115|    408|    }
_RNvMs9_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE17new_uninitializedCs3hbrbrmFUf_8wasmtime:
 1057|    408|    unsafe fn new_uninitialized(
 1058|    408|        alloc: A,
 1059|    408|        table_layout: TableLayout,
 1060|    408|        buckets: usize,
 1061|    408|        fallibility: Fallibility,
 1062|    408|    ) -> Result<Self, TryReserveError> {
 1063|    408|        debug_assert!(buckets.is_power_of_two());
 1064|       |
 1065|       |        // Avoid `Option::ok_or_else` because it bloats LLVM IR.
 1066|    408|        let (layout, ctrl_offset) = match table_layout.calculate_layout_for(buckets) {
 1067|    408|            Some(lco) => lco,
 1068|      0|            None => return Err(fallibility.capacity_overflow()),
 1069|       |        };
 1070|       |
 1071|       |        // We need an additional check to ensure that the allocation doesn't
 1072|       |        // exceed `isize::MAX`. We can skip this check on 64-bit systems since
 1073|       |        // such allocations will never succeed anyways.
 1074|       |        //
 1075|       |        // This mirrors what Vec does in the standard library.
 1076|    408|        if mem::size_of::<usize>() < 8 && layout.size() > isize::MAX as usize {
 1077|      0|            return Err(fallibility.capacity_overflow());
 1078|    408|        }
 1079|       |
 1080|    408|        let ptr: NonNull<u8> = match do_alloc(&alloc, layout) {
 1081|    408|            Ok(block) => block.cast(),
 1082|      0|            Err(_) => return Err(fallibility.alloc_err(layout)),
 1083|       |        };
 1084|       |
 1085|    408|        let ctrl = NonNull::new_unchecked(ptr.as_ptr().add(ctrl_offset));
 1086|    408|        Ok(Self {
 1087|    408|            ctrl,
 1088|    408|            bucket_mask: buckets - 1,
 1089|    408|            items: 0,
 1090|    408|            growth_left: bucket_mask_to_capacity(buckets - 1),
 1091|    408|            alloc,
 1092|    408|        })
 1093|    408|    }
_RNvMs5_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerINtB5_8RawTablejE12free_bucketsCs3hbrbrmFUf_8wasmtime:
  495|    408|    unsafe fn free_buckets(&mut self) {
  496|    408|        self.table.free_buckets(TableLayout::new::<T>());
  497|    408|    }
_RNvXse_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerINtB5_8RawTablejENtNtNtCshM4Il2Z0i4R_4core3ops4drop4Drop4dropCs3hbrbrmFUf_8wasmtime:
 1815|    612|    fn drop(&mut self) {
 1816|    612|        if !self.table.is_empty_singleton() {
 1817|    408|            unsafe {
 1818|    408|                self.drop_elements();
 1819|    408|                self.free_buckets();
 1820|    408|            }
 1821|    204|        }
 1822|    612|    }
_RNCNvMs9_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerINtB7_13RawTableInnerNtNtNtB7_5alloc5inner6GlobalE14prepare_resize0Cs3hbrbrmFUf_8wasmtime:
 1368|    408|        Ok(guard(new_table, move |self_| {
 1369|    408|            if !self_.is_empty_singleton() {
 1370|      0|                self_.free_buckets(table_layout);
 1371|    408|            }
 1372|    408|        }))
_RNvMs5_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerINtB5_8RawTablejE8data_endCs3hbrbrmFUf_8wasmtime:
  501|    408|    pub unsafe fn data_end(&self) -> NonNull<T> {
  502|    408|        NonNull::new_unchecked(self.table.ctrl.as_ptr().cast())
  503|    408|    }
_RINvMs5_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerINtB6_8RawTablejE6insertNCINvNtNtCs3roF1RhYbpt_8indexmap3map4core8get_hashNtNtCsjYc3JqMxxfa_5alloc6string6StringNtCsf9ABzndBH7D_14wasmtime_types11EntityIndexE0ECs3hbrbrmFUf_8wasmtime:
  716|    408|    pub fn insert(&mut self, hash: u64, value: T, hasher: impl Fn(&T) -> u64) -> Bucket<T> {
  717|    408|        unsafe {
  718|    408|            let mut index = self.table.find_insert_slot(hash);
  719|    408|
  720|    408|            // We can avoid growing the table once we have reached our load
  721|    408|            // factor if we are replacing a tombstone. This works since the
  722|    408|            // number of EMPTY slots does not change in this case.
  723|    408|            let old_ctrl = *self.table.ctrl(index);
  724|    408|            if unlikely(self.table.growth_left == 0 && special_is_empty(old_ctrl)) {
  725|    408|                self.reserve(1, hasher);
  726|    408|                index = self.table.find_insert_slot(hash);
  727|    408|            }
  728|       |
  729|    408|            self.table.record_item_insert_at(index, old_ctrl, hash);
  730|    408|
  731|    408|            let bucket = self.bucket(index);
  732|    408|            bucket.write(value);
  733|    408|            bucket
  734|    408|        }
  735|    408|    }
_RNvMs9_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE11set_ctrl_h2Cs3hbrbrmFUf_8wasmtime:
 1281|    408|    unsafe fn set_ctrl_h2(&self, index: usize, hash: u64) {
 1282|    408|        self.set_ctrl(index, h2(hash));
 1283|    408|    }
_RNvMs9_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE14num_ctrl_bytesCs3hbrbrmFUf_8wasmtime:
 1333|  4.48k|    fn num_ctrl_bytes(&self) -> usize {
 1334|  4.48k|        self.bucket_mask + 1 + Group::WIDTH
 1335|  4.48k|    }
_RNvMs3_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerINtB5_6BucketjE6as_ptrCs3hbrbrmFUf_8wasmtime:
  314|    408|    pub fn as_ptr(&self) -> *mut T {
  315|    408|        if mem::size_of::<T>() == 0 {
  316|       |            // Just return an arbitrary ZST pointer which is properly aligned
  317|      0|            mem::align_of::<T>() as *mut T
  318|       |        } else {
  319|    408|            unsafe { self.ptr.as_ptr().sub(1) }
  320|       |        }
  321|    408|    }
_RNvMs9_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE7bucketsCs3hbrbrmFUf_8wasmtime:
 1328|    816|    fn buckets(&self) -> usize {
 1329|    816|        self.bucket_mask + 1
 1330|    816|    }
_RNvMs5_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerINtB5_8RawTablejE8capacityCs3hbrbrmFUf_8wasmtime:
  909|    408|    pub fn capacity(&self) -> usize {
  910|    408|        self.table.items + self.table.growth_left
  911|    408|    }
_RNvMs9_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE4ctrlCs3hbrbrmFUf_8wasmtime:
 1322|  4.08k|    unsafe fn ctrl(&self, index: usize) -> *mut u8 {
 1323|  4.08k|        debug_assert!(index < self.num_ctrl_bytes());
 1324|  4.08k|        self.ctrl.as_ptr().add(index)
 1325|  4.08k|    }
_RINvMs0_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerNtB6_11TableLayout3newjECs3hbrbrmFUf_8wasmtime:
  233|    816|    fn new<T>() -> Self {
  234|    816|        let layout = Layout::new::<T>();
  235|    816|        Self {
  236|    816|            size: layout.size(),
  237|    816|            ctrl_align: usize::max(layout.align(), Group::WIDTH),
  238|    816|        }
  239|    816|    }
_RNvMs9_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE16find_insert_slotCs3hbrbrmFUf_8wasmtime:
 1134|    816|    fn find_insert_slot(&self, hash: u64) -> usize {
 1135|    816|        let mut probe_seq = self.probe_seq(hash);
 1136|       |        loop {
 1137|       |            unsafe {
 1138|    816|                let group = Group::load(self.ctrl(probe_seq.pos));
 1139|    816|                if let Some(bit) = group.match_empty_or_deleted().lowest_set_bit() {
 1140|    816|                    let result = (probe_seq.pos + bit) & self.bucket_mask;
 1141|    816|
 1142|    816|                    // In tables smaller than the group width, trailing control
 1143|    816|                    // bytes outside the range of the table are filled with
 1144|    816|                    // EMPTY entries. These will unfortunately trigger a
 1145|    816|                    // match, but once masked may point to a full bucket that
 1146|    816|                    // is already occupied. We detect this situation here and
 1147|    816|                    // perform a second scan starting at the beginning of the
 1148|    816|                    // table. This second scan is guaranteed to find an empty
 1149|    816|                    // slot (due to the load factor) before hitting the trailing
 1150|    816|                    // control bytes (containing EMPTY).
 1151|    816|                    if unlikely(is_full(*self.ctrl(result))) {
 1152|      0|                        debug_assert!(self.bucket_mask < Group::WIDTH);
 1153|      0|                        debug_assert_ne!(probe_seq.pos, 0);
 1154|      0|                        return Group::load_aligned(self.ctrl(0))
 1155|      0|                            .match_empty_or_deleted()
 1156|      0|                            .lowest_set_bit_nonzero();
 1157|    816|                    }
 1158|    816|
 1159|    816|                    return result;
 1160|      0|                }
 1161|      0|            }
 1162|      0|            probe_seq.move_next(self.bucket_mask);
 1163|       |        }
 1164|    816|    }
_RNvMs9_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE9probe_seqCs3hbrbrmFUf_8wasmtime:
 1241|  1.22k|    fn probe_seq(&self, hash: u64) -> ProbeSeq {
 1242|  1.22k|        ProbeSeq {
 1243|  1.22k|            pos: h1(hash) & self.bucket_mask,
 1244|  1.22k|            stride: 0,
 1245|  1.22k|        }
 1246|  1.22k|    }
_RNvMs9_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE8set_ctrlCs3hbrbrmFUf_8wasmtime:
 1295|    408|    unsafe fn set_ctrl(&self, index: usize, ctrl: u8) {
 1296|    408|        // Replicate the first Group::WIDTH control bytes at the end of
 1297|    408|        // the array without using a branch:
 1298|    408|        // - If index >= Group::WIDTH then index == index2.
 1299|    408|        // - Otherwise index2 == self.bucket_mask + 1 + index.
 1300|    408|        //
 1301|    408|        // The very last replicated control byte is never actually read because
 1302|    408|        // we mask the initial index for unaligned loads, but we write it
 1303|    408|        // anyways because it makes the set_ctrl implementation simpler.
 1304|    408|        //
 1305|    408|        // If there are fewer buckets than Group::WIDTH then this code will
 1306|    408|        // replicate the buckets at the end of the trailing group. For example
 1307|    408|        // with 2 buckets and a group size of 4, the control bytes will look
 1308|    408|        // like this:
 1309|    408|        //
 1310|    408|        //     Real    |             Replicated
 1311|    408|        // ---------------------------------------------
 1312|    408|        // | [A] | [B] | [EMPTY] | [EMPTY] | [A] | [B] |
 1313|    408|        // ---------------------------------------------
 1314|    408|        let index2 = ((index.wrapping_sub(Group::WIDTH)) & self.bucket_mask) + Group::WIDTH;
 1315|    408|
 1316|    408|        *self.ctrl(index) = ctrl;
 1317|    408|        *self.ctrl(index2) = ctrl;
 1318|    408|    }
_RNvMs9_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE12free_bucketsCs3hbrbrmFUf_8wasmtime:
 1549|    408|    unsafe fn free_buckets(&mut self, table_layout: TableLayout) {
 1550|       |        // Avoid `Option::unwrap_or_else` because it bloats LLVM IR.
 1551|    408|        let (layout, ctrl_offset) = match table_layout.calculate_layout_for(self.buckets()) {
 1552|    408|            Some(lco) => lco,
 1553|      0|            None => hint::unreachable_unchecked(),
 1554|       |        };
 1555|    408|        self.alloc.deallocate(
 1556|    408|            NonNull::new_unchecked(self.ctrl.as_ptr().sub(ctrl_offset)),
 1557|    408|            layout,
 1558|    408|        );
 1559|    408|    }
_RNvMs9_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE20reserve_rehash_innerCs3hbrbrmFUf_8wasmtime:
 1381|    408|    unsafe fn reserve_rehash_inner(
 1382|    408|        &mut self,
 1383|    408|        additional: usize,
 1384|    408|        hasher: &dyn Fn(&mut Self, usize) -> u64,
 1385|    408|        fallibility: Fallibility,
 1386|    408|        layout: TableLayout,
 1387|    408|        drop: Option<fn(*mut u8)>,
 1388|    408|    ) -> Result<(), TryReserveError> {
 1389|       |        // Avoid `Option::ok_or_else` because it bloats LLVM IR.
 1390|    408|        let new_items = match self.items.checked_add(additional) {
 1391|    408|            Some(new_items) => new_items,
 1392|      0|            None => return Err(fallibility.capacity_overflow()),
 1393|       |        };
 1394|    408|        let full_capacity = bucket_mask_to_capacity(self.bucket_mask);
 1395|    408|        if new_items <= full_capacity / 2 {
 1396|       |            // Rehash in-place without re-allocating if we have plenty of spare
 1397|       |            // capacity that is locked up due to DELETED entries.
 1398|      0|            self.rehash_in_place(hasher, layout.size, drop);
 1399|      0|            Ok(())
 1400|       |        } else {
 1401|       |            // Otherwise, conservatively resize to at least the next size up
 1402|       |            // to avoid churning deletes into frequent rehashes.
 1403|    408|            self.resize_inner(
 1404|    408|                usize::max(new_items, full_capacity + 1),
 1405|    408|                hasher,
 1406|    408|                fallibility,
 1407|    408|                layout,
 1408|    408|            )
 1409|       |        }
 1410|    408|    }
_RINvMs5_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerINtB6_8RawTablejE14reserve_rehashNCINvNtNtCs3roF1RhYbpt_8indexmap3map4core8get_hashNtNtCsjYc3JqMxxfa_5alloc6string6StringNtCsf9ABzndBH7D_14wasmtime_types11EntityIndexE0ECs3hbrbrmFUf_8wasmtime:
  681|    408|                additional,
  682|    408|                &|table, index| hasher(table.bucket::<T>(index).as_ref()),
  683|    408|                fallibility,
  684|    408|                TableLayout::new::<T>(),
  685|    408|                if mem::needs_drop::<T>() {
  686|      0|                    Some(mem::transmute(ptr::drop_in_place::<T> as unsafe fn(*mut T)))
  687|       |                } else {
  688|    408|                    None
  689|       |                },
  690|       |            )
  691|       |        }
  692|    408|    }
_RNvMs9_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE14prepare_resizeCs3hbrbrmFUf_8wasmtime:
 1344|    408|    unsafe fn prepare_resize(
 1345|    408|        &self,
 1346|    408|        table_layout: TableLayout,
 1347|    408|        capacity: usize,
 1348|    408|        fallibility: Fallibility,
 1349|    408|    ) -> Result<crate::scopeguard::ScopeGuard<Self, impl FnMut(&mut Self)>, TryReserveError> {
 1350|    408|        debug_assert!(self.items <= capacity);
 1351|       |
 1352|       |        // Allocate and initialize the new table.
 1353|    408|        let mut new_table = RawTableInner::fallible_with_capacity(
 1354|    408|            self.alloc.clone(),
 1355|    408|            table_layout,
 1356|    408|            capacity,
 1357|    408|            fallibility,
 1358|    408|        )?;
 1359|    408|        new_table.growth_left -= self.items;
 1360|    408|        new_table.items = self.items;
 1361|    408|
 1362|    408|        // The hash function may panic, in which case we simply free the new
 1363|    408|        // table without dropping any elements that may have been copied into
 1364|    408|        // it.
 1365|    408|        //
 1366|    408|        // This guard is also used to free the old table on success, see
 1367|    408|        // the comment at the bottom of this function.
 1368|    408|        Ok(guard(new_table, move |self_| {
 1369|       |            if !self_.is_empty_singleton() {
 1370|       |                self_.free_buckets(table_layout);
 1371|       |            }
 1372|    408|        }))
 1373|    408|    }
_RINvMs5_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerINtB6_8RawTablejE4findNCINvNtNtCs3roF1RhYbpt_8indexmap3map4core10equivalentNtNtCsjYc3JqMxxfa_5alloc6string6StringNtCsf9ABzndBH7D_14wasmtime_types11EntityIndexB1V_E0ECs3hbrbrmFUf_8wasmtime:
  815|    408|    pub fn find(&self, hash: u64, mut eq: impl FnMut(&T) -> bool) -> Option<Bucket<T>> {
  816|    408|        let result = self.table.find_inner(hash, &mut |index| unsafe {
  817|       |            eq(self.bucket(index).as_ref())
  818|    408|        });
  819|    408|
  820|    408|        // Avoid `Option::map` because it bloats LLVM IR.
  821|    408|        match result {
  822|      0|            Some(index) => Some(unsafe { self.bucket(index) }),
  823|    408|            None => None,
  824|       |        }
  825|    408|    }
_RNvMs4_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerINtB5_8RawTablejE3newCshaNIPJAj9Ao_16wasmtime_environ:
  394|    408|    pub const fn new() -> Self {
  395|    408|        Self {
  396|    408|            table: RawTableInner::new_in(Global),
  397|    408|            marker: PhantomData,
  398|    408|        }
  399|    408|    }
_RNvMs8_NtNtCse0eIYbiiGGk_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE6new_inCshaNIPJAj9Ao_16wasmtime_environ:
 1043|    408|    const fn new_in(alloc: A) -> Self {
 1044|    408|        Self {
 1045|    408|            // Be careful to cast the entire slice to a raw pointer.
 1046|    408|            ctrl: unsafe { NonNull::new_unchecked(Group::static_empty() as *const _ as *mut u8) },
 1047|    408|            bucket_mask: 0,
 1048|    408|            items: 0,
 1049|    408|            growth_left: 0,
 1050|    408|            alloc,
 1051|    408|        }
 1052|    408|    }

_RNvMNtNtNtCse0eIYbiiGGk_9hashbrown3raw5inner4sse2NtB2_5Group12static_empty:
   33|    612|    pub const fn static_empty() -> &'static [u8; Group::WIDTH] {
   34|    612|        #[repr(C)]
   35|    612|        struct AlignedBytes {
   36|    612|            _align: [Group; 0],
   37|    612|            bytes: [u8; Group::WIDTH],
   38|    612|        }
   39|    612|        const ALIGNED_BYTES: AlignedBytes = AlignedBytes {
   40|    612|            _align: [],
   41|    612|            bytes: [EMPTY; Group::WIDTH],
   42|    612|        };
   43|    612|        &ALIGNED_BYTES.bytes
   44|    612|    }
_RNvMNtNtNtCse0eIYbiiGGk_9hashbrown3raw5inner4sse2NtB2_5Group22match_empty_or_deleted:
  101|    816|    pub fn match_empty_or_deleted(self) -> BitMask {
  102|    816|        #[allow(
  103|    816|            // byte: i32 as u16
  104|    816|            //   note: _mm_movemask_epi8 returns a 16-bit mask in a i32, the
  105|    816|            //   upper 16-bits of the i32 are zeroed:
  106|    816|            clippy::cast_sign_loss,
  107|    816|            clippy::cast_possible_truncation
  108|    816|        )]
  109|    816|        unsafe {
  110|    816|            // A byte is EMPTY or DELETED iff the high bit is set
  111|    816|            BitMask(x86::_mm_movemask_epi8(self.0) as u16)
  112|    816|        }
  113|    816|    }
_RNvMNtNtNtCse0eIYbiiGGk_9hashbrown3raw5inner4sse2NtB2_5Group11match_empty:
   94|    408|    pub fn match_empty(self) -> BitMask {
   95|    408|        self.match_byte(EMPTY)
   96|    408|    }
_RNvMNtNtNtCse0eIYbiiGGk_9hashbrown3raw5inner4sse2NtB2_5Group10match_byte:
   76|    816|    pub fn match_byte(self, byte: u8) -> BitMask {
   77|    816|        #[allow(
   78|    816|            clippy::cast_possible_wrap, // byte: u8 as i8
   79|    816|            // byte: i32 as u16
   80|    816|            //   note: _mm_movemask_epi8 returns a 16-bit mask in a i32, the
   81|    816|            //   upper 16-bits of the i32 are zeroed:
   82|    816|            clippy::cast_sign_loss,
   83|    816|            clippy::cast_possible_truncation
   84|    816|        )]
   85|    816|        unsafe {
   86|    816|            let cmp = x86::_mm_cmpeq_epi8(self.0, x86::_mm_set1_epi8(byte as i8));
   87|    816|            BitMask(x86::_mm_movemask_epi8(cmp) as u16)
   88|    816|        }
   89|    816|    }
_RNvMNtNtNtCse0eIYbiiGGk_9hashbrown3raw5inner4sse2NtB2_5Group4load:
   49|  1.22k|    pub unsafe fn load(ptr: *const u8) -> Self {
   50|  1.22k|        Group(x86::_mm_loadu_si128(ptr.cast()))
   51|  1.22k|    }

_RNvXs1_NtCse0eIYbiiGGk_9hashbrown10scopeguardINtB5_10ScopeGuardINtNtNtB7_3raw5inner13RawTableInnerNtNtNtB12_5alloc5inner6GlobalENCNvMs9_B12_BZ_14prepare_resize0ENtNtNtCshM4Il2Z0i4R_4core3ops4drop4Drop4dropCs3hbrbrmFUf_8wasmtime:
   71|    408|    fn drop(&mut self) {
   72|    408|        (self.dropfn)(&mut self.value);
   73|    408|    }
_RNvXs0_NtCse0eIYbiiGGk_9hashbrown10scopeguardINtB5_10ScopeGuardINtNtNtB7_3raw5inner13RawTableInnerNtNtNtB12_5alloc5inner6GlobalENCNvMs9_B12_BZ_14prepare_resize0ENtNtNtCshM4Il2Z0i4R_4core3ops5deref8DerefMut9deref_mutCs3hbrbrmFUf_8wasmtime:
   61|    408|    fn deref_mut(&mut self) -> &mut T {
   62|    408|        &mut self.value
   63|    408|    }
_RINvNtCse0eIYbiiGGk_9hashbrown10scopeguard5guardINtNtNtB4_3raw5inner13RawTableInnerNtNtNtBN_5alloc5inner6GlobalENCNvMs9_BN_BK_14prepare_resize0ECs3hbrbrmFUf_8wasmtime:
   17|    408|pub fn guard<T, F>(value: T, dropfn: F) -> ScopeGuard<T, F>
   18|    408|where
   19|    408|    F: FnMut(&mut T),
   20|    408|{
   21|    408|    ScopeGuard { dropfn, value }
   22|    408|}

_RNvXsa_NtCs7MaeCn23RYF_9humantime4dateNtB5_9PrecisionNtNtCshM4Il2Z0i4R_4core3cmp9PartialEq2eq:
   58|  66.5k|#[derive(Debug, Clone, PartialEq, Eq)]
_RNvNtCs7MaeCn23RYF_9humantime4date22format_rfc3339_seconds:
  212|  66.5k|pub fn format_rfc3339_seconds(system_time: SystemTime) -> Rfc3339Timestamp {
  213|  66.5k|    Rfc3339Timestamp(system_time, Precision::Seconds)
  214|  66.5k|}
_RNvXs1_NtCs7MaeCn23RYF_9humantime4dateNtB5_16Rfc3339TimestampNtNtCshM4Il2Z0i4R_4core3fmt7Display3fmt:
  251|  66.5k|    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
  252|  66.5k|        use self::Precision::*;
  253|  66.5k|
  254|  66.5k|        let dur = self.0.duration_since(UNIX_EPOCH)
  255|  66.5k|            .expect("all times should be after the epoch");
  256|  66.5k|        let secs_since_epoch = dur.as_secs();
  257|  66.5k|        let nanos = dur.subsec_nanos();
  258|  66.5k|
  259|  66.5k|        if secs_since_epoch >= 253_402_300_800 { // year 9999
  260|      0|            return Err(fmt::Error);
  261|  66.5k|        }
  262|  66.5k|
  263|  66.5k|        /* 2000-03-01 (mod 400 year, immediately after feb29 */
  264|  66.5k|        const LEAPOCH: i64 = 11017;
  265|  66.5k|        const DAYS_PER_400Y: i64 = 365*400 + 97;
  266|  66.5k|        const DAYS_PER_100Y: i64 = 365*100 + 24;
  267|  66.5k|        const DAYS_PER_4Y: i64 = 365*4 + 1;
  268|  66.5k|
  269|  66.5k|        let days = (secs_since_epoch / 86400) as i64 - LEAPOCH;
  270|  66.5k|        let secs_of_day = secs_since_epoch % 86400;
  271|  66.5k|
  272|  66.5k|        let mut qc_cycles = days / DAYS_PER_400Y;
  273|  66.5k|        let mut remdays = days % DAYS_PER_400Y;
  274|  66.5k|
  275|  66.5k|        if remdays < 0 {
  276|      0|            remdays += DAYS_PER_400Y;
  277|      0|            qc_cycles -= 1;
  278|  66.5k|        }
  279|       |
  280|  66.5k|        let mut c_cycles = remdays / DAYS_PER_100Y;
  281|  66.5k|        if c_cycles == 4 { c_cycles -= 1; }
  282|  66.5k|        remdays -= c_cycles * DAYS_PER_100Y;
  283|  66.5k|
  284|  66.5k|        let mut q_cycles = remdays / DAYS_PER_4Y;
  285|  66.5k|        if q_cycles == 25 { q_cycles -= 1; }
  286|  66.5k|        remdays -= q_cycles * DAYS_PER_4Y;
  287|  66.5k|
  288|  66.5k|        let mut remyears = remdays / 365;
  289|  66.5k|        if remyears == 4 { remyears -= 1; }
  290|  66.5k|        remdays -= remyears * 365;
  291|  66.5k|
  292|  66.5k|        let mut year = 2000 +
  293|  66.5k|            remyears + 4*q_cycles + 100*c_cycles + 400*qc_cycles;
  294|  66.5k|
  295|  66.5k|        let months = [31,30,31,30,31,31,30,31,30,31,31,29];
  296|  66.5k|        let mut mon = 0;
  297|   665k|        for mon_len in months.iter() {
  298|   665k|            mon += 1;
  299|   665k|            if remdays < *mon_len {
  300|  66.5k|                break;
  301|   598k|            }
  302|   598k|            remdays -= *mon_len;
  303|       |        }
  304|  66.5k|        let mday = remdays+1;
  305|  66.5k|        let mon = if mon + 2 > 12 {
  306|      0|            year += 1;
  307|      0|            mon - 10
  308|       |        } else {
  309|  66.5k|            mon + 2
  310|       |        };
  311|       |
  312|  66.5k|        let mut buf: [u8; 30] = [
  313|  66.5k|            // Too long to write as: b"0000-00-00T00:00:00.000000000Z"
  314|  66.5k|            b'0', b'0', b'0', b'0', b'-', b'0', b'0', b'-', b'0', b'0', b'T',
  315|  66.5k|            b'0', b'0', b':', b'0', b'0', b':', b'0', b'0',
  316|  66.5k|            b'.', b'0', b'0', b'0', b'0', b'0', b'0', b'0', b'0', b'0', b'Z',
  317|  66.5k|        ];
  318|  66.5k|        buf[0] = b'0' + (year / 1000) as u8;
  319|  66.5k|        buf[1] = b'0' + (year / 100 % 10) as u8;
  320|  66.5k|        buf[2] = b'0' + (year / 10 % 10) as u8;
  321|  66.5k|        buf[3] = b'0' + (year % 10) as u8;
  322|  66.5k|        buf[5] = b'0' + (mon / 10) as u8;
  323|  66.5k|        buf[6] = b'0' + (mon % 10) as u8;
  324|  66.5k|        buf[8] = b'0' + (mday / 10) as u8;
  325|  66.5k|        buf[9] = b'0' + (mday % 10) as u8;
  326|  66.5k|        buf[11] = b'0' + (secs_of_day / 3600 / 10) as u8;
  327|  66.5k|        buf[12] = b'0' + (secs_of_day / 3600 % 10) as u8;
  328|  66.5k|        buf[14] = b'0' + (secs_of_day / 60 / 10 % 6) as u8;
  329|  66.5k|        buf[15] = b'0' + (secs_of_day / 60 % 10) as u8;
  330|  66.5k|        buf[17] = b'0' + (secs_of_day / 10 % 6) as u8;
  331|  66.5k|        buf[18] = b'0' + (secs_of_day % 10) as u8;
  332|       |
  333|  66.5k|        let offset = if self.1 == Seconds || nanos == 0 && self.1 == Smart {
  334|  66.5k|            buf[19] = b'Z';
  335|  66.5k|            19
  336|      0|        } else if self.1 == Millis {
  337|      0|            buf[20] = b'0' + (nanos / 100_000_000) as u8;
  338|      0|            buf[21] = b'0' + (nanos / 10_000_000 % 10) as u8;
  339|      0|            buf[22] = b'0' + (nanos / 1_000_000 % 10) as u8;
  340|      0|            buf[23] = b'Z';
  341|      0|            23
  342|      0|        } else if self.1 == Micros {
  343|      0|            buf[20] = b'0' + (nanos / 100_000_000) as u8;
  344|      0|            buf[21] = b'0' + (nanos / 10_000_000 % 10) as u8;
  345|      0|            buf[22] = b'0' + (nanos / 1_000_000 % 10) as u8;
  346|      0|            buf[23] = b'0' + (nanos / 100_000 % 10) as u8;
  347|      0|            buf[24] = b'0' + (nanos / 10_000 % 10) as u8;
  348|      0|            buf[25] = b'0' + (nanos / 1_000 % 10) as u8;
  349|      0|            buf[26] = b'Z';
  350|      0|            26
  351|       |        } else {
  352|      0|            buf[20] = b'0' + (nanos / 100_000_000) as u8;
  353|      0|            buf[21] = b'0' + (nanos / 10_000_000 % 10) as u8;
  354|      0|            buf[22] = b'0' + (nanos / 1_000_000 % 10) as u8;
  355|      0|            buf[23] = b'0' + (nanos / 100_000 % 10) as u8;
  356|      0|            buf[24] = b'0' + (nanos / 10_000 % 10) as u8;
  357|      0|            buf[25] = b'0' + (nanos / 1_000 % 10) as u8;
  358|      0|            buf[26] = b'0' + (nanos / 100 % 10) as u8;
  359|      0|            buf[27] = b'0' + (nanos / 10 % 10) as u8;
  360|      0|            buf[28] = b'0' + (nanos / 1 % 10) as u8;
  361|      0|            // 29th is 'Z'
  362|      0|            29
  363|       |        };
  364|       |
  365|       |        // we know our chars are all ascii
  366|  66.5k|        f.write_str(str::from_utf8(&buf[..=offset]).expect("Conversion to utf8 failed"))
  367|  66.5k|    }

_RNvMCs3roF1RhYbpt_8indexmapNtB2_9HashValue3get:
  123|    816|    fn get(self) -> u64 {
  124|    816|        self.0 as u64
  125|    816|    }

_RNvMs2_NtCs3roF1RhYbpt_8indexmap3mapINtB5_8IndexMapNtNtCsjYc3JqMxxfa_5alloc6string6StringNtCsf9ABzndBH7D_14wasmtime_types11EntityIndexE11with_hasherCs7Ei498kZF3p_3fvm:
  182|    204|    pub const fn with_hasher(hash_builder: S) -> Self {
  183|    204|        IndexMap {
  184|    204|            core: IndexMapCore::new(),
  185|    204|            hash_builder,
  186|    204|        }
  187|    204|    }
_RNvMs2_NtCs3roF1RhYbpt_8indexmap3mapINtB5_8IndexMapNtNtCsjYc3JqMxxfa_5alloc6string6StringNtCsf9ABzndBH7D_14wasmtime_types11EntityIndexE24with_capacity_and_hasherCs7Ei498kZF3p_3fvm:
  167|    204|    pub fn with_capacity_and_hasher(n: usize, hash_builder: S) -> Self {
  168|    204|        if n == 0 {
  169|    204|            Self::with_hasher(hash_builder)
  170|       |        } else {
  171|      0|            IndexMap {
  172|      0|                core: IndexMapCore::with_capacity(n),
  173|      0|                hash_builder,
  174|      0|            }
  175|       |        }
  176|    204|    }
_RNvXs12_NtCs3roF1RhYbpt_8indexmap3mapINtB6_8IndexMapNtNtCsjYc3JqMxxfa_5alloc6string6StringNtCsf9ABzndBH7D_14wasmtime_types11EntityIndexENtNtCshM4Il2Z0i4R_4core7default7Default7defaultCs7Ei498kZF3p_3fvm:
 1495|    204|    fn default() -> Self {
 1496|    204|        Self::with_capacity_and_hasher(0, S::default())
 1497|    204|    }
_RNvMs3_NtCs3roF1RhYbpt_8indexmap3mapINtB5_8IndexMapNtNtCsjYc3JqMxxfa_5alloc6string6StringNtCsf9ABzndBH7D_14wasmtime_types11EntityIndexE6insertCs3hbrbrmFUf_8wasmtime:
  364|    408|    pub fn insert(&mut self, key: K, value: V) -> Option<V> {
  365|    408|        self.insert_full(key, value).1
  366|    408|    }
_RINvMs3_NtCs3roF1RhYbpt_8indexmap3mapINtB6_8IndexMapNtNtCsjYc3JqMxxfa_5alloc6string6StringNtCsf9ABzndBH7D_14wasmtime_types11EntityIndexE4hashBO_ECs3hbrbrmFUf_8wasmtime:
  345|    408|    fn hash<Q: ?Sized + Hash>(&self, key: &Q) -> HashValue {
  346|    408|        let mut h = self.hash_builder.build_hasher();
  347|    408|        key.hash(&mut h);
  348|    408|        HashValue(h.finish() as usize)
  349|    408|    }
_RNvMs3_NtCs3roF1RhYbpt_8indexmap3mapINtB5_8IndexMapNtNtCsjYc3JqMxxfa_5alloc6string6StringNtCsf9ABzndBH7D_14wasmtime_types11EntityIndexE11insert_fullCs3hbrbrmFUf_8wasmtime:
  381|    408|    pub fn insert_full(&mut self, key: K, value: V) -> (usize, Option<V>) {
  382|    408|        let hash = self.hash(&key);
  383|    408|        self.core.insert_full(hash, key, value)
  384|    408|    }
_RNvMs2_NtCs3roF1RhYbpt_8indexmap3mapINtB5_8IndexMapNtNtCsjYc3JqMxxfa_5alloc6string6StringNtCsf9ABzndBH7D_14wasmtime_types11EntityIndexE11with_hasherCshaNIPJAj9Ao_16wasmtime_environ:
  182|    408|    pub const fn with_hasher(hash_builder: S) -> Self {
  183|    408|        IndexMap {
  184|    408|            core: IndexMapCore::new(),
  185|    408|            hash_builder,
  186|    408|        }
  187|    408|    }
_RNvXs12_NtCs3roF1RhYbpt_8indexmap3mapINtB6_8IndexMapNtNtCsjYc3JqMxxfa_5alloc6string6StringNtCsf9ABzndBH7D_14wasmtime_types11EntityIndexENtNtCshM4Il2Z0i4R_4core7default7Default7defaultCshaNIPJAj9Ao_16wasmtime_environ:
 1495|    408|    fn default() -> Self {
 1496|    408|        Self::with_capacity_and_hasher(0, S::default())
 1497|    408|    }
_RNvMs2_NtCs3roF1RhYbpt_8indexmap3mapINtB5_8IndexMapNtNtCsjYc3JqMxxfa_5alloc6string6StringNtCsf9ABzndBH7D_14wasmtime_types11EntityIndexE24with_capacity_and_hasherCshaNIPJAj9Ao_16wasmtime_environ:
  167|    408|    pub fn with_capacity_and_hasher(n: usize, hash_builder: S) -> Self {
  168|    408|        if n == 0 {
  169|    408|            Self::with_hasher(hash_builder)
  170|       |        } else {
  171|      0|            IndexMap {
  172|      0|                core: IndexMapCore::with_capacity(n),
  173|      0|                hash_builder,
  174|      0|            }
  175|       |        }
  176|    408|    }

_RNvMs1_NtNtCs3roF1RhYbpt_8indexmap3map4coreINtB5_12IndexMapCoreNtNtCsjYc3JqMxxfa_5alloc6string6StringNtCsf9ABzndBH7D_14wasmtime_types11EntityIndexE3newCs7Ei498kZF3p_3fvm:
  124|    204|    pub(crate) const fn new() -> Self {
  125|    204|        IndexMapCore {
  126|    204|            indices: RawTable::new(),
  127|    204|            entries: Vec::new(),
  128|    204|        }
  129|    204|    }
_RNvMs1_NtNtCs3roF1RhYbpt_8indexmap3map4coreINtB5_12IndexMapCoreNtNtCsjYc3JqMxxfa_5alloc6string6StringNtCsf9ABzndBH7D_14wasmtime_types11EntityIndexE15reserve_entriesCs3hbrbrmFUf_8wasmtime:
  200|    408|    fn reserve_entries(&mut self) {
  201|    408|        let additional = self.indices.capacity() - self.entries.len();
  202|    408|        self.entries.reserve_exact(additional);
  203|    408|    }
_RINvNtNtCs3roF1RhYbpt_8indexmap3map4core8get_hashNtNtCsjYc3JqMxxfa_5alloc6string6StringNtCsf9ABzndBH7D_14wasmtime_types11EntityIndexECs3hbrbrmFUf_8wasmtime:
   33|    408|fn get_hash<K, V>(entries: &[Bucket<K, V>]) -> impl Fn(&usize) -> u64 + '_ {
   34|       |    move |&i| entries[i].hash.get()
   35|    408|}
_RINvNtNtCs3roF1RhYbpt_8indexmap3map4core10equivalentNtNtCsjYc3JqMxxfa_5alloc6string6StringNtCsf9ABzndBH7D_14wasmtime_types11EntityIndexBO_ECs3hbrbrmFUf_8wasmtime:
   38|    408|fn equivalent<'a, K, V, Q: ?Sized + Equivalent<K>>(
   39|    408|    key: &'a Q,
   40|    408|    entries: &'a [Bucket<K, V>],
   41|    408|) -> impl Fn(&usize) -> bool + 'a {
   42|       |    move |&i| Q::equivalent(key, &entries[i].key)
   43|    408|}
_RNvMs1_NtNtCs3roF1RhYbpt_8indexmap3map4coreINtB5_12IndexMapCoreNtNtCsjYc3JqMxxfa_5alloc6string6StringNtCsf9ABzndBH7D_14wasmtime_types11EntityIndexE11insert_fullCs3hbrbrmFUf_8wasmtime:
  246|    408|    pub(crate) fn insert_full(&mut self, hash: HashValue, key: K, value: V) -> (usize, Option<V>)
  247|    408|    where
  248|    408|        K: Eq,
  249|    408|    {
  250|    408|        match self.get_index_of(hash, &key) {
  251|      0|            Some(i) => (i, Some(replace(&mut self.entries[i].value, value))),
  252|    408|            None => (self.push(hash, key, value), None),
  253|       |        }
  254|    408|    }
_RINvMs1_NtNtCs3roF1RhYbpt_8indexmap3map4coreINtB6_12IndexMapCoreNtNtCsjYc3JqMxxfa_5alloc6string6StringNtCsf9ABzndBH7D_14wasmtime_types11EntityIndexE12get_index_ofB10_ECs3hbrbrmFUf_8wasmtime:
  238|    408|    pub(crate) fn get_index_of<Q>(&self, hash: HashValue, key: &Q) -> Option<usize>
  239|    408|    where
  240|    408|        Q: ?Sized + Equivalent<K>,
  241|    408|    {
  242|    408|        let eq = equivalent(key, &self.entries);
  243|    408|        self.indices.get(hash.get(), eq).copied()
  244|    408|    }
_RNvMs1_NtNtCs3roF1RhYbpt_8indexmap3map4coreINtB5_12IndexMapCoreNtNtCsjYc3JqMxxfa_5alloc6string6StringNtCsf9ABzndBH7D_14wasmtime_types11EntityIndexE4pushCs3hbrbrmFUf_8wasmtime:
  225|    408|    fn push(&mut self, hash: HashValue, key: K, value: V) -> usize {
  226|    408|        let i = self.entries.len();
  227|    408|        self.indices.insert(hash.get(), i, get_hash(&self.entries));
  228|    408|        if i == self.entries.capacity() {
  229|    408|            // Reserve our own capacity synced to the indices,
  230|    408|            // rather than letting `Vec::push` just double it.
  231|    408|            self.reserve_entries();
  232|    408|        }
  233|    408|        self.entries.push(Bucket { hash, key, value });
  234|    408|        i
  235|    408|    }
_RNvMs1_NtNtCs3roF1RhYbpt_8indexmap3map4coreINtB5_12IndexMapCoreNtNtCsjYc3JqMxxfa_5alloc6string6StringNtCsf9ABzndBH7D_14wasmtime_types11EntityIndexE3newCshaNIPJAj9Ao_16wasmtime_environ:
  124|    408|    pub(crate) const fn new() -> Self {
  125|    408|        IndexMapCore {
  126|    408|            indices: RawTable::new(),
  127|    408|            entries: Vec::new(),
  128|    408|        }
  129|    408|    }

_RINvMNtCs10DEiQ4fRdm_16integer_encoding6readerNtB3_15VarIntProcessor3newjECsitTtQF8ArIt_8fvm_fuzz:
   42|  1.93k|    fn new<VI: VarIntMaxSize>() -> VarIntProcessor {
   43|  1.93k|        VarIntProcessor {
   44|  1.93k|            maxsize: VI::varint_max_size(),
   45|  1.93k|            ..VarIntProcessor::default()
   46|  1.93k|        }
   47|  1.93k|    }
_RNvXs1_NtCs10DEiQ4fRdm_16integer_encoding6readerNtB5_15VarIntProcessorNtNtCshM4Il2Z0i4R_4core7default7Default7default:
   34|  1.93k|#[derive(Default)]
_RINvXs2_NtCs10DEiQ4fRdm_16integer_encoding6readerQRShNtB6_17VarIntAsyncReader17read_varint_asyncjECsitTtQF8ArIt_8fvm_fuzz:
   70|  1.93k|    async fn read_varint_async<VI: VarInt>(&mut self) -> Result<VI> {
_RINvMNtCs10DEiQ4fRdm_16integer_encoding6readerNtB3_15VarIntProcessor6decodejECsitTtQF8ArIt_8fvm_fuzz:
   62|  1.83k|    fn decode<VI: VarInt>(&self) -> Option<VI> {
   63|  1.83k|        Some(VI::decode_var(&self.buf[0..self.i])?.0)
   64|  1.83k|    }
_RNCINvXs2_NtCs10DEiQ4fRdm_16integer_encoding6readerQRShNtB8_17VarIntAsyncReader17read_varint_asyncjE0CsitTtQF8ArIt_8fvm_fuzz:
   70|  1.93k|    async fn read_varint_async<VI: VarInt>(&mut self) -> Result<VI> {
   71|  1.93k|        let mut buf = [0 as u8; 1];
   72|  1.93k|        let mut p = VarIntProcessor::new::<VI>();
   73|       |
   74|  6.93k|        while !p.finished() {
   75|  5.10k|            let read = self.read(&mut buf).await?;
   76|       |
   77|       |            // EOF
   78|  5.10k|            if read == 0 && p.i == 0 {
   79|    102|                return Err(io::Error::new(io::ErrorKind::UnexpectedEof, "Reached EOF"));
   80|  4.99k|            }
   81|  4.99k|            if read == 0 {
   82|      0|                break;
   83|  4.99k|            }
   84|  4.99k|
   85|  4.99k|            p.push(buf[0])?;
   86|       |        }
   87|       |
   88|  1.83k|        p.decode()
   89|  1.83k|            .ok_or_else(|| io::Error::new(io::ErrorKind::UnexpectedEof, "Reached EOF"))
   90|  3.87k|    }
_RNvMNtCs10DEiQ4fRdm_16integer_encoding6readerNtB2_15VarIntProcessor8finished:
   59|  6.93k|    fn finished(&self) -> bool {
   60|  6.93k|        self.i > 0 && (self.buf[self.i - 1] & MSB == 0)
   61|  6.93k|    }
_RNvMNtCs10DEiQ4fRdm_16integer_encoding6readerNtB2_15VarIntProcessor4push:
   48|  4.99k|    fn push(&mut self, b: u8) -> Result<()> {
   49|  4.99k|        if self.i >= self.maxsize {
   50|      0|            return Err(io::Error::new(
   51|      0|                io::ErrorKind::InvalidData,
   52|      0|                "Unterminated varint",
   53|      0|            ));
   54|  4.99k|        }
   55|  4.99k|        self.buf[self.i] = b;
   56|  4.99k|        self.i += 1;
   57|  4.99k|        Ok(())
   58|  4.99k|    }

_RNvXNtCs10DEiQ4fRdm_16integer_encoding6varintjNtB2_13VarIntMaxSize15varint_max_sizeCsitTtQF8ArIt_8fvm_fuzz:
   74|  1.93k|    fn varint_max_size() -> usize {
   75|  1.93k|        (size_of::<VI>() * 8 + 7) / 7
   76|  1.93k|    }
_RNvXs_NtCs10DEiQ4fRdm_16integer_encoding6varintyNtB4_6VarInt10decode_var:
  133|  1.83k|    fn decode_var(src: &[u8]) -> Option<(Self, usize)> {
  134|  1.83k|        let mut result: u64 = 0;
  135|  1.83k|        let mut shift = 0;
  136|  1.83k|
  137|  1.83k|        let mut success = false;
  138|  4.99k|        for b in src.iter() {
  139|  4.99k|            let msb_dropped = b & DROP_MSB;
  140|  4.99k|            result |= (msb_dropped as u64) << shift;
  141|  4.99k|            shift += 7;
  142|  4.99k|
  143|  4.99k|            if b & MSB == 0 || shift > (9 * 7) {
  144|  1.83k|                success = b & MSB == 0;
  145|  1.83k|                break;
  146|  3.16k|            }
  147|       |        }
  148|       |
  149|  1.83k|        if success {
  150|  1.83k|            Some((result, shift / 7 as usize))
  151|       |        } else {
  152|      0|            None
  153|       |        }
  154|  1.83k|    }
_RNvXs1_NtCs10DEiQ4fRdm_16integer_encoding6varintjNtB5_6VarInt10decode_var:
   86|  1.83k|            fn decode_var(src: &[u8]) -> Option<(Self, usize)> {
   87|  1.83k|                let (n, s) = u64::decode_var(src)?;
   88|  1.83k|                Some((n as Self, s))
   89|  1.83k|            }

_RINvMNtCsf8iG4rjcH0e_11lazy_static4lazyINtB3_4LazyNtNtNtCs7Ei498kZF3p_3fvm3gas10price_list9PriceListE3getNvNvXs5_BO_NtBO_12HYGGE_PRICESNtNtNtCshM4Il2Z0i4R_4core3ops5deref5Deref5deref23___static_ref_initializeEBS_:
   26|    204|    pub fn get<F>(&'static self, f: F) -> &T
   27|    204|    where
   28|    204|        F: FnOnce() -> T,
   29|    204|    {
   30|    204|        self.1.call_once(|| {
   31|       |            self.0.set(Some(f()));
   32|    204|        });
   33|    204|
   34|    204|        // `self.0` is guaranteed to be `Some` by this point
   35|    204|        // The `Once` will catch and propagate panics
   36|    204|        unsafe {
   37|    204|            match *self.0.as_ptr() {
   38|    204|                Some(ref x) => x,
   39|       |                None => {
   40|      0|                    debug_assert!(false, "attempted to derefence an uninitialized lazy static. This is a bug");
   41|       |
   42|      0|                    unreachable_unchecked()
   43|       |                },
   44|       |            }
   45|       |        }
   46|    204|    }
_RNCINvMNtCsf8iG4rjcH0e_11lazy_static4lazyINtB5_4LazyNtNtNtCs7Ei498kZF3p_3fvm3gas10price_list9PriceListE3getNvNvXs5_BQ_NtBQ_12HYGGE_PRICESNtNtNtCshM4Il2Z0i4R_4core3ops5deref5Deref5deref23___static_ref_initializeE0BU_:
   30|      1|        self.1.call_once(|| {
   31|      1|            self.0.set(Some(f()));
   32|      1|        });
_RINvMNtCsf8iG4rjcH0e_11lazy_static4lazyINtB3_4LazyNtNtCs4pVfV2XJudO_10fvm_shared4econ11TokenAmountE3getNvNvXs_BQ_NtBQ_14TOTAL_FILECOINNtNtNtCshM4Il2Z0i4R_4core3ops5deref5Deref5deref23___static_ref_initializeEBQ_:
   26|    102|    pub fn get<F>(&'static self, f: F) -> &T
   27|    102|    where
   28|    102|        F: FnOnce() -> T,
   29|    102|    {
   30|    102|        self.1.call_once(|| {
   31|       |            self.0.set(Some(f()));
   32|    102|        });
   33|    102|
   34|    102|        // `self.0` is guaranteed to be `Some` by this point
   35|    102|        // The `Once` will catch and propagate panics
   36|    102|        unsafe {
   37|    102|            match *self.0.as_ptr() {
   38|    102|                Some(ref x) => x,
   39|       |                None => {
   40|      0|                    debug_assert!(false, "attempted to derefence an uninitialized lazy static. This is a bug");
   41|       |
   42|      0|                    unreachable_unchecked()
   43|       |                },
   44|       |            }
   45|       |        }
   46|    102|    }
_RNCINvMNtCsf8iG4rjcH0e_11lazy_static4lazyINtB5_4LazyNtNtCs4pVfV2XJudO_10fvm_shared4econ11TokenAmountE3getNvNvXs_BS_NtBS_14TOTAL_FILECOINNtNtNtCshM4Il2Z0i4R_4core3ops5deref5Deref5deref23___static_ref_initializeE0BS_:
   30|      1|        self.1.call_once(|| {
   31|      1|            self.0.set(Some(f()));
   32|      1|        });

_RNvXs5_NtNtCs7Ei498kZF3p_3fvm3gas10price_listNtB5_12HYGGE_PRICESNtNtNtCshM4Il2Z0i4R_4core3ops5deref5Deref5deref:
  135|    204|            fn deref(&self) -> &$T {
  136|    204|                #[inline(always)]
  137|    204|                fn __static_ref_initialize() -> $T { $e }
  138|    204|
  139|    204|                #[inline(always)]
  140|    204|                fn __stability() -> &'static $T {
  141|    204|                    __lazy_static_create!(LAZY, $T);
  142|    204|                    LAZY.get(__static_ref_initialize)
  143|    204|                }
  144|    204|                __stability()
  145|    204|            }
_RNvNvXs5_NtNtCs7Ei498kZF3p_3fvm3gas10price_listNtB7_12HYGGE_PRICESNtNtNtCshM4Il2Z0i4R_4core3ops5deref5Deref5deref11___stability:
  140|    204|                fn __stability() -> &'static $T {
  141|    204|                    __lazy_static_create!(LAZY, $T);
  142|    204|                    LAZY.get(__static_ref_initialize)
  143|    204|                }
_RNvNvXs5_NtNtCs7Ei498kZF3p_3fvm3gas10price_listNtB7_12HYGGE_PRICESNtNtNtCshM4Il2Z0i4R_4core3ops5deref5Deref5deref23___static_ref_initialize:
  137|      1|                fn __static_ref_initialize() -> $T { $e }
_RNvNvXs_Cs4pVfV2XJudO_10fvm_sharedNtB6_14TOTAL_FILECOINNtNtNtCshM4Il2Z0i4R_4core3ops5deref5Deref5deref23___static_ref_initialize:
  137|      1|                fn __static_ref_initialize() -> $T { $e }
_RNvXs_Cs4pVfV2XJudO_10fvm_sharedNtB4_14TOTAL_FILECOINNtNtNtCshM4Il2Z0i4R_4core3ops5deref5Deref5deref:
  135|    102|            fn deref(&self) -> &$T {
  136|    102|                #[inline(always)]
  137|    102|                fn __static_ref_initialize() -> $T { $e }
  138|    102|
  139|    102|                #[inline(always)]
  140|    102|                fn __stability() -> &'static $T {
  141|    102|                    __lazy_static_create!(LAZY, $T);
  142|    102|                    LAZY.get(__static_ref_initialize)
  143|    102|                }
  144|    102|                __stability()
  145|    102|            }
_RNvNvXs_Cs4pVfV2XJudO_10fvm_sharedNtB6_14TOTAL_FILECOINNtNtNtCshM4Il2Z0i4R_4core3ops5deref5Deref5deref11___stability:
  140|    102|                fn __stability() -> &'static $T {
  141|    102|                    __lazy_static_create!(LAZY, $T);
  142|    102|                    LAZY.get(__static_ref_initialize)
  143|    102|                }

rust_fuzzer_test_input:
  215|    102|                if let Some(path) = $crate::RUST_LIBFUZZER_DEBUG_PATH.get() {
  216|       |                    use std::io::Write;
  217|      0|                    let mut file = std::fs::File::create(path)
  218|      0|                        .expect("failed to create `RUST_LIBFUZZER_DEBUG_PATH` file");
  219|      0|                    writeln!(&mut file, "{:?}", bytes)
  220|      0|                        .expect("failed to write to `RUST_LIBFUZZER_DEBUG_PATH` file");
  221|      0|                    return 0;
  222|    102|                }
  223|    102|
  224|    102|                run(bytes);
  225|    102|                0
  226|    102|            }
_RNvNvCsbTo8XeKCRZK_15direct_syscalls1__3run:
  241|    204|            fn run($bytes: &[u8]) {
  242|    204|                $body
  243|    204|            }
LLVMFuzzerTestOneInput:
   58|    102|pub fn test_input_wrap(data: *const u8, size: usize) -> i32 {
   59|    102|    let test_input = ::std::panic::catch_unwind(|| unsafe {
   60|       |        let data_slice = ::std::slice::from_raw_parts(data, size);
   61|       |        rust_fuzzer_test_input(data_slice)
   62|    102|    });
   63|    102|
   64|    102|    match test_input {
   65|    102|        Ok(i) => i,
   66|       |        Err(_) => {
   67|       |            // hopefully the custom panic hook will be called before and abort the
   68|       |            // process before the stack frames are unwinded.
   69|      0|            ::std::process::abort();
   70|       |        }
   71|       |    }
   72|    102|}
_RNCNvCsleHBUCVNfHp_13libfuzzer_sys15test_input_wrap0B3_:
   59|    102|    let test_input = ::std::panic::catch_unwind(|| unsafe {
   60|    102|        let data_slice = ::std::slice::from_raw_parts(data, size);
   61|    102|        rust_fuzzer_test_input(data_slice)
   62|    102|    });
LLVMFuzzerInitialize:
   79|      2|pub fn initialize(_argc: *const isize, _argv: *const *const *const u8) -> isize {
   80|      2|    // Registers a panic hook that aborts the process before unwinding.
   81|      2|    // It is useful to abort before unwinding so that the fuzzer will then be
   82|      2|    // able to analyse the process stack frames to tell different bugs appart.
   83|      2|    //
   84|      2|    // HACK / FIXME: it would be better to use `-C panic=abort` but it's currently
   85|      2|    // impossible to build code using compiler plugins with this flag.
   86|      2|    // We will be able to remove this code when
   87|      2|    // https://github.com/rust-lang/cargo/issues/5423 is fixed.
   88|      2|    let default_hook = ::std::panic::take_hook();
   89|      2|    ::std::panic::set_hook(Box::new(move |panic_info| {
   90|       |        default_hook(panic_info);
   91|       |        ::std::process::abort();
   92|      2|    }));
   93|       |
   94|       |    // Initialize the `RUST_LIBFUZZER_DEBUG_PATH` cell with the path so it can be
   95|       |    // reused with little overhead.
   96|      2|    if let Ok(path) = std::env::var("RUST_LIBFUZZER_DEBUG_PATH") {
   97|      0|        RUST_LIBFUZZER_DEBUG_PATH
   98|      0|            .set(path)
   99|      0|            .expect("Since this is initialize it is only called once so can never fail");
  100|      2|    }
  101|      2|    0
  102|      2|}

_RINvXs0_NtNtCsalhrieD8kwf_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCslVZeVZySzLE_5serde2de12Deserializer26deserialize_newtype_structINtNvXs0_NtCs1slUOa8tBso_3cid5serdeINtNtB2k_3cid3CidKpENtB14_11Deserialize11deserialize16MainEntryVisitorKj40_EECsitTtQF8ArIt_8fvm_fuzz:
  471|    612|    fn deserialize_newtype_struct<V: de::Visitor<'de>>(
  472|    612|        self,
  473|    612|        name: &str,
  474|    612|        visitor: V,
  475|    612|    ) -> Result<V::Value, Self::Error> {
  476|    612|        if name == CID_SERDE_PRIVATE_IDENTIFIER {
  477|    612|            match self {
  478|    612|                Ipld::Link(cid) => visitor.visit_newtype_struct(CidDeserializer(cid)),
  479|      0|                _ => error(format!(
  480|      0|                    "Only `Ipld::Link`s can be deserialized to CIDs, input was `{:#?}`",
  481|      0|                    self
  482|      0|                )),
  483|       |            }
  484|       |        } else {
  485|      0|            visitor.visit_newtype_struct(self)
  486|       |        }
  487|    612|    }
_RINvXs0_NtNtCsalhrieD8kwf_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCslVZeVZySzLE_5serde2de12Deserializer24deserialize_tuple_structINtNvXNvCshRBVfIqfJKm_13fvm_ipld_hamts_1__INtB2f_12KeyValuePairppENtB14_11Deserialize11deserialize9___VisitorNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateEECsitTtQF8ArIt_8fvm_fuzz:
  416|    306|    fn deserialize_tuple_struct<V: de::Visitor<'de>>(
  417|    306|        self,
  418|    306|        _name: &str,
  419|    306|        len: usize,
  420|    306|        visitor: V,
  421|    306|    ) -> Result<V::Value, Self::Error> {
  422|    306|        self.deserialize_tuple(len, visitor)
  423|    306|    }
_RINvXs4_NtNtCsalhrieD8kwf_12libipld_core5serde2deNtB6_15SeqDeserializerNtNtCslVZeVZySzLE_5serde2de9SeqAccess17next_element_seedINtNtCshM4Il2Z0i4R_4core6marker11PhantomDataNtNtCs4pVfV2XJudO_10fvm_shared4econ11TokenAmountEECsitTtQF8ArIt_8fvm_fuzz:
  627|    306|    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>
  628|    306|    where
  629|    306|        T: de::DeserializeSeed<'de>,
  630|    306|    {
  631|    306|        match self.iter.next() {
  632|    306|            Some(value) => seed.deserialize(value).map(Some),
  633|      0|            None => Ok(None),
  634|       |        }
  635|    306|    }
_RINvNtNtCsalhrieD8kwf_12libipld_core5serde2de9visit_seqINtNvXNvCshRBVfIqfJKm_13fvm_ipld_hamts_1__INtBZ_12KeyValuePairppENtNtCslVZeVZySzLE_5serde2de11Deserialize11deserialize9___VisitorNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateEECsitTtQF8ArIt_8fvm_fuzz:
  552|    306|fn visit_seq<'de, V>(list: Vec<Ipld>, visitor: V) -> Result<V::Value, SerdeError>
  553|    306|where
  554|    306|    V: de::Visitor<'de>,
  555|    306|{
  556|    306|    let mut deserializer = SeqDeserializer::new(list);
  557|    306|    visitor.visit_seq(&mut deserializer)
  558|    306|}
_RINvNtNtCsalhrieD8kwf_12libipld_core5serde2de9visit_seqNtNvXNvNvXsa_NtCs7Ei498kZF3p_3fvm10state_treeNtB14_10ActorStateNtNtCslVZeVZySzLE_5serde2de11Deserialize11deserialize1__NtBY_5InnerB1S_11deserialize9___VisitorECsitTtQF8ArIt_8fvm_fuzz:
  552|    306|fn visit_seq<'de, V>(list: Vec<Ipld>, visitor: V) -> Result<V::Value, SerdeError>
  553|    306|where
  554|    306|    V: de::Visitor<'de>,
  555|    306|{
  556|    306|    let mut deserializer = SeqDeserializer::new(list);
  557|    306|    visitor.visit_seq(&mut deserializer)
  558|    306|}
_RINvXs0_NtNtCsalhrieD8kwf_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCslVZeVZySzLE_5serde2de12Deserializer15deserialize_u64NtNvXsX_NtB14_5implsyNtB14_11Deserialize11deserialize16PrimitiveVisitorECsitTtQF8ArIt_8fvm_fuzz:
  191|    306|        fn $deserialize<V: de::Visitor<'de>>(self, visitor: V) -> Result<V::Value, Self::Error> {
  192|    306|            match self {
  193|    306|                Self::Integer(integer) => match $ty::try_from(integer) {
  194|    306|                    Ok(int) => visitor.$visit(int),
  195|      0|                    Err(_) => error(format!(
  196|      0|                        "`Ipld::Integer` value was bigger than `{}`",
  197|      0|                        stringify!($ty)
  198|      0|                    )),
  199|       |                },
  200|      0|                _ => error(format!(
  201|      0|                    "Only `Ipld::Integer` can be deserialized to `{}`, input was `{:#?}`",
  202|      0|                    stringify!($ty),
  203|      0|                    self
  204|      0|                )),
  205|       |            }
  206|    306|        }
_RINvXNtNtCsalhrieD8kwf_12libipld_core5serde2deNtNtB7_4ipld4IpldNtNtCslVZeVZySzLE_5serde2de11Deserialize11deserializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
   60|  2.75k|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
   61|  2.75k|    where
   62|  2.75k|        D: de::Deserializer<'de>,
   63|  2.75k|    {
   64|  2.75k|        struct IpldVisitor;
   65|  2.75k|
   66|  2.75k|        impl<'de> de::Visitor<'de> for IpldVisitor {
   67|  2.75k|            type Value = Ipld;
   68|  2.75k|
   69|  2.75k|            fn expecting(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
   70|  2.75k|                fmt.write_str("any valid IPLD kind")
   71|  2.75k|            }
   72|  2.75k|
   73|  2.75k|            #[inline]
   74|  2.75k|            fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>
   75|  2.75k|            where
   76|  2.75k|                E: de::Error,
   77|  2.75k|            {
   78|  2.75k|                Ok(Ipld::String(String::from(value)))
   79|  2.75k|            }
   80|  2.75k|
   81|  2.75k|            #[inline]
   82|  2.75k|            fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>
   83|  2.75k|            where
   84|  2.75k|                E: de::Error,
   85|  2.75k|            {
   86|  2.75k|                self.visit_byte_buf(v.to_owned())
   87|  2.75k|            }
   88|  2.75k|
   89|  2.75k|            #[inline]
   90|  2.75k|            fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<Self::Value, E>
   91|  2.75k|            where
   92|  2.75k|                E: de::Error,
   93|  2.75k|            {
   94|  2.75k|                Ok(Ipld::Bytes(v))
   95|  2.75k|            }
   96|  2.75k|
   97|  2.75k|            #[inline]
   98|  2.75k|            fn visit_u64<E>(self, v: u64) -> Result<Self::Value, E>
   99|  2.75k|            where
  100|  2.75k|                E: de::Error,
  101|  2.75k|            {
  102|  2.75k|                Ok(Ipld::Integer(v.into()))
  103|  2.75k|            }
  104|  2.75k|
  105|  2.75k|            #[inline]
  106|  2.75k|            fn visit_i64<E>(self, v: i64) -> Result<Self::Value, E>
  107|  2.75k|            where
  108|  2.75k|                E: de::Error,
  109|  2.75k|            {
  110|  2.75k|                Ok(Ipld::Integer(v.into()))
  111|  2.75k|            }
  112|  2.75k|
  113|  2.75k|            #[inline]
  114|  2.75k|            fn visit_i128<E>(self, v: i128) -> Result<Self::Value, E>
  115|  2.75k|            where
  116|  2.75k|                E: de::Error,
  117|  2.75k|            {
  118|  2.75k|                Ok(Ipld::Integer(v))
  119|  2.75k|            }
  120|  2.75k|
  121|  2.75k|            #[inline]
  122|  2.75k|            fn visit_f64<E>(self, v: f64) -> Result<Self::Value, E>
  123|  2.75k|            where
  124|  2.75k|                E: de::Error,
  125|  2.75k|            {
  126|  2.75k|                Ok(Ipld::Float(v))
  127|  2.75k|            }
  128|  2.75k|
  129|  2.75k|            #[inline]
  130|  2.75k|            fn visit_bool<E>(self, v: bool) -> Result<Self::Value, E>
  131|  2.75k|            where
  132|  2.75k|                E: de::Error,
  133|  2.75k|            {
  134|  2.75k|                Ok(Ipld::Bool(v))
  135|  2.75k|            }
  136|  2.75k|
  137|  2.75k|            #[inline]
  138|  2.75k|            fn visit_none<E>(self) -> Result<Self::Value, E>
  139|  2.75k|            where
  140|  2.75k|                E: de::Error,
  141|  2.75k|            {
  142|  2.75k|                Ok(Ipld::Null)
  143|  2.75k|            }
  144|  2.75k|
  145|  2.75k|            #[inline]
  146|  2.75k|            fn visit_seq<V>(self, mut visitor: V) -> Result<Self::Value, V::Error>
  147|  2.75k|            where
  148|  2.75k|                V: de::SeqAccess<'de>,
  149|  2.75k|            {
  150|  2.75k|                let mut vec = Vec::with_capacity(visitor.size_hint().unwrap_or(0));
  151|  2.75k|
  152|  2.75k|                while let Some(elem) = visitor.next_element()? {
  153|  2.75k|                    vec.push(elem);
  154|  2.75k|                }
  155|  2.75k|
  156|  2.75k|                Ok(Ipld::List(vec))
  157|  2.75k|            }
  158|  2.75k|
  159|  2.75k|            #[inline]
  160|  2.75k|            fn visit_map<V>(self, mut visitor: V) -> Result<Self::Value, V::Error>
  161|  2.75k|            where
  162|  2.75k|                V: de::MapAccess<'de>,
  163|  2.75k|            {
  164|  2.75k|                let mut values = BTreeMap::new();
  165|  2.75k|
  166|  2.75k|                while let Some((key, value)) = visitor.next_entry()? {
  167|  2.75k|                    values.insert(key, value);
  168|  2.75k|                }
  169|  2.75k|
  170|  2.75k|                Ok(Ipld::Map(values))
  171|  2.75k|            }
  172|  2.75k|
  173|  2.75k|            /// Newtype structs are only used to deserialize CIDs.
  174|  2.75k|            #[inline]
  175|  2.75k|            fn visit_newtype_struct<D>(self, deserializer: D) -> Result<Self::Value, D::Error>
  176|  2.75k|            where
  177|  2.75k|                D: de::Deserializer<'de>,
  178|  2.75k|            {
  179|  2.75k|                deserializer
  180|  2.75k|                    .deserialize_bytes(BytesToCidVisitor)
  181|  2.75k|                    .map(Ipld::Link)
  182|  2.75k|            }
  183|  2.75k|        }
  184|  2.75k|
  185|  2.75k|        deserializer.deserialize_any(IpldVisitor)
  186|  2.75k|    }
_RINvXs0_NtNtCsalhrieD8kwf_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCslVZeVZySzLE_5serde2de12Deserializer17deserialize_tupleINtNvXNvCshRBVfIqfJKm_13fvm_ipld_hamts_1__INtB28_12KeyValuePairppENtB14_11Deserialize11deserialize9___VisitorNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateEECsitTtQF8ArIt_8fvm_fuzz:
  396|    306|    fn deserialize_tuple<V: de::Visitor<'de>>(
  397|    306|        self,
  398|    306|        len: usize,
  399|    306|        visitor: V,
  400|    306|    ) -> Result<V::Value, Self::Error> {
  401|    306|        match self {
  402|    306|            Self::List(list) => {
  403|    306|                if len == list.len() {
  404|    306|                    visit_seq(list, visitor)
  405|       |                } else {
  406|      0|                    error(format!("The tuple size must match the length of the `Ipld::List`, tuple size: {}, `Ipld::List` length: {}", len, list.len()))
  407|       |                }
  408|       |            }
  409|      0|            _ => error(format!(
  410|      0|                "Only `Ipld::List` can be deserialized to tuple, input was `{:#?}`",
  411|      0|                self
  412|      0|            )),
  413|       |        }
  414|    306|    }
_RINvXs4_NtNtCsalhrieD8kwf_12libipld_core5serde2deNtB6_15SeqDeserializerNtNtCslVZeVZySzLE_5serde2de9SeqAccess17next_element_seedINtNtCshM4Il2Z0i4R_4core6marker11PhantomDataINtCshRBVfIqfJKm_13fvm_ipld_hamt12KeyValuePairNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateEEECsitTtQF8ArIt_8fvm_fuzz:
  627|    612|    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>
  628|    612|    where
  629|    612|        T: de::DeserializeSeed<'de>,
  630|    612|    {
  631|    612|        match self.iter.next() {
  632|    306|            Some(value) => seed.deserialize(value).map(Some),
  633|    306|            None => Ok(None),
  634|       |        }
  635|    612|    }
_RINvXs4_NtNtCsalhrieD8kwf_12libipld_core5serde2deNtB6_15SeqDeserializerNtNtCslVZeVZySzLE_5serde2de9SeqAccess17next_element_seedINtNtCshM4Il2Z0i4R_4core6marker11PhantomDataINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EEECsitTtQF8ArIt_8fvm_fuzz:
  627|    612|    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>
  628|    612|    where
  629|    612|        T: de::DeserializeSeed<'de>,
  630|    612|    {
  631|    612|        match self.iter.next() {
  632|    612|            Some(value) => seed.deserialize(value).map(Some),
  633|      0|            None => Ok(None),
  634|       |        }
  635|    612|    }
_RINvXNvXNtNtCsalhrieD8kwf_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCslVZeVZySzLE_5serde2de11Deserialize11deserializeNtB3_11IpldVisitorNtB14_7Visitor9visit_u64INtNtCs8loA9e5gPGU_18serde_ipld_dagcbor5error11DecodeErrorNtNtCshM4Il2Z0i4R_4core7convert10InfallibleEECsitTtQF8ArIt_8fvm_fuzz:
   98|    306|            fn visit_u64<E>(self, v: u64) -> Result<Self::Value, E>
   99|    306|            where
  100|    306|                E: de::Error,
  101|    306|            {
  102|    306|                Ok(Ipld::Integer(v.into()))
  103|    306|            }
_RINvXNvXNtNtCsalhrieD8kwf_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCslVZeVZySzLE_5serde2de11Deserialize11deserializeNtB3_11IpldVisitorNtB14_7Visitor11visit_bytesINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor5error11DecodeErrorNtNtCshM4Il2Z0i4R_4core7convert10InfallibleEECsitTtQF8ArIt_8fvm_fuzz:
   82|    612|            fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>
   83|    612|            where
   84|    612|                E: de::Error,
   85|    612|            {
   86|    612|                self.visit_byte_buf(v.to_owned())
   87|    612|            }
_RINvXs0_NtNtCsalhrieD8kwf_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCslVZeVZySzLE_5serde2de12Deserializer15deserialize_seqINtNvXsh_NtB14_5implsINtNtCsjYc3JqMxxfa_5alloc3vec3VecpENtB14_11Deserialize11deserialize10VecVisitorINtCshRBVfIqfJKm_13fvm_ipld_hamt12KeyValuePairNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateEEECsitTtQF8ArIt_8fvm_fuzz:
  386|    306|    fn deserialize_seq<V: de::Visitor<'de>>(self, visitor: V) -> Result<V::Value, Self::Error> {
  387|    306|        match self {
  388|    306|            Self::List(list) => visit_seq(list, visitor),
  389|      0|            _ => error(format!(
  390|      0|                "Only `Ipld::List` can be deserialized to sequence, input was `{:#?}`",
  391|      0|                self
  392|      0|            )),
  393|       |        }
  394|    306|    }
_RINvXNvXNtNtCsalhrieD8kwf_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCslVZeVZySzLE_5serde2de11Deserialize11deserializeNtB3_11IpldVisitorNtB14_7Visitor20visit_newtype_structQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de15CidDeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
  175|    612|            fn visit_newtype_struct<D>(self, deserializer: D) -> Result<Self::Value, D::Error>
  176|    612|            where
  177|    612|                D: de::Deserializer<'de>,
  178|    612|            {
  179|    612|                deserializer
  180|    612|                    .deserialize_bytes(BytesToCidVisitor)
  181|    612|                    .map(Ipld::Link)
  182|    612|            }
_RINvXs4_NtNtCsalhrieD8kwf_12libipld_core5serde2deNtB6_15SeqDeserializerNtNtCslVZeVZySzLE_5serde2de9SeqAccess17next_element_seedINtNtCshM4Il2Z0i4R_4core6marker11PhantomDatayEECsitTtQF8ArIt_8fvm_fuzz:
  627|    306|    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>
  628|    306|    where
  629|    306|        T: de::DeserializeSeed<'de>,
  630|    306|    {
  631|    306|        match self.iter.next() {
  632|    306|            Some(value) => seed.deserialize(value).map(Some),
  633|      0|            None => Ok(None),
  634|       |        }
  635|    306|    }
_RINvXs0_NtNtCsalhrieD8kwf_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCslVZeVZySzLE_5serde2de12Deserializer18deserialize_optionINtNtB14_5impls13OptionVisitorNtNtCs4pVfV2XJudO_10fvm_shared7address7AddressEECsitTtQF8ArIt_8fvm_fuzz:
  536|    306|    fn deserialize_option<V: de::Visitor<'de>>(self, visitor: V) -> Result<V::Value, Self::Error> {
  537|    306|        match self {
  538|    306|            Self::Null => visitor.visit_none(),
  539|      0|            _ => visitor.visit_some(self),
  540|       |        }
  541|    306|    }
_RINvXNvXNtNtCsalhrieD8kwf_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCslVZeVZySzLE_5serde2de11Deserialize11deserializeNtB3_11IpldVisitorNtB14_7Visitor10visit_noneINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor5error11DecodeErrorNtNtCshM4Il2Z0i4R_4core7convert10InfallibleEECsitTtQF8ArIt_8fvm_fuzz:
  138|    306|            fn visit_none<E>(self) -> Result<Self::Value, E>
  139|    306|            where
  140|    306|                E: de::Error,
  141|    306|            {
  142|    306|                Ok(Ipld::Null)
  143|    306|            }
_RINvXNvXNtNtCsalhrieD8kwf_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCslVZeVZySzLE_5serde2de11Deserialize11deserializeNtB3_11IpldVisitorNtB14_7Visitor9visit_seqINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de8AccessorNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
  146|    918|            fn visit_seq<V>(self, mut visitor: V) -> Result<Self::Value, V::Error>
  147|    918|            where
  148|    918|                V: de::SeqAccess<'de>,
  149|    918|            {
  150|    918|                let mut vec = Vec::with_capacity(visitor.size_hint().unwrap_or(0));
  151|       |
  152|  3.36k|                while let Some(elem) = visitor.next_element()? {
  153|  2.44k|                    vec.push(elem);
  154|  2.44k|                }
  155|       |
  156|    918|                Ok(Ipld::List(vec))
  157|    918|            }
_RINvXs0_NtNtCsalhrieD8kwf_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCslVZeVZySzLE_5serde2de12Deserializer24deserialize_tuple_structNtNvXNvNvXsa_NtCs7Ei498kZF3p_3fvm10state_treeNtB2k_10ActorStateNtB14_11Deserialize11deserialize1__NtB2e_5InnerB38_11deserialize9___VisitorECsitTtQF8ArIt_8fvm_fuzz:
  416|    306|    fn deserialize_tuple_struct<V: de::Visitor<'de>>(
  417|    306|        self,
  418|    306|        _name: &str,
  419|    306|        len: usize,
  420|    306|        visitor: V,
  421|    306|    ) -> Result<V::Value, Self::Error> {
  422|    306|        self.deserialize_tuple(len, visitor)
  423|    306|    }
_RINvXs4_NtNtCsalhrieD8kwf_12libipld_core5serde2deNtB6_15SeqDeserializerNtNtCslVZeVZySzLE_5serde2de9SeqAccess17next_element_seedINtNtCshM4Il2Z0i4R_4core6marker11PhantomDataINtNtB26_6option6OptionNtNtCs4pVfV2XJudO_10fvm_shared7address7AddressEEECsitTtQF8ArIt_8fvm_fuzz:
  627|    306|    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>
  628|    306|    where
  629|    306|        T: de::DeserializeSeed<'de>,
  630|    306|    {
  631|    306|        match self.iter.next() {
  632|    306|            Some(value) => seed.deserialize(value).map(Some),
  633|      0|            None => Ok(None),
  634|       |        }
  635|    306|    }
_RINvXs4_NtNtCsalhrieD8kwf_12libipld_core5serde2deNtB6_15SeqDeserializerNtNtCslVZeVZySzLE_5serde2de9SeqAccess17next_element_seedINtNtCshM4Il2Z0i4R_4core6marker11PhantomDataNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateEECsitTtQF8ArIt_8fvm_fuzz:
  627|    306|    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>
  628|    306|    where
  629|    306|        T: de::DeserializeSeed<'de>,
  630|    306|    {
  631|    306|        match self.iter.next() {
  632|    306|            Some(value) => seed.deserialize(value).map(Some),
  633|      0|            None => Ok(None),
  634|       |        }
  635|    306|    }
_RINvXNvXNtNtCsalhrieD8kwf_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCslVZeVZySzLE_5serde2de11Deserialize11deserializeNtB3_11IpldVisitorNtB14_7Visitor14visit_byte_bufINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor5error11DecodeErrorNtNtCshM4Il2Z0i4R_4core7convert10InfallibleEECsitTtQF8ArIt_8fvm_fuzz:
   90|    612|            fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<Self::Value, E>
   91|    612|            where
   92|    612|                E: de::Error,
   93|    612|            {
   94|    612|                Ok(Ipld::Bytes(v))
   95|    612|            }
_RINvXs_NtNtCsalhrieD8kwf_12libipld_core5serde2deNtB5_15CidDeserializerNtNtCslVZeVZySzLE_5serde2de12Deserializer17deserialize_bytesNtNtCs1slUOa8tBso_3cid5serde17BytesToCidVisitorECsitTtQF8ArIt_8fvm_fuzz:
  224|    612|    fn deserialize_bytes<V: de::Visitor<'de>>(self, visitor: V) -> Result<V::Value, Self::Error> {
  225|    612|        visitor.visit_bytes(&self.0.to_bytes())
  226|    612|    }
_RINvNtNtCsalhrieD8kwf_12libipld_core5serde2de9visit_seqINtNvXsh_NtNtCslVZeVZySzLE_5serde2de5implsINtNtCsjYc3JqMxxfa_5alloc3vec3VecpENtB12_11Deserialize11deserialize10VecVisitorINtCshRBVfIqfJKm_13fvm_ipld_hamt12KeyValuePairNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateEEECsitTtQF8ArIt_8fvm_fuzz:
  552|    306|fn visit_seq<'de, V>(list: Vec<Ipld>, visitor: V) -> Result<V::Value, SerdeError>
  553|    306|where
  554|    306|    V: de::Visitor<'de>,
  555|    306|{
  556|    306|    let mut deserializer = SeqDeserializer::new(list);
  557|    306|    visitor.visit_seq(&mut deserializer)
  558|    306|}
_RINvXs0_NtNtCsalhrieD8kwf_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCslVZeVZySzLE_5serde2de12Deserializer17deserialize_bytesNtNvXs0_NtNtCsbsA1N0ivJJv_17fvm_ipld_encoding5bytes12strict_bytesINtNtCsjYc3JqMxxfa_5alloc6borrow3CowShENtB28_11Deserialize11deserialize10CowVisitorECsitTtQF8ArIt_8fvm_fuzz:
  363|    306|    fn deserialize_bytes<V: de::Visitor<'de>>(self, visitor: V) -> Result<V::Value, Self::Error> {
  364|    306|        match self {
  365|    306|            Self::Bytes(bytes) => visitor.visit_bytes(&bytes),
  366|      0|            _ => error(format!(
  367|      0|                "Only `Ipld::Bytes` can be deserialized to bytes, input was `{:#?}`",
  368|      0|                self
  369|      0|            )),
  370|       |        }
  371|    306|    }
_RINvXs0_NtNtCsalhrieD8kwf_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCslVZeVZySzLE_5serde2de12Deserializer20deserialize_byte_bufNtNtCskiMMfqUGwCy_14cs_serde_bytes7bytebuf14ByteBufVisitorECsitTtQF8ArIt_8fvm_fuzz:
  373|    306|    fn deserialize_byte_buf<V: de::Visitor<'de>>(
  374|    306|        self,
  375|    306|        visitor: V,
  376|    306|    ) -> Result<V::Value, Self::Error> {
  377|    306|        match self {
  378|    306|            Self::Bytes(bytes) => visitor.visit_byte_buf(bytes),
  379|      0|            _ => error(format!(
  380|      0|                "Only `Ipld::Bytes` can be deserialized to bytes, input was `{:#?}`",
  381|      0|                self
  382|      0|            )),
  383|       |        }
  384|    306|    }
_RINvXs4_NtNtCsalhrieD8kwf_12libipld_core5serde2deNtB6_15SeqDeserializerNtNtCslVZeVZySzLE_5serde2de9SeqAccess17next_element_seedINtNtCshM4Il2Z0i4R_4core6marker11PhantomDataNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyEECsitTtQF8ArIt_8fvm_fuzz:
  627|    306|    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>
  628|    306|    where
  629|    306|        T: de::DeserializeSeed<'de>,
  630|    306|    {
  631|    306|        match self.iter.next() {
  632|    306|            Some(value) => seed.deserialize(value).map(Some),
  633|      0|            None => Ok(None),
  634|       |        }
  635|    306|    }
_RINvXs0_NtNtCsalhrieD8kwf_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCslVZeVZySzLE_5serde2de12Deserializer17deserialize_tupleNtNvXNvNvXsa_NtCs7Ei498kZF3p_3fvm10state_treeNtB2d_10ActorStateNtB14_11Deserialize11deserialize1__NtB27_5InnerB31_11deserialize9___VisitorECsitTtQF8ArIt_8fvm_fuzz:
  396|    306|    fn deserialize_tuple<V: de::Visitor<'de>>(
  397|    306|        self,
  398|    306|        len: usize,
  399|    306|        visitor: V,
  400|    306|    ) -> Result<V::Value, Self::Error> {
  401|    306|        match self {
  402|    306|            Self::List(list) => {
  403|    306|                if len == list.len() {
  404|    306|                    visit_seq(list, visitor)
  405|       |                } else {
  406|      0|                    error(format!("The tuple size must match the length of the `Ipld::List`, tuple size: {}, `Ipld::List` length: {}", len, list.len()))
  407|       |                }
  408|       |            }
  409|      0|            _ => error(format!(
  410|      0|                "Only `Ipld::List` can be deserialized to tuple, input was `{:#?}`",
  411|      0|                self
  412|      0|            )),
  413|       |        }
  414|    306|    }
_RNvMs3_NtNtCsalhrieD8kwf_12libipld_core5serde2deNtB5_15SeqDeserializer3new:
  617|    918|    fn new(vec: Vec<Ipld>) -> Self {
  618|    918|        Self {
  619|    918|            iter: vec.into_iter(),
  620|    918|        }
  621|    918|    }
_RNvXs4_NtNtCsalhrieD8kwf_12libipld_core5serde2deNtB5_15SeqDeserializerNtNtCslVZeVZySzLE_5serde2de9SeqAccess9size_hint:
  638|    306|        match self.iter.size_hint() {
  639|    306|            (lower, Some(upper)) if lower == upper => Some(upper),
  640|      0|            _ => None,
  641|       |        }
  642|    306|    }

_RNvMsh_Cs6vrtZ9rvsjP_3logNtB5_6Record6target:
  928|  66.5k|    pub fn target(&self) -> &'a str {
  929|  66.5k|        self.metadata.target()
  930|  66.5k|    }
_RNvMsj_Cs6vrtZ9rvsjP_3logNtB5_8Metadata5level:
 1198|   133k|    pub fn level(&self) -> Level {
 1199|   133k|        self.level
 1200|   133k|    }
_RNvCs6vrtZ9rvsjP_3log13set_max_level:
 1365|      1|pub fn set_max_level(level: LevelFilter) {
 1366|      1|    MAX_LOG_LEVEL_FILTER.store(level as usize, Ordering::Relaxed)
 1367|      1|}
_RNvMsh_Cs6vrtZ9rvsjP_3logNtB5_6Record5level:
  922|  66.5k|    pub fn level(&self) -> Level {
  923|  66.5k|        self.metadata.level()
  924|  66.5k|    }
_RNvXs2_Cs6vrtZ9rvsjP_3logNtB5_5LevelINtNtCshM4Il2Z0i4R_4core3cmp10PartialOrdNtB5_11LevelFilterE2le:
  511|   199k|    fn le(&self, other: &LevelFilter) -> bool {
  512|   199k|        *self as usize <= *other as usize
  513|   199k|    }
_RNvMsf_Cs6vrtZ9rvsjP_3logNtB5_11LevelFilter3max:
  774|    306|    pub fn max() -> LevelFilter {
  775|    306|        LevelFilter::Trace
  776|    306|    }
_RNvMsh_Cs6vrtZ9rvsjP_3logNtB5_6Record8metadata:
  916|  66.5k|    pub fn metadata(&self) -> &Metadata<'a> {
  917|  66.5k|        &self.metadata
  918|  66.5k|    }
_RNvMsj_Cs6vrtZ9rvsjP_3logNtB5_8Metadata6target:
 1204|   133k|    pub fn target(&self) -> &'a str {
 1205|   133k|        self.target
 1206|   133k|    }
_RNvMsh_Cs6vrtZ9rvsjP_3logNtB5_6Record4args:
  910|  66.5k|    pub fn args(&self) -> &fmt::Arguments<'a> {
  911|  66.5k|        &self.args
  912|  66.5k|    }
_RNvXsc_Cs6vrtZ9rvsjP_3logNtB5_11LevelFilterNtNtCshM4Il2Z0i4R_4core3cmp3Ord3cmp:
  735|    408|    fn cmp(&self, other: &LevelFilter) -> cmp::Ordering {
  736|    408|        (*self as usize).cmp(&(*other as usize))
  737|    408|    }
_RNvCs6vrtZ9rvsjP_3log9max_level:
 1383|  66.5k|pub fn max_level() -> LevelFilter {
 1384|  66.5k|    // Since `LevelFilter` is `repr(usize)`,
 1385|  66.5k|    // this transmute is sound if and only if `MAX_LOG_LEVEL_FILTER`
 1386|  66.5k|    // is set to a usize that is a valid discriminant for `LevelFilter`.
 1387|  66.5k|    // Since `MAX_LOG_LEVEL_FILTER` is private, the only time it's set
 1388|  66.5k|    // is by `set_max_level` above, i.e. by casting a `LevelFilter` to `usize`.
 1389|  66.5k|    // So any usize stored in `MAX_LOG_LEVEL_FILTER` is a valid discriminant.
 1390|  66.5k|    unsafe { mem::transmute(MAX_LOG_LEVEL_FILTER.load(Ordering::Relaxed)) }
 1391|  66.5k|}
_RNCNvXsd_Cs6vrtZ9rvsjP_3logNtB7_11LevelFilterNtNtNtCshM4Il2Z0i4R_4core3str6traits7FromStr8from_strs_0B7_:
  747|    204|                .map(|p| LevelFilter::from_usize(p).unwrap()),
_RNvXCs6vrtZ9rvsjP_3logNtB2_5LevelNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
  453|   133k|    fn clone(&self) -> Level {
  454|   133k|        *self
  455|   133k|    }
_RNvCs6vrtZ9rvsjP_3log17___private_api_log:
 1591|  66.5k|    if kvs.is_some() {
 1592|      0|        panic!(
 1593|      0|            "key-value support is experimental and must be enabled using the `kv_unstable` feature"
 1594|      0|        )
 1595|  66.5k|    }
 1596|  66.5k|
 1597|  66.5k|    logger().log(
 1598|  66.5k|        &Record::builder()
 1599|  66.5k|            .args(args)
 1600|  66.5k|            .level(level)
 1601|  66.5k|            .target(target)
 1602|  66.5k|            .module_path_static(Some(module_path))
 1603|  66.5k|            .file_static(Some(file))
 1604|  66.5k|            .line(Some(line))
 1605|  66.5k|            .build(),
 1606|  66.5k|    );
 1607|  66.5k|}
_RNCNvCs6vrtZ9rvsjP_3log16set_boxed_logger0B3_:
 1408|      1|    set_logger_inner(|| Box::leak(logger))
_RNvMsi_Cs6vrtZ9rvsjP_3logNtB5_13RecordBuilder18module_path_static:
 1104|  66.5k|    pub fn module_path_static(&mut self, path: Option<&'static str>) -> &mut RecordBuilder<'a> {
 1105|  66.5k|        self.record.module_path = path.map(MaybeStaticStr::Static);
 1106|  66.5k|        self
 1107|  66.5k|    }
_RNvNvCs6vrtZ9rvsjP_3log20eq_ignore_ascii_case18to_ascii_uppercase:
  542|  2.65k|    fn to_ascii_uppercase(c: u8) -> u8 {
  543|  2.65k|        if c >= b'a' && c <= b'z' {
  544|  1.32k|            c - b'a' + b'A'
  545|       |        } else {
  546|  1.32k|            c
  547|       |        }
  548|  2.65k|    }
_RNvXsd_Cs6vrtZ9rvsjP_3logNtB5_11LevelFilterNtNtNtCshM4Il2Z0i4R_4core3str6traits7FromStr8from_str:
  742|    510|    fn from_str(level: &str) -> Result<LevelFilter, Self::Err> {
  743|    510|        ok_or(
  744|    510|            LOG_LEVEL_NAMES
  745|    510|                .iter()
  746|    510|                .position(|&name| eq_ignore_ascii_case(name, level))
  747|    510|                .map(|p| LevelFilter::from_usize(p).unwrap()),
  748|    510|            ParseLevelError(()),
  749|    510|        )
  750|    510|    }
_RNvMsj_Cs6vrtZ9rvsjP_3logNtB5_8Metadata7builder:
 1192|  66.5k|    pub fn builder() -> MetadataBuilder<'a> {
 1193|  66.5k|        MetadataBuilder::new()
 1194|  66.5k|    }
_RNvMsk_Cs6vrtZ9rvsjP_3logNtB5_15MetadataBuilder3new:
 1238|  66.5k|    pub fn new() -> MetadataBuilder<'a> {
 1239|  66.5k|        MetadataBuilder {
 1240|  66.5k|            metadata: Metadata {
 1241|  66.5k|                level: Level::Info,
 1242|  66.5k|                target: "",
 1243|  66.5k|            },
 1244|  66.5k|        }
 1245|  66.5k|    }
_RNvMsi_Cs6vrtZ9rvsjP_3logNtB5_13RecordBuilder4line:
 1125|  66.5k|    pub fn line(&mut self, line: Option<u32>) -> &mut RecordBuilder<'a> {
 1126|  66.5k|        self.record.line = line;
 1127|  66.5k|        self
 1128|  66.5k|    }
_RNvXsQ_Cs6vrtZ9rvsjP_3logNtB5_8MetadataNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
 1183|   133k|#[derive(Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug)]
_RNvCs6vrtZ9rvsjP_3log6logger:
 1573|  66.5k|pub fn logger() -> &'static dyn Log {
 1574|  66.5k|    if STATE.load(Ordering::SeqCst) != INITIALIZED {
 1575|       |        static NOP: NopLogger = NopLogger;
 1576|      0|        &NOP
 1577|       |    } else {
 1578|  66.5k|        unsafe { LOGGER }
 1579|       |    }
 1580|  66.5k|}
_RNvMsi_Cs6vrtZ9rvsjP_3logNtB5_13RecordBuilder4args:
 1069|  66.5k|    pub fn args(&mut self, args: fmt::Arguments<'a>) -> &mut RecordBuilder<'a> {
 1070|  66.5k|        self.record.args = args;
 1071|  66.5k|        self
 1072|  66.5k|    }
_RNvCs6vrtZ9rvsjP_3log16set_boxed_logger:
 1407|    102|pub fn set_boxed_logger(logger: Box<dyn Log>) -> Result<(), SetLoggerError> {
 1408|    102|    set_logger_inner(|| Box::leak(logger))
 1409|    102|}
_RNvMsi_Cs6vrtZ9rvsjP_3logNtB5_13RecordBuilder5level:
 1083|  66.5k|    pub fn level(&mut self, level: Level) -> &mut RecordBuilder<'a> {
 1084|  66.5k|        self.record.metadata.level = level;
 1085|  66.5k|        self
 1086|  66.5k|    }
_RNvMs6_Cs6vrtZ9rvsjP_3logNtB5_5Level6as_str:
  608|  66.5k|    pub fn as_str(&self) -> &'static str {
  609|  66.5k|        LOG_LEVEL_NAMES[*self as usize]
  610|  66.5k|    }
_RNvMsk_Cs6vrtZ9rvsjP_3logNtB5_15MetadataBuilder5build:
 1263|  66.5k|    pub fn build(&self) -> Metadata<'a> {
 1264|  66.5k|        self.metadata.clone()
 1265|  66.5k|    }
_RNvMsh_Cs6vrtZ9rvsjP_3logNtB5_6Record7builder:
  904|  66.5k|    pub fn builder() -> RecordBuilder<'a> {
  905|  66.5k|        RecordBuilder::new()
  906|  66.5k|    }
_RNvMsi_Cs6vrtZ9rvsjP_3logNtB5_13RecordBuilder11file_static:
 1118|  66.5k|    pub fn file_static(&mut self, file: Option<&'static str>) -> &mut RecordBuilder<'a> {
 1119|  66.5k|        self.record.file = file.map(MaybeStaticStr::Static);
 1120|  66.5k|        self
 1121|  66.5k|    }
_RNvMsf_Cs6vrtZ9rvsjP_3logNtB5_11LevelFilter10from_usize:
  760|    204|    fn from_usize(u: usize) -> Option<LevelFilter> {
  761|    204|        match u {
  762|      0|            0 => Some(LevelFilter::Off),
  763|      0|            1 => Some(LevelFilter::Error),
  764|      0|            2 => Some(LevelFilter::Warn),
  765|      0|            3 => Some(LevelFilter::Info),
  766|    102|            4 => Some(LevelFilter::Debug),
  767|    102|            5 => Some(LevelFilter::Trace),
  768|      0|            _ => None,
  769|       |        }
  770|    204|    }
_RNvMsi_Cs6vrtZ9rvsjP_3logNtB5_13RecordBuilder5build:
 1140|  66.5k|    pub fn build(&self) -> Record<'a> {
 1141|  66.5k|        self.record.clone()
 1142|  66.5k|    }
_RNvXsE_Cs6vrtZ9rvsjP_3logNtB5_14MaybeStaticStrNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
  812|   133k|#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug)]
_RNvXs5_Cs6vrtZ9rvsjP_3logNtB5_5LevelNtNtCshM4Il2Z0i4R_4core3fmt7Display3fmt:
  576|  66.5k|    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
  577|  66.5k|        fmt.pad(self.as_str())
  578|  66.5k|    }
_RINvCs6vrtZ9rvsjP_3log16set_logger_innerNCNvB2_16set_boxed_logger0EB2_:
 1470|    102|fn set_logger_inner<F>(make_logger: F) -> Result<(), SetLoggerError>
 1471|    102|where
 1472|    102|    F: FnOnce() -> &'static dyn Log,
 1473|    102|{
 1474|    102|    let old_state = match STATE.compare_exchange(
 1475|    102|        UNINITIALIZED,
 1476|    102|        INITIALIZING,
 1477|    102|        Ordering::SeqCst,
 1478|    102|        Ordering::SeqCst,
 1479|    102|    ) {
 1480|    102|        Ok(s) | Err(s) => s,
 1481|    102|    };
 1482|    102|    match old_state {
 1483|       |        UNINITIALIZED => {
 1484|      1|            unsafe {
 1485|      1|                LOGGER = make_logger();
 1486|      1|            }
 1487|      1|            STATE.store(INITIALIZED, Ordering::SeqCst);
 1488|      1|            Ok(())
 1489|       |        }
 1490|       |        INITIALIZING => {
 1491|      0|            while STATE.load(Ordering::SeqCst) == INITIALIZING {
 1492|      0|                // TODO: replace with `hint::spin_loop` once MSRV is 1.49.0.
 1493|      0|                #[allow(deprecated)]
 1494|      0|                std::sync::atomic::spin_loop_hint();
 1495|      0|            }
 1496|      0|            Err(SetLoggerError(()))
 1497|       |        }
 1498|    101|        _ => Err(SetLoggerError(())),
 1499|       |    }
 1500|    102|}
_RINvCs6vrtZ9rvsjP_3log5ok_orNtB2_11LevelFilterNtB2_15ParseLevelErrorEB2_:
  533|    510|fn ok_or<T, E>(t: Option<T>, e: E) -> Result<T, E> {
  534|    510|    match t {
  535|    204|        Some(t) => Ok(t),
  536|    306|        None => Err(e),
  537|       |    }
  538|    510|}
_RNCNvCs6vrtZ9rvsjP_3log20eq_ignore_ascii_case0B3_:
  553|  1.32k|            .all(|(a, b)| to_ascii_uppercase(a) == to_ascii_uppercase(b))
_RNvXsN_Cs6vrtZ9rvsjP_3logNtB5_6RecordNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
  873|  66.5k|#[derive(Clone, Debug)]
_RNvMsi_Cs6vrtZ9rvsjP_3logNtB5_13RecordBuilder3new:
 1053|  66.5k|    pub fn new() -> RecordBuilder<'a> {
 1054|  66.5k|        RecordBuilder {
 1055|  66.5k|            record: Record {
 1056|  66.5k|                args: format_args!(""),
 1057|  66.5k|                metadata: Metadata::builder().build(),
 1058|  66.5k|                module_path: None,
 1059|  66.5k|                file: None,
 1060|  66.5k|                line: None,
 1061|  66.5k|                #[cfg(feature = "kv_unstable")]
 1062|  66.5k|                key_values: KeyValues(&Option::None::<(kv::Key, kv::Value)>),
 1063|  66.5k|            },
 1064|  66.5k|        }
 1065|  66.5k|    }
_RNCNvXsd_Cs6vrtZ9rvsjP_3logNtB7_11LevelFilterNtNtNtCshM4Il2Z0i4R_4core3str6traits7FromStr8from_str0B7_:
  746|  2.95k|                .position(|&name| eq_ignore_ascii_case(name, level))
_RNvCs6vrtZ9rvsjP_3log20eq_ignore_ascii_case:
  541|  2.95k|fn eq_ignore_ascii_case(a: &str, b: &str) -> bool {
  542|  2.95k|    fn to_ascii_uppercase(c: u8) -> u8 {
  543|  2.95k|        if c >= b'a' && c <= b'z' {
  544|  2.95k|            c - b'a' + b'A'
  545|  2.95k|        } else {
  546|  2.95k|            c
  547|  2.95k|        }
  548|  2.95k|    }
  549|  2.95k|
  550|  2.95k|    if a.len() == b.len() {
  551|    510|        a.bytes()
  552|    510|            .zip(b.bytes())
  553|    510|            .all(|(a, b)| to_ascii_uppercase(a) == to_ascii_uppercase(b))
  554|       |    } else {
  555|  2.44k|        false
  556|       |    }
  557|  2.95k|}
_RNvMsi_Cs6vrtZ9rvsjP_3logNtB5_13RecordBuilder6target:
 1090|  66.5k|    pub fn target(&mut self, target: &'a str) -> &mut RecordBuilder<'a> {
 1091|  66.5k|        self.record.metadata.target = target;
 1092|  66.5k|        self
 1093|  66.5k|    }

_RNvMNtCsiNIzhTJeOBI_8minstant7instantNtB2_7Instant3now:
   25|    387|    pub fn now() -> Instant {
   26|    387|        Instant(crate::current_cycle())
   27|    387|    }
_RNvMNtCsiNIzhTJeOBI_8minstant7instantNtB2_7Instant7elapsed:
  122|     59|    pub fn elapsed(&self) -> Duration {
  123|     59|        Instant::now() - *self
  124|     59|    }
_RNvMNtCsiNIzhTJeOBI_8minstant7instantNtB2_7Instant14duration_since:
   52|     59|    pub fn duration_since(&self, earlier: Instant) -> Duration {
   53|     59|        self.checked_duration_since(earlier).unwrap_or_default()
   54|     59|    }
_RNvXs3_NtCsiNIzhTJeOBI_8minstant7instantNtB5_7InstantNtNtNtCshM4Il2Z0i4R_4core3ops5arith3Sub3sub:
  215|     59|    fn sub(self, other: Instant) -> Duration {
  216|     59|        self.duration_since(other)
  217|     59|    }
_RNvMNtCsiNIzhTJeOBI_8minstant7instantNtB2_7Instant22checked_duration_since:
   73|     59|    pub fn checked_duration_since(&self, earlier: Instant) -> Option<Duration> {
   74|     59|        Some(Duration::from_nanos(
   75|     59|            (self.0.checked_sub(earlier.0)? as f64 * crate::nanos_per_cycle()) as u64,
   76|       |        ))
   77|     59|    }

_RNvCsiNIzhTJeOBI_8minstant16is_tsc_available:
   46|    387|pub fn is_tsc_available() -> bool {
   47|    387|    #[cfg(all(target_os = "linux", any(target_arch = "x86", target_arch = "x86_64")))]
   48|    387|    {
   49|    387|        tsc_now::is_tsc_available()
   50|    387|    }
   51|    387|    #[cfg(not(all(target_os = "linux", any(target_arch = "x86", target_arch = "x86_64"))))]
   52|    387|    {
   53|    387|        false
   54|    387|    }
   55|    387|}
_RNvCsiNIzhTJeOBI_8minstant13current_cycle:
   58|    387|pub(crate) fn current_cycle() -> u64 {
   59|    387|    #[cfg(all(target_os = "linux", any(target_arch = "x86", target_arch = "x86_64")))]
   60|    387|    if is_tsc_available() {
   61|    387|        tsc_now::current_cycle()
   62|       |    } else {
   63|      0|        coarse_now::current_cycle()
   64|       |    }
   65|       |    #[cfg(not(all(target_os = "linux", any(target_arch = "x86", target_arch = "x86_64"))))]
   66|       |    {
   67|       |        coarse_now::current_cycle()
   68|       |    }
   69|    387|}
_RNvCsiNIzhTJeOBI_8minstant15nanos_per_cycle:
   72|     59|pub(crate) fn nanos_per_cycle() -> f64 {
   73|     59|    #[cfg(all(target_os = "linux", any(target_arch = "x86", target_arch = "x86_64")))]
   74|     59|    {
   75|     59|        tsc_now::nanos_per_cycle()
   76|     59|    }
   77|     59|    #[cfg(not(all(target_os = "linux", any(target_arch = "x86", target_arch = "x86_64"))))]
   78|     59|    {
   79|     59|        1.0
   80|     59|    }
   81|     59|}

_RNvNtCsiNIzhTJeOBI_8minstant7tsc_now13current_cycle:
   55|    387|pub(crate) fn current_cycle() -> u64 {
   56|    387|    match unsafe { &*TSC_STATE.tsc_level.get() } {
   57|       |        TSCLevel::Stable {
   58|    387|            cycles_from_anchor, ..
   59|    387|        } => tsc().wrapping_sub(*cycles_from_anchor),
   60|       |        TSCLevel::PerCPUStable {
   61|      0|            cycles_from_anchor, ..
   62|      0|        } => {
   63|      0|            let (tsc, cpuid) = tsc_with_cpuid();
   64|      0|            let anchor = cycles_from_anchor[cpuid];
   65|      0|            tsc.wrapping_sub(anchor)
   66|       |        }
   67|      0|        TSCLevel::Unstable => panic!("tsc is unstable"),
   68|       |    }
   69|    387|}
_RNvNtCsiNIzhTJeOBI_8minstant7tsc_now3tsc:
  270|   671k|fn tsc() -> u64 {
  271|   671k|    #[cfg(target_arch = "x86")]
  272|   671k|    use core::arch::x86::_rdtsc;
  273|   671k|    #[cfg(target_arch = "x86_64")]
  274|   671k|    use core::arch::x86_64::_rdtsc;
  275|   671k|
  276|   671k|    unsafe { _rdtsc() }
  277|   671k|}
_RNvNtCsiNIzhTJeOBI_8minstant7tsc_now16is_tsc_available:
   45|    387|pub(crate) fn is_tsc_available() -> bool {
   46|    387|    unsafe { *TSC_STATE.is_tsc_available.get() }
   47|    387|}
_RNvNtCsiNIzhTJeOBI_8minstant7tsc_now13is_tsc_stable:
  182|      2|fn is_tsc_stable() -> bool {
  183|      2|    let clock_source =
  184|      2|        read_to_string("/sys/devices/system/clocksource/clocksource0/available_clocksource");
  185|      2|
  186|      2|    clock_source.map(|s| s.contains("tsc")).unwrap_or(false)
  187|      2|}
_RNCNvNtCsiNIzhTJeOBI_8minstant7tsc_now13is_tsc_stable0B5_:
  186|      2|    clock_source.map(|s| s.contains("tsc")).unwrap_or(false)
_RNvNtCsiNIzhTJeOBI_8minstant7tsc_now18monotonic_with_tsc:
  265|   671k|fn monotonic_with_tsc() -> (Instant, u64) {
  266|   671k|    (Instant::now(), tsc())
  267|   671k|}
_RNvNtCsiNIzhTJeOBI_8minstant7tsc_now14cycles_per_sec:
  224|      2|fn cycles_per_sec(anchor: Instant) -> (u64, u64) {
  225|      2|    let (cps, last_monotonic, last_tsc) = _cycles_per_sec();
  226|      2|    let nanos_from_anchor = (last_monotonic - anchor).as_nanos();
  227|      2|    let cycles_flied = cps as f64 * nanos_from_anchor as f64 / 1_000_000_000.0;
  228|      2|    let cycles_from_anchor = last_tsc - cycles_flied.ceil() as u64;
  229|      2|
  230|      2|    (cps, cycles_from_anchor)
  231|      2|}
_RNvMs_NtCsiNIzhTJeOBI_8minstant7tsc_nowNtB4_8TSCLevel17cycles_per_second:
  166|      2|    fn cycles_per_second(&self) -> u64 {
  167|      2|        match self {
  168|       |            TSCLevel::Stable {
  169|      2|                cycles_per_second, ..
  170|      2|            } => *cycles_per_second,
  171|       |            TSCLevel::PerCPUStable {
  172|      0|                cycles_per_second, ..
  173|      0|            } => *cycles_per_second,
  174|      0|            TSCLevel::Unstable => panic!("tsc is unstable"),
  175|       |        }
  176|      2|    }
_RNvNtCsiNIzhTJeOBI_8minstant7tsc_now15__cycles_per_sec:
  234|      2|fn _cycles_per_sec() -> (u64, Instant, u64) {
  235|      2|    let mut cycles_per_sec;
  236|      2|    let mut last_monotonic;
  237|      2|    let mut last_tsc;
  238|      2|    let mut old_cycles = 0.0;
  239|       |
  240|       |    loop {
  241|      4|        let (t1, tsc1) = monotonic_with_tsc();
  242|   671k|        loop {
  243|   671k|            let (t2, tsc2) = monotonic_with_tsc();
  244|   671k|            last_monotonic = t2;
  245|   671k|            last_tsc = tsc2;
  246|   671k|            let elapsed_nanos = (t2 - t1).as_nanos();
  247|   671k|            if elapsed_nanos > 10_000_000 {
  248|      4|                cycles_per_sec = (tsc2 - tsc1) as f64 * 1_000_000_000.0 / elapsed_nanos as f64;
  249|      4|                break;
  250|   671k|            }
  251|       |        }
  252|      4|        let delta = f64::abs(cycles_per_sec - old_cycles);
  253|      4|        if delta / cycles_per_sec < 0.00001 {
  254|      2|            break;
  255|      2|        }
  256|      2|        old_cycles = cycles_per_sec;
  257|       |    }
  258|       |
  259|      2|    (cycles_per_sec.round() as u64, last_monotonic, last_tsc)
  260|      2|}
_RNvNtCsiNIzhTJeOBI_8minstant7tsc_now15nanos_per_cycle:
   50|     59|pub(crate) fn nanos_per_cycle() -> f64 {
   51|     59|    unsafe { *TSC_STATE.nanos_per_cycle.get() }
   52|     59|}
_RNvMs_NtCsiNIzhTJeOBI_8minstant7tsc_nowNtB4_8TSCLevel3get:
   84|      2|    fn get() -> TSCLevel {
   85|      2|        let anchor = Instant::now();
   86|      2|        if is_tsc_stable() {
   87|      2|            let (cps, cfa) = cycles_per_sec(anchor);
   88|      2|            return TSCLevel::Stable {
   89|      2|                cycles_per_second: cps,
   90|      2|                cycles_from_anchor: cfa,
   91|      2|            };
   92|      0|        }
   93|      0|
   94|      0|        if is_tsc_percpu_stable() {
   95|       |            // Retrieve the IDs of all active CPUs.
   96|      0|            let cpuids = if let Ok(cpuids) = available_cpus() {
   97|      0|                if cpuids.is_empty() {
   98|      0|                    return TSCLevel::Unstable;
   99|      0|                }
  100|      0|
  101|      0|                cpuids
  102|       |            } else {
  103|      0|                return TSCLevel::Unstable;
  104|       |            };
  105|       |
  106|      0|            let max_cpu_id = *cpuids.iter().max().unwrap();
  107|      0|
  108|      0|            // Spread the threads to all CPUs and calculate
  109|      0|            // cycles from anchor separately
  110|      0|            let handles = cpuids.into_iter().map(|id| {
  111|       |                std::thread::spawn(move || {
  112|       |                    set_affinity(id).unwrap();
  113|       |
  114|       |                    // check if cpu id matches IA32_TSC_AUX
  115|       |                    let (_, cpuid) = tsc_with_cpuid();
  116|       |                    assert_eq!(cpuid, id);
  117|       |
  118|       |                    let (cps, cfa) = cycles_per_sec(anchor);
  119|       |
  120|       |                    (id, cps, cfa)
  121|       |                })
  122|      0|            });
  123|      0|
  124|      0|            // Block and wait for all threads finished
  125|      0|            let results = handles.map(|h| h.join()).collect::<Result<Vec<_>, _>>();
  126|       |
  127|      0|            let results = if let Ok(results) = results {
  128|      0|                results
  129|       |            } else {
  130|      0|                return TSCLevel::Unstable;
  131|       |            };
  132|       |
  133|       |            // Indexed by CPU ID
  134|      0|            let mut cycles_from_anchor = vec![0; max_cpu_id + 1];
  135|      0|
  136|      0|            // Rates of TSCs on different CPUs won't be a big gap
  137|      0|            // or it's unstable.
  138|      0|            let mut max_cps = std::u64::MIN;
  139|      0|            let mut min_cps = std::u64::MAX;
  140|      0|            let mut sum_cps = 0;
  141|      0|            let len = results.len();
  142|      0|            for (cpuid, cps, cfa) in results {
  143|      0|                if cps > max_cps {
  144|      0|                    max_cps = cps;
  145|      0|                }
  146|      0|                if cps < min_cps {
  147|      0|                    min_cps = cps;
  148|      0|                }
  149|      0|                sum_cps += cps;
  150|      0|                cycles_from_anchor[cpuid] = cfa;
  151|       |            }
  152|      0|            if (max_cps - min_cps) as f64 / min_cps as f64 > 0.0005 {
  153|      0|                return TSCLevel::Unstable;
  154|      0|            }
  155|      0|
  156|      0|            return TSCLevel::PerCPUStable {
  157|      0|                cycles_per_second: sum_cps / len as u64,
  158|      0|                cycles_from_anchor,
  159|      0|            };
  160|      0|        }
  161|      0|
  162|      0|        TSCLevel::Unstable
  163|      2|    }
_RNvNtCsiNIzhTJeOBI_8minstant7tsc_now4init:
   29|      2|unsafe fn init() {
   30|      2|    let tsc_level = TSCLevel::get();
   31|      2|    let is_tsc_available = match &tsc_level {
   32|      2|        TSCLevel::Stable { .. } => true,
   33|      0|        TSCLevel::PerCPUStable { .. } => true,
   34|      0|        TSCLevel::Unstable => false,
   35|       |    };
   36|      2|    if is_tsc_available {
   37|      2|        *TSC_STATE.nanos_per_cycle.get() = 1_000_000_000.0 / tsc_level.cycles_per_second() as f64;
   38|      2|    }
   39|      2|    *TSC_STATE.is_tsc_available.get() = is_tsc_available;
   40|      2|    *TSC_STATE.tsc_level.get() = tsc_level;
   41|      2|    std::sync::atomic::fence(std::sync::atomic::Ordering::SeqCst);
   42|      2|}
_RNvNvNtCsiNIzhTJeOBI_8minstant7tsc_now23init___rust_ctor___ctor23init___rust_ctor___ctor:
   28|      2|#[ctor::ctor]

_RINvMNtCseuLmRcTcQvG_9multibase4baseNtB3_4Base6encodeRShECsitTtQF8ArIt_8fvm_fuzz:
   34|    204|            pub fn encode<I: AsRef<[u8]>>(&self, input: I) -> String {
   35|    204|                match self {
   36|      0|                    $( Self::$base => $base::encode(input), )*
   37|       |                }
   38|    204|            }
_RNvMNtCseuLmRcTcQvG_9multibase4baseNtB2_4Base4code:
   27|    204|            pub fn code(&self) -> char {
   28|    204|                match self {
   29|       |                    $( Self::$base => $code, )*
   30|       |                }
   31|    204|            }

_RINvXsc_NtCseuLmRcTcQvG_9multibase5implsNtB6_11Base32LowerNtB6_9BaseCodec6encodeRShECsitTtQF8ArIt_8fvm_fuzz:
   15|    204|                fn encode<I: AsRef<[u8]>>(input: I) -> String {
   16|    204|                    $encoding.encode(input.as_ref())
   17|    204|                }

_RINvCseuLmRcTcQvG_9multibase6encodeRShECsitTtQF8ArIt_8fvm_fuzz:
   51|    102|pub fn encode<T: AsRef<[u8]>>(base: Base, input: T) -> String {
   52|    102|    let input = input.as_ref();
   53|    102|    let mut encoded = base.encode(input.as_ref());
   54|    102|    encoded.insert(0, base.code());
   55|    102|    encoded
   56|    102|}
_RINvCseuLmRcTcQvG_9multibase6encodeAhj10_ECsitTtQF8ArIt_8fvm_fuzz:
   51|    102|pub fn encode<T: AsRef<[u8]>>(base: Base, input: T) -> String {
   52|    102|    let input = input.as_ref();
   53|    102|    let mut encoded = base.encode(input.as_ref());
   54|    102|    encoded.insert(0, base.code());
   55|    102|    encoded
   56|    102|}

_RNvXNtNtCsh09Zh6AP1I4_9multihash11hasher_impl7blake2bINtB2_13Blake2bHasherKj20_ENtNtCshM4Il2Z0i4R_4core7default7Default7defaultB6_:
   35|    714|            fn default() -> Self {
   36|    714|                let mut params = $module::Params::new();
   37|    714|                params.hash_length(S);
   38|    714|                Self {
   39|    714|                    state: params.to_state(),
   40|    714|                    digest: [0; S],
   41|    714|                }
   42|    714|            }
_RNvXs_NtNtCsh09Zh6AP1I4_9multihash11hasher_impl7blake2bINtB4_13Blake2bHasherKj20_ENtNtB8_6hasher6Hasher8finalizeB8_:
   50|    714|            fn finalize(&mut self) -> &[u8] {
   51|    714|                let digest = self.state.finalize();
   52|    714|                let digest_bytes = digest.as_bytes();
   53|    714|                let digest_out = &mut self.digest[..digest_bytes.len().max(S)];
   54|    714|                digest_out.copy_from_slice(digest_bytes);
   55|    714|                digest_out
   56|    714|            }
_RNvXs_NtNtCsh09Zh6AP1I4_9multihash11hasher_impl7blake2bINtB4_13Blake2bHasherKj20_ENtNtB8_6hasher6Hasher6updateB8_:
   46|    714|            fn update(&mut self, input: &[u8]) {
   47|    714|                self.state.update(input);
   48|    714|            }

_RINvMs_NtCsh09Zh6AP1I4_9multihash9multihashINtB5_9MultihashKj40_E4readQRShECsitTtQF8ArIt_8fvm_fuzz:
  135|  4.79k|    pub fn read<R: io::Read>(r: R) -> Result<Self, Error>
  136|  4.79k|    where
  137|  4.79k|        Self: Sized,
  138|  4.79k|    {
  139|  4.79k|        let (code, size, digest) = read_multihash(r)?;
  140|  4.79k|        Ok(Self { code, size, digest })
  141|  4.79k|    }
_RINvXs0_NtCsh09Zh6AP1I4_9multihash9multihashINtB6_9MultihashKj40_ENtNtCshM4Il2Z0i4R_4core4hash4Hash4hashNtNtNtNtCsxnqwkJeFav_3std11collections4hash3map13DefaultHasherECsitTtQF8ArIt_8fvm_fuzz:
  239|  7.95k|    fn hash<T: core::hash::Hasher>(&self, state: &mut T) {
  240|  7.95k|        self.code.hash(state);
  241|  7.95k|        self.digest().hash(state);
  242|  7.95k|    }
_RINvNtCsh09Zh6AP1I4_9multihash9multihash14read_multihashQRShKj40_ECsitTtQF8ArIt_8fvm_fuzz:
  318|  4.79k|pub fn read_multihash<R, const S: usize>(mut r: R) -> Result<(u64, u8, [u8; S]), Error>
  319|  4.79k|where
  320|  4.79k|    R: io::Read,
  321|  4.79k|{
  322|  4.79k|    let code = read_u64(&mut r)?;
  323|  4.79k|    let size = read_u64(&mut r)?;
  324|       |
  325|  4.79k|    if size > S as u64 || size > u8::MAX as u64 {
  326|      0|        return Err(Error::InvalidSize(size));
  327|  4.79k|    }
  328|  4.79k|
  329|  4.79k|    let mut digest = [0; S];
  330|  4.79k|    r.read_exact(&mut digest[..size as usize])?;
  331|  4.79k|    Ok((code, size as u8, digest))
  332|  4.79k|}
_RINvNtCsh09Zh6AP1I4_9multihash9multihash14read_multihashQINtNtNtCsxnqwkJeFav_3std2io6cursor6CursorRINtNtCsjYc3JqMxxfa_5alloc3vec3VechEEKj40_ECsitTtQF8ArIt_8fvm_fuzz:
  318|  1.73k|pub fn read_multihash<R, const S: usize>(mut r: R) -> Result<(u64, u8, [u8; S]), Error>
  319|  1.73k|where
  320|  1.73k|    R: io::Read,
  321|  1.73k|{
  322|  1.73k|    let code = read_u64(&mut r)?;
  323|  1.73k|    let size = read_u64(&mut r)?;
  324|       |
  325|  1.73k|    if size > S as u64 || size > u8::MAX as u64 {
  326|      0|        return Err(Error::InvalidSize(size));
  327|  1.73k|    }
  328|  1.73k|
  329|  1.73k|    let mut digest = [0; S];
  330|  1.73k|    r.read_exact(&mut digest[..size as usize])?;
  331|  1.73k|    Ok((code, size as u8, digest))
  332|  1.73k|}
_RINvNtCsh09Zh6AP1I4_9multihash9multihash15write_multihashQQINtNtCsjYc3JqMxxfa_5alloc3vec3VechEECsitTtQF8ArIt_8fvm_fuzz:
  296|  1.73k|pub fn write_multihash<W>(mut w: W, code: u64, size: u8, digest: &[u8]) -> Result<(), Error>
  297|  1.73k|where
  298|  1.73k|    W: io::Write,
  299|  1.73k|{
  300|  1.73k|    let mut code_buf = varint_encode::u64_buffer();
  301|  1.73k|    let code = varint_encode::u64(code, &mut code_buf);
  302|  1.73k|
  303|  1.73k|    let mut size_buf = varint_encode::u8_buffer();
  304|  1.73k|    let size = varint_encode::u8(size, &mut size_buf);
  305|  1.73k|
  306|  1.73k|    w.write_all(code)?;
  307|  1.73k|    w.write_all(size)?;
  308|  1.73k|    w.write_all(digest)?;
  309|  1.73k|    Ok(())
  310|  1.73k|}
_RNvMs_NtCsh09Zh6AP1I4_9multihash9multihashINtB4_9MultihashKj40_E4codeCsitTtQF8ArIt_8fvm_fuzz:
  120|  1.73k|    pub const fn code(&self) -> u64 {
  121|  1.73k|        self.code
  122|  1.73k|    }
_RINvMs_NtCsh09Zh6AP1I4_9multihash9multihashINtB5_9MultihashKj40_E5writeQQINtNtCsjYc3JqMxxfa_5alloc3vec3VechEECsitTtQF8ArIt_8fvm_fuzz:
  163|  1.73k|    pub fn write<W: io::Write>(&self, w: W) -> Result<(), Error> {
  164|  1.73k|        write_multihash(w, self.code(), self.size(), self.digest())
  165|  1.73k|    }
_RNvMs_NtCsh09Zh6AP1I4_9multihash9multihashINtB4_9MultihashKj40_E6digestCsitTtQF8ArIt_8fvm_fuzz:
  130|  10.0k|    pub fn digest(&self) -> &[u8] {
  131|  10.0k|        &self.digest[..self.size as usize]
  132|  10.0k|    }
_RINvMs_NtCsh09Zh6AP1I4_9multihash9multihashINtB5_9MultihashKj40_E4readQINtNtNtCsxnqwkJeFav_3std2io6cursor6CursorRINtNtCsjYc3JqMxxfa_5alloc3vec3VechEEECsitTtQF8ArIt_8fvm_fuzz:
  135|  1.73k|    pub fn read<R: io::Read>(r: R) -> Result<Self, Error>
  136|  1.73k|    where
  137|  1.73k|        Self: Sized,
  138|  1.73k|    {
  139|  1.73k|        let (code, size, digest) = read_multihash(r)?;
  140|  1.73k|        Ok(Self { code, size, digest })
  141|  1.73k|    }
_RNvXs2_NtCsh09Zh6AP1I4_9multihash9multihashINtB5_9MultihashKj40_ENtNtCshM4Il2Z0i4R_4core3cmp9PartialEq2eqCsitTtQF8ArIt_8fvm_fuzz:
  253|    163|    fn eq(&self, other: &Multihash<B>) -> bool {
  254|    163|        // NOTE: there's no need to explicitly check the sizes, that's implicit in the digest.
  255|    163|        self.code == other.code && self.digest() == other.digest()
  256|    163|    }
_RNvMs_NtCsh09Zh6AP1I4_9multihash9multihashINtB4_9MultihashKj40_E4sizeCsitTtQF8ArIt_8fvm_fuzz:
  125|  1.73k|    pub const fn size(&self) -> u8 {
  126|  1.73k|        self.size
  127|  1.73k|    }
_RNvMs_NtCsh09Zh6AP1I4_9multihash9multihashINtB4_9MultihashKj40_E6digestCs6SqvG5Yde5c_19fvm_ipld_blockstore:
  130|  7.44k|    pub fn digest(&self) -> &[u8] {
  131|  7.44k|        &self.digest[..self.size as usize]
  132|  7.44k|    }
_RINvXs0_NtCsh09Zh6AP1I4_9multihash9multihashINtB6_9MultihashKj40_ENtNtCshM4Il2Z0i4R_4core4hash4Hash4hashNtNtNtNtCsxnqwkJeFav_3std11collections4hash3map13DefaultHasherECs6SqvG5Yde5c_19fvm_ipld_blockstore:
  239|  5.61k|    fn hash<T: core::hash::Hasher>(&self, state: &mut T) {
  240|  5.61k|        self.code.hash(state);
  241|  5.61k|        self.digest().hash(state);
  242|  5.61k|    }
_RNvXs2_NtCsh09Zh6AP1I4_9multihash9multihashINtB5_9MultihashKj40_ENtNtCshM4Il2Z0i4R_4core3cmp9PartialEq2eqCs6SqvG5Yde5c_19fvm_ipld_blockstore:
  253|    917|    fn eq(&self, other: &Multihash<B>) -> bool {
  254|    917|        // NOTE: there's no need to explicitly check the sizes, that's implicit in the digest.
  255|    917|        self.code == other.code && self.digest() == other.digest()
  256|    917|    }
_RNvMs_NtCsh09Zh6AP1I4_9multihash9multihashINtB4_9MultihashKj40_E4wrapB6_:
  101|    714|    pub const fn wrap(code: u64, input_digest: &[u8]) -> Result<Self, Error> {
  102|    714|        if input_digest.len() > S {
  103|      0|            return Err(Error::InvalidSize(input_digest.len() as _));
  104|    714|        }
  105|    714|        let size = input_digest.len();
  106|    714|        let mut digest = [0; S];
  107|    714|        let mut i = 0;
  108|  23.5k|        while i < size {
  109|  22.8k|            digest[i] = input_digest[i];
  110|  22.8k|            i += 1;
  111|  22.8k|        }
  112|    714|        Ok(Self {
  113|    714|            code,
  114|    714|            size: size as u8,
  115|    714|            digest,
  116|    714|        })
  117|    714|    }

_RNvXs3_NtCsh09Zh6AP1I4_9multihash14multihash_implNtB5_4CodeINtNtB7_9multihash15MultihashDigestKj40_E6digest:
   11|    714|#[derive(Copy, Clone, Debug, Eq, Multihash, PartialEq)]

_RNvXs_NtCs2fUfrN5zbVj_10num_bigint6bigintNtB4_6BigIntNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
   71|    816|    fn clone(&self) -> Self {
   72|    816|        BigInt {
   73|    816|            sign: self.sign,
   74|    816|            data: self.data.clone(),
   75|    816|        }
   76|    816|    }
_RNvMsm_NtCs2fUfrN5zbVj_10num_bigint6bigintNtB5_6BigInt11to_bytes_be:
  731|    306|    pub fn to_bytes_be(&self) -> (Sign, Vec<u8>) {
  732|    306|        (self.sign, self.data.to_bytes_be())
  733|    306|    }
_RNvXso_NtCs2fUfrN5zbVj_10num_bigint6bigintNtB5_4SignNtNtCshM4Il2Z0i4R_4core3cmp9PartialEq2eq:
   40|    919|#[derive(PartialEq, PartialOrd, Eq, Ord, Copy, Clone, Debug, Hash)]
_RNvMsm_NtCs2fUfrN5zbVj_10num_bigint6bigintNtB5_6BigInt12from_biguint:
  582|    409|    pub fn from_biguint(mut sign: Sign, mut data: BigUint) -> BigInt {
  583|    409|        if sign == NoSign {
  584|      0|            data.assign_from_slice(&[]);
  585|    409|        } else if data.is_zero() {
  586|    215|            sign = NoSign;
  587|    215|        }
  588|       |
  589|    409|        BigInt { sign, data }
  590|    409|    }
_RNvXs5_NtCs2fUfrN5zbVj_10num_bigint6bigintNtB5_6BigIntNtNtCshM4Il2Z0i4R_4core7default7Default7default:
  134|    306|    fn default() -> BigInt {
  135|    306|        Zero::zero()
  136|    306|    }
_RNvXse_NtCs2fUfrN5zbVj_10num_bigint6bigintNtB5_6BigIntNtNtCs4qz2OQMshGu_10num_traits10identities4Zero4zero:
  213|    714|    fn zero() -> BigInt {
  214|    714|        BigInt {
  215|    714|            sign: NoSign,
  216|    714|            data: BigUint::zero(),
  217|    714|        }
  218|    714|    }
_RNvMsm_NtCs2fUfrN5zbVj_10num_bigint6bigintNtB5_6BigInt12to_str_radix:
  870|    204|    pub fn to_str_radix(&self, radix: u32) -> String {
  871|    204|        let mut v = to_str_radix_reversed(&self.data, radix);
  872|    204|
  873|    204|        if self.is_negative() {
  874|      0|            v.push(b'-');
  875|    204|        }
  876|       |
  877|    204|        v.reverse();
  878|    204|        unsafe { String::from_utf8_unchecked(v) }
  879|    204|    }
_RNvXsj_NtCs2fUfrN5zbVj_10num_bigint6bigintNtB5_6BigIntNtCsfwJUme4k6g3_11num_integer7Integer7div_rem:
  356|    102|    fn div_rem(&self, other: &BigInt) -> (BigInt, BigInt) {
  357|    102|        // r.sign == self.sign
  358|    102|        let (d_ui, r_ui) = self.data.div_rem(&other.data);
  359|    102|        let d = BigInt::from_biguint(self.sign, d_ui);
  360|    102|        let r = BigInt::from_biguint(self.sign, r_ui);
  361|    102|        if other.is_negative() {
  362|      0|            (-d, r)
  363|       |        } else {
  364|    102|            (d, r)
  365|       |        }
  366|    102|    }
_RNvXsg_NtCs2fUfrN5zbVj_10num_bigint6bigintNtB5_6BigIntNtNtCs4qz2OQMshGu_10num_traits4sign6Signed11is_negative:
  286|    408|    fn is_negative(&self) -> bool {
  287|    408|        self.sign == Minus
  288|    408|    }
_RNvXse_NtCs2fUfrN5zbVj_10num_bigint6bigintNtB5_6BigIntNtNtCs4qz2OQMshGu_10num_traits10identities4Zero7is_zero:
  227|    102|    fn is_zero(&self) -> bool {
  228|    102|        self.sign == NoSign
  229|    102|    }
_RNvXsg_NtCs2fUfrN5zbVj_10num_bigint6bigintNtB5_6BigIntNtNtCs4qz2OQMshGu_10num_traits4sign6Signed3abs:
  255|    204|    fn abs(&self) -> BigInt {
  256|    204|        match self.sign {
  257|    204|            Plus | NoSign => self.clone(),
  258|      0|            Minus => BigInt::from(self.data.clone()),
  259|       |        }
  260|    204|    }

_RNvXs_NtNtCs2fUfrN5zbVj_10num_bigint6bigint7convertNtB6_6BigIntNtCs4qz2OQMshGu_10num_traits3Num14from_str_radix:
   29|    204|    fn from_str_radix(mut s: &str, radix: u32) -> Result<BigInt, ParseBigIntError> {
   30|    204|        let sign = if s.starts_with('-') {
   31|      0|            let tail = &s[1..];
   32|      0|            if !tail.starts_with('+') {
   33|      0|                s = tail
   34|      0|            }
   35|      0|            Minus
   36|       |        } else {
   37|    204|            Plus
   38|       |        };
   39|    204|        let bu = BigUint::from_str_radix(s, radix)?;
   40|    204|        Ok(BigInt::from_biguint(sign, bu))
   41|    204|    }
_RNvXs4_NtNtCs2fUfrN5zbVj_10num_bigint6bigint7convertNtB7_6BigIntINtNtCshM4Il2Z0i4R_4core7convert4FromyE4from:
  228|    205|    fn from(n: u64) -> Self {
  229|    205|        if n > 0 {
  230|    205|            BigInt {
  231|    205|                sign: Plus,
  232|    205|                data: BigUint::from(n),
  233|    205|            }
  234|       |        } else {
  235|      0|            BigInt::zero()
  236|       |        }
  237|    205|    }
_RNvXNtNtCs2fUfrN5zbVj_10num_bigint6bigint7convertNtB4_6BigIntNtNtNtCshM4Il2Z0i4R_4core3str6traits7FromStr8from_str:
   19|    204|    fn from_str(s: &str) -> Result<BigInt, ParseBigIntError> {
   20|    204|        BigInt::from_str_radix(s, 10)
   21|    204|    }
_RNvXs2_NtNtCs2fUfrN5zbVj_10num_bigint6bigint7convertNtB7_6BigIntINtNtCshM4Il2Z0i4R_4core7convert4FromxE4from:
  182|      1|    fn from(n: i64) -> Self {
  183|      1|        if n >= 0 {
  184|      1|            BigInt::from(n as u64)
  185|       |        } else {
  186|      0|            let u = core::u64::MAX - (n as u64) + 1;
  187|      0|            BigInt {
  188|      0|                sign: Minus,
  189|      0|                data: BigUint::from(u),
  190|      0|            }
  191|       |        }
  192|      1|    }

_RNvXs1_NtNtCs2fUfrN5zbVj_10num_bigint6bigint14multiplicationNtB7_6BigIntINtNtNtCshM4Il2Z0i4R_4core3ops5arith3MulyE3mul:
   97|      1|    fn mul(self, other: u64) -> BigInt {
   98|      1|        BigInt::from_biguint(self.sign, self.data * other)
   99|      1|    }

_RNvMsg_NtCs2fUfrN5zbVj_10num_bigint7biguintNtB5_7BigUint11to_bytes_le:
  695|    306|    pub fn to_bytes_le(&self) -> Vec<u8> {
  696|    306|        if self.is_zero() {
  697|    306|            vec![0]
  698|       |        } else {
  699|      0|            convert::to_bitwise_digits_le(self, 8)
  700|       |        }
  701|    306|    }
_RNvMsg_NtCs2fUfrN5zbVj_10num_bigint7biguintNtB5_7BigUint11to_bytes_be:
  678|    306|    pub fn to_bytes_be(&self) -> Vec<u8> {
  679|    306|        let mut v = self.to_bytes_le();
  680|    306|        v.reverse();
  681|    306|        v
  682|    306|    }
_RNvXsb_NtCs2fUfrN5zbVj_10num_bigint7biguintNtB5_7BigUintNtNtCs4qz2OQMshGu_10num_traits10identities4Zero4zero:
  148|  1.02k|    fn zero() -> BigUint {
  149|  1.02k|        BigUint { data: Vec::new() }
  150|  1.02k|    }
_RNvMsg_NtCs2fUfrN5zbVj_10num_bigint7biguintNtB5_7BigUint9normalize:
  848|    306|    fn normalize(&mut self) {
  849|    306|        if let Some(&0) = self.data.last() {
  850|    263|            let len = self.data.iter().rposition(|&d| d != 0).map_or(0, |i| i + 1);
  851|    263|            self.data.truncate(len);
  852|    263|        }
  853|    306|        if self.data.len() < self.data.capacity() / 4 {
  854|      0|            self.data.shrink_to_fit();
  855|    306|        }
  856|    306|    }
_RNvXNtCs2fUfrN5zbVj_10num_bigint7biguintNtB2_7BigUintNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
   46|  1.02k|    fn clone(&self) -> Self {
   47|  1.02k|        BigUint {
   48|  1.02k|            data: self.data.clone(),
   49|  1.02k|        }
   50|  1.02k|    }
_RNvXsb_NtCs2fUfrN5zbVj_10num_bigint7biguintNtB5_7BigUintNtNtCs4qz2OQMshGu_10num_traits10identities4Zero7is_zero:
  158|  1.42k|    fn is_zero(&self) -> bool {
  159|  1.42k|        self.data.is_empty()
  160|  1.42k|    }
_RNvMsg_NtCs2fUfrN5zbVj_10num_bigint7biguintNtB5_7BigUint10normalized:
  860|    306|    fn normalized(mut self) -> BigUint {
  861|    306|        self.normalize();
  862|    306|        self
  863|    306|    }
_RNvXse_NtCs2fUfrN5zbVj_10num_bigint7biguintNtB5_7BigUintNtCsfwJUme4k6g3_11num_integer7Integer7div_rem:
  185|    102|    fn div_rem(&self, other: &BigUint) -> (BigUint, BigUint) {
  186|    102|        division::div_rem_ref(self, other)
  187|    102|    }
_RNvMsg_NtCs2fUfrN5zbVj_10num_bigint7biguintNtB5_7BigUint4bits:
  837|    102|    pub fn bits(&self) -> u64 {
  838|    102|        if self.is_zero() {
  839|      0|            return 0;
  840|    102|        }
  841|    102|        let zeros: u64 = self.data.last().unwrap().leading_zeros().into();
  842|    102|        self.data.len() as u64 * u64::from(big_digit::BITS) - zeros
  843|    102|    }
_RNCNvMsg_NtCs2fUfrN5zbVj_10num_bigint7biguintNtB7_7BigUint9normalizes_0B9_:
  850|     48|            let len = self.data.iter().rposition(|&d| d != 0).map_or(0, |i| i + 1);
_RNvNtCs2fUfrN5zbVj_10num_bigint7biguint16biguint_from_vec:
  514|    204|pub(crate) fn biguint_from_vec(digits: Vec<BigDigit>) -> BigUint {
  515|    204|    BigUint { data: digits }.normalized()
  516|    204|}
_RNCNvMsg_NtCs2fUfrN5zbVj_10num_bigint7biguintNtB7_7BigUint9normalize0B9_:
  850|    311|            let len = self.data.iter().rposition(|&d| d != 0).map_or(0, |i| i + 1);

_RNvNtNtCs2fUfrN5zbVj_10num_bigint7biguint8addition6___add2:
   53|    127|pub(super) fn __add2(a: &mut [BigDigit], b: &[BigDigit]) -> BigDigit {
   54|    127|    debug_assert!(a.len() >= b.len());
   55|       |
   56|    127|    let mut carry = 0;
   57|    127|    let (a_lo, a_hi) = a.split_at_mut(b.len());
   58|       |
   59|    127|    for (a, b) in a_lo.iter_mut().zip(b) {
   60|    127|        carry = adc(carry, *a, *b, a);
   61|    127|    }
   62|       |
   63|    127|    if carry != 0 {
   64|     18|        for a in a_hi {
   65|     18|            carry = adc(carry, *a, 0, a);
   66|     18|            if carry == 0 {
   67|     18|                break;
   68|      0|            }
   69|       |        }
   70|    109|    }
   71|       |
   72|    127|    carry as BigDigit
   73|    127|}
_RNvNtNtCs2fUfrN5zbVj_10num_bigint7biguint8addition3adc:
   21|    145|fn adc(carry: u8, a: u64, b: u64, out: &mut u64) -> u8 {
   22|    145|    // Safety: There are absolutely no safety concerns with calling `_addcarry_u64`.
   23|    145|    // It's just unsafe for API consistency with other intrinsics.
   24|    145|    unsafe { arch::_addcarry_u64(carry, a, b, out) }
   25|    145|}
_RNvNtNtCs2fUfrN5zbVj_10num_bigint7biguint8addition4add2:
   80|    127|pub(super) fn add2(a: &mut [BigDigit], b: &[BigDigit]) {
   81|    127|    let carry = __add2(a, b);
   82|       |
   83|    127|    debug_assert!(carry == 0);
   84|    127|}

_RNvXs2_NtNtCs2fUfrN5zbVj_10num_bigint7biguint7convertNtB7_7BigUintINtNtCshM4Il2Z0i4R_4core7convert4FromyE4from:
  476|    307|    fn from(mut n: u64) -> Self {
  477|    307|        let mut ret: BigUint = Zero::zero();
  478|       |
  479|    614|        while n != 0 {
  480|    307|            ret.data.push(n as BigDigit);
  481|    307|            // don't overflow if BITS is 64:
  482|    307|            n = (n >> 1) >> (big_digit::BITS - 1);
  483|    307|        }
  484|       |
  485|    307|        ret
  486|    307|    }
_RNvXs_NtNtCs2fUfrN5zbVj_10num_bigint7biguint7convertNtB6_7BigUintNtCs4qz2OQMshGu_10num_traits3Num14from_str_radix:
  214|    204|    fn from_str_radix(s: &str, radix: u32) -> Result<BigUint, ParseBigIntError> {
  215|    204|        assert!(2 <= radix && radix <= 36, "The radix must be within 2...36");
  216|    204|        let mut s = s;
  217|    204|        if s.starts_with('+') {
  218|      0|            let tail = &s[1..];
  219|      0|            if !tail.starts_with('+') {
  220|      0|                s = tail
  221|      0|            }
  222|    204|        }
  223|       |
  224|    204|        if s.is_empty() {
  225|      0|            return Err(ParseBigIntError::empty());
  226|    204|        }
  227|    204|
  228|    204|        if s.starts_with('_') {
  229|       |            // Must lead with a real digit!
  230|      0|            return Err(ParseBigIntError::invalid());
  231|    204|        }
  232|    204|
  233|    204|        // First normalize all characters to plain digit values
  234|    204|        let mut v = Vec::with_capacity(s.len());
  235|  2.93k|        for b in s.bytes() {
  236|  2.93k|            let d = match b {
  237|  2.93k|                b'0'..=b'9' => b - b'0',
  238|      0|                b'a'..=b'z' => b - b'a' + 10,
  239|      0|                b'A'..=b'Z' => b - b'A' + 10,
  240|      0|                b'_' => continue,
  241|      0|                _ => core::u8::MAX,
  242|       |            };
  243|  2.93k|            if d < radix as u8 {
  244|  2.93k|                v.push(d);
  245|  2.93k|            } else {
  246|      0|                return Err(ParseBigIntError::invalid());
  247|       |            }
  248|       |        }
  249|       |
  250|    204|        let res = if radix.is_power_of_two() {
  251|       |            // Powers of two can use bitwise masks and shifting instead of multiplication
  252|      0|            let bits = ilog2(radix);
  253|      0|            v.reverse();
  254|      0|            if big_digit::BITS % bits == 0 {
  255|      0|                from_bitwise_digits_le(&v, bits)
  256|       |            } else {
  257|      0|                from_inexact_bitwise_digits_le(&v, bits)
  258|       |            }
  259|       |        } else {
  260|    204|            from_radix_digits_be(&v, radix)
  261|       |        };
  262|    204|        Ok(res)
  263|    204|    }
_RNvNtNtCs2fUfrN5zbVj_10num_bigint7biguint7convert18to_radix_digits_le:
  646|    102|pub(super) fn to_radix_digits_le(u: &BigUint, radix: u32) -> Vec<u8> {
  647|    102|    debug_assert!(!u.is_zero() && !radix.is_power_of_two());
  648|       |
  649|       |    #[cfg(feature = "std")]
  650|    102|    let radix_log2 = f64::from(radix).log2();
  651|    102|    #[cfg(not(feature = "std"))]
  652|    102|    let radix_log2 = ilog2(radix) as f64;
  653|    102|
  654|    102|    // Estimate how big the result will be, so we can pre-allocate it.
  655|    102|    let radix_digits = ((u.bits() as f64) / radix_log2).ceil();
  656|    102|    let mut res = Vec::with_capacity(radix_digits.to_usize().unwrap_or(0));
  657|    102|
  658|    102|    let mut digits = u.clone();
  659|    102|
  660|    102|    let (base, power) = get_radix_base(radix, big_digit::HALF_BITS);
  661|    102|    let radix = radix as BigDigit;
  662|    102|
  663|    102|    // For very large numbers, the O(n) loop of repeated `div_rem_digit` dominates the
  664|    102|    // performance. We can mitigate this by dividing into chunks of a larger base first.
  665|    102|    // The threshold for this was chosen by anecdotal performance measurements to
  666|    102|    // approximate where this starts to make a noticeable difference.
  667|    102|    if digits.data.len() >= 64 {
  668|      0|        let mut big_base = BigUint::from(base * base);
  669|      0|        let mut big_power = 2usize;
  670|      0|
  671|      0|        // Choose a target base length near n.
  672|      0|        let target_len = digits.data.len().sqrt();
  673|      0|        while big_base.data.len() < target_len {
  674|      0|            big_base = &big_base * &big_base;
  675|      0|            big_power *= 2;
  676|      0|        }
  677|       |
  678|       |        // This outer loop will run approximately n times.
  679|      0|        while digits > big_base {
  680|       |            // This is still the dominating factor, with n digits divided by n digits.
  681|      0|            let (q, mut big_r) = digits.div_rem(&big_base);
  682|      0|            digits = q;
  683|      0|
  684|      0|            // This inner loop now has O(n)=O(n) behavior altogether.
  685|      0|            for _ in 0..big_power {
  686|      0|                let (q, mut r) = div_rem_digit(big_r, base);
  687|      0|                big_r = q;
  688|      0|                for _ in 0..power {
  689|      0|                    res.push((r % radix) as u8);
  690|      0|                    r /= radix;
  691|      0|                }
  692|       |            }
  693|       |        }
  694|    102|    }
  695|       |
  696|    102|    while digits.data.len() > 1 {
  697|      0|        let (q, mut r) = div_rem_digit(digits, base);
  698|      0|        for _ in 0..power {
  699|      0|            res.push((r % radix) as u8);
  700|      0|            r /= radix;
  701|      0|        }
  702|      0|        digits = q;
  703|       |    }
  704|       |
  705|    102|    let mut r = digits.data[0];
  706|    408|    while r != 0 {
  707|    306|        res.push((r % radix) as u8);
  708|    306|        r /= radix;
  709|    306|    }
  710|       |
  711|    102|    res
  712|    102|}
_RNCNvNtNtCs2fUfrN5zbVj_10num_bigint7biguint7convert20from_radix_digits_be0B7_:
  124|    518|        .fold(0, |acc, &d| acc * radix + BigDigit::from(d));
_RNvNtNtCs2fUfrN5zbVj_10num_bigint7biguint7convert20from_radix_digits_be:
  101|    204|fn from_radix_digits_be(v: &[u8], radix: u32) -> BigUint {
  102|    204|    debug_assert!(!v.is_empty() && !radix.is_power_of_two());
  103|    204|    debug_assert!(v.iter().all(|&c| u32::from(c) < radix));
  104|       |
  105|       |    #[cfg(feature = "std")]
  106|    204|    let radix_log2 = f64::from(radix).log2();
  107|    204|    #[cfg(not(feature = "std"))]
  108|    204|    let radix_log2 = ilog2(radix.next_power_of_two()) as f64;
  109|    204|
  110|    204|    // Estimate how big the result will be, so we can pre-allocate it.
  111|    204|    let bits = radix_log2 * v.len() as f64;
  112|    204|    let big_digits = (bits / big_digit::BITS as f64).ceil();
  113|    204|    let mut data = Vec::with_capacity(big_digits.to_usize().unwrap_or(0));
  114|    204|
  115|    204|    let (base, power) = get_radix_base(radix, big_digit::BITS);
  116|    204|    let radix = radix as BigDigit;
  117|    204|
  118|    204|    let r = v.len() % power;
  119|    204|    let i = if r == 0 { power } else { r };
  120|    204|    let (head, tail) = v.split_at(i);
  121|    204|
  122|    204|    let first = head
  123|    204|        .iter()
  124|    204|        .fold(0, |acc, &d| acc * radix + BigDigit::from(d));
  125|    204|    data.push(first);
  126|       |
  127|    204|    debug_assert!(tail.len() % power == 0);
  128|    204|    for chunk in tail.chunks(power) {
  129|    127|        if data.last() != Some(&0) {
  130|    120|            data.push(0);
  131|    120|        }
  132|       |
  133|    127|        let mut carry = 0;
  134|    301|        for d in data.iter_mut() {
  135|    301|            *d = mac_with_carry(0, *d, base, &mut carry);
  136|    301|        }
  137|    127|        debug_assert!(carry == 0);
  138|       |
  139|    127|        let n = chunk
  140|    127|            .iter()
  141|    127|            .fold(0, |acc, &d| acc * radix + BigDigit::from(d));
  142|    127|        add2(&mut data, &[n]);
  143|       |    }
  144|       |
  145|    204|    biguint_from_vec(data)
  146|    204|}
_RNvNtNtCs2fUfrN5zbVj_10num_bigint7biguint7convert21to_str_radix_reversed:
  734|    204|pub(crate) fn to_str_radix_reversed(u: &BigUint, radix: u32) -> Vec<u8> {
  735|    204|    assert!(2 <= radix && radix <= 36, "The radix must be within 2...36");
  736|       |
  737|    204|    if u.is_zero() {
  738|    102|        return vec![b'0'];
  739|    102|    }
  740|    102|
  741|    102|    let mut res = to_radix_le(u, radix);
  742|       |
  743|       |    // Now convert everything to ASCII digits.
  744|    408|    for r in &mut res {
  745|    306|        debug_assert!(u32::from(*r) < radix);
  746|    306|        if *r < 10 {
  747|    306|            *r += b'0';
  748|    306|        } else {
  749|      0|            *r += b'a' - 10;
  750|      0|        }
  751|       |    }
  752|    102|    res
  753|    204|}
_RNvNtNtCs2fUfrN5zbVj_10num_bigint7biguint7convert11to_radix_le:
  714|    102|pub(super) fn to_radix_le(u: &BigUint, radix: u32) -> Vec<u8> {
  715|    102|    if u.is_zero() {
  716|      0|        vec![0]
  717|    102|    } else if radix.is_power_of_two() {
  718|       |        // Powers of two can use bitwise masks and shifting instead of division
  719|      0|        let bits = ilog2(radix);
  720|      0|        if big_digit::BITS % bits == 0 {
  721|      0|            to_bitwise_digits_le(u, bits)
  722|       |        } else {
  723|      0|            to_inexact_bitwise_digits_le(u, bits)
  724|       |        }
  725|    102|    } else if radix == 10 {
  726|       |        // 10 is so common that it's worth separating out for const-propagation.
  727|       |        // Optimizers can often turn constant division into a faster multiplication.
  728|    102|        to_radix_digits_le(u, 10)
  729|       |    } else {
  730|      0|        to_radix_digits_le(u, radix)
  731|       |    }
  732|    102|}
_RNCNvNtNtCs2fUfrN5zbVj_10num_bigint7biguint7convert20from_radix_digits_bes_0B7_:
  141|  2.41k|            .fold(0, |acc, &d| acc * radix + BigDigit::from(d));
_RNCNvNtNtCs2fUfrN5zbVj_10num_bigint7biguint7convert20from_radix_digits_bes0_0B7_:
  103|  2.93k|    debug_assert!(v.iter().all(|&c| u32::from(c) < radix));
_RNvNtNtCs2fUfrN5zbVj_10num_bigint7biguint7convert14get_radix_base:
  757|    306|fn get_radix_base(radix: u32, bits: u8) -> (BigDigit, usize) {
  758|       |    mod gen {
  759|       |        include! { concat!(env!("OUT_DIR"), "/radix_bases.rs") }
  760|       |    }
  761|       |
  762|       |    debug_assert!(
  763|    306|        2 <= radix && radix <= 256,
  764|       |        "The radix must be within 2...256"
  765|       |    );
  766|    306|    debug_assert!(!radix.is_power_of_two());
  767|    306|    debug_assert!(bits <= big_digit::BITS);
  768|       |
  769|    306|    match bits {
  770|       |        16 => {
  771|      0|            let (base, power) = gen::BASES_16[radix as usize];
  772|      0|            (base as BigDigit, power)
  773|       |        }
  774|       |        32 => {
  775|    102|            let (base, power) = gen::BASES_32[radix as usize];
  776|    102|            (base as BigDigit, power)
  777|       |        }
  778|       |        64 => {
  779|    204|            let (base, power) = gen::BASES_64[radix as usize];
  780|    204|            (base as BigDigit, power)
  781|       |        }
  782|      0|        _ => panic!("Invalid bigdigit size"),
  783|       |    }
  784|    306|}

_RNvNtNtCs2fUfrN5zbVj_10num_bigint7biguint8division11div_rem_ref:
  166|    102|pub(super) fn div_rem_ref(u: &BigUint, d: &BigUint) -> (BigUint, BigUint) {
  167|    102|    if d.is_zero() {
  168|      0|        panic!("attempt to divide by zero")
  169|    102|    }
  170|    102|    if u.is_zero() {
  171|      0|        return (Zero::zero(), Zero::zero());
  172|    102|    }
  173|    102|
  174|    102|    if d.data.len() == 1 {
  175|    102|        if d.data == [1] {
  176|      0|            return (u.clone(), Zero::zero());
  177|    102|        }
  178|    102|
  179|    102|        let (div, rem) = div_rem_digit(u.clone(), d.data[0]);
  180|    102|        return (div, rem.into());
  181|      0|    }
  182|      0|
  183|      0|    // Required or the q_len calculation below can underflow:
  184|      0|    match u.cmp(d) {
  185|      0|        Less => return (Zero::zero(), u.clone()),
  186|      0|        Equal => return (One::one(), Zero::zero()),
  187|      0|        Greater => {} // Do nothing
  188|      0|    }
  189|      0|
  190|      0|    // This algorithm is from Knuth, TAOCP vol 2 section 4.3, algorithm D:
  191|      0|    //
  192|      0|    // First, normalize the arguments so the highest bit in the highest digit of the divisor is
  193|      0|    // set: the main loop uses the highest digit of the divisor for generating guesses, so we
  194|      0|    // want it to be the largest number we can efficiently divide by.
  195|      0|    //
  196|      0|    let shift = d.data.last().unwrap().leading_zeros() as usize;
  197|      0|
  198|      0|    if shift == 0 {
  199|       |        // no need to clone d
  200|      0|        div_rem_core(u.clone(), &d.data)
  201|       |    } else {
  202|      0|        let (q, r) = div_rem_core(u << shift, &(d << shift).data);
  203|      0|        // renormalize the remainder
  204|      0|        (q, r >> shift)
  205|       |    }
  206|    102|}
_RNvNtNtCs2fUfrN5zbVj_10num_bigint7biguint8division13div_rem_digit:
   43|    102|pub(super) fn div_rem_digit(mut a: BigUint, b: BigDigit) -> (BigUint, BigDigit) {
   44|    102|    if b == 0 {
   45|      0|        panic!("attempt to divide by zero")
   46|    102|    }
   47|    102|
   48|    102|    let mut rem = 0;
   49|    102|
   50|    102|    if b <= big_digit::HALF {
   51|      0|        for d in a.data.iter_mut().rev() {
   52|      0|            let (q, r) = div_half(rem, *d, b);
   53|      0|            *d = q;
   54|      0|            rem = r;
   55|      0|        }
   56|       |    } else {
   57|    102|        for d in a.data.iter_mut().rev() {
   58|    102|            let (q, r) = div_wide(rem, *d, b);
   59|    102|            *d = q;
   60|    102|            rem = r;
   61|    102|        }
   62|       |    }
   63|       |
   64|    102|    (a.normalized(), rem)
   65|    102|}
_RNvNtNtCs2fUfrN5zbVj_10num_bigint7biguint8division8div_wide:
   22|    102|fn div_wide(hi: BigDigit, lo: BigDigit, divisor: BigDigit) -> (BigDigit, BigDigit) {
   23|    102|    debug_assert!(hi < divisor);
   24|       |
   25|    102|    let lhs = big_digit::to_doublebigdigit(hi, lo);
   26|    102|    let rhs = DoubleBigDigit::from(divisor);
   27|    102|    ((lhs / rhs) as BigDigit, (lhs % rhs) as BigDigit)
   28|    102|}

_RNvXs1_NtNtCs2fUfrN5zbVj_10num_bigint7biguint14multiplicationNtB7_7BigUintINtNtNtCshM4Il2Z0i4R_4core3ops5arith9MulAssignyE10mul_assign:
  500|      1|    fn mul_assign(&mut self, other: u64) {
  501|      1|        scalar_mul(self, other);
  502|      1|    }
_RNvXs0_NtNtCs2fUfrN5zbVj_10num_bigint7biguint14multiplicationNtB7_7BigUintINtNtNtCshM4Il2Z0i4R_4core3ops5arith3MulyE3mul:
  481|      1|    fn mul(mut self, other: u64) -> BigUint {
  482|      1|        self *= other;
  483|      1|        self
  484|      1|    }
_RNvNtNtCs2fUfrN5zbVj_10num_bigint7biguint14multiplication14mac_with_carry:
   17|    301|pub(super) fn mac_with_carry(
   18|    301|    a: BigDigit,
   19|    301|    b: BigDigit,
   20|    301|    c: BigDigit,
   21|    301|    acc: &mut DoubleBigDigit,
   22|    301|) -> BigDigit {
   23|    301|    *acc += DoubleBigDigit::from(a);
   24|    301|    *acc += DoubleBigDigit::from(b) * DoubleBigDigit::from(c);
   25|    301|    let lo = *acc as BigDigit;
   26|    301|    *acc >>= big_digit::BITS;
   27|    301|    lo
   28|    301|}
_RNvNtNtCs2fUfrN5zbVj_10num_bigint7biguint14multiplication10scalar_mul:
  360|      1|fn scalar_mul(a: &mut BigUint, b: BigDigit) {
  361|      1|    match b {
  362|      0|        0 => a.set_zero(),
  363|      0|        1 => {}
  364|       |        _ => {
  365|      1|            if b.is_power_of_two() {
  366|      0|                *a <<= b.trailing_zeros();
  367|      0|            } else {
  368|      1|                let mut carry = 0;
  369|      1|                for a in a.data.iter_mut() {
  370|      1|                    *a = mul_with_carry(*a, b, &mut carry);
  371|      1|                }
  372|      1|                if carry != 0 {
  373|      1|                    a.data.push(carry as BigDigit);
  374|      1|                }
  375|       |            }
  376|       |        }
  377|       |    }
  378|      1|}
_RNvNtNtCs2fUfrN5zbVj_10num_bigint7biguint14multiplication14mul_with_carry:
   31|      1|fn mul_with_carry(a: BigDigit, b: BigDigit, acc: &mut DoubleBigDigit) -> BigDigit {
   32|      1|    *acc += DoubleBigDigit::from(a) * DoubleBigDigit::from(b);
   33|      1|    let lo = *acc as BigDigit;
   34|      1|    *acc >>= big_digit::BITS;
   35|      1|    lo
   36|      1|}

_RNvNtCs2fUfrN5zbVj_10num_bigint9big_digit17to_doublebigdigit:
  291|    102|    pub(crate) fn to_doublebigdigit(hi: BigDigit, lo: BigDigit) -> DoubleBigDigit {
  292|    102|        DoubleBigDigit::from(lo) | (DoubleBigDigit::from(hi) << BITS)
  293|    102|    }

_RNvXse_NtCs4qz2OQMshGu_10num_traits4castdNtB5_11ToPrimitive8to_usize:
  344|    306|        fn $method(&self) -> Option<$u> {
  345|    306|            // Float as int truncates toward zero, so we want to allow values
  346|    306|            // in the exclusive range `(-1, MAX+1)`.
  347|    306|            if size_of::<$f>() > size_of::<$u>() {
  348|       |                // With a larger size, we can represent the range exactly.
  349|       |                const MAX_P1: $f = $u::MAX as $f + 1.0;
  350|      0|                if *self > -1.0 && *self < MAX_P1 {
  351|      0|                    return Some(float_to_int_unchecked!(*self => $u));
  352|      0|                }
  353|       |            } else {
  354|       |                // We can't represent `MAX` exactly, but it will round up to exactly
  355|       |                // `MAX+1` (a power of two) when we cast it.
  356|       |                // (`u128::MAX as f32` is infinity, but this is still ok.)
  357|       |                const MAX_P1: $f = $u::MAX as $f;
  358|    306|                if *self > -1.0 && *self < MAX_P1 {
  359|    306|                    return Some(float_to_int_unchecked!(*self => $u));
  360|      0|                }
  361|       |            }
  362|      0|            None
  363|    306|        }

_RNvMs2_NtCs3WrfEAqP78b_9once_cell3impINtB5_8OnceCellNtNtCsjYc3JqMxxfa_5alloc6string6StringE14is_initializedCsbTo8XeKCRZK_15direct_syscalls:
   59|    102|    pub(crate) fn is_initialized(&self) -> bool {
   60|    102|        // An `Acquire` load is enough because that makes all the initialization
   61|    102|        // operations visible to us, and, this being a fast path, weaker
   62|    102|        // ordering helps with performance. This `Acquire` synchronizes with
   63|    102|        // `SeqCst` operations on the slow path.
   64|    102|        self.queue.load(Ordering::Acquire) == COMPLETE_PTR
   65|    102|    }
_RNvMs2_NtCs3WrfEAqP78b_9once_cell3impINtB5_8OnceCellNtNtCshM4Il2Z0i4R_4core4time8DurationE3newCs7Ei498kZF3p_3fvm:
   41|     85|    pub(crate) const fn new() -> OnceCell<T> {
   42|     85|        OnceCell {
   43|     85|            queue: AtomicPtr::new(INCOMPLETE_PTR),
   44|     85|            _marker: PhantomData,
   45|     85|            value: UnsafeCell::new(None),
   46|     85|        }
   47|     85|    }
_RINvMs2_NtCs3WrfEAqP78b_9once_cell3impINtB6_8OnceCellNtNtCshM4Il2Z0i4R_4core4time8DurationE10initializeNCINvMs4_NtB8_4syncINtB1M_8OnceCellBP_E11get_or_initNCNvB1I_10try_insert0E0NtNvMs4_B1M_IB1X_pE11get_or_init4VoidECs7Ei498kZF3p_3fvm:
   71|     59|    pub(crate) fn initialize<F, E>(&self, f: F) -> Result<(), E>
   72|     59|    where
   73|     59|        F: FnOnce() -> Result<T, E>,
   74|     59|    {
   75|     59|        let mut f = Some(f);
   76|     59|        let mut res: Result<(), E> = Ok(());
   77|     59|        let slot: *mut Option<T> = self.value.get();
   78|     59|        initialize_or_wait(
   79|     59|            &self.queue,
   80|     59|            Some(&mut || {
   81|       |                let f = unsafe { crate::unwrap_unchecked(f.take()) };
   82|       |                match f() {
   83|       |                    Ok(value) => {
   84|       |                        unsafe { *slot = Some(value) };
   85|       |                        true
   86|       |                    }
   87|       |                    Err(err) => {
   88|       |                        res = Err(err);
   89|       |                        false
   90|       |                    }
   91|       |                }
   92|     59|            }),
   93|     59|        );
   94|     59|        res
   95|     59|    }
_RNvMs2_NtCs3WrfEAqP78b_9once_cell3impINtB5_8OnceCellNtNtCshM4Il2Z0i4R_4core4time8DurationE13get_uncheckedCs7Ei498kZF3p_3fvm:
  109|     59|    pub(crate) unsafe fn get_unchecked(&self) -> &T {
  110|     59|        debug_assert!(self.is_initialized());
  111|     59|        let slot = &*self.value.get();
  112|     59|        crate::unwrap_unchecked(slot.as_ref())
  113|     59|    }
_RNCINvMs2_NtCs3WrfEAqP78b_9once_cell3impINtB8_8OnceCellNtNtCshM4Il2Z0i4R_4core4time8DurationE10initializeNCINvMs4_NtBa_4syncINtB1O_8OnceCellBR_E11get_or_initNCNvB1K_10try_insert0E0NtNvMs4_B1O_IB1Z_pE11get_or_init4VoidE0Cs7Ei498kZF3p_3fvm:
   80|     59|            Some(&mut || {
   81|     59|                let f = unsafe { crate::unwrap_unchecked(f.take()) };
   82|     59|                match f() {
   83|     59|                    Ok(value) => {
   84|     59|                        unsafe { *slot = Some(value) };
   85|     59|                        true
   86|       |                    }
   87|      0|                    Err(err) => {
   88|      0|                        res = Err(err);
   89|      0|                        false
   90|       |                    }
   91|       |                }
   92|     59|            }),
_RNvMs2_NtCs3WrfEAqP78b_9once_cell3impINtB5_8OnceCellNtNtCshM4Il2Z0i4R_4core4time8DurationE14is_initializedCs7Ei498kZF3p_3fvm:
   59|    177|    pub(crate) fn is_initialized(&self) -> bool {
   60|    177|        // An `Acquire` load is enough because that makes all the initialization
   61|    177|        // operations visible to us, and, this being a fast path, weaker
   62|    177|        // ordering helps with performance. This `Acquire` synchronizes with
   63|    177|        // `SeqCst` operations on the slow path.
   64|    177|        self.queue.load(Ordering::Acquire) == COMPLETE_PTR
   65|    177|    }
_RNvMs2_NtCs3WrfEAqP78b_9once_cell3impINtB5_8OnceCellINtNtCshM4Il2Z0i4R_4core6result6ResultuNtNtCsjYc3JqMxxfa_5alloc6string6StringEE3newCs3hbrbrmFUf_8wasmtime:
   41|    204|    pub(crate) const fn new() -> OnceCell<T> {
   42|    204|        OnceCell {
   43|    204|            queue: AtomicPtr::new(INCOMPLETE_PTR),
   44|    204|            _marker: PhantomData,
   45|    204|            value: UnsafeCell::new(None),
   46|    204|        }
   47|    204|    }
_RNCNvXs3_NtCs3WrfEAqP78b_9once_cell3impNtB7_5GuardNtNtNtCshM4Il2Z0i4R_4core3ops4drop4Drop4drop0B9_:
  168|     59|            let mut waiter = strict::map_addr(queue, |q| q & !STATE_MASK);
_RNCNvNtCs3WrfEAqP78b_9once_cell3imp18initialize_or_wait0B5_:
  197|     59|                    strict::map_addr(curr_queue, |q| (q & !STATE_MASK) | RUNNING),
_RINvNtNtCs3WrfEAqP78b_9once_cell3imp6strict8map_addrNtB4_6WaiterNCNvXs3_B4_NtB4_5GuardNtNtNtCshM4Il2Z0i4R_4core3ops4drop4Drop4drop0EB6_:
  291|     59|    pub(crate) fn map_addr<T>(ptr: *mut T, f: impl FnOnce(usize) -> usize) -> *mut T
  292|     59|    where
  293|     59|        T: Sized,
  294|     59|    {
  295|     59|        self::with_addr(ptr, f(addr(ptr)))
  296|     59|    }
_RINvNtNtCs3WrfEAqP78b_9once_cell3imp6strict4addrNtB4_6WaiterEB6_:
  258|    354|    pub(crate) fn addr<T>(ptr: *mut T) -> usize
  259|    354|    where
  260|    354|        T: Sized,
  261|    354|    {
  262|    354|        // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.
  263|    354|        // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the
  264|    354|        // provenance).
  265|    354|        unsafe { core::mem::transmute(ptr) }
  266|    354|    }
_RINvNtNtCs3WrfEAqP78b_9once_cell3imp6strict8map_addrNtB4_6WaiterNCNvB4_18initialize_or_wait0EB6_:
  291|     59|    pub(crate) fn map_addr<T>(ptr: *mut T, f: impl FnOnce(usize) -> usize) -> *mut T
  292|     59|    where
  293|     59|        T: Sized,
  294|     59|    {
  295|     59|        self::with_addr(ptr, f(addr(ptr)))
  296|     59|    }
_RINvNtNtCs3WrfEAqP78b_9once_cell3imp6strict9with_addrNtB4_6WaiterEB6_:
  270|    118|    pub(crate) fn with_addr<T>(ptr: *mut T, addr: usize) -> *mut T
  271|    118|    where
  272|    118|        T: Sized,
  273|    118|    {
  274|    118|        // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.
  275|    118|        //
  276|    118|        // In the mean-time, this operation is defined to be "as if" it was
  277|    118|        // a wrapping_offset, so we can emulate it as such. This should properly
  278|    118|        // restore pointer provenance even under today's compiler.
  279|    118|        let self_addr = self::addr(ptr) as isize;
  280|    118|        let dest_addr = addr as isize;
  281|    118|        let offset = dest_addr.wrapping_sub(self_addr);
  282|    118|
  283|    118|        // This is the canonical desugarring of this operation,
  284|    118|        // but `pointer::cast` was only stabilized in 1.38.
  285|    118|        // self.cast::<u8>().wrapping_offset(offset).cast::<T>()
  286|    118|        (ptr as *mut u8).wrapping_offset(offset) as *mut T
  287|    118|    }
_RNvXs3_NtCs3WrfEAqP78b_9once_cell3impNtB5_5GuardNtNtNtCshM4Il2Z0i4R_4core3ops4drop4Drop4drop:
  161|     59|    fn drop(&mut self) {
  162|     59|        let queue = self.queue.swap(self.new_queue, Ordering::AcqRel);
  163|     59|
  164|     59|        let state = strict::addr(queue) & STATE_MASK;
  165|     59|        assert_eq!(state, RUNNING);
  166|       |
  167|       |        unsafe {
  168|     59|            let mut waiter = strict::map_addr(queue, |q| q & !STATE_MASK);
  169|     59|            while !waiter.is_null() {
  170|      0|                let next = (*waiter).next;
  171|      0|                let thread = (*waiter).thread.take().unwrap();
  172|      0|                (*waiter).signaled.store(true, Ordering::Release);
  173|      0|                waiter = next;
  174|      0|                thread.unpark();
  175|      0|            }
  176|       |        }
  177|     59|    }
_RNvNtCs3WrfEAqP78b_9once_cell3imp18initialize_or_wait:
  187|     59|fn initialize_or_wait(queue: &AtomicPtr<Waiter>, mut init: Option<&mut dyn FnMut() -> bool>) {
  188|     59|    let mut curr_queue = queue.load(Ordering::Acquire);
  189|       |
  190|     59|    loop {
  191|     59|        let curr_state = strict::addr(curr_queue) & STATE_MASK;
  192|     59|        match (curr_state, &mut init) {
  193|      0|            (COMPLETE, _) => return,
  194|     59|            (INCOMPLETE, Some(init)) => {
  195|     59|                let exchange = queue.compare_exchange(
  196|     59|                    curr_queue,
  197|     59|                    strict::map_addr(curr_queue, |q| (q & !STATE_MASK) | RUNNING),
  198|     59|                    Ordering::Acquire,
  199|     59|                    Ordering::Acquire,
  200|     59|                );
  201|     59|                if let Err(new_queue) = exchange {
  202|      0|                    curr_queue = new_queue;
  203|      0|                    continue;
  204|     59|                }
  205|     59|                let mut guard = Guard { queue, new_queue: INCOMPLETE_PTR };
  206|     59|                if init() {
  207|     59|                    guard.new_queue = COMPLETE_PTR;
  208|     59|                }
  209|     59|                return;
  210|       |            }
  211|      0|            (INCOMPLETE, None) | (RUNNING, _) => {
  212|      0|                wait(&queue, curr_queue);
  213|      0|                curr_queue = queue.load(Ordering::Acquire);
  214|      0|            }
  215|      0|            _ => debug_assert!(false),
  216|       |        }
  217|       |    }
  218|     59|}

_RNvMs4_NtCs3WrfEAqP78b_9once_cell4syncINtB5_8OnceCellNtNtCsjYc3JqMxxfa_5alloc6string6StringE3getCsbTo8XeKCRZK_15direct_syscalls:
  922|    102|        pub fn get(&self) -> Option<&T> {
  923|    102|            if self.0.is_initialized() {
  924|       |                // Safe b/c value is initialized.
  925|      0|                Some(unsafe { self.get_unchecked() })
  926|       |            } else {
  927|    102|                None
  928|       |            }
  929|    102|        }
_RINvCs3WrfEAqP78b_9once_cell16unwrap_uncheckedNtNtCshM4Il2Z0i4R_4core4time8DurationECs7Ei498kZF3p_3fvm:
 1370|     59|unsafe fn unwrap_unchecked<T>(val: Option<T>) -> T {
 1371|     59|    match val {
 1372|     59|        Some(value) => value,
 1373|       |        None => {
 1374|      0|            debug_assert!(false);
 1375|      0|            core::hint::unreachable_unchecked()
 1376|       |        }
 1377|       |    }
 1378|     59|}
_RNCINvMs4_NtCs3WrfEAqP78b_9once_cell4syncINtB8_8OnceCellNtNtCshM4Il2Z0i4R_4core4time8DurationE11get_or_initNCNvB4_10try_insert0E0Cs7Ei498kZF3p_3fvm:
 1079|     59|            match self.get_or_try_init(|| Ok::<T, Void>(f())) {
_RNvXNtCs3WrfEAqP78b_9once_cell4syncINtB2_8OnceCellNtNtCshM4Il2Z0i4R_4core4time8DurationENtNtBQ_7default7Default7defaultCs7Ei498kZF3p_3fvm:
  863|     85|        fn default() -> OnceCell<T> {
  864|     85|            OnceCell::new()
  865|     85|        }
_RINvCs3WrfEAqP78b_9once_cell16unwrap_uncheckedRNtNtCshM4Il2Z0i4R_4core4time8DurationECs7Ei498kZF3p_3fvm:
 1370|     59|unsafe fn unwrap_unchecked<T>(val: Option<T>) -> T {
 1371|     59|    match val {
 1372|     59|        Some(value) => value,
 1373|       |        None => {
 1374|      0|            debug_assert!(false);
 1375|      0|            core::hint::unreachable_unchecked()
 1376|       |        }
 1377|       |    }
 1378|     59|}
_RINvCs3WrfEAqP78b_9once_cell16unwrap_uncheckedNCINvMs4_NtB2_4syncINtBR_8OnceCellNtNtCshM4Il2Z0i4R_4core4time8DurationE11get_or_initNCNvBN_10try_insert0E0ECs7Ei498kZF3p_3fvm:
 1370|     59|unsafe fn unwrap_unchecked<T>(val: Option<T>) -> T {
 1371|     59|    match val {
 1372|     59|        Some(value) => value,
 1373|       |        None => {
 1374|      0|            debug_assert!(false);
 1375|      0|            core::hint::unreachable_unchecked()
 1376|       |        }
 1377|       |    }
 1378|     59|}
_RINvMs4_NtCs3WrfEAqP78b_9once_cell4syncINtB6_8OnceCellNtNtCshM4Il2Z0i4R_4core4time8DurationE15get_or_try_initNCINvB2_11get_or_initNCNvB2_10try_insert0E0NtNvMs4_B6_IBC_pE11get_or_init4VoidECs7Ei498kZF3p_3fvm:
 1111|     59|        pub fn get_or_try_init<F, E>(&self, f: F) -> Result<&T, E>
 1112|     59|        where
 1113|     59|            F: FnOnce() -> Result<T, E>,
 1114|     59|        {
 1115|       |            // Fast path check
 1116|     59|            if let Some(value) = self.get() {
 1117|      0|                return Ok(value);
 1118|     59|            }
 1119|     59|
 1120|     59|            self.0.initialize(f)?;
 1121|       |
 1122|       |            // Safe b/c value is initialized.
 1123|     59|            debug_assert!(self.0.is_initialized());
 1124|     59|            Ok(unsafe { self.get_unchecked() })
 1125|     59|        }
_RNvMs4_NtCs3WrfEAqP78b_9once_cell4syncINtB5_8OnceCellNtNtCshM4Il2Z0i4R_4core4time8DurationE3setCs7Ei498kZF3p_3fvm:
 1017|     59|        pub fn set(&self, value: T) -> Result<(), T> {
 1018|     59|            match self.try_insert(value) {
 1019|     59|                Ok(_) => Ok(()),
 1020|      0|                Err((_, value)) => Err(value),
 1021|       |            }
 1022|     59|        }
_RNvMs4_NtCs3WrfEAqP78b_9once_cell4syncINtB5_8OnceCellNtNtCshM4Il2Z0i4R_4core4time8DurationE3newCs7Ei498kZF3p_3fvm:
  909|     85|        pub const fn new() -> OnceCell<T> {
  910|     85|            OnceCell(Imp::new())
  911|     85|        }
_RNvMs4_NtCs3WrfEAqP78b_9once_cell4syncINtB5_8OnceCellNtNtCshM4Il2Z0i4R_4core4time8DurationE3getCs7Ei498kZF3p_3fvm:
  922|     59|        pub fn get(&self) -> Option<&T> {
  923|     59|            if self.0.is_initialized() {
  924|       |                // Safe b/c value is initialized.
  925|      0|                Some(unsafe { self.get_unchecked() })
  926|       |            } else {
  927|     59|                None
  928|       |            }
  929|     59|        }
_RNvMs4_NtCs3WrfEAqP78b_9once_cell4syncINtB5_8OnceCellNtNtCshM4Il2Z0i4R_4core4time8DurationE13get_uncheckedCs7Ei498kZF3p_3fvm:
  990|     59|        pub unsafe fn get_unchecked(&self) -> &T {
  991|     59|            self.0.get_unchecked()
  992|     59|        }
_RINvMs4_NtCs3WrfEAqP78b_9once_cell4syncINtB6_8OnceCellNtNtCshM4Il2Z0i4R_4core4time8DurationE11get_or_initNCNvB2_10try_insert0ECs7Ei498kZF3p_3fvm:
 1074|     59|        pub fn get_or_init<F>(&self, f: F) -> &T
 1075|     59|        where
 1076|     59|            F: FnOnce() -> T,
 1077|     59|        {
 1078|     59|            enum Void {}
 1079|     59|            match self.get_or_try_init(|| Ok::<T, Void>(f())) {
 1080|     59|                Ok(val) => val,
 1081|     59|                Err(void) => match void {},
 1082|     59|            }
 1083|     59|        }
_RNCNvMs4_NtCs3WrfEAqP78b_9once_cell4syncINtB7_8OnceCellNtNtCshM4Il2Z0i4R_4core4time8DurationE10try_insert0Cs7Ei498kZF3p_3fvm:
 1041|     59|            let res = self.get_or_init(|| unsafe { unwrap_unchecked(value.take()) });
_RNvMs4_NtCs3WrfEAqP78b_9once_cell4syncINtB5_8OnceCellNtNtCshM4Il2Z0i4R_4core4time8DurationE10try_insertCs7Ei498kZF3p_3fvm:
 1039|     59|        pub fn try_insert(&self, value: T) -> Result<&T, (&T, T)> {
 1040|     59|            let mut value = Some(value);
 1041|     59|            let res = self.get_or_init(|| unsafe { unwrap_unchecked(value.take()) });
 1042|     59|            match value {
 1043|     59|                None => Ok(res),
 1044|      0|                Some(value) => Err((res, value)),
 1045|       |            }
 1046|     59|        }
_RNvMs4_NtCs3WrfEAqP78b_9once_cell4syncINtB5_8OnceCellINtNtCshM4Il2Z0i4R_4core6result6ResultuNtNtCsjYc3JqMxxfa_5alloc6string6StringEE3newCs3hbrbrmFUf_8wasmtime:
  909|    204|        pub const fn new() -> OnceCell<T> {
  910|    204|            OnceCell(Imp::new())
  911|    204|        }

_RNvMNvNtNtCsaySvaz5DPef_12futures_util2io4take1__INtB4_4TakeQRShE7projectCsitTtQF8ArIt_8fvm_fuzz:
  926|  3.77k|        $proj_vis fn $method_ident<'__pin>(
  927|  3.77k|            self: $crate::__private::Pin<&'__pin $($mut)? Self>,
  928|  3.77k|        ) -> $proj_ty_ident <'__pin, $($ty_generics)*> {
  929|  3.77k|            unsafe {
  930|  3.77k|                let Self { $($field),* } = self.$get_method();
  931|  3.77k|                $proj_ty_ident {
  932|  3.77k|                    $(
  933|  3.77k|                        $field: $crate::__pin_project_make_unsafe_field_proj!(
  934|  3.77k|                            $(#[$pin])? $field
  935|  3.77k|                        )
  936|  3.77k|                    ),+
  937|  3.77k|                }
  938|  3.77k|            }
  939|  3.77k|        }

_RNvXsg_NtCs27Gwpxl4iNu_10ppv_lite864softINtB5_2x2INtNtNtNtB7_6x86_644sse24avx212u32x4x2_avx2NtBS_4NoNIENtBQ_2G0ENtNtB7_5types10LaneWords422shuffle_lane_words1230CsHILSoMIldr_11rand_chacha:
  208|    312|    fn shuffle_lane_words1230(self) -> Self {
  209|    312|        Self::new([
  210|    312|            self.0[0].shuffle_lane_words1230(),
  211|    312|            self.0[1].shuffle_lane_words1230(),
  212|    312|        ])
  213|    312|    }
_RNvXsg_NtCs27Gwpxl4iNu_10ppv_lite864softINtB5_2x2INtNtNtNtB7_6x86_644sse24avx212u32x4x2_avx2NtBS_4NoNIENtBQ_2G0ENtNtB7_5types10LaneWords422shuffle_lane_words2301CsHILSoMIldr_11rand_chacha:
  201|    312|    fn shuffle_lane_words2301(self) -> Self {
  202|    312|        Self::new([
  203|    312|            self.0[0].shuffle_lane_words2301(),
  204|    312|            self.0[1].shuffle_lane_words2301(),
  205|    312|        ])
  206|    312|    }
_RNvXs_NtCs27Gwpxl4iNu_10ppv_lite864softINtB4_2x2INtNtNtNtB6_6x86_644sse24avx212u32x4x2_avx2NtBR_4NoNIENtBP_2G0ENtNtB6_5types16RotateEachWord3224rotate_each_word_right25CsHILSoMIldr_11rand_chacha:
   42|    312|        fn $fn(self) -> Self {
   43|    312|            x2::new([self.0[0].$fn(), self.0[1].$fn()])
   44|    312|        }
_RNvMNtCs27Gwpxl4iNu_10ppv_lite864softINtB2_2x2INtNtNtNtB4_6x86_644sse24avx212u32x4x2_avx2NtBP_4NoNIENtBN_2G0E3newCsHILSoMIldr_11rand_chacha:
   13|  3.56k|    pub fn new(xs: [W; 2]) -> Self {
   14|  3.56k|        x2(xs, PhantomData)
   15|  3.56k|    }
_RNvXsG_NtCs27Gwpxl4iNu_10ppv_lite864softINtB5_2x2INtNtNtNtB7_6x86_644sse24avx212u32x4x2_avx2NtBS_4NoNIENtBQ_2G0ENtNtNtCshM4Il2Z0i4R_4core3ops3bit6BitXor6bitxorCsHILSoMIldr_11rand_chacha:
   22|  1.24k|            fn $fn(self, rhs: Self) -> Self::Output {
   23|  1.24k|                x2::new([self.0[0].$fn(rhs.0[0]), self.0[1].$fn(rhs.0[1])])
   24|  1.24k|            }
_RNvXs_NtCs27Gwpxl4iNu_10ppv_lite864softINtB4_2x2INtNtNtNtB6_6x86_644sse24avx212u32x4x2_avx2NtBR_4NoNIENtBP_2G0ENtNtB6_5types16RotateEachWord3224rotate_each_word_right16CsHILSoMIldr_11rand_chacha:
   42|    312|        fn $fn(self) -> Self {
   43|    312|            x2::new([self.0[0].$fn(), self.0[1].$fn()])
   44|    312|        }
_RNvXs_NtCs27Gwpxl4iNu_10ppv_lite864softINtB4_2x2INtNtNtNtB6_6x86_644sse24avx212u32x4x2_avx2NtBR_4NoNIENtBP_2G0ENtNtB6_5types16RotateEachWord3224rotate_each_word_right24CsHILSoMIldr_11rand_chacha:
   42|    312|        fn $fn(self) -> Self {
   43|    312|            x2::new([self.0[0].$fn(), self.0[1].$fn()])
   44|    312|        }
_RNvXs_NtCs27Gwpxl4iNu_10ppv_lite864softINtB4_2x2INtNtNtNtB6_6x86_644sse24avx212u32x4x2_avx2NtBR_4NoNIENtBP_2G0ENtNtB6_5types16RotateEachWord3224rotate_each_word_right20CsHILSoMIldr_11rand_chacha:
   42|    312|        fn $fn(self) -> Self {
   43|    312|            x2::new([self.0[0].$fn(), self.0[1].$fn()])
   44|    312|        }
_RNvXsM_NtCs27Gwpxl4iNu_10ppv_lite864softINtB5_2x2INtNtNtNtB7_6x86_644sse24avx212u32x4x2_avx2NtBS_4NoNIENtBQ_2G0ENtNtNtCshM4Il2Z0i4R_4core3ops5arith9AddAssign10add_assignCsHILSoMIldr_11rand_chacha:
   32|  1.24k|            fn $fn_assign(&mut self, rhs: Self) {
   33|  1.24k|                (self.0[0]).$fn_assign(rhs.0[0]);
   34|  1.24k|                (self.0[1]).$fn_assign(rhs.0[1]);
   35|  1.24k|            }
_RNvXsg_NtCs27Gwpxl4iNu_10ppv_lite864softINtB5_2x2INtNtNtNtB7_6x86_644sse24avx212u32x4x2_avx2NtBS_4NoNIENtBQ_2G0ENtNtB7_5types10LaneWords422shuffle_lane_words3012CsHILSoMIldr_11rand_chacha:
  215|    312|    fn shuffle_lane_words3012(self) -> Self {
  216|    312|        Self::new([
  217|    312|            self.0[0].shuffle_lane_words3012(),
  218|    312|            self.0[1].shuffle_lane_words3012(),
  219|    312|        ])
  220|    312|    }

_RINvYINtNtCs27Gwpxl4iNu_10ppv_lite866x86_6410SseMachineNtB6_5YesS3NtB6_5YesS4NtB6_4NoNIENtNtB8_5types7Machine7read_leINtNtB6_4sse210u32x4_sse2BR_B12_B1d_EECsHILSoMIldr_11rand_chacha:
  259|      2|    fn read_le<V>(self, input: &[u8]) -> V
  260|      2|    where
  261|      2|        V: StoreBytes,
  262|      2|    {
  263|      2|        unsafe { V::unsafe_read_le(input) }
  264|      2|    }
_RINvYINtNtCs27Gwpxl4iNu_10ppv_lite866x86_6411Avx2MachineNtB6_4NoNIENtNtB8_5types7Machine3vecINtNtB6_4sse210u32x4_sse2NtB6_5YesS3NtB6_5YesS4BS_EAmj4_ECsHILSoMIldr_11rand_chacha:
  251|     26|    fn vec<V, A>(self, a: A) -> V
  252|     26|    where
  253|     26|        V: MultiLane<A>,
  254|     26|    {
  255|     26|        V::from_lanes(a)
  256|     26|    }
_RINvYINtNtCs27Gwpxl4iNu_10ppv_lite866x86_6411Avx2MachineNtB6_4NoNIENtNtB8_5types7Machine6unpackNtB6_14vec128_storageINtNtB6_4sse210u32x4_sse2NtB6_5YesS3NtB6_5YesS4BS_EECsHILSoMIldr_11rand_chacha:
  246|    234|    fn unpack<S, V: Store<S>>(self, s: S) -> V {
  247|    234|        unsafe { V::unpack(s) }
  248|    234|    }
_RINvYINtNtCs27Gwpxl4iNu_10ppv_lite866x86_6411Avx2MachineNtB6_4NoNIENtNtB8_5types7Machine6unpackNtB6_14vec512_storageINtNtB8_4soft2x2INtNtNtB6_4sse24avx212u32x4x2_avx2BS_ENtB2b_2G0EECsHILSoMIldr_11rand_chacha:
  246|     26|    fn unpack<S, V: Store<S>>(self, s: S) -> V {
  247|     26|        unsafe { V::unpack(s) }
  248|     26|    }

_RNvNtCsHILSoMIldr_11rand_chacha4guts11init_chacha:
  333|      1|        $($pub $(($krate))*)* fn $name($($arg: $argty),*) -> $ret {
  334|       |            #[inline(always)]
  335|       |            fn fn_impl<$MTy: $crate::Machine>($mach: $MTy, $($arg: $argty),*) -> $ret $body
  336|       |            use std::arch::x86_64::*;
  337|       |            #[target_feature(enable = "avx")]
  338|       |            unsafe fn impl_avx($($arg: $argty),*) -> $ret {
  339|       |                fn_impl($crate::x86_64::AVX::instance(), $($arg),*)
  340|       |            }
  341|       |            #[target_feature(enable = "sse2")]
  342|       |            unsafe fn impl_sse2($($arg: $argty),*) -> $ret {
  343|       |                fn_impl($crate::x86_64::SSE2::instance(), $($arg),*)
  344|       |            }
  345|       |            unsafe {
  346|      0|                if is_x86_feature_detected!("avx") {
  347|      1|                    impl_avx($($arg),*)
  348|      0|                } else if is_x86_feature_detected!("sse2") {
  349|      0|                    impl_sse2($($arg),*)
  350|       |                } else {
  351|      0|                    unimplemented!()
  352|       |                }
  353|       |            }
  354|      1|        }
_RNvNvNtCsHILSoMIldr_11rand_chacha4guts11refill_wide9impl_avx2:
  255|     26|            unsafe fn impl_avx2($($arg: $argty),*) -> $ret {
  256|     26|                let ret = fn_impl($crate::x86_64::AVX2::instance(), $($arg),*);
  257|     26|                _mm256_zeroupper();
  258|     26|                ret
  259|     26|            }
_RNvXs2_NtCs27Gwpxl4iNu_10ppv_lite866x86_64NtB5_14vec128_storageINtNtCshM4Il2Z0i4R_4core7convert4FromAmj4_E4from:
  130|      1|    fn from(u32x4: [u32; 4]) -> Self {
  131|      1|        vec128_storage { u32x4 }
  132|      1|    }
_RNvNvNtCsHILSoMIldr_11rand_chacha4guts11init_chacha8impl_avx:
  338|      1|            unsafe fn impl_avx($($arg: $argty),*) -> $ret {
  339|      1|                fn_impl($crate::x86_64::AVX::instance(), $($arg),*)
  340|      1|            }
_RNvXNtCs27Gwpxl4iNu_10ppv_lite866x86_64INtB2_10SseMachineNtB2_5YesS3NtB2_5YesS4NtB2_4NoNIENtNtB4_5types7Machine8instanceCsHILSoMIldr_11rand_chacha:
   64|      1|    unsafe fn instance() -> Self {
   65|      1|        SseMachine(PhantomData)
   66|      1|    }
_RNvNtCsHILSoMIldr_11rand_chacha4guts11refill_wide:
  250|     26|        $($pub$(($krate))*)* fn $name($($arg: $argty),*) -> $ret {
  251|       |            #[inline(always)]
  252|       |            fn fn_impl<$MTy: $crate::Machine>($mach: $MTy, $($arg: $argty),*) -> $ret $body
  253|       |            use std::arch::x86_64::*;
  254|       |            #[target_feature(enable = "avx2")]
  255|       |            unsafe fn impl_avx2($($arg: $argty),*) -> $ret {
  256|       |                let ret = fn_impl($crate::x86_64::AVX2::instance(), $($arg),*);
  257|       |                _mm256_zeroupper();
  258|       |                ret
  259|       |            }
  260|       |            #[target_feature(enable = "avx")]
  261|       |            #[target_feature(enable = "sse4.1")]
  262|       |            #[target_feature(enable = "ssse3")]
  263|       |            unsafe fn impl_avx($($arg: $argty),*) -> $ret {
  264|       |                let ret = fn_impl($crate::x86_64::AVX::instance(), $($arg),*);
  265|       |                _mm256_zeroupper();
  266|       |                ret
  267|       |            }
  268|       |            #[target_feature(enable = "sse4.1")]
  269|       |            #[target_feature(enable = "ssse3")]
  270|       |            unsafe fn impl_sse41($($arg: $argty),*) -> $ret {
  271|       |                fn_impl($crate::x86_64::SSE41::instance(), $($arg),*)
  272|       |            }
  273|       |            #[target_feature(enable = "ssse3")]
  274|       |            unsafe fn impl_ssse3($($arg: $argty),*) -> $ret {
  275|       |                fn_impl($crate::x86_64::SSSE3::instance(), $($arg),*)
  276|       |            }
  277|       |            #[target_feature(enable = "sse2")]
  278|       |            unsafe fn impl_sse2($($arg: $argty),*) -> $ret {
  279|       |                fn_impl($crate::x86_64::SSE2::instance(), $($arg),*)
  280|       |            }
  281|       |            unsafe {
  282|      0|                if is_x86_feature_detected!("avx2") {
  283|     26|                    impl_avx2($($arg),*)
  284|      0|                } else if is_x86_feature_detected!("avx") {
  285|      0|                    impl_avx($($arg),*)
  286|      0|                } else if is_x86_feature_detected!("sse4.1") {
  287|      0|                    impl_sse41($($arg),*)
  288|      0|                } else if is_x86_feature_detected!("ssse3") {
  289|      0|                    impl_ssse3($($arg),*)
  290|      0|                } else if is_x86_feature_detected!("sse2") {
  291|      0|                    impl_sse2($($arg),*)
  292|       |                } else {
  293|      0|                    unimplemented!()
  294|       |                }
  295|       |            }
  296|     26|        }
_RNvXs_NtCs27Gwpxl4iNu_10ppv_lite866x86_64INtB4_11Avx2MachineNtB4_4NoNIENtNtB6_5types7Machine8instanceCsHILSoMIldr_11rand_chacha:
   92|     26|    unsafe fn instance() -> Self {
   93|     26|        Avx2Machine(PhantomData)
   94|     26|    }

_RNvXsr_NtNtNtCs27Gwpxl4iNu_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtNtCshM4Il2Z0i4R_4core3ops3bit6BitXor6bitxorCsHILSoMIldr_11rand_chacha:
 1543|  2.49k|                fn $op_fn(self, rhs: Self) -> Self::Output {
 1544|  2.49k|                    Self::new(unsafe { $impl_fn(self.x, rhs.x) })
 1545|  2.49k|                }
_RNvXs10_NtNtCs27Gwpxl4iNu_10ppv_lite866x86_644sse2INtB6_10u32x4_sse2NtB8_5YesS3NtB8_5YesS4NtB8_4NoNIENtNtBa_5types10StoreBytes8write_leCsHILSoMIldr_11rand_chacha:
   89|    416|            fn write_le(self, out: &mut [u8]) {
   90|    416|                assert_eq!(out.len(), 16);
   91|    416|                unsafe { _mm_storeu_si128(out.as_mut_ptr() as *mut _, self.x) }
   92|    416|            }
_RNvXs6_NtNtCs27Gwpxl4iNu_10ppv_lite866x86_644sse2INtB5_10u32x4_sse2NtB7_5YesS3NtB7_5YesS4NtB7_4NoNIEINtNtB9_5types9MultiLaneAmj4_E10from_lanesCsHILSoMIldr_11rand_chacha:
  331|     26|    fn from_lanes(xs: [u32; 4]) -> Self {
  332|     26|        unsafe {
  333|     26|            let mut x = _mm_cvtsi64_si128((xs[0] as u64 | ((xs[1] as u64) << 32)) as i64);
  334|     26|            x = _mm_insert_epi64(x, (xs[2] as u64 | ((xs[3] as u64) << 32)) as i64, 1);
  335|     26|            Self::new(x)
  336|     26|        }
  337|     26|    }
_RNvXs2_NtNtNtCs27Gwpxl4iNu_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIEINtNtBb_5types9MultiLaneAINtB7_10u32x4_sse2NtB9_5YesS3NtB9_5YesS4B1c_Ej2_E8to_lanesCsHILSoMIldr_11rand_chacha:
 1430|    208|        fn to_lanes(self) -> [u32x4_sse2<YesS3, YesS4, NI>; 2] {
 1431|    208|            unsafe {
 1432|    208|                [
 1433|    208|                    u32x4_sse2::new(_mm256_extracti128_si256(self.x, 0)),
 1434|    208|                    u32x4_sse2::new(_mm256_extracti128_si256(self.x, 1)),
 1435|    208|                ]
 1436|    208|            }
 1437|    208|        }
_RNvMsZ_NtNtCs27Gwpxl4iNu_10ppv_lite866x86_644sse2INtB5_10u32x4_sse2NtB7_5YesS3NtB7_5YesS4NtB7_4NoNIE3newCsHILSoMIldr_11rand_chacha:
   64|  1.45k|            fn new(x: __m128i) -> Self {
   65|  1.45k|                $vec {
   66|  1.45k|                    x,
   67|  1.45k|                    s3: PhantomData,
   68|  1.45k|                    s4: PhantomData,
   69|  1.45k|                    ni: PhantomData,
   70|  1.45k|                }
   71|  1.45k|            }
_RNvXs6_NtNtNtCs27Gwpxl4iNu_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtBb_5types16RotateEachWord3224rotate_each_word_right16CsHILSoMIldr_11rand_chacha:
 1470|    624|            fn $name(self) -> Self {
 1471|    624|                Self::new(unsafe {
 1472|    624|                    _mm256_shuffle_epi8(self.x, _mm256_set_epi64x($k0, $k1, $k0, $k1))
 1473|    624|                })
 1474|    624|            }
_RNvXsf_NtNtNtCs27Gwpxl4iNu_10ppv_lite866x86_644sse24avx2INtNtBb_4soft2x2INtB5_12u32x4x2_avx2NtB9_4NoNIENtB7_2G0EINtNtBb_5types9MultiLaneAINtB7_10u32x4_sse2NtB9_5YesS3NtB9_5YesS4B1s_Ej4_E8to_lanesCsHILSoMIldr_11rand_chacha:
 1611|    104|        fn to_lanes(self) -> [u32x4_sse2<YesS3, YesS4, NI>; 4] {
 1612|    104|            let [a, b] = self.0[0].to_lanes();
 1613|    104|            let [c, d] = self.0[1].to_lanes();
 1614|    104|            [a, b, c, d]
 1615|    104|        }
_RNvXs10_NtNtCs27Gwpxl4iNu_10ppv_lite866x86_644sse2INtB6_10u32x4_sse2NtB8_5YesS3NtB8_5YesS4NtB8_4NoNIENtNtBa_5types10StoreBytes14unsafe_read_leCsHILSoMIldr_11rand_chacha:
   79|      2|            unsafe fn unsafe_read_le(input: &[u8]) -> Self {
   80|      2|                assert_eq!(input.len(), 16);
   81|      2|                Self::new(_mm_loadu_si128(input.as_ptr() as *const _))
   82|      2|            }
_RNvXsX_NtNtCs27Gwpxl4iNu_10ppv_lite866x86_644sse2INtB5_10u32x4_sse2NtB7_5YesS3NtB7_5YesS4NtB7_4NoNIEINtNtB9_5types5StoreNtB7_14vec128_storageE6unpackCsHILSoMIldr_11rand_chacha:
   52|    234|            unsafe fn unpack(x: vec128_storage) -> Self {
   53|    234|                Self::new(x.sse2)
   54|    234|            }
_RNvXsq_NtNtNtCs27Gwpxl4iNu_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtNtCshM4Il2Z0i4R_4core3ops5arith9AddAssign10add_assignCsHILSoMIldr_11rand_chacha:
 1527|  2.49k|                fn $assign_fn(&mut self, rhs: Self) {
 1528|  2.49k|                    *self = self.$bin_fn(rhs);
 1529|  2.49k|                }
_RNvXs0_NtNtNtCs27Gwpxl4iNu_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIEINtNtBb_5types5StoreNtB9_14vec256_storageE6unpackCsHILSoMIldr_11rand_chacha:
 1402|     52|        unsafe fn unpack(p: vec256_storage) -> Self {
 1403|     52|            Self::new(p.avx)
 1404|     52|        }
_RNvXsc_NtNtNtCs27Gwpxl4iNu_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtBb_5types10LaneWords422shuffle_lane_words1230CsHILSoMIldr_11rand_chacha:
 1582|    624|        fn shuffle_lane_words1230(self) -> Self {
 1583|    624|            Self::new(unsafe { _mm256_shuffle_epi32(self.x, 0b1001_0011) })
 1584|    624|        }
_RNvXs6_NtNtNtCs27Gwpxl4iNu_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtBb_5types16RotateEachWord3224rotate_each_word_right20CsHILSoMIldr_11rand_chacha:
 1480|    624|            fn $name(self) -> Self {
 1481|    624|                Self::new(unsafe {
 1482|    624|                    _mm256_or_si256(
 1483|    624|                        _mm256_srli_epi32(self.x, $i as i32),
 1484|    624|                        _mm256_slli_epi32(self.x, 32 - $i as i32),
 1485|    624|                    )
 1486|    624|                })
 1487|    624|            }
_RNvXs1R_NtNtCs27Gwpxl4iNu_10ppv_lite866x86_644sse2INtB6_10u32x4_sse2NtB8_5YesS3NtB8_5YesS4NtB8_4NoNIENtNtNtCshM4Il2Z0i4R_4core3ops5arith3Add3addCsHILSoMIldr_11rand_chacha:
   18|    416|            fn $fn(self, rhs: Self) -> Self::Output {
   19|    416|                Self::new(unsafe { $impl_fn(self.x, rhs.x) })
   20|    416|            }
_RNvXs2_NtNtNtCs27Gwpxl4iNu_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIEINtNtBb_5types9MultiLaneAINtB7_10u32x4_sse2NtB9_5YesS3NtB9_5YesS4B1c_Ej2_E10from_lanesCsHILSoMIldr_11rand_chacha:
 1439|    208|        fn from_lanes(x: [u32x4_sse2<YesS3, YesS4, NI>; 2]) -> Self {
 1440|    208|            Self::new(unsafe { _mm256_setr_m128i(x[0].x, x[1].x) })
 1441|    208|        }
_RNvXs6_NtNtNtCs27Gwpxl4iNu_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtBb_5types16RotateEachWord3224rotate_each_word_right25CsHILSoMIldr_11rand_chacha:
 1480|    624|            fn $name(self) -> Self {
 1481|    624|                Self::new(unsafe {
 1482|    624|                    _mm256_or_si256(
 1483|    624|                        _mm256_srli_epi32(self.x, $i as i32),
 1484|    624|                        _mm256_slli_epi32(self.x, 32 - $i as i32),
 1485|    624|                    )
 1486|    624|                })
 1487|    624|            }
_RNvXsY_NtNtCs27Gwpxl4iNu_10ppv_lite866x86_644sse2NtB7_14vec128_storageINtNtCshM4Il2Z0i4R_4core7convert4FromINtB5_10u32x4_sse2NtB7_5YesS3NtB7_5YesS4NtB7_4NoNIEE4fromCsHILSoMIldr_11rand_chacha:
   58|     28|            fn from(x: $vec<S3, S4, NI>) -> Self {
   59|     28|                vec128_storage { sse2: x.x }
   60|     28|            }
_RNvXs6_NtNtCs27Gwpxl4iNu_10ppv_lite866x86_644sse2INtB5_10u32x4_sse2NtB7_5YesS3NtB7_5YesS4NtB7_4NoNIEINtNtB9_5types9MultiLaneAmj4_E8to_lanesCsHILSoMIldr_11rand_chacha:
  323|    104|    fn to_lanes(self) -> [u32; 4] {
  324|    104|        unsafe {
  325|    104|            let x = _mm_cvtsi128_si64(self.x) as u64;
  326|    104|            let y = _mm_extract_epi64(self.x, 1) as u64;
  327|    104|            [x as u32, (x >> 32) as u32, y as u32, (y >> 32) as u32]
  328|    104|        }
  329|    104|    }
_RNvXse_NtNtNtCs27Gwpxl4iNu_10ppv_lite866x86_644sse24avx2INtNtBb_4soft2x2INtB5_12u32x4x2_avx2NtB9_4NoNIENtB7_2G0EINtNtBb_5types5StoreNtB9_14vec512_storageE6unpackCsHILSoMIldr_11rand_chacha:
 1602|     26|        unsafe fn unpack(p: vec512_storage) -> Self {
 1603|     26|            Self::new([
 1604|     26|                u32x4x2_avx2::unpack(p.avx[0]),
 1605|     26|                u32x4x2_avx2::unpack(p.avx[1]),
 1606|     26|            ])
 1607|     26|        }
_RNvXsc_NtNtNtCs27Gwpxl4iNu_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtBb_5types10LaneWords422shuffle_lane_words2301CsHILSoMIldr_11rand_chacha:
 1586|    624|        fn shuffle_lane_words2301(self) -> Self {
 1587|    624|            Self::new(unsafe { _mm256_shuffle_epi32(self.x, 0b0100_1110) })
 1588|    624|        }
_RNvXsv_NtNtNtCs27Gwpxl4iNu_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtNtCshM4Il2Z0i4R_4core3ops5arith3Add3addCsHILSoMIldr_11rand_chacha:
 1543|  2.49k|                fn $op_fn(self, rhs: Self) -> Self::Output {
 1544|  2.49k|                    Self::new(unsafe { $impl_fn(self.x, rhs.x) })
 1545|  2.49k|                }
_RNvMNtNtNtCs27Gwpxl4iNu_10ppv_lite866x86_644sse24avx2INtB2_12u32x4x2_avx2NtB6_4NoNIE3newCsHILSoMIldr_11rand_chacha:
 1394|  9.62k|        fn new(x: __m256i) -> Self {
 1395|  9.62k|            Self { x, ni: PhantomData }
 1396|  9.62k|        }
_RNvXsc_NtNtNtCs27Gwpxl4iNu_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtBb_5types10LaneWords422shuffle_lane_words3012CsHILSoMIldr_11rand_chacha:
 1590|    624|        fn shuffle_lane_words3012(self) -> Self {
 1591|    624|            Self::new(unsafe { _mm256_shuffle_epi32(self.x, 0b0011_1001) })
 1592|    624|        }
_RNvXs6_NtNtNtCs27Gwpxl4iNu_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtBb_5types16RotateEachWord3224rotate_each_word_right24CsHILSoMIldr_11rand_chacha:
 1470|    624|            fn $name(self) -> Self {
 1471|    624|                Self::new(unsafe {
 1472|    624|                    _mm256_shuffle_epi8(self.x, _mm256_set_epi64x($k0, $k1, $k0, $k1))
 1473|    624|                })
 1474|    624|            }
_RNvXsj_NtNtNtCs27Gwpxl4iNu_10ppv_lite866x86_644sse24avx2NtB9_14vec512_storageINtNtCshM4Il2Z0i4R_4core7convert4FromINtNtBb_4soft2x2INtB5_12u32x4x2_avx2NtB9_4NoNIENtB7_2G0EE4fromCsHILSoMIldr_11rand_chacha:
 1683|     26|        fn from(x: u32x4x4_avx2<NI>) -> Self {
 1684|     26|            Self {
 1685|     26|                avx: [
 1686|     26|                    vec256_storage { avx: x.0[0].x },
 1687|     26|                    vec256_storage { avx: x.0[1].x },
 1688|     26|                ],
 1689|     26|            }
 1690|     26|        }
_RNvXsl_NtNtCs27Gwpxl4iNu_10ppv_lite866x86_644sse2INtB5_10u32x4_sse2NtB7_5YesS3NtB7_5YesS4NtB7_4NoNIEINtNtB9_5types4Vec4mE6insertCsHILSoMIldr_11rand_chacha:
  523|    364|    fn insert(self, v: u32, i: u32) -> Self {
  524|    364|        Self::new(unsafe {
  525|    364|            match i {
  526|    182|                0 => _mm_insert_epi32(self.x, v as i32, 0),
  527|    182|                1 => _mm_insert_epi32(self.x, v as i32, 1),
  528|      0|                2 => _mm_insert_epi32(self.x, v as i32, 2),
  529|      0|                3 => _mm_insert_epi32(self.x, v as i32, 3),
  530|      0|                _ => unreachable!(),
  531|       |            }
  532|       |        })
  533|    364|    }
_RNvXsf_NtNtNtCs27Gwpxl4iNu_10ppv_lite866x86_644sse24avx2INtNtBb_4soft2x2INtB5_12u32x4x2_avx2NtB9_4NoNIENtB7_2G0EINtNtBb_5types9MultiLaneAINtB7_10u32x4_sse2NtB9_5YesS3NtB9_5YesS4B1s_Ej4_E10from_lanesCsHILSoMIldr_11rand_chacha:
 1617|    104|        fn from_lanes(x: [u32x4_sse2<YesS3, YesS4, NI>; 4]) -> Self {
 1618|    104|            let ab = u32x4x2_avx2::from_lanes([x[0], x[1]]);
 1619|    104|            let cd = u32x4x2_avx2::from_lanes([x[2], x[3]]);
 1620|    104|            Self::new([ab, cd])
 1621|    104|        }
_RNvXsl_NtNtCs27Gwpxl4iNu_10ppv_lite866x86_644sse2INtB5_10u32x4_sse2NtB7_5YesS3NtB7_5YesS4NtB7_4NoNIEINtNtB9_5types4Vec4mE7extractCsHILSoMIldr_11rand_chacha:
  519|    104|    fn extract(self, i: u32) -> u32 {
  520|    104|        self.to_lanes()[i as usize]
  521|    104|    }

_RINvXNtNtCsk2tDUwjDqRE_4rand13distributions7integerNtB5_8StandardINtNtB5_12distribution12DistributionhE6sampleNtNtNtB7_4rngs6thread9ThreadRngECsitTtQF8ArIt_8fvm_fuzz:
   23|  1.63k|    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> u8 {
   24|  1.63k|        rng.next_u32() as u8
   25|  1.63k|    }

_RINvXsB_NtNtCsk2tDUwjDqRE_4rand13distributions5otherNtB8_8StandardINtNtB8_12distribution12DistributionAhj10_E6sampleNtNtNtBa_4rngs6thread9ThreadRngECsitTtQF8ArIt_8fvm_fuzz:
  217|    102|            fn sample<R: Rng + ?Sized>(&self, _rng: &mut R) -> [T; $n] {
  218|    102|                [_rng.gen::<$t>(), $(_rng.gen::<$ts>()),*]
  219|    102|            }

_RINvCsk2tDUwjDqRE_4rand6randomAhj10_ECsitTtQF8ArIt_8fvm_fuzz:
  183|    102|pub fn random<T>() -> T
  184|    102|where Standard: Distribution<T> {
  185|    102|    thread_rng().gen()
  186|    102|}

_RINvYNtNtNtCsk2tDUwjDqRE_4rand4rngs6thread9ThreadRngNtNtB9_3rng3Rng3genAhj10_ECsitTtQF8ArIt_8fvm_fuzz:
   93|    102|    fn gen<T>(&mut self) -> T
   94|    102|    where Standard: Distribution<T> {
   95|    102|        Standard.sample(self)
   96|    102|    }
_RINvYNtNtNtCsk2tDUwjDqRE_4rand4rngs6thread9ThreadRngNtNtB9_3rng3Rng3genhECsitTtQF8ArIt_8fvm_fuzz:
   93|  1.63k|    fn gen<T>(&mut self) -> T
   94|  1.63k|    where Standard: Distribution<T> {
   95|  1.63k|        Standard.sample(self)
   96|  1.63k|    }

_RNvXs_NtNtNtCsk2tDUwjDqRE_4rand4rngs7adapter9reseedingINtB4_12ReseedingRngNtNtCsHILSoMIldr_11rand_chacha6chacha12ChaCha12CoreNtNtCs87mpcsWZVN2_9rand_core2os5OsRngENtB23_7RngCore8next_u32CsitTtQF8ArIt_8fvm_fuzz:
  119|  1.63k|    fn next_u32(&mut self) -> u32 {
  120|  1.63k|        self.0.next_u32()
  121|  1.63k|    }
_RNvXs2_NtNtNtCsk2tDUwjDqRE_4rand4rngs7adapter9reseedingINtB5_13ReseedingCoreNtNtCsHILSoMIldr_11rand_chacha6chacha12ChaCha12CoreNtNtCs87mpcsWZVN2_9rand_core2os5OsRngENtNtB25_5block12BlockRngCore8generateCsitTtQF8ArIt_8fvm_fuzz:
  173|     26|    fn generate(&mut self, results: &mut Self::Results) {
  174|     26|        let global_fork_counter = fork::get_fork_counter();
  175|     26|        if self.bytes_until_reseed <= 0 || self.is_forked(global_fork_counter) {
  176|       |            // We get better performance by not calling only `reseed` here
  177|       |            // and continuing with the rest of the function, but by directly
  178|       |            // returning from a non-inlined function.
  179|      0|            return self.reseed_and_generate(results, global_fork_counter);
  180|     26|        }
  181|     26|        let num_bytes = results.as_ref().len() * size_of::<Self::Item>();
  182|     26|        self.bytes_until_reseed -= num_bytes as i64;
  183|     26|        self.inner.generate(results);
  184|     26|    }
_RNvMs3_NtNtNtCsk2tDUwjDqRE_4rand4rngs7adapter9reseedingINtB5_13ReseedingCoreNtNtCsHILSoMIldr_11rand_chacha6chacha12ChaCha12CoreNtNtCs87mpcsWZVN2_9rand_core2os5OsRngE9is_forkedCsitTtQF8ArIt_8fvm_fuzz:
  226|     26|    fn is_forked(&self, global_fork_counter: usize) -> bool {
  227|     26|        // In theory, on 32-bit platforms, it is possible for
  228|     26|        // `global_fork_counter` to wrap around after ~4e9 forks.
  229|     26|        //
  230|     26|        // This check will detect a fork in the normal case where
  231|     26|        // `fork_counter < global_fork_counter`, and also when the difference
  232|     26|        // between both is greater than `isize::MAX` (wrapped around).
  233|     26|        //
  234|     26|        // It will still fail to detect a fork if there have been more than
  235|     26|        // `isize::MAX` forks, without any reseed in between. Seems unlikely
  236|     26|        // enough.
  237|     26|        (self.fork_counter.wrapping_sub(global_fork_counter) as isize) < 0
  238|     26|    }
_RNvMs3_NtNtNtCsk2tDUwjDqRE_4rand4rngs7adapter9reseedingINtB5_13ReseedingCoreNtNtCsHILSoMIldr_11rand_chacha6chacha12ChaCha12CoreNtNtCs87mpcsWZVN2_9rand_core2os5OsRngE3newBb_:
  193|      1|    fn new(rng: R, threshold: u64, reseeder: Rsdr) -> Self {
  194|      1|        use ::core::i64::MAX;
  195|      1|        fork::register_fork_handler();
  196|       |
  197|       |        // Because generating more values than `i64::MAX` takes centuries on
  198|       |        // current hardware, we just clamp to that value.
  199|       |        // Also we set a threshold of 0, which indicates no limit, to that
  200|       |        // value.
  201|      1|        let threshold = if threshold == 0 {
  202|      0|            MAX
  203|      1|        } else if threshold <= MAX as u64 {
  204|      1|            threshold as i64
  205|       |        } else {
  206|      0|            MAX
  207|       |        };
  208|       |
  209|      1|        ReseedingCore {
  210|      1|            inner: rng,
  211|      1|            reseeder,
  212|      1|            threshold: threshold as i64,
  213|      1|            bytes_until_reseed: threshold as i64,
  214|      1|            fork_counter: 0,
  215|      1|        }
  216|      1|    }
_RNvNtNtNtNtCsk2tDUwjDqRE_4rand4rngs7adapter9reseeding4fork21register_fork_handler:
  317|      1|    pub fn register_fork_handler() {
  318|      1|        static REGISTER: Once = Once::new();
  319|      1|        REGISTER.call_once(|| {
  320|       |            // Bump the counter before and after forking (see #1169):
  321|       |            let ret = unsafe { libc::pthread_atfork(
  322|       |                Some(fork_handler),
  323|       |                Some(fork_handler),
  324|       |                Some(fork_handler),
  325|       |            ) };
  326|       |            if ret != 0 {
  327|       |                panic!("libc::pthread_atfork failed with code {}", ret);
  328|       |            }
  329|      1|        });
  330|      1|    }
_RNCNvNtNtNtNtCsk2tDUwjDqRE_4rand4rngs7adapter9reseeding4fork21register_fork_handler0Bb_:
  319|      1|        REGISTER.call_once(|| {
  320|      1|            // Bump the counter before and after forking (see #1169):
  321|      1|            let ret = unsafe { libc::pthread_atfork(
  322|      1|                Some(fork_handler),
  323|      1|                Some(fork_handler),
  324|      1|                Some(fork_handler),
  325|      1|            ) };
  326|      1|            if ret != 0 {
  327|      0|                panic!("libc::pthread_atfork failed with code {}", ret);
  328|      1|            }
  329|      1|        });
_RNvNtNtNtNtCsk2tDUwjDqRE_4rand4rngs7adapter9reseeding4fork16get_fork_counter:
  307|     26|    pub fn get_fork_counter() -> usize {
  308|     26|        RESEEDING_RNG_FORK_COUNTER.load(Ordering::Relaxed)
  309|     26|    }
_RNvMNtNtNtCsk2tDUwjDqRE_4rand4rngs7adapter9reseedingINtB2_12ReseedingRngNtNtCsHILSoMIldr_11rand_chacha6chacha12ChaCha12CoreNtNtCs87mpcsWZVN2_9rand_core2os5OsRngE3newB8_:
  101|      1|    pub fn new(rng: R, threshold: u64, reseeder: Rsdr) -> Self {
  102|      1|        ReseedingRng(BlockRng::new(ReseedingCore::new(rng, threshold, reseeder)))
  103|      1|    }

_RNvXs_NtNtCsk2tDUwjDqRE_4rand4rngs6threadNtB4_9ThreadRngNtCs87mpcsWZVN2_9rand_core7RngCore8next_u32:
  101|  1.63k|    fn next_u32(&mut self) -> u32 {
  102|  1.63k|        // SAFETY: We must make sure to stop using `rng` before anyone else
  103|  1.63k|        // creates another mutable reference
  104|  1.63k|        let rng = unsafe { &mut *self.rng.get() };
  105|  1.63k|        rng.next_u32()
  106|  1.63k|    }
_RNCNvNtNtCsk2tDUwjDqRE_4rand4rngs6thread10thread_rng0B7_:
   89|    102|    let rng = THREAD_RNG_KEY.with(|t| t.clone());
_RNCNvNvNtNtCsk2tDUwjDqRE_4rand4rngs6thread14THREAD_RNG_KEY7___getit0B9_:
   67|      1|thread_local!(
   68|      1|    // We require Rc<..> to avoid premature freeing when thread_rng is used
   69|      1|    // within thread-local destructors. See #968.
   70|      1|    static THREAD_RNG_KEY: Rc<UnsafeCell<ReseedingRng<Core, OsRng>>> = {
   71|      1|        let r = Core::from_rng(OsRng).unwrap_or_else(|err|
   72|      1|                panic!("could not initialize thread_rng: {}", err));
   73|      1|        let rng = ReseedingRng::new(r,
   74|      1|                                    THREAD_RNG_RESEED_THRESHOLD,
   75|      1|                                    OsRng);
   76|      1|        Rc::new(UnsafeCell::new(rng))
   77|      1|    }
   78|      1|);
_RNvNtNtCsk2tDUwjDqRE_4rand4rngs6thread10thread_rng:
   88|    102|pub fn thread_rng() -> ThreadRng {
   89|    102|    let rng = THREAD_RNG_KEY.with(|t| t.clone());
   90|    102|    ThreadRng { rng }
   91|    102|}

_RNvXs0_NtCsHILSoMIldr_11rand_chacha6chachaINtB5_7Array64mEINtNtCshM4Il2Z0i4R_4core7convert5AsMutSmE6as_mutCsitTtQF8ArIt_8fvm_fuzz:
   51|     26|    fn as_mut(&mut self) -> &mut [T] {
   52|     26|        &mut self.0
   53|     26|    }
_RNvXsm_NtCsHILSoMIldr_11rand_chacha6chachaNtB5_12ChaCha12CoreNtNtCs87mpcsWZVN2_9rand_core5block12BlockRngCore8generate:
   89|     26|            fn generate(&mut self, r: &mut Self::Results) {
   90|     26|                // Fill slice of words by writing to equivalent slice of bytes, then fixing endianness.
   91|     26|                self.state.refill4($rounds, unsafe {
   92|     26|                    &mut *(&mut *r as *mut Array64<u32> as *mut [u8; 256])
   93|     26|                });
   94|  1.66k|                for x in r.as_mut() {
   95|  1.66k|                    *x = x.to_le();
   96|  1.66k|                }
   97|     26|            }
_RNvXsn_NtCsHILSoMIldr_11rand_chacha6chachaNtB5_12ChaCha12CoreNtCs87mpcsWZVN2_9rand_core11SeedableRng9from_seed:
  103|      1|            fn from_seed(seed: Self::Seed) -> Self {
  104|      1|                $ChaChaXCore { state: ChaCha::new(&seed, &[0u8; 8]) }
  105|      1|            }
_RNvXs_NtCsHILSoMIldr_11rand_chacha6chachaINtB4_7Array64mEINtNtCshM4Il2Z0i4R_4core7convert5AsRefSmE6as_refCsitTtQF8ArIt_8fvm_fuzz:
   46|  3.31k|    fn as_ref(&self) -> &[T] {
   47|  3.31k|        &self.0
   48|  3.31k|    }
_RNvXNtCsHILSoMIldr_11rand_chacha6chachaINtB2_7Array64mENtNtCshM4Il2Z0i4R_4core7default7Default7defaultCsk2tDUwjDqRE_4rand:
   32|      1|    fn default() -> Self {
   33|      1|        Self([
   34|      1|            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),
   35|      1|            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),
   36|      1|            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),
   37|      1|            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),
   38|      1|            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),
   39|      1|            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),
   40|      1|            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),
   41|      1|            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),
   42|      1|        ])
   43|      1|    }
_RNvXs_NtCsHILSoMIldr_11rand_chacha6chachaINtB4_7Array64mEINtNtCshM4Il2Z0i4R_4core7convert5AsRefSmE6as_refCsk2tDUwjDqRE_4rand:
   46|      1|    fn as_ref(&self) -> &[T] {
   47|      1|        &self.0
   48|      1|    }

_RNvMNtCsHILSoMIldr_11rand_chacha4gutsNtB2_6ChaCha7refill4:
   84|     26|    pub fn refill4(&mut self, drounds: u32, out: &mut [u8; BUFSZ]) {
   85|     26|        refill_wide(self, drounds, out)
   86|     26|    }
_RNvMNtCsHILSoMIldr_11rand_chacha4gutsNtB2_6ChaCha3new:
   72|      1|    pub fn new(key: &[u8; 32], nonce: &[u8]) -> Self {
   73|      1|        init_chacha(key, nonce)
   74|      1|    }
_RINvNtCsHILSoMIldr_11rand_chacha4guts5roundINtNtCs27Gwpxl4iNu_10ppv_lite864soft2x2INtNtNtNtBK_6x86_644sse24avx212u32x4x2_avx2NtB1p_4NoNIENtB1n_2G0EEB4_:
   43|    312|pub(crate) fn round<V: ArithOps + BitOps32>(mut x: State<V>) -> State<V> {
   44|    312|    x.a += x.b;
   45|    312|    x.d = (x.d ^ x.a).rotate_each_word_right16();
   46|    312|    x.c += x.d;
   47|    312|    x.b = (x.b ^ x.c).rotate_each_word_right20();
   48|    312|    x.a += x.b;
   49|    312|    x.d = (x.d ^ x.a).rotate_each_word_right24();
   50|    312|    x.c += x.d;
   51|    312|    x.b = (x.b ^ x.c).rotate_each_word_right25();
   52|    312|    x
   53|    312|}
_RINvMNtCsHILSoMIldr_11rand_chacha4gutsNtB3_6ChaCha5pos64INtNtCs27Gwpxl4iNu_10ppv_lite866x86_6411Avx2MachineNtBV_4NoNIEEB5_:
   77|     52|    fn pos64<M: Machine>(&self, m: M) -> u64 {
   78|     52|        let d: M::u32x4 = m.unpack(self.d);
   79|     52|        ((d.extract(1) as u64) << 32) | d.extract(0) as u64
   80|     52|    }
_RINvNvNtCsHILSoMIldr_11rand_chacha4guts11refill_wide7fn_implINtNtCs27Gwpxl4iNu_10ppv_lite866x86_6411Avx2MachineNtBZ_4NoNIEEB6_:
  172|     26|    fn refill_wide(state: &mut ChaCha, drounds: u32, out: &mut [u8; BUFSZ]) {
  173|     26|        refill_wide_impl(m, state, drounds, out);
  174|     26|    }
_RINvNtCsHILSoMIldr_11rand_chacha4guts16refill_wide_implINtNtCs27Gwpxl4iNu_10ppv_lite866x86_6411Avx2MachineNtBU_4NoNIEEB4_:
  116|     26|fn refill_wide_impl<Mach: Machine>(
  117|     26|    m: Mach, state: &mut ChaCha, drounds: u32, out: &mut [u8; BUFSZ],
  118|     26|) {
  119|     26|    let k = m.vec([0x6170_7865, 0x3320_646e, 0x7962_2d32, 0x6b20_6574]);
  120|     26|    let mut pos = state.pos64(m);
  121|     26|    let d0: Mach::u32x4 = m.unpack(state.d);
  122|     26|    pos = pos.wrapping_add(1);
  123|     26|    let d1 = d0.insert((pos >> 32) as u32, 1).insert(pos as u32, 0);
  124|     26|    pos = pos.wrapping_add(1);
  125|     26|    let d2 = d0.insert((pos >> 32) as u32, 1).insert(pos as u32, 0);
  126|     26|    pos = pos.wrapping_add(1);
  127|     26|    let d3 = d0.insert((pos >> 32) as u32, 1).insert(pos as u32, 0);
  128|     26|
  129|     26|    let b = m.unpack(state.b);
  130|     26|    let c = m.unpack(state.c);
  131|     26|    let mut x = State {
  132|     26|        a: Mach::u32x4x4::from_lanes([k, k, k, k]),
  133|     26|        b: Mach::u32x4x4::from_lanes([b, b, b, b]),
  134|     26|        c: Mach::u32x4x4::from_lanes([c, c, c, c]),
  135|     26|        d: m.unpack(Mach::u32x4x4::from_lanes([d0, d1, d2, d3]).into()),
  136|     26|    };
  137|    156|    for _ in 0..drounds {
  138|    156|        x = round(x);
  139|    156|        x = undiagonalize(round(diagonalize(x)));
  140|    156|    }
  141|     26|    let mut pos = state.pos64(m);
  142|     26|    let d0: Mach::u32x4 = m.unpack(state.d);
  143|     26|    pos = pos.wrapping_add(1);
  144|     26|    let d1 = d0.insert((pos >> 32) as u32, 1).insert(pos as u32, 0);
  145|     26|    pos = pos.wrapping_add(1);
  146|     26|    let d2 = d0.insert((pos >> 32) as u32, 1).insert(pos as u32, 0);
  147|     26|    pos = pos.wrapping_add(1);
  148|     26|    let d3 = d0.insert((pos >> 32) as u32, 1).insert(pos as u32, 0);
  149|     26|    pos = pos.wrapping_add(1);
  150|     26|    let d4 = d0.insert((pos >> 32) as u32, 1).insert(pos as u32, 0);
  151|     26|
  152|     26|    let (a, b, c, d) = (
  153|     26|        x.a.to_lanes(),
  154|     26|        x.b.to_lanes(),
  155|     26|        x.c.to_lanes(),
  156|     26|        x.d.to_lanes(),
  157|     26|    );
  158|     26|    let sb = m.unpack(state.b);
  159|     26|    let sc = m.unpack(state.c);
  160|     26|    let sd = [m.unpack(state.d), d1, d2, d3];
  161|     26|    state.d = d4.into();
  162|     26|    let mut words = out.chunks_exact_mut(16);
  163|    104|    for ((((&a, &b), &c), &d), &sd) in a.iter().zip(&b).zip(&c).zip(&d).zip(&sd) {
  164|    104|        (a + k).write_le(words.next().unwrap());
  165|    104|        (b + sb).write_le(words.next().unwrap());
  166|    104|        (c + sc).write_le(words.next().unwrap());
  167|    104|        (d + sd).write_le(words.next().unwrap());
  168|    104|    }
  169|     26|}
_RINvNtCsHILSoMIldr_11rand_chacha4guts13undiagonalizeINtNtCs27Gwpxl4iNu_10ppv_lite864soft2x2INtNtNtNtBT_6x86_644sse24avx212u32x4x2_avx2NtB1y_4NoNIENtB1w_2G0EEB4_:
   63|    156|pub(crate) fn undiagonalize<V: LaneWords4>(mut x: State<V>) -> State<V> {
   64|    156|    x.b = x.b.shuffle_lane_words1230();
   65|    156|    x.c = x.c.shuffle_lane_words2301();
   66|    156|    x.d = x.d.shuffle_lane_words3012();
   67|    156|    x
   68|    156|}
_RNvNtCsHILSoMIldr_11rand_chacha4guts10read_u32le:
  229|      2|fn read_u32le(xs: &[u8]) -> u32 {
  230|      2|    assert_eq!(xs.len(), 4);
  231|      2|    u32::from(xs[0]) | (u32::from(xs[1]) << 8) | (u32::from(xs[2]) << 16) | (u32::from(xs[3]) << 24)
  232|      2|}
_RINvNtCsHILSoMIldr_11rand_chacha4guts11diagonalizeINtNtCs27Gwpxl4iNu_10ppv_lite864soft2x2INtNtNtNtBR_6x86_644sse24avx212u32x4x2_avx2NtB1w_4NoNIENtB1u_2G0EEB4_:
   56|    156|pub(crate) fn diagonalize<V: LaneWords4>(mut x: State<V>) -> State<V> {
   57|    156|    x.b = x.b.shuffle_lane_words3012();
   58|    156|    x.c = x.c.shuffle_lane_words2301();
   59|    156|    x.d = x.d.shuffle_lane_words1230();
   60|    156|    x
   61|    156|}
_RINvNvNtCsHILSoMIldr_11rand_chacha4guts11init_chacha7fn_implINtNtCs27Gwpxl4iNu_10ppv_lite866x86_6410SseMachineNtBZ_5YesS3NtBZ_5YesS4NtBZ_4NoNIEEB6_:
  235|      1|    fn init_chacha(key: &[u8; 32], nonce: &[u8]) -> ChaCha {
  236|      1|        let ctr_nonce = [
  237|       |            0,
  238|      1|            if nonce.len() == 12 {
  239|      0|                read_u32le(&nonce[0..4])
  240|       |            } else {
  241|      1|                0
  242|       |            },
  243|      1|            read_u32le(&nonce[nonce.len() - 8..nonce.len() - 4]),
  244|      1|            read_u32le(&nonce[nonce.len() - 4..]),
  245|      1|        ];
  246|      1|        let key0: Mach::u32x4 = m.read_le(&key[..16]);
  247|      1|        let key1: Mach::u32x4 = m.read_le(&key[16..]);
  248|      1|        ChaCha {
  249|      1|            b: key0.into(),
  250|      1|            c: key1.into(),
  251|      1|            d: ctr_nonce.into(),
  252|      1|        }

_RNvXs0_NtCs87mpcsWZVN2_9rand_core5blockINtB5_8BlockRngINtNtNtNtCsk2tDUwjDqRE_4rand4rngs7adapter9reseeding13ReseedingCoreNtNtCsHILSoMIldr_11rand_chacha6chacha12ChaCha12CoreNtNtB7_2os5OsRngEENtB7_7RngCore8next_u32CsitTtQF8ArIt_8fvm_fuzz:
  186|  1.63k|    fn next_u32(&mut self) -> u32 {
  187|  1.63k|        if self.index >= self.results.as_ref().len() {
  188|     26|            self.generate_and_set(0);
  189|  1.60k|        }
  190|       |
  191|  1.63k|        let value = self.results.as_ref()[self.index];
  192|  1.63k|        self.index += 1;
  193|  1.63k|        value
  194|  1.63k|    }
_RNvMs_NtCs87mpcsWZVN2_9rand_core5blockINtB4_8BlockRngINtNtNtNtCsk2tDUwjDqRE_4rand4rngs7adapter9reseeding13ReseedingCoreNtNtCsHILSoMIldr_11rand_chacha6chacha12ChaCha12CoreNtNtB6_2os5OsRngEE16generate_and_setCsitTtQF8ArIt_8fvm_fuzz:
  174|     26|    pub fn generate_and_set(&mut self, index: usize) {
  175|     26|        assert!(index < self.results.as_ref().len());
  176|     26|        self.core.generate(&mut self.results);
  177|     26|        self.index = index;
  178|     26|    }
_RNvMs_NtCs87mpcsWZVN2_9rand_core5blockINtB4_8BlockRngINtNtNtNtCsk2tDUwjDqRE_4rand4rngs7adapter9reseeding13ReseedingCoreNtNtCsHILSoMIldr_11rand_chacha6chacha12ChaCha12CoreNtNtB6_2os5OsRngEE3newBY_:
  145|      1|    pub fn new(core: R) -> BlockRng<R> {
  146|      1|        let results_empty = R::Results::default();
  147|      1|        BlockRng {
  148|      1|            core,
  149|      1|            index: results_empty.as_ref().len(),
  150|      1|            results: results_empty,
  151|      1|        }
  152|      1|    }

_RINvYNtNtCsHILSoMIldr_11rand_chacha6chacha12ChaCha12CoreNtCs87mpcsWZVN2_9rand_core11SeedableRng8from_rngNtNtBU_2os5OsRngECsk2tDUwjDqRE_4rand:
  390|      1|    fn from_rng<R: RngCore>(mut rng: R) -> Result<Self, Error> {
  391|      1|        let mut seed = Self::Seed::default();
  392|      1|        rng.try_fill_bytes(seed.as_mut())?;
  393|      1|        Ok(Self::from_seed(seed))
  394|      1|    }

_RNvXs_NtCs87mpcsWZVN2_9rand_core2osNtB4_5OsRngNtB6_7RngCore14try_fill_bytes:
   68|      1|        getrandom(dest)?;
   69|      1|        Ok(())
   70|      1|    }

_RNvMCs4eRjD9IvbzL_9regalloc2NtB2_4PReg3new:
   97|  6.52k|    pub const fn new(hw_enc: usize, class: RegClass) -> Self {
   98|  6.52k|        // We don't have const panics yet (rust-lang/rust#85194) so we
   99|  6.52k|        // need to use a little indexing trick here. We unfortunately
  100|  6.52k|        // can't use the `static-assertions` crate because we need
  101|  6.52k|        // this to work both for const `hw_enc` and for runtime
  102|  6.52k|        // values.
  103|  6.52k|        const HW_ENC_MUST_BE_IN_BOUNDS: &[bool; PReg::MAX + 1] = &[true; PReg::MAX + 1];
  104|  6.52k|        let _ = HW_ENC_MUST_BE_IN_BOUNDS[hw_enc];
  105|  6.52k|
  106|  6.52k|        PReg {
  107|  6.52k|            bits: ((class as u8) << Self::MAX_BITS) | (hw_enc as u8),
  108|  6.52k|        }
  109|  6.52k|    }
_RNvMCs4eRjD9IvbzL_9regalloc2NtB2_4PReg10from_index:
  137|  12.2k|    pub const fn from_index(index: usize) -> Self {
  138|  12.2k|        PReg {
  139|  12.2k|            bits: (index & (Self::NUM_INDEX - 1)) as u8,
  140|  12.2k|        }
  141|  12.2k|    }
_RNvMCs4eRjD9IvbzL_9regalloc2NtB2_4PReg5index:
  131|  6.52k|    pub const fn index(self) -> usize {
  132|  6.52k|        self.bits as usize
  133|  6.52k|    }
_RNvMs4_Cs4eRjD9IvbzL_9regalloc2NtB5_4VReg4vreg:
  278|  18.3k|    pub const fn vreg(self) -> usize {
  279|  18.3k|        let vreg = (self.bits >> 1) as usize;
  280|  18.3k|        vreg
  281|  18.3k|    }
_RNvMs4_Cs4eRjD9IvbzL_9regalloc2NtB5_4VReg3new:
  266|  6.52k|    pub const fn new(virt_reg: usize, class: RegClass) -> Self {
  267|  6.52k|        // See comment in `PReg::new()`: we are emulating a const
  268|  6.52k|        // assert here until const panics are stable.
  269|  6.52k|        const VIRT_REG_MUST_BE_IN_BOUNDS: &[bool; VReg::MAX + 1] = &[true; VReg::MAX + 1];
  270|  6.52k|        let _ = VIRT_REG_MUST_BE_IN_BOUNDS[virt_reg];
  271|  6.52k|
  272|  6.52k|        VReg {
  273|  6.52k|            bits: ((virt_reg as u32) << 1) | (class as u8 as u32),
  274|  6.52k|        }
  275|  6.52k|    }
_RNvXsU_Cs4eRjD9IvbzL_9regalloc2NtB5_4VRegNtNtCshM4Il2Z0i4R_4core3cmp9PartialEq2eq:
  255|    204|#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]

_RNvNtNtNtNtCs4szf3uycwns_6rustix7backend4arch3asm11target_arch8syscall6:
  242|    816|pub(in crate::backend) unsafe fn syscall6(
  243|    816|    nr: SyscallNumber<'_>,
  244|    816|    a0: ArgReg<'_, A0>,
  245|    816|    a1: ArgReg<'_, A1>,
  246|    816|    a2: ArgReg<'_, A2>,
  247|    816|    a3: ArgReg<'_, A3>,
  248|    816|    a4: ArgReg<'_, A4>,
  249|    816|    a5: ArgReg<'_, A5>,
  250|    816|) -> RetReg<R0> {
  251|    816|    let r0;
  252|    816|    asm!(
  253|    816|        "syscall",
  254|    816|        inlateout("rax") nr.to_asm() => r0,
  255|    816|        in("rdi") a0.to_asm(),
  256|    816|        in("rsi") a1.to_asm(),
  257|    816|        in("rdx") a2.to_asm(),
  258|    816|        in("r10") a3.to_asm(),
  259|    816|        in("r8") a4.to_asm(),
  260|    816|        in("r9") a5.to_asm(),
  261|    816|        lateout("rcx") _,
  262|    816|        lateout("r11") _,
  263|    816|        options(nostack, preserves_flags)
  264|    816|    );
  265|    816|    FromAsm::from_asm(r0)
  266|    816|}
_RNvNtNtNtNtCs4szf3uycwns_6rustix7backend4arch3asm11target_arch8syscall2:
   66|    816|pub(in crate::backend) unsafe fn syscall2(
   67|    816|    nr: SyscallNumber<'_>,
   68|    816|    a0: ArgReg<'_, A0>,
   69|    816|    a1: ArgReg<'_, A1>,
   70|    816|) -> RetReg<R0> {
   71|    816|    let r0;
   72|    816|    asm!(
   73|    816|        "syscall",
   74|    816|        inlateout("rax") nr.to_asm() => r0,
   75|    816|        in("rdi") a0.to_asm(),
   76|    816|        in("rsi") a1.to_asm(),
   77|    816|        lateout("rcx") _,
   78|    816|        lateout("r11") _,
   79|    816|        options(nostack, preserves_flags)
   80|    816|    );
   81|    816|    FromAsm::from_asm(r0)
   82|    816|}

_RINvNtNtCs4szf3uycwns_6rustix7backend4conv10pass_usizeNtNtB4_3reg2A3ECsa8j9dqGMVk5_16wasmtime_runtime:
   99|    816|pub(super) fn pass_usize<'a, Num: ArgNumber>(t: usize) -> ArgReg<'a, Num> {
  100|    816|    raw_arg(t as *mut _)
  101|    816|}
_RINvNtNtCs4szf3uycwns_6rustix7backend4conv10pass_usizeNtNtB4_3reg2A4ECsa8j9dqGMVk5_16wasmtime_runtime:
   99|    816|pub(super) fn pass_usize<'a, Num: ArgNumber>(t: usize) -> ArgReg<'a, Num> {
  100|    816|    raw_arg(t as *mut _)
  101|    816|}
_RINvNtNtCs4szf3uycwns_6rustix7backend4conv15loff_t_from_u64NtNtB4_3reg2A5ECsa8j9dqGMVk5_16wasmtime_runtime:
  260|    816|pub(super) fn loff_t_from_u64<'a, Num: ArgNumber>(i: u64) -> ArgReg<'a, Num> {
  261|    816|    // `loff_t` is signed, but syscalls which expect `loff_t` return `EINVAL`
  262|    816|    // if it's outside the signed `i64` range, so we can silently cast.
  263|    816|    pass_usize(i as usize)
  264|    816|}
_RNvXsf_NtNtCs4szf3uycwns_6rustix7backend4convINtNtB7_3reg6ArgRegNtBK_2A2EINtNtCshM4Il2Z0i4R_4core7convert4FromNtNtNtB7_2mm5types9ProtFlagsE4fromCsa8j9dqGMVk5_16wasmtime_runtime:
  375|    816|    fn from(flags: crate::backend::mm::types::ProtFlags) -> Self {
  376|    816|        c_uint(flags.bits())
  377|    816|    }
_RINvNtNtCs4szf3uycwns_6rustix7backend4conv6c_uintNtNtB4_3reg2A2ECsa8j9dqGMVk5_16wasmtime_runtime:
  248|    816|pub(super) fn c_uint<'a, Num: ArgNumber>(i: c::c_uint) -> ArgReg<'a, Num> {
  249|    816|    pass_usize(i as usize)
  250|    816|}
_RINvNtNtCs4szf3uycwns_6rustix7backend4conv10pass_usizeNtNtB4_3reg2A2ECsa8j9dqGMVk5_16wasmtime_runtime:
   99|    816|pub(super) fn pass_usize<'a, Num: ArgNumber>(t: usize) -> ArgReg<'a, Num> {
  100|    816|    raw_arg(t as *mut _)
  101|    816|}
_RNvNtNtCs4szf3uycwns_6rustix7backend4conv13ret_void_star:
  772|    816|pub(super) fn ret_void_star(raw: RetReg<R0>) -> io::Result<*mut c::c_void> {
  773|    816|    try_decode_void_star(raw)
  774|    816|}
_RNvXNtNtCs4szf3uycwns_6rustix7backend4convINtNtB4_3reg6ArgRegNtBH_2A0EINtNtCshM4Il2Z0i4R_4core7convert4FromONtNtB1b_3ffi6c_voidE4fromCsa8j9dqGMVk5_16wasmtime_runtime:
  105|  1.63k|    fn from(c: *mut T) -> ArgReg<'a, Num> {
  106|  1.63k|        raw_arg(c.cast())
  107|  1.63k|    }
_RNvNtNtCs4szf3uycwns_6rustix7backend4conv3ret:
  658|    816|pub(super) unsafe fn ret(raw: RetReg<R0>) -> io::Result<()> {
  659|    816|    try_decode_void(raw)
  660|    816|}
_RINvNtNtCs4szf3uycwns_6rustix7backend4conv10pass_usizeNtNtB4_3reg2A1ECsa8j9dqGMVk5_16wasmtime_runtime:
   99|  1.63k|pub(super) fn pass_usize<'a, Num: ArgNumber>(t: usize) -> ArgReg<'a, Num> {
  100|  1.63k|    raw_arg(t as *mut _)
  101|  1.63k|}
_RINvNtNtCs4szf3uycwns_6rustix7backend4conv5no_fdNtNtB4_3reg2A4ECsa8j9dqGMVk5_16wasmtime_runtime:
  178|    816|pub(super) fn no_fd<'a, Num: ArgNumber>() -> ArgReg<'a, Num> {
  179|    816|    pass_usize(!0_usize)
  180|    816|}
_RINvNtNtCs4szf3uycwns_6rustix7backend4conv10pass_usizeNtNtB4_3reg2A5ECsa8j9dqGMVk5_16wasmtime_runtime:
   99|    816|pub(super) fn pass_usize<'a, Num: ArgNumber>(t: usize) -> ArgReg<'a, Num> {
  100|    816|    raw_arg(t as *mut _)
  101|    816|}
_RINvNtNtCs4szf3uycwns_6rustix7backend4conv6c_uintNtNtB4_3reg2A3ECsa8j9dqGMVk5_16wasmtime_runtime:
  248|    816|pub(super) fn c_uint<'a, Num: ArgNumber>(i: c::c_uint) -> ArgReg<'a, Num> {
  249|    816|    pass_usize(i as usize)
  250|    816|}

_RINvNtNtNtCs4szf3uycwns_6rustix7backend2io5errno20try_decode_void_starNtNtB6_3reg2R0ECsa8j9dqGMVk5_16wasmtime_runtime:
  124|    816|pub(in crate::backend) fn try_decode_void_star<Num: RetNumber>(
  125|    816|    raw: RetReg<Num>,
  126|    816|) -> io::Result<*mut c::c_void> {
  127|    816|    if raw.is_in_range(-4095..0) {
  128|       |        // Safety: `raw` must be in `-4095..0`, and we just checked that raw is
  129|       |        // in that range.
  130|      0|        return Err(unsafe { Errno(raw.decode_error_code()) });
  131|    816|    }
  132|    816|
  133|    816|    Ok(raw.decode_void_star())
  134|    816|}
_RINvNtNtNtCs4szf3uycwns_6rustix7backend2io5errno15try_decode_voidNtNtB6_3reg2R0ECsa8j9dqGMVk5_16wasmtime_runtime:
  187|    816|pub(in crate::backend) unsafe fn try_decode_void<Num: RetNumber>(
  188|    816|    raw: RetReg<Num>,
  189|    816|) -> io::Result<()> {
  190|    816|    // Instead of using `check_result` here, we just check for zero, since this
  191|    816|    // function is only used for system calls which have no other return value,
  192|    816|    // and this produces smaller code.
  193|    816|    if raw.is_nonzero() {
  194|      0|        debug_assert!(raw.is_in_range(-4095..0));
  195|       |
  196|       |        // Tell the optimizer that we know the value is in the error range.
  197|       |        // This helps it avoid unnecessary integer conversions.
  198|       |        #[cfg(core_intrinsics)]
  199|      0|        {
  200|      0|            core::intrinsics::assume(raw.is_in_range(-4095..0));
  201|      0|        }
  202|      0|
  203|      0|        return Err(Errno(raw.decode_error_code()));
  204|    816|    }
  205|    816|
  206|    816|    raw.decode_void();
  207|    816|
  208|    816|    Ok(())
  209|    816|}

_RNvNtNtNtCs4szf3uycwns_6rustix7backend2mm8syscalls6munmap:
  133|    816|pub(crate) unsafe fn munmap(addr: *mut c::c_void, length: usize) -> io::Result<()> {
  134|    816|    ret(syscall!(__NR_munmap, addr, pass_usize(length)))
  135|    816|}
_RNvNtNtNtCs4szf3uycwns_6rustix7backend2mm8syscalls14mmap_anonymous:
   87|    816|pub(crate) unsafe fn mmap_anonymous(
   88|    816|    addr: *mut c::c_void,
   89|    816|    length: usize,
   90|    816|    prot: ProtFlags,
   91|    816|    flags: MapFlags,
   92|    816|) -> io::Result<*mut c::c_void> {
   93|    816|    #[cfg(target_pointer_width = "32")]
   94|    816|    {
   95|    816|        ret_void_star(syscall!(
   96|    816|            __NR_mmap2,
   97|    816|            addr,
   98|    816|            pass_usize(length),
   99|    816|            prot,
  100|    816|            c_uint(flags.bits() | MAP_ANONYMOUS),
  101|    816|            no_fd(),
  102|    816|            pass_usize(0)
  103|    816|        ))
  104|    816|    }
  105|    816|    #[cfg(target_pointer_width = "64")]
  106|    816|    {
  107|    816|        ret_void_star(syscall!(
  108|    816|            __NR_mmap,
  109|    816|            addr,
  110|    816|            pass_usize(length),
  111|    816|            prot,
  112|    816|            c_uint(flags.bits() | MAP_ANONYMOUS),
  113|    816|            no_fd(),
  114|    816|            loff_t_from_u64(0)
  115|    816|        ))
  116|    816|    }
  117|    816|}

_RNvXs5_NtNtCs4szf3uycwns_6rustix7backend3regINtB5_6ArgRegNtB5_2A5ENtB5_5ToAsm6to_asmCsa8j9dqGMVk5_16wasmtime_runtime:
   95|    816|    unsafe fn to_asm(self) -> *mut Opaque {
   96|    816|        self.raw
   97|    816|    }
_RINvNtNtCs4szf3uycwns_6rustix7backend3reg7raw_argNtB2_2A5ECsa8j9dqGMVk5_16wasmtime_runtime:
  221|    816|pub(super) fn raw_arg<'a, Num: ArgNumber>(raw: *mut Opaque) -> ArgReg<'a, Num> {
  222|    816|    ArgReg {
  223|    816|        raw,
  224|    816|        _phantom: PhantomData,
  225|    816|    }
  226|    816|}
_RNvMs6_NtNtCs4szf3uycwns_6rustix7backend3regINtB5_6RetRegNtB5_2R0E12decode_usizeCsa8j9dqGMVk5_16wasmtime_runtime:
  114|    816|    pub(super) fn decode_usize(self) -> usize {
  115|    816|        debug_assert!(!(-4095..0).contains(&(self.raw as isize)));
  116|    816|        self.raw as usize
  117|    816|    }
_RNvMs6_NtNtCs4szf3uycwns_6rustix7backend3regINtB5_6RetRegNtB5_2R0E10is_nonzeroCsa8j9dqGMVk5_16wasmtime_runtime:
  181|    816|    pub(super) fn is_nonzero(&self) -> bool {
  182|    816|        !self.raw.is_null()
  183|    816|    }
_RNvXs5_NtNtCs4szf3uycwns_6rustix7backend3regINtB5_6ArgRegNtB5_2A0ENtB5_5ToAsm6to_asmCsa8j9dqGMVk5_16wasmtime_runtime:
   95|  1.63k|    unsafe fn to_asm(self) -> *mut Opaque {
   96|  1.63k|        self.raw
   97|  1.63k|    }
_RINvNtNtCs4szf3uycwns_6rustix7backend3reg7raw_argNtB2_2A4ECsa8j9dqGMVk5_16wasmtime_runtime:
  221|    816|pub(super) fn raw_arg<'a, Num: ArgNumber>(raw: *mut Opaque) -> ArgReg<'a, Num> {
  222|    816|    ArgReg {
  223|    816|        raw,
  224|    816|        _phantom: PhantomData,
  225|    816|    }
  226|    816|}
_RNvMs6_NtNtCs4szf3uycwns_6rustix7backend3regINtB5_6RetRegNtB5_2R0E16decode_void_starCsa8j9dqGMVk5_16wasmtime_runtime:
  153|    816|    pub(super) fn decode_void_star(self) -> *mut c::c_void {
  154|    816|        self.raw.cast()
  155|    816|    }
_RNvXs8_NtNtCs4szf3uycwns_6rustix7backend3regNtB5_13SyscallNumberNtB5_5ToAsm6to_asm:
  214|  1.63k|    unsafe fn to_asm(self) -> *mut Opaque {
  215|  1.63k|        self.nr as usize as *mut Opaque
  216|  1.63k|    }
_RNvXs5_NtNtCs4szf3uycwns_6rustix7backend3regINtB5_6ArgRegNtB5_2A2ENtB5_5ToAsm6to_asmCsa8j9dqGMVk5_16wasmtime_runtime:
   95|    816|    unsafe fn to_asm(self) -> *mut Opaque {
   96|    816|        self.raw
   97|    816|    }
_RNvNtNtCs4szf3uycwns_6rustix7backend3reg2nr:
  230|  1.63k|pub(super) const fn nr<'a>(nr: u32) -> SyscallNumber<'a> {
  231|  1.63k|    SyscallNumber {
  232|  1.63k|        nr: nr as usize,
  233|  1.63k|        _phantom: PhantomData,
  234|  1.63k|    }
  235|  1.63k|}
_RNvMs6_NtNtCs4szf3uycwns_6rustix7backend3regINtB5_6RetRegNtB5_2R0E11is_in_rangeCsa8j9dqGMVk5_16wasmtime_runtime:
  191|    816|    pub(super) fn is_in_range(&self, range: core::ops::Range<isize>) -> bool {
  192|    816|        range.contains(&(self.raw as isize))
  193|    816|    }
_RNvXs5_NtNtCs4szf3uycwns_6rustix7backend3regINtB5_6ArgRegNtB5_2A3ENtB5_5ToAsm6to_asmCsa8j9dqGMVk5_16wasmtime_runtime:
   95|    816|    unsafe fn to_asm(self) -> *mut Opaque {
   96|    816|        self.raw
   97|    816|    }
_RNvXs5_NtNtCs4szf3uycwns_6rustix7backend3regINtB5_6ArgRegNtB5_2A4ENtB5_5ToAsm6to_asmCsa8j9dqGMVk5_16wasmtime_runtime:
   95|    816|    unsafe fn to_asm(self) -> *mut Opaque {
   96|    816|        self.raw
   97|    816|    }
_RNvMs6_NtNtCs4szf3uycwns_6rustix7backend3regINtB5_6RetRegNtB5_2R0E11decode_voidCsa8j9dqGMVk5_16wasmtime_runtime:
  164|    816|    pub(super) fn decode_void(self) {
  165|    816|        let ignore = self.decode_usize();
  166|    816|        debug_assert_eq!(ignore, 0);
  167|    816|    }
_RINvNtNtCs4szf3uycwns_6rustix7backend3reg7raw_argNtB2_2A2ECsa8j9dqGMVk5_16wasmtime_runtime:
  221|    816|pub(super) fn raw_arg<'a, Num: ArgNumber>(raw: *mut Opaque) -> ArgReg<'a, Num> {
  222|    816|    ArgReg {
  223|    816|        raw,
  224|    816|        _phantom: PhantomData,
  225|    816|    }
  226|    816|}
_RNvXs7_NtNtCs4szf3uycwns_6rustix7backend3regINtB5_6RetRegNtB5_2R0ENtB5_7FromAsm8from_asmCsa8j9dqGMVk5_16wasmtime_runtime:
  198|  1.63k|    unsafe fn from_asm(raw: *mut Opaque) -> Self {
  199|  1.63k|        Self {
  200|  1.63k|            raw,
  201|  1.63k|            _phantom: PhantomData,
  202|  1.63k|        }
  203|  1.63k|    }
_RINvNtNtCs4szf3uycwns_6rustix7backend3reg7raw_argNtB2_2A1ECsa8j9dqGMVk5_16wasmtime_runtime:
  221|  1.63k|pub(super) fn raw_arg<'a, Num: ArgNumber>(raw: *mut Opaque) -> ArgReg<'a, Num> {
  222|  1.63k|    ArgReg {
  223|  1.63k|        raw,
  224|  1.63k|        _phantom: PhantomData,
  225|  1.63k|    }
  226|  1.63k|}
_RINvNtNtCs4szf3uycwns_6rustix7backend3reg7raw_argNtB2_2A0ECsa8j9dqGMVk5_16wasmtime_runtime:
  221|  1.63k|pub(super) fn raw_arg<'a, Num: ArgNumber>(raw: *mut Opaque) -> ArgReg<'a, Num> {
  222|  1.63k|    ArgReg {
  223|  1.63k|        raw,
  224|  1.63k|        _phantom: PhantomData,
  225|  1.63k|    }
  226|  1.63k|}
_RNvXs5_NtNtCs4szf3uycwns_6rustix7backend3regINtB5_6ArgRegNtB5_2A1ENtB5_5ToAsm6to_asmCsa8j9dqGMVk5_16wasmtime_runtime:
   95|  1.63k|    unsafe fn to_asm(self) -> *mut Opaque {
   96|  1.63k|        self.raw
   97|  1.63k|    }
_RINvNtNtCs4szf3uycwns_6rustix7backend3reg7raw_argNtB2_2A3ECsa8j9dqGMVk5_16wasmtime_runtime:
  221|    816|pub(super) fn raw_arg<'a, Num: ArgNumber>(raw: *mut Opaque) -> ArgReg<'a, Num> {
  222|    816|    ArgReg {
  223|    816|        raw,
  224|    816|        _phantom: PhantomData,
  225|    816|    }
  226|    816|}

_RNvNtNtCs4szf3uycwns_6rustix2mm4mmap6munmap:
   86|    816|pub unsafe fn munmap(ptr: *mut c_void, len: usize) -> io::Result<()> {
   87|    816|    backend::mm::syscalls::munmap(ptr, len)
   88|    816|}
_RNvNtNtCs4szf3uycwns_6rustix2mm4mmap14mmap_anonymous:
   64|    816|pub unsafe fn mmap_anonymous(
   65|    816|    ptr: *mut c_void,
   66|    816|    len: usize,
   67|    816|    prot: ProtFlags,
   68|    816|    flags: MapFlags,
   69|    816|) -> io::Result<*mut c_void> {
   70|    816|    backend::mm::syscalls::mmap_anonymous(ptr, len, prot, flags)
   71|    816|}

_RNvXCsf6sGIiMhboj_10scopeguardNtB2_6AlwaysNtB2_8Strategy10should_run:
  231|  39.4k|    fn should_run() -> bool { true }
_RNvXs4_Csf6sGIiMhboj_10scopeguardINtB5_10ScopeGuardQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEFBN_EuENtNtNtCshM4Il2Z0i4R_4core3ops5deref8DerefMut9deref_mutCsitTtQF8ArIt_8fvm_fuzz:
  443|  39.4k|    fn deref_mut(&mut self) -> &mut T {
  444|  39.4k|        &mut *self.value
  445|  39.4k|    }
_RNvXs5_Csf6sGIiMhboj_10scopeguardINtB5_10ScopeGuardQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEFBN_EuENtNtNtCshM4Il2Z0i4R_4core3ops4drop4Drop4dropCsitTtQF8ArIt_8fvm_fuzz:
  452|  39.4k|    fn drop(&mut self) {
  453|  39.4k|        // This is OK because the fields are `ManuallyDrop`s
  454|  39.4k|        // which will not be dropped by the compiler.
  455|  39.4k|        let (value, dropfn) = unsafe {
  456|  39.4k|            (ptr::read(&*self.value), ptr::read(&*self.dropfn))
  457|  39.4k|        };
  458|  39.4k|        if S::should_run() {
  459|  39.4k|            dropfn(value);
  460|  39.4k|        }
  461|  39.4k|    }
_RINvCsf6sGIiMhboj_10scopeguard5guardQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEFBy_EuECsitTtQF8ArIt_8fvm_fuzz:
  367|  39.4k|pub fn guard<T, F>(v: T, dropfn: F) -> ScopeGuard<T, F, Always>
  368|  39.4k|    where F: FnOnce(T)
  369|  39.4k|{
  370|  39.4k|    ScopeGuard::with_strategy(v, dropfn)
  371|  39.4k|}
_RNvMs1_Csf6sGIiMhboj_10scopeguardINtB5_10ScopeGuardQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEFBN_EuE13with_strategyCsitTtQF8ArIt_8fvm_fuzz:
  317|  39.4k|    pub fn with_strategy(v: T, dropfn: F) -> ScopeGuard<T, F, S> {
  318|  39.4k|        ScopeGuard {
  319|  39.4k|            value: ManuallyDrop::new(v),
  320|  39.4k|            dropfn: ManuallyDrop::new(dropfn),
  321|  39.4k|            strategy: PhantomData,
  322|  39.4k|        }
  323|  39.4k|    }

_RINvXNvXs2M_NtNtCslVZeVZySzLE_5serde2de5implsTppENtBc_11Deserialize11deserializeINtB3_12TupleVisitormINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EENtBc_7Visitor9visit_seqINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de8AccessorNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
 1277|    204|                        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1278|    204|                        where
 1279|    204|                            A: SeqAccess<'de>,
 1280|    204|                        {
 1281|       |                            $(
 1282|    204|                                let $name = match try!(seq.next_element()) {
 1283|    204|                                    Some(value) => value,
 1284|      0|                                    None => return Err(Error::invalid_length($n, &self)),
 1285|       |                                };
 1286|       |                            )+
 1287|       |
 1288|    204|                            Ok(($($name,)+))
 1289|    204|                        }
_RINvXNvXsX_NtNtCslVZeVZySzLE_5serde2de5implsyNtBb_11Deserialize11deserializeNtB3_16PrimitiveVisitorNtBb_7Visitor9visit_u64NtNtCsalhrieD8kwf_12libipld_core5error10SerdeErrorECsitTtQF8ArIt_8fvm_fuzz:
  138|    306|        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>
  139|    306|        where
  140|    306|            E: Error,
  141|    306|        {
  142|    306|            Ok(v)
  143|    306|        }
_RINvXsX_NtNtCslVZeVZySzLE_5serde2de5implsyNtB8_11Deserialize11deserializeNtNtCsalhrieD8kwf_12libipld_core4ipld4IpldECsitTtQF8ArIt_8fvm_fuzz:
  113|    306|            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  114|    306|            where
  115|    306|                D: Deserializer<'de>,
  116|    306|            {
  117|    306|                struct PrimitiveVisitor;
  118|    306|
  119|    306|                impl<'de> Visitor<'de> for PrimitiveVisitor {
  120|    306|                    type Value = $primitive;
  121|    306|
  122|    306|                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
  123|    306|                        formatter.write_str(stringify!($primitive))
  124|    306|                    }
  125|    306|
  126|    306|                    $($($method!($val : $visit);)*)*
  127|    306|                }
  128|    306|
  129|    306|                deserializer.$deserialize(PrimitiveVisitor)
  130|    306|            }
_RINvXs4_NtNtCslVZeVZySzLE_5serde2de5implsNtB6_13StringVisitorNtB8_7Visitor9visit_strINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor5error11DecodeErrorNtNtCshM4Il2Z0i4R_4core7convert10InfallibleEECsitTtQF8ArIt_8fvm_fuzz:
  486|  3.06k|    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
  487|  3.06k|    where
  488|  3.06k|        E: Error,
  489|  3.06k|    {
  490|  3.06k|        Ok(v.to_owned())
  491|  3.06k|    }
_RINvXsd_NtNtCslVZeVZySzLE_5serde2de5implsINtB6_13OptionVisitorNtNtCs4pVfV2XJudO_10fvm_shared7address7AddressENtB8_7Visitor10visit_noneNtNtCsalhrieD8kwf_12libipld_core5error10SerdeErrorECsitTtQF8ArIt_8fvm_fuzz:
  781|    306|    fn visit_none<E>(self) -> Result<Self::Value, E>
  782|    306|    where
  783|    306|        E: Error,
  784|    306|    {
  785|    306|        Ok(None)
  786|    306|    }
_RINvXs6_NtNtCslVZeVZySzLE_5serde2de5implsNtNtCsjYc3JqMxxfa_5alloc6string6StringNtB8_11Deserialize11deserializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
  582|  3.06k|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  583|  3.06k|    where
  584|  3.06k|        D: Deserializer<'de>,
  585|  3.06k|    {
  586|  3.06k|        deserializer.deserialize_string(StringVisitor)
  587|  3.06k|    }
_RINvXNvXs2M_NtNtCslVZeVZySzLE_5serde2de5implsTppENtBc_11Deserialize11deserializeINtB3_12TupleVisitorNtNtCshRBVfIqfJKm_13fvm_ipld_hamt8bitfield8BitfieldINtNtCsjYc3JqMxxfa_5alloc3vec3VecINtNtB1E_7pointer7PointerNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtB1E_14hash_algorithm6Sha256EEENtBc_7Visitor9visit_seqINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de8AccessorNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
 1277|    102|                        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1278|    102|                        where
 1279|    102|                            A: SeqAccess<'de>,
 1280|    102|                        {
 1281|       |                            $(
 1282|    102|                                let $name = match try!(seq.next_element()) {
 1283|    102|                                    Some(value) => value,
 1284|      0|                                    None => return Err(Error::invalid_length($n, &self)),
 1285|       |                                };
 1286|       |                            )+
 1287|       |
 1288|    102|                            Ok(($($name,)+))
 1289|    102|                        }
_RINvXNvXsh_NtNtCslVZeVZySzLE_5serde2de5implsINtNtCsjYc3JqMxxfa_5alloc3vec3VecpENtBb_11Deserialize11deserializeINtB3_10VecVisitorTNtNtBL_6string6StringINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EEENtBb_7Visitor9visit_seqINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de8AccessorNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
 1031|    204|            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1032|    204|            where
 1033|    204|                A: SeqAccess<'de>,
 1034|    204|            {
 1035|    204|                let mut values = Vec::with_capacity(size_hint::cautious(seq.size_hint()));
 1036|       |
 1037|  3.26k|                while let Some(value) = try!(seq.next_element()) {
 1038|  3.06k|                    values.push(value);
 1039|  3.06k|                }
 1040|       |
 1041|    204|                Ok(values)
 1042|    204|            }
_RINvXs2M_NtNtCslVZeVZySzLE_5serde2de5implsTmINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EENtB9_11Deserialize11deserializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
 1260|    204|                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
 1261|    204|                where
 1262|    204|                    D: Deserializer<'de>,
 1263|    204|                {
 1264|    204|                    struct TupleVisitor<$($name,)+> {
 1265|    204|                        marker: PhantomData<($($name,)+)>,
 1266|    204|                    }
 1267|    204|
 1268|    204|                    impl<'de, $($name: Deserialize<'de>),+> Visitor<'de> for TupleVisitor<$($name,)+> {
 1269|    204|                        type Value = ($($name,)+);
 1270|    204|
 1271|    204|                        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
 1272|    204|                            formatter.write_str(concat!("a tuple of size ", $len))
 1273|    204|                        }
 1274|    204|
 1275|    204|                        #[inline]
 1276|    204|                        #[allow(non_snake_case)]
 1277|    204|                        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1278|    204|                        where
 1279|    204|                            A: SeqAccess<'de>,
 1280|    204|                        {
 1281|    204|                            $(
 1282|    204|                                let $name = match try!(seq.next_element()) {
 1283|    204|                                    Some(value) => value,
 1284|    204|                                    None => return Err(Error::invalid_length($n, &self)),
 1285|    204|                                };
 1286|    204|                            )+
 1287|    204|
 1288|    204|                            Ok(($($name,)+))
 1289|    204|                        }
 1290|    204|                    }
 1291|    204|
 1292|    204|                    deserializer.deserialize_tuple($len, TupleVisitor { marker: PhantomData })
 1293|    204|                }
_RINvXNvXsh_NtNtCslVZeVZySzLE_5serde2de5implsINtNtCsjYc3JqMxxfa_5alloc3vec3VecpENtBb_11Deserialize11deserializeINtB3_10VecVisitorINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EENtBb_7Visitor9visit_seqINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de8AccessorNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
 1031|    102|            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1032|    102|            where
 1033|    102|                A: SeqAccess<'de>,
 1034|    102|            {
 1035|    102|                let mut values = Vec::with_capacity(size_hint::cautious(seq.size_hint()));
 1036|       |
 1037|    204|                while let Some(value) = try!(seq.next_element()) {
 1038|    102|                    values.push(value);
 1039|    102|                }
 1040|       |
 1041|    102|                Ok(values)
 1042|    102|            }
_RINvXNvXs2M_NtNtCslVZeVZySzLE_5serde2de5implsTppENtBc_11Deserialize11deserializeINtB3_12TupleVisitorNtNtCsjYc3JqMxxfa_5alloc6string6StringINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EENtBc_7Visitor9visit_seqINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de8AccessorNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
 1277|  3.06k|                        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1278|  3.06k|                        where
 1279|  3.06k|                            A: SeqAccess<'de>,
 1280|  3.06k|                        {
 1281|       |                            $(
 1282|  3.06k|                                let $name = match try!(seq.next_element()) {
 1283|  3.06k|                                    Some(value) => value,
 1284|      0|                                    None => return Err(Error::invalid_length($n, &self)),
 1285|       |                                };
 1286|       |                            )+
 1287|       |
 1288|  3.06k|                            Ok(($($name,)+))
 1289|  3.06k|                        }
_RINvXsh_NtNtCslVZeVZySzLE_5serde2de5implsINtNtCsjYc3JqMxxfa_5alloc3vec3VecINtCshRBVfIqfJKm_13fvm_ipld_hamt12KeyValuePairNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateEENtB8_11Deserialize11deserializeNtNtCsalhrieD8kwf_12libipld_core4ipld4IpldECsitTtQF8ArIt_8fvm_fuzz:
 1013|    306|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
 1014|    306|    where
 1015|    306|        D: Deserializer<'de>,
 1016|    306|    {
 1017|    306|        struct VecVisitor<T> {
 1018|    306|            marker: PhantomData<T>,
 1019|    306|        }
 1020|    306|
 1021|    306|        impl<'de, T> Visitor<'de> for VecVisitor<T>
 1022|    306|        where
 1023|    306|            T: Deserialize<'de>,
 1024|    306|        {
 1025|    306|            type Value = Vec<T>;
 1026|    306|
 1027|    306|            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
 1028|    306|                formatter.write_str("a sequence")
 1029|    306|            }
 1030|    306|
 1031|    306|            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1032|    306|            where
 1033|    306|                A: SeqAccess<'de>,
 1034|    306|            {
 1035|    306|                let mut values = Vec::with_capacity(size_hint::cautious(seq.size_hint()));
 1036|    306|
 1037|    306|                while let Some(value) = try!(seq.next_element()) {
 1038|    306|                    values.push(value);
 1039|    306|                }
 1040|    306|
 1041|    306|                Ok(values)
 1042|    306|            }
 1043|    306|        }
 1044|    306|
 1045|    306|        let visitor = VecVisitor {
 1046|    306|            marker: PhantomData,
 1047|    306|        };
 1048|    306|        deserializer.deserialize_seq(visitor)
 1049|    306|    }
_RINvXsh_NtNtCslVZeVZySzLE_5serde2de5implsINtNtCsjYc3JqMxxfa_5alloc3vec3VecINtNtCshRBVfIqfJKm_13fvm_ipld_hamt7pointer7PointerNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtB1f_14hash_algorithm6Sha256EENtB8_11Deserialize11deserializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
 1013|    102|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
 1014|    102|    where
 1015|    102|        D: Deserializer<'de>,
 1016|    102|    {
 1017|    102|        struct VecVisitor<T> {
 1018|    102|            marker: PhantomData<T>,
 1019|    102|        }
 1020|    102|
 1021|    102|        impl<'de, T> Visitor<'de> for VecVisitor<T>
 1022|    102|        where
 1023|    102|            T: Deserialize<'de>,
 1024|    102|        {
 1025|    102|            type Value = Vec<T>;
 1026|    102|
 1027|    102|            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
 1028|    102|                formatter.write_str("a sequence")
 1029|    102|            }
 1030|    102|
 1031|    102|            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1032|    102|            where
 1033|    102|                A: SeqAccess<'de>,
 1034|    102|            {
 1035|    102|                let mut values = Vec::with_capacity(size_hint::cautious(seq.size_hint()));
 1036|    102|
 1037|    102|                while let Some(value) = try!(seq.next_element()) {
 1038|    102|                    values.push(value);
 1039|    102|                }
 1040|    102|
 1041|    102|                Ok(values)
 1042|    102|            }
 1043|    102|        }
 1044|    102|
 1045|    102|        let visitor = VecVisitor {
 1046|    102|            marker: PhantomData,
 1047|    102|        };
 1048|    102|        deserializer.deserialize_seq(visitor)
 1049|    102|    }
_RINvXNvXsV_NtNtCslVZeVZySzLE_5serde2de5implsmNtBb_11Deserialize11deserializeNtB3_16PrimitiveVisitorNtBb_7Visitor9visit_u32INtNtCs8loA9e5gPGU_18serde_ipld_dagcbor5error11DecodeErrorNtNtCshM4Il2Z0i4R_4core7convert10InfallibleEECsitTtQF8ArIt_8fvm_fuzz:
  138|    204|        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>
  139|    204|        where
  140|    204|            E: Error,
  141|    204|        {
  142|    204|            Ok(v)
  143|    204|        }
_RINvXsX_NtNtCslVZeVZySzLE_5serde2de5implsyNtB8_11Deserialize11deserializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
  113|    204|            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  114|    204|            where
  115|    204|                D: Deserializer<'de>,
  116|    204|            {
  117|    204|                struct PrimitiveVisitor;
  118|    204|
  119|    204|                impl<'de> Visitor<'de> for PrimitiveVisitor {
  120|    204|                    type Value = $primitive;
  121|    204|
  122|    204|                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
  123|    204|                        formatter.write_str(stringify!($primitive))
  124|    204|                    }
  125|    204|
  126|    204|                    $($($method!($val : $visit);)*)*
  127|    204|                }
  128|    204|
  129|    204|                deserializer.$deserialize(PrimitiveVisitor)
  130|    204|            }
_RINvXsh_NtNtCslVZeVZySzLE_5serde2de5implsINtNtCsjYc3JqMxxfa_5alloc3vec3VecINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EENtB8_11Deserialize11deserializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
 1013|    102|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
 1014|    102|    where
 1015|    102|        D: Deserializer<'de>,
 1016|    102|    {
 1017|    102|        struct VecVisitor<T> {
 1018|    102|            marker: PhantomData<T>,
 1019|    102|        }
 1020|    102|
 1021|    102|        impl<'de, T> Visitor<'de> for VecVisitor<T>
 1022|    102|        where
 1023|    102|            T: Deserialize<'de>,
 1024|    102|        {
 1025|    102|            type Value = Vec<T>;
 1026|    102|
 1027|    102|            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
 1028|    102|                formatter.write_str("a sequence")
 1029|    102|            }
 1030|    102|
 1031|    102|            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1032|    102|            where
 1033|    102|                A: SeqAccess<'de>,
 1034|    102|            {
 1035|    102|                let mut values = Vec::with_capacity(size_hint::cautious(seq.size_hint()));
 1036|    102|
 1037|    102|                while let Some(value) = try!(seq.next_element()) {
 1038|    102|                    values.push(value);
 1039|    102|                }
 1040|    102|
 1041|    102|                Ok(values)
 1042|    102|            }
 1043|    102|        }
 1044|    102|
 1045|    102|        let visitor = VecVisitor {
 1046|    102|            marker: PhantomData,
 1047|    102|        };
 1048|    102|        deserializer.deserialize_seq(visitor)
 1049|    102|    }
_RINvXse_NtNtCslVZeVZySzLE_5serde2de5implsINtNtCshM4Il2Z0i4R_4core6option6OptionNtNtCs4pVfV2XJudO_10fvm_shared7address7AddressENtB8_11Deserialize11deserializeNtNtCsalhrieD8kwf_12libipld_core4ipld4IpldECsitTtQF8ArIt_8fvm_fuzz:
  808|    306|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  809|    306|    where
  810|    306|        D: Deserializer<'de>,
  811|    306|    {
  812|    306|        deserializer.deserialize_option(OptionVisitor {
  813|    306|            marker: PhantomData,
  814|    306|        })
  815|    306|    }
_RINvXNvXsX_NtNtCslVZeVZySzLE_5serde2de5implsyNtBb_11Deserialize11deserializeNtB3_16PrimitiveVisitorNtBb_7Visitor9visit_u64INtNtCs8loA9e5gPGU_18serde_ipld_dagcbor5error11DecodeErrorNtNtCshM4Il2Z0i4R_4core7convert10InfallibleEECsitTtQF8ArIt_8fvm_fuzz:
  138|    204|        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>
  139|    204|        where
  140|    204|            E: Error,
  141|    204|        {
  142|    204|            Ok(v)
  143|    204|        }
_RINvXNvXsh_NtNtCslVZeVZySzLE_5serde2de5implsINtNtCsjYc3JqMxxfa_5alloc3vec3VecpENtBb_11Deserialize11deserializeINtB3_10VecVisitorINtNtCshRBVfIqfJKm_13fvm_ipld_hamt7pointer7PointerNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtB27_14hash_algorithm6Sha256EENtBb_7Visitor9visit_seqINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de8AccessorNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
 1031|    102|            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1032|    102|            where
 1033|    102|                A: SeqAccess<'de>,
 1034|    102|            {
 1035|    102|                let mut values = Vec::with_capacity(size_hint::cautious(seq.size_hint()));
 1036|       |
 1037|    408|                while let Some(value) = try!(seq.next_element()) {
 1038|    306|                    values.push(value);
 1039|    306|                }
 1040|       |
 1041|    102|                Ok(values)
 1042|    102|            }
_RINvXs2M_NtNtCslVZeVZySzLE_5serde2de5implsTNtNtCsjYc3JqMxxfa_5alloc6string6StringINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EENtB9_11Deserialize11deserializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
 1260|  3.06k|                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
 1261|  3.06k|                where
 1262|  3.06k|                    D: Deserializer<'de>,
 1263|  3.06k|                {
 1264|  3.06k|                    struct TupleVisitor<$($name,)+> {
 1265|  3.06k|                        marker: PhantomData<($($name,)+)>,
 1266|  3.06k|                    }
 1267|  3.06k|
 1268|  3.06k|                    impl<'de, $($name: Deserialize<'de>),+> Visitor<'de> for TupleVisitor<$($name,)+> {
 1269|  3.06k|                        type Value = ($($name,)+);
 1270|  3.06k|
 1271|  3.06k|                        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
 1272|  3.06k|                            formatter.write_str(concat!("a tuple of size ", $len))
 1273|  3.06k|                        }
 1274|  3.06k|
 1275|  3.06k|                        #[inline]
 1276|  3.06k|                        #[allow(non_snake_case)]
 1277|  3.06k|                        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1278|  3.06k|                        where
 1279|  3.06k|                            A: SeqAccess<'de>,
 1280|  3.06k|                        {
 1281|  3.06k|                            $(
 1282|  3.06k|                                let $name = match try!(seq.next_element()) {
 1283|  3.06k|                                    Some(value) => value,
 1284|  3.06k|                                    None => return Err(Error::invalid_length($n, &self)),
 1285|  3.06k|                                };
 1286|  3.06k|                            )+
 1287|  3.06k|
 1288|  3.06k|                            Ok(($($name,)+))
 1289|  3.06k|                        }
 1290|  3.06k|                    }
 1291|  3.06k|
 1292|  3.06k|                    deserializer.deserialize_tuple($len, TupleVisitor { marker: PhantomData })
 1293|  3.06k|                }
_RINvXNvXsh_NtNtCslVZeVZySzLE_5serde2de5implsINtNtCsjYc3JqMxxfa_5alloc3vec3VecpENtBb_11Deserialize11deserializeINtB3_10VecVisitorINtCshRBVfIqfJKm_13fvm_ipld_hamt12KeyValuePairNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateEENtBb_7Visitor9visit_seqQNtNtNtCsalhrieD8kwf_12libipld_core5serde2de15SeqDeserializerECsitTtQF8ArIt_8fvm_fuzz:
 1031|    306|            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1032|    306|            where
 1033|    306|                A: SeqAccess<'de>,
 1034|    306|            {
 1035|    306|                let mut values = Vec::with_capacity(size_hint::cautious(seq.size_hint()));
 1036|       |
 1037|    612|                while let Some(value) = try!(seq.next_element()) {
 1038|    306|                    values.push(value);
 1039|    306|                }
 1040|       |
 1041|    306|                Ok(values)
 1042|    306|            }
_RINvXsV_NtNtCslVZeVZySzLE_5serde2de5implsmNtB8_11Deserialize11deserializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
  113|    204|            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  114|    204|            where
  115|    204|                D: Deserializer<'de>,
  116|    204|            {
  117|    204|                struct PrimitiveVisitor;
  118|    204|
  119|    204|                impl<'de> Visitor<'de> for PrimitiveVisitor {
  120|    204|                    type Value = $primitive;
  121|    204|
  122|    204|                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
  123|    204|                        formatter.write_str(stringify!($primitive))
  124|    204|                    }
  125|    204|
  126|    204|                    $($($method!($val : $visit);)*)*
  127|    204|                }
  128|    204|
  129|    204|                deserializer.$deserialize(PrimitiveVisitor)
  130|    204|            }
_RINvXs2M_NtNtCslVZeVZySzLE_5serde2de5implsTNtNtCshRBVfIqfJKm_13fvm_ipld_hamt8bitfield8BitfieldINtNtCsjYc3JqMxxfa_5alloc3vec3VecINtNtBJ_7pointer7PointerNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtBJ_14hash_algorithm6Sha256EEENtB9_11Deserialize11deserializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
 1260|    102|                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
 1261|    102|                where
 1262|    102|                    D: Deserializer<'de>,
 1263|    102|                {
 1264|    102|                    struct TupleVisitor<$($name,)+> {
 1265|    102|                        marker: PhantomData<($($name,)+)>,
 1266|    102|                    }
 1267|    102|
 1268|    102|                    impl<'de, $($name: Deserialize<'de>),+> Visitor<'de> for TupleVisitor<$($name,)+> {
 1269|    102|                        type Value = ($($name,)+);
 1270|    102|
 1271|    102|                        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
 1272|    102|                            formatter.write_str(concat!("a tuple of size ", $len))
 1273|    102|                        }
 1274|    102|
 1275|    102|                        #[inline]
 1276|    102|                        #[allow(non_snake_case)]
 1277|    102|                        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1278|    102|                        where
 1279|    102|                            A: SeqAccess<'de>,
 1280|    102|                        {
 1281|    102|                            $(
 1282|    102|                                let $name = match try!(seq.next_element()) {
 1283|    102|                                    Some(value) => value,
 1284|    102|                                    None => return Err(Error::invalid_length($n, &self)),
 1285|    102|                                };
 1286|    102|                            )+
 1287|    102|
 1288|    102|                            Ok(($($name,)+))
 1289|    102|                        }
 1290|    102|                    }
 1291|    102|
 1292|    102|                    deserializer.deserialize_tuple($len, TupleVisitor { marker: PhantomData })
 1293|    102|                }
_RINvXsh_NtNtCslVZeVZySzLE_5serde2de5implsINtNtCsjYc3JqMxxfa_5alloc3vec3VecNtNtCs4pVfV2XJudO_10fvm_shared5piece9PieceInfoENtB8_11Deserialize11deserializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
 1013|  31.7k|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
 1014|  31.7k|    where
 1015|  31.7k|        D: Deserializer<'de>,
 1016|  31.7k|    {
 1017|  31.7k|        struct VecVisitor<T> {
 1018|  31.7k|            marker: PhantomData<T>,
 1019|  31.7k|        }
 1020|  31.7k|
 1021|  31.7k|        impl<'de, T> Visitor<'de> for VecVisitor<T>
 1022|  31.7k|        where
 1023|  31.7k|            T: Deserialize<'de>,
 1024|  31.7k|        {
 1025|  31.7k|            type Value = Vec<T>;
 1026|  31.7k|
 1027|  31.7k|            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
 1028|  31.7k|                formatter.write_str("a sequence")
 1029|  31.7k|            }
 1030|  31.7k|
 1031|  31.7k|            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1032|  31.7k|            where
 1033|  31.7k|                A: SeqAccess<'de>,
 1034|  31.7k|            {
 1035|  31.7k|                let mut values = Vec::with_capacity(size_hint::cautious(seq.size_hint()));
 1036|  31.7k|
 1037|  31.7k|                while let Some(value) = try!(seq.next_element()) {
 1038|  31.7k|                    values.push(value);
 1039|  31.7k|                }
 1040|  31.7k|
 1041|  31.7k|                Ok(values)
 1042|  31.7k|            }
 1043|  31.7k|        }
 1044|  31.7k|
 1045|  31.7k|        let visitor = VecVisitor {
 1046|  31.7k|            marker: PhantomData,
 1047|  31.7k|        };
 1048|  31.7k|        deserializer.deserialize_seq(visitor)
 1049|  31.7k|    }
_RINvXsh_NtNtCslVZeVZySzLE_5serde2de5implsINtNtCsjYc3JqMxxfa_5alloc3vec3VecTNtNtBI_6string6StringINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EEENtB8_11Deserialize11deserializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
 1013|    204|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
 1014|    204|    where
 1015|    204|        D: Deserializer<'de>,
 1016|    204|    {
 1017|    204|        struct VecVisitor<T> {
 1018|    204|            marker: PhantomData<T>,
 1019|    204|        }
 1020|    204|
 1021|    204|        impl<'de, T> Visitor<'de> for VecVisitor<T>
 1022|    204|        where
 1023|    204|            T: Deserialize<'de>,
 1024|    204|        {
 1025|    204|            type Value = Vec<T>;
 1026|    204|
 1027|    204|            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
 1028|    204|                formatter.write_str("a sequence")
 1029|    204|            }
 1030|    204|
 1031|    204|            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1032|    204|            where
 1033|    204|                A: SeqAccess<'de>,
 1034|    204|            {
 1035|    204|                let mut values = Vec::with_capacity(size_hint::cautious(seq.size_hint()));
 1036|    204|
 1037|    204|                while let Some(value) = try!(seq.next_element()) {
 1038|    204|                    values.push(value);
 1039|    204|                }
 1040|    204|
 1041|    204|                Ok(values)
 1042|    204|            }
 1043|    204|        }
 1044|    204|
 1045|    204|        let visitor = VecVisitor {
 1046|    204|            marker: PhantomData,
 1047|    204|        };
 1048|    204|        deserializer.deserialize_seq(visitor)
 1049|    204|    }

_RINvXs3_NtCslVZeVZySzLE_5serde2deINtNtCshM4Il2Z0i4R_4core6marker11PhantomDataINtNtCsjYc3JqMxxfa_5alloc3vec3VecINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EEENtB6_15DeserializeSeed11deserializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
  788|    102|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    102|    where
  790|    102|        D: Deserializer<'de>,
  791|    102|    {
  792|    102|        T::deserialize(deserializer)
  793|    102|    }
_RINvYNtNtNtCsalhrieD8kwf_12libipld_core5serde2de15SeqDeserializerNtNtCslVZeVZySzLE_5serde2de9SeqAccess12next_elementNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyECsitTtQF8ArIt_8fvm_fuzz:
 1728|    306|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|    306|    where
 1730|    306|        T: Deserialize<'de>,
 1731|    306|    {
 1732|    306|        self.next_element_seed(PhantomData)
 1733|    306|    }
_RINvXs3_NtCslVZeVZySzLE_5serde2deINtNtCshM4Il2Z0i4R_4core6marker11PhantomDataNtNtCs4pVfV2XJudO_10fvm_shared5state16StateTreeVersionENtB6_15DeserializeSeed11deserializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
  788|    102|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    102|    where
  790|    102|        D: Deserializer<'de>,
  791|    102|    {
  792|    102|        T::deserialize(deserializer)
  793|    102|    }
_RINvYINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de8AccessorNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de9MapAccess8next_keyNtNvXNvCsFqKNUWW8VZ_12fvm_ipld_cars_1__NtB2z_9CarHeaderNtB1K_11Deserialize11deserialize7___FieldECsitTtQF8ArIt_8fvm_fuzz:
 1850|    306|    fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>
 1851|    306|    where
 1852|    306|        K: Deserialize<'de>,
 1853|    306|    {
 1854|    306|        self.next_key_seed(PhantomData)
 1855|    306|    }
_RINvXs3_NtCslVZeVZySzLE_5serde2deINtNtCshM4Il2Z0i4R_4core6marker11PhantomDataINtNtBA_6option6OptionNtNtCs4pVfV2XJudO_10fvm_shared7address7AddressEENtB6_15DeserializeSeed11deserializeNtNtCsalhrieD8kwf_12libipld_core4ipld4IpldECsitTtQF8ArIt_8fvm_fuzz:
  788|    306|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    306|    where
  790|    306|        D: Deserializer<'de>,
  791|    306|    {
  792|    306|        T::deserialize(deserializer)
  793|    306|    }
_RINvYNtNtNtCsalhrieD8kwf_12libipld_core5serde2de15SeqDeserializerNtNtCslVZeVZySzLE_5serde2de9SeqAccess12next_elementNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateECsitTtQF8ArIt_8fvm_fuzz:
 1728|    306|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|    306|    where
 1730|    306|        T: Deserialize<'de>,
 1731|    306|    {
 1732|    306|        self.next_element_seed(PhantomData)
 1733|    306|    }
_RNvXs4_NtCslVZeVZySzLE_5serde2deQNtNtNtCsalhrieD8kwf_12libipld_core5serde2de15SeqDeserializerNtB5_9SeqAccess9size_hintCsitTtQF8ArIt_8fvm_fuzz:
 1765|    306|    fn size_hint(&self) -> Option<usize> {
 1766|    306|        (**self).size_hint()
 1767|    306|    }
_RINvXs3_NtCslVZeVZySzLE_5serde2deINtNtCshM4Il2Z0i4R_4core6marker11PhantomDataINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EENtB6_15DeserializeSeed11deserializeNtNtCsalhrieD8kwf_12libipld_core4ipld4IpldECsitTtQF8ArIt_8fvm_fuzz:
  788|    612|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    612|    where
  790|    612|        D: Deserializer<'de>,
  791|    612|    {
  792|    612|        T::deserialize(deserializer)
  793|    612|    }
_RINvXs4_NtCslVZeVZySzLE_5serde2deQNtNtNtCsalhrieD8kwf_12libipld_core5serde2de15SeqDeserializerNtB6_9SeqAccess12next_elementINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EECsitTtQF8ArIt_8fvm_fuzz:
 1757|    612|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1758|    612|    where
 1759|    612|        T: Deserialize<'de>,
 1760|    612|    {
 1761|    612|        (**self).next_element()
 1762|    612|    }
_RINvYINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de8AccessorNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de9SeqAccess12next_elementmECsitTtQF8ArIt_8fvm_fuzz:
 1728|    204|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|    204|    where
 1730|    204|        T: Deserialize<'de>,
 1731|    204|    {
 1732|    204|        self.next_element_seed(PhantomData)
 1733|    204|    }
_RINvYINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de8AccessorNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de9SeqAccess12next_elementNtNtCsjYc3JqMxxfa_5alloc6string6StringECsitTtQF8ArIt_8fvm_fuzz:
 1728|  3.06k|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|  3.06k|    where
 1730|  3.06k|        T: Deserialize<'de>,
 1731|  3.06k|    {
 1732|  3.06k|        self.next_element_seed(PhantomData)
 1733|  3.06k|    }
_RINvYNtNtNtCsalhrieD8kwf_12libipld_core5serde2de15SeqDeserializerNtNtCslVZeVZySzLE_5serde2de9SeqAccess12next_elementINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EECsitTtQF8ArIt_8fvm_fuzz:
 1728|    612|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|    612|    where
 1730|    612|        T: Deserialize<'de>,
 1731|    612|    {
 1732|    612|        self.next_element_seed(PhantomData)
 1733|    612|    }
_RINvYINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de8AccessorNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de9SeqAccess12next_elementNtNtCs4pVfV2XJudO_10fvm_shared5state16StateTreeVersionECsitTtQF8ArIt_8fvm_fuzz:
 1728|    102|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|    102|    where
 1730|    102|        T: Deserialize<'de>,
 1731|    102|    {
 1732|    102|        self.next_element_seed(PhantomData)
 1733|    102|    }
_RINvYNtNtNtCsalhrieD8kwf_12libipld_core5serde2de15SeqDeserializerNtNtCslVZeVZySzLE_5serde2de9SeqAccess12next_elementINtNtCshM4Il2Z0i4R_4core6option6OptionNtNtCs4pVfV2XJudO_10fvm_shared7address7AddressEECsitTtQF8ArIt_8fvm_fuzz:
 1728|    306|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|    306|    where
 1730|    306|        T: Deserialize<'de>,
 1731|    306|    {
 1732|    306|        self.next_element_seed(PhantomData)
 1733|    306|    }
_RINvYNtNtNtCsalhrieD8kwf_12libipld_core5serde2de15SeqDeserializerNtNtCslVZeVZySzLE_5serde2de9SeqAccess12next_elementyECsitTtQF8ArIt_8fvm_fuzz:
 1728|    306|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|    306|    where
 1730|    306|        T: Deserialize<'de>,
 1731|    306|    {
 1732|    306|        self.next_element_seed(PhantomData)
 1733|    306|    }
_RINvXs4_NtCslVZeVZySzLE_5serde2deQNtNtNtCsalhrieD8kwf_12libipld_core5serde2de15SeqDeserializerNtB6_9SeqAccess12next_elementINtCshRBVfIqfJKm_13fvm_ipld_hamt12KeyValuePairNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateEECsitTtQF8ArIt_8fvm_fuzz:
 1757|    612|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1758|    612|    where
 1759|    612|        T: Deserialize<'de>,
 1760|    612|    {
 1761|    612|        (**self).next_element()
 1762|    612|    }
_RINvXs3_NtCslVZeVZySzLE_5serde2deINtNtCshM4Il2Z0i4R_4core6marker11PhantomDataNtNtCsalhrieD8kwf_12libipld_core4ipld4IpldENtB6_15DeserializeSeed11deserializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
  788|  2.44k|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|  2.44k|    where
  790|  2.44k|        D: Deserializer<'de>,
  791|  2.44k|    {
  792|  2.44k|        T::deserialize(deserializer)
  793|  2.44k|    }
_RINvYNtNtNtCsalhrieD8kwf_12libipld_core5serde2de15SeqDeserializerNtNtCslVZeVZySzLE_5serde2de9SeqAccess12next_elementNtNtCs4pVfV2XJudO_10fvm_shared4econ11TokenAmountECsitTtQF8ArIt_8fvm_fuzz:
 1728|    306|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|    306|    where
 1730|    306|        T: Deserialize<'de>,
 1731|    306|    {
 1732|    306|        self.next_element_seed(PhantomData)
 1733|    306|    }
_RINvYINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de8AccessorNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de9SeqAccess12next_elementTNtNtCsjYc3JqMxxfa_5alloc6string6StringINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EEECsitTtQF8ArIt_8fvm_fuzz:
 1728|  3.26k|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|  3.26k|    where
 1730|  3.26k|        T: Deserialize<'de>,
 1731|  3.26k|    {
 1732|  3.26k|        self.next_element_seed(PhantomData)
 1733|  3.26k|    }
_RINvXs4_NtCslVZeVZySzLE_5serde2deQNtNtNtCsalhrieD8kwf_12libipld_core5serde2de15SeqDeserializerNtB6_9SeqAccess12next_elementNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyECsitTtQF8ArIt_8fvm_fuzz:
 1757|    306|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1758|    306|    where
 1759|    306|        T: Deserialize<'de>,
 1760|    306|    {
 1761|    306|        (**self).next_element()
 1762|    306|    }
_RINvXs4_NtCslVZeVZySzLE_5serde2deQNtNtNtCsalhrieD8kwf_12libipld_core5serde2de15SeqDeserializerNtB6_9SeqAccess12next_elementINtNtCshM4Il2Z0i4R_4core6option6OptionNtNtCs4pVfV2XJudO_10fvm_shared7address7AddressEECsitTtQF8ArIt_8fvm_fuzz:
 1757|    306|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1758|    306|    where
 1759|    306|        T: Deserialize<'de>,
 1760|    306|    {
 1761|    306|        (**self).next_element()
 1762|    306|    }
_RINvYNtNtCs1slUOa8tBso_3cid5serde17BytesToCidVisitorNtNtCslVZeVZySzLE_5serde2de7Visitor20visit_borrowed_bytesINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor5error11DecodeErrorNtNtCshM4Il2Z0i4R_4core7convert10InfallibleEECsitTtQF8ArIt_8fvm_fuzz:
 1568|  4.18k|    fn visit_borrowed_bytes<E>(self, v: &'de [u8]) -> Result<Self::Value, E>
 1569|  4.18k|    where
 1570|  4.18k|        E: Error,
 1571|  4.18k|    {
 1572|  4.18k|        self.visit_bytes(v)
 1573|  4.18k|    }
_RINvYINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de8AccessorNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de9SeqAccess12next_elementINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EECsitTtQF8ArIt_8fvm_fuzz:
 1728|  3.67k|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|  3.67k|    where
 1730|  3.67k|        T: Deserialize<'de>,
 1731|  3.67k|    {
 1732|  3.67k|        self.next_element_seed(PhantomData)
 1733|  3.67k|    }
_RINvXs3_NtCslVZeVZySzLE_5serde2deINtNtCshM4Il2Z0i4R_4core6marker11PhantomDatayENtB6_15DeserializeSeed11deserializeNtNtCsalhrieD8kwf_12libipld_core4ipld4IpldECsitTtQF8ArIt_8fvm_fuzz:
  788|    306|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    306|    where
  790|    306|        D: Deserializer<'de>,
  791|    306|    {
  792|    306|        T::deserialize(deserializer)
  793|    306|    }
_RINvYINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de8AccessorNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de9SeqAccess12next_elementNtNtCshRBVfIqfJKm_13fvm_ipld_hamt8bitfield8BitfieldECsitTtQF8ArIt_8fvm_fuzz:
 1728|    102|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|    102|    where
 1730|    102|        T: Deserialize<'de>,
 1731|    102|    {
 1732|    102|        self.next_element_seed(PhantomData)
 1733|    102|    }
_RINvXs3_NtCslVZeVZySzLE_5serde2deINtNtCshM4Il2Z0i4R_4core6marker11PhantomDataINtCshRBVfIqfJKm_13fvm_ipld_hamt12KeyValuePairNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateEENtB6_15DeserializeSeed11deserializeNtNtCsalhrieD8kwf_12libipld_core4ipld4IpldECsitTtQF8ArIt_8fvm_fuzz:
  788|    306|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    306|    where
  790|    306|        D: Deserializer<'de>,
  791|    306|    {
  792|    306|        T::deserialize(deserializer)
  793|    306|    }
_RINvXs4_NtCslVZeVZySzLE_5serde2deQNtNtNtCsalhrieD8kwf_12libipld_core5serde2de15SeqDeserializerNtB6_9SeqAccess12next_elementNtNtCs4pVfV2XJudO_10fvm_shared4econ11TokenAmountECsitTtQF8ArIt_8fvm_fuzz:
 1757|    306|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1758|    306|    where
 1759|    306|        T: Deserialize<'de>,
 1760|    306|    {
 1761|    306|        (**self).next_element()
 1762|    306|    }
_RINvXs3_NtCslVZeVZySzLE_5serde2deINtNtCshM4Il2Z0i4R_4core6marker11PhantomDataINtNtCsjYc3JqMxxfa_5alloc3vec3VecINtNtCshRBVfIqfJKm_13fvm_ipld_hamt7pointer7PointerNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtB1P_14hash_algorithm6Sha256EEENtB6_15DeserializeSeed11deserializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
  788|    102|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    102|    where
  790|    102|        D: Deserializer<'de>,
  791|    102|    {
  792|    102|        T::deserialize(deserializer)
  793|    102|    }
_RINvXs3_NtCslVZeVZySzLE_5serde2deINtNtCshM4Il2Z0i4R_4core6marker11PhantomDataNtNtCs4pVfV2XJudO_10fvm_shared4econ11TokenAmountENtB6_15DeserializeSeed11deserializeNtNtCsalhrieD8kwf_12libipld_core4ipld4IpldECsitTtQF8ArIt_8fvm_fuzz:
  788|    306|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    306|    where
  790|    306|        D: Deserializer<'de>,
  791|    306|    {
  792|    306|        T::deserialize(deserializer)
  793|    306|    }
_RINvYINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de8AccessorNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de9SeqAccess12next_elementNtNtCsalhrieD8kwf_12libipld_core4ipld4IpldECsitTtQF8ArIt_8fvm_fuzz:
 1728|  3.36k|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|  3.36k|    where
 1730|  3.36k|        T: Deserialize<'de>,
 1731|  3.36k|    {
 1732|  3.36k|        self.next_element_seed(PhantomData)
 1733|  3.36k|    }
_RINvXs3_NtCslVZeVZySzLE_5serde2deINtNtCshM4Il2Z0i4R_4core6marker11PhantomDataTNtNtCsjYc3JqMxxfa_5alloc6string6StringINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EEENtB6_15DeserializeSeed11deserializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
  788|  3.06k|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|  3.06k|    where
  790|  3.06k|        D: Deserializer<'de>,
  791|  3.06k|    {
  792|  3.06k|        T::deserialize(deserializer)
  793|  3.06k|    }
_RINvXs3_NtCslVZeVZySzLE_5serde2deINtNtCshM4Il2Z0i4R_4core6marker11PhantomDataINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EENtB6_15DeserializeSeed11deserializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
  788|  3.57k|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|  3.57k|    where
  790|  3.57k|        D: Deserializer<'de>,
  791|  3.57k|    {
  792|  3.57k|        T::deserialize(deserializer)
  793|  3.57k|    }
_RINvYINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de8AccessorNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de9MapAccess10next_valueINtNtCsjYc3JqMxxfa_5alloc3vec3VecINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EEECsitTtQF8ArIt_8fvm_fuzz:
 1867|    102|    fn next_value<V>(&mut self) -> Result<V, Self::Error>
 1868|    102|    where
 1869|    102|        V: Deserialize<'de>,
 1870|    102|    {
 1871|    102|        self.next_value_seed(PhantomData)
 1872|    102|    }
_RINvYNtNtNtCslVZeVZySzLE_5serde2de5impls13StringVisitorNtB7_7Visitor18visit_borrowed_strINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor5error11DecodeErrorNtNtCshM4Il2Z0i4R_4core7convert10InfallibleEECsitTtQF8ArIt_8fvm_fuzz:
 1509|  3.06k|    fn visit_borrowed_str<E>(self, v: &'de str) -> Result<Self::Value, E>
 1510|  3.06k|    where
 1511|  3.06k|        E: Error,
 1512|  3.06k|    {
 1513|  3.06k|        self.visit_str(v)
 1514|  3.06k|    }
_RINvYNtNtNtCsalhrieD8kwf_12libipld_core5serde2de15SeqDeserializerNtNtCslVZeVZySzLE_5serde2de9SeqAccess12next_elementINtCshRBVfIqfJKm_13fvm_ipld_hamt12KeyValuePairNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateEECsitTtQF8ArIt_8fvm_fuzz:
 1728|    612|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|    612|    where
 1730|    612|        T: Deserialize<'de>,
 1731|    612|    {
 1732|    612|        self.next_element_seed(PhantomData)
 1733|    612|    }
_RINvYINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de8AccessorNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de9SeqAccess12next_elementINtNtCsjYc3JqMxxfa_5alloc3vec3VecINtNtCshRBVfIqfJKm_13fvm_ipld_hamt7pointer7PointerNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtB39_14hash_algorithm6Sha256EEECsitTtQF8ArIt_8fvm_fuzz:
 1728|    102|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|    102|    where
 1730|    102|        T: Deserialize<'de>,
 1731|    102|    {
 1732|    102|        self.next_element_seed(PhantomData)
 1733|    102|    }
_RINvYNtNvXs_NtNtCsbsA1N0ivJJv_17fvm_ipld_encoding5bytes12strict_bytesINtNtCsjYc3JqMxxfa_5alloc3vec3VechENtBa_11Deserialize11deserialize10VecVisitorNtNtCslVZeVZySzLE_5serde2de7Visitor20visit_borrowed_bytesINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor5error11DecodeErrorNtNtCshM4Il2Z0i4R_4core7convert10InfallibleEECsitTtQF8ArIt_8fvm_fuzz:
 1568|    102|    fn visit_borrowed_bytes<E>(self, v: &'de [u8]) -> Result<Self::Value, E>
 1569|    102|    where
 1570|    102|        E: Error,
 1571|    102|    {
 1572|    102|        self.visit_bytes(v)
 1573|    102|    }
_RINvXs3_NtCslVZeVZySzLE_5serde2deINtNtCshM4Il2Z0i4R_4core6marker11PhantomDatayENtB6_15DeserializeSeed11deserializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
  788|    102|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    102|    where
  790|    102|        D: Deserializer<'de>,
  791|    102|    {
  792|    102|        T::deserialize(deserializer)
  793|    102|    }
_RINvYINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de8AccessorNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de9SeqAccess12next_elementINtNtCshRBVfIqfJKm_13fvm_ipld_hamt7pointer7PointerNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtB2C_14hash_algorithm6Sha256EECsitTtQF8ArIt_8fvm_fuzz:
 1728|    408|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|    408|    where
 1730|    408|        T: Deserialize<'de>,
 1731|    408|    {
 1732|    408|        self.next_element_seed(PhantomData)
 1733|    408|    }
_RINvXs3_NtCslVZeVZySzLE_5serde2deINtNtCshM4Il2Z0i4R_4core6marker11PhantomDataINtNtCshRBVfIqfJKm_13fvm_ipld_hamt7pointer7PointerNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtB1i_14hash_algorithm6Sha256EENtB6_15DeserializeSeed11deserializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
  788|    306|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    306|    where
  790|    306|        D: Deserializer<'de>,
  791|    306|    {
  792|    306|        T::deserialize(deserializer)
  793|    306|    }
_RINvXs3_NtCslVZeVZySzLE_5serde2deINtNtCshM4Il2Z0i4R_4core6marker11PhantomDataNtNtCsjYc3JqMxxfa_5alloc6string6StringENtB6_15DeserializeSeed11deserializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
  788|  3.06k|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|  3.06k|    where
  790|  3.06k|        D: Deserializer<'de>,
  791|  3.06k|    {
  792|  3.06k|        T::deserialize(deserializer)
  793|  3.06k|    }
_RINvXs3_NtCslVZeVZySzLE_5serde2deINtNtCshM4Il2Z0i4R_4core6marker11PhantomDatamENtB6_15DeserializeSeed11deserializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
  788|    204|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    204|    where
  790|    204|        D: Deserializer<'de>,
  791|    204|    {
  792|    204|        T::deserialize(deserializer)
  793|    204|    }
_RINvXs3_NtCslVZeVZySzLE_5serde2deINtNtCshM4Il2Z0i4R_4core6marker11PhantomDataNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateENtB6_15DeserializeSeed11deserializeNtNtCsalhrieD8kwf_12libipld_core4ipld4IpldECsitTtQF8ArIt_8fvm_fuzz:
  788|    306|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    306|    where
  790|    306|        D: Deserializer<'de>,
  791|    306|    {
  792|    306|        T::deserialize(deserializer)
  793|    306|    }
_RINvYNtNvXNtNtCsalhrieD8kwf_12libipld_core5serde2deNtNtBc_4ipld4IpldNtNtCslVZeVZySzLE_5serde2de11Deserialize11deserialize11IpldVisitorNtB16_7Visitor20visit_borrowed_bytesINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor5error11DecodeErrorNtNtCshM4Il2Z0i4R_4core7convert10InfallibleEECsitTtQF8ArIt_8fvm_fuzz:
 1568|    612|    fn visit_borrowed_bytes<E>(self, v: &'de [u8]) -> Result<Self::Value, E>
 1569|    612|    where
 1570|    612|        E: Error,
 1571|    612|    {
 1572|    612|        self.visit_bytes(v)
 1573|    612|    }
_RINvXs3_NtCslVZeVZySzLE_5serde2deINtNtCshM4Il2Z0i4R_4core6marker11PhantomDataNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyENtB6_15DeserializeSeed11deserializeNtNtCsalhrieD8kwf_12libipld_core4ipld4IpldECsitTtQF8ArIt_8fvm_fuzz:
  788|    306|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    306|    where
  790|    306|        D: Deserializer<'de>,
  791|    306|    {
  792|    306|        T::deserialize(deserializer)
  793|    306|    }
_RINvYINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de8AccessorNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de9MapAccess10next_valueyECsitTtQF8ArIt_8fvm_fuzz:
 1867|    102|    fn next_value<V>(&mut self) -> Result<V, Self::Error>
 1868|    102|    where
 1869|    102|        V: Deserialize<'de>,
 1870|    102|    {
 1871|    102|        self.next_value_seed(PhantomData)
 1872|    102|    }
_RINvXs3_NtCslVZeVZySzLE_5serde2deINtNtCshM4Il2Z0i4R_4core6marker11PhantomDataNtNtCshRBVfIqfJKm_13fvm_ipld_hamt8bitfield8BitfieldENtB6_15DeserializeSeed11deserializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
  788|    102|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    102|    where
  790|    102|        D: Deserializer<'de>,
  791|    102|    {
  792|    102|        T::deserialize(deserializer)
  793|    102|    }
_RINvYNtNvXNvCsFqKNUWW8VZ_12fvm_ipld_cars_1__NtBa_9CarHeaderNtNtCslVZeVZySzLE_5serde2de11Deserialize11deserialize14___FieldVisitorNtBX_7Visitor18visit_borrowed_strINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor5error11DecodeErrorNtNtCshM4Il2Z0i4R_4core7convert10InfallibleEECsitTtQF8ArIt_8fvm_fuzz:
 1509|    204|    fn visit_borrowed_str<E>(self, v: &'de str) -> Result<Self::Value, E>
 1510|    204|    where
 1511|    204|        E: Error,
 1512|    204|    {
 1513|    204|        self.visit_str(v)
 1514|    204|    }
_RINvXs4_NtCslVZeVZySzLE_5serde2deQNtNtNtCsalhrieD8kwf_12libipld_core5serde2de15SeqDeserializerNtB6_9SeqAccess12next_elementNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateECsitTtQF8ArIt_8fvm_fuzz:
 1757|    306|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1758|    306|    where
 1759|    306|        T: Deserialize<'de>,
 1760|    306|    {
 1761|    306|        (**self).next_element()
 1762|    306|    }
_RINvXs4_NtCslVZeVZySzLE_5serde2deQNtNtNtCsalhrieD8kwf_12libipld_core5serde2de15SeqDeserializerNtB6_9SeqAccess12next_elementyECsitTtQF8ArIt_8fvm_fuzz:
 1757|    306|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1758|    306|    where
 1759|    306|        T: Deserialize<'de>,
 1760|    306|    {
 1761|    306|        (**self).next_element()
 1762|    306|    }
_RINvXs3_NtCslVZeVZySzLE_5serde2deINtNtCshM4Il2Z0i4R_4core6marker11PhantomDataNtNvXNvCsFqKNUWW8VZ_12fvm_ipld_cars_1__NtB1k_9CarHeaderNtB6_11Deserialize11deserialize7___FieldENtB6_15DeserializeSeed11deserializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
  788|    204|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    204|    where
  790|    204|        D: Deserializer<'de>,
  791|    204|    {
  792|    204|        T::deserialize(deserializer)
  793|    204|    }

_RNvNtNtCslVZeVZySzLE_5serde9___private9size_hint8cautious:
   12|    714|pub fn cautious(hint: Option<usize>) -> usize {
   13|    714|    cmp::min(hint.unwrap_or(0), 4096)
   14|    714|}

_RINvXs1G_NtNtCslVZeVZySzLE_5serde3ser5implsRINtNtCshRBVfIqfJKm_13fvm_ipld_hamt7pointer7PointerNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtBL_14hash_algorithm6Sha256ENtB9_9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
  386|    306|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|    306|            where
  388|    306|                S: Serializer,
  389|    306|            {
  390|    306|                (**self).serialize(serializer)
  391|    306|            }
_RINvXs1G_NtNtCslVZeVZySzLE_5serde3ser5implsRINtNtCshM4Il2Z0i4R_4core6option6OptionNtNtCs4pVfV2XJudO_10fvm_shared7address7AddressENtB9_9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
  386|    306|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|    306|            where
  388|    306|                S: Serializer,
  389|    306|            {
  390|    306|                (**self).serialize(serializer)
  391|    306|            }
_RINvXs1G_NtNtCslVZeVZySzLE_5serde3ser5implsRINtCshRBVfIqfJKm_13fvm_ipld_hamt12KeyValuePairNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateENtB9_9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
  386|    306|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|    306|            where
  388|    306|                S: Serializer,
  389|    306|            {
  390|    306|                (**self).serialize(serializer)
  391|    306|            }
_RINvXs1G_NtNtCslVZeVZySzLE_5serde3ser5implsRNtNtCsjYc3JqMxxfa_5alloc6string6StringNtB9_9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
  386|    102|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|    102|            where
  388|    102|                S: Serializer,
  389|    102|            {
  390|    102|                (**self).serialize(serializer)
  391|    102|            }
_RINvXs1m_NtNtCslVZeVZySzLE_5serde3ser5implsINtNtCsjYc3JqMxxfa_5alloc3vec3VecINtNtCshRBVfIqfJKm_13fvm_ipld_hamt7pointer7PointerNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtBK_6string6StringNtNtB1h_14hash_algorithm6Sha256EENtB9_9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
  194|    102|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  195|    102|            where
  196|    102|                S: Serializer,
  197|    102|            {
  198|    102|                serializer.collect_seq(self)
  199|    102|            }
_RINvXs1m_NtNtCslVZeVZySzLE_5serde3ser5implsINtNtCsjYc3JqMxxfa_5alloc3vec3VecINtNtCshRBVfIqfJKm_13fvm_ipld_hamt7pointer7PointerNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtB1h_14hash_algorithm6Sha256EENtB9_9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
  194|    102|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  195|    102|            where
  196|    102|                S: Serializer,
  197|    102|            {
  198|    102|                serializer.collect_seq(self)
  199|    102|            }
_RINvXs1G_NtNtCslVZeVZySzLE_5serde3ser5implsRINtNtCsjYc3JqMxxfa_5alloc3vec3VecINtNtCshRBVfIqfJKm_13fvm_ipld_hamt7pointer7PointerNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtBL_6string6StringNtNtB1i_14hash_algorithm6Sha256EENtB9_9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
  386|    102|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|    102|            where
  388|    102|                S: Serializer,
  389|    102|            {
  390|    102|                (**self).serialize(serializer)
  391|    102|            }
_RINvXs1G_NtNtCslVZeVZySzLE_5serde3ser5implsRNtNtCs4pVfV2XJudO_10fvm_shared4econ11TokenAmountNtB9_9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
  386|    306|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|    306|            where
  388|    306|                S: Serializer,
  389|    306|            {
  390|    306|                (**self).serialize(serializer)
  391|    306|            }
_RINvXs3_NtNtCslVZeVZySzLE_5serde3ser5implsINtNtCshM4Il2Z0i4R_4core6option6OptionNtNtCs4pVfV2XJudO_10fvm_shared7address7AddressENtB8_9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
  104|    306|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  105|    306|    where
  106|    306|        S: Serializer,
  107|    306|    {
  108|    306|        match *self {
  109|      0|            Some(ref value) => serializer.serialize_some(value),
  110|    306|            None => serializer.serialize_none(),
  111|       |        }
  112|    306|    }
_RINvXs1G_NtNtCslVZeVZySzLE_5serde3ser5implsRINtNtCs1slUOa8tBso_3cid3cid3CidKj40_ENtB9_9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
  386|  1.02k|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|  1.02k|            where
  388|  1.02k|                S: Serializer,
  389|  1.02k|            {
  390|  1.02k|                (**self).serialize(serializer)
  391|  1.02k|            }
_RINvXsG_NtNtCslVZeVZySzLE_5serde3ser5implsyNtB8_9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
   11|    510|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   12|    510|            where
   13|    510|                S: Serializer,
   14|    510|            {
   15|    510|                serializer.$method(*self $($cast)*)
   16|    510|            }
_RINvXs1p_NtNtCslVZeVZySzLE_5serde3ser5implsTRNtNtCshRBVfIqfJKm_13fvm_ipld_hamt8bitfield8BitfieldRINtNtCsjYc3JqMxxfa_5alloc3vec3VecINtNtBL_7pointer7PointerNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtBL_14hash_algorithm6Sha256EEENtB9_9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
  314|    102|                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  315|    102|                where
  316|    102|                    S: Serializer,
  317|    102|                {
  318|    102|                    let mut tuple = try!(serializer.serialize_tuple($len));
  319|       |                    $(
  320|    102|                        try!(tuple.serialize_element(&self.$n));
  321|       |                    )+
  322|    102|                    tuple.end()
  323|    102|                }
_RINvXs1G_NtNtCslVZeVZySzLE_5serde3ser5implsRNtNtCs4pVfV2XJudO_10fvm_shared5state16StateTreeVersionNtB9_9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
  386|    102|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|    102|            where
  388|    102|                S: Serializer,
  389|    102|            {
  390|    102|                (**self).serialize(serializer)
  391|    102|            }
_RINvXs1m_NtNtCslVZeVZySzLE_5serde3ser5implsINtNtCsjYc3JqMxxfa_5alloc3vec3VecINtCshRBVfIqfJKm_13fvm_ipld_hamt12KeyValuePairNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateEENtB9_9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
  194|    306|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  195|    306|            where
  196|    306|                S: Serializer,
  197|    306|            {
  198|    306|                serializer.collect_seq(self)
  199|    306|            }
_RINvXs1G_NtNtCslVZeVZySzLE_5serde3ser5implsRNtNtCshRBVfIqfJKm_13fvm_ipld_hamt8bitfield8BitfieldNtB9_9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
  386|    204|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|    204|            where
  388|    204|                S: Serializer,
  389|    204|            {
  390|    204|                (**self).serialize(serializer)
  391|    204|            }
_RINvXs1G_NtNtCslVZeVZySzLE_5serde3ser5implsRINtNtCsjYc3JqMxxfa_5alloc3vec3VecINtNtCshRBVfIqfJKm_13fvm_ipld_hamt7pointer7PointerNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtB1i_14hash_algorithm6Sha256EENtB9_9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
  386|    102|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|    102|            where
  388|    102|                S: Serializer,
  389|    102|            {
  390|    102|                (**self).serialize(serializer)
  391|    102|            }
_RINvXs_NtNtCslVZeVZySzLE_5serde3ser5implsNtNtCsjYc3JqMxxfa_5alloc6string6StringNtB7_9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
   56|    102|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   57|    102|    where
   58|    102|        S: Serializer,
   59|    102|    {
   60|    102|        serializer.serialize_str(self)
   61|    102|    }
_RINvXs1p_NtNtCslVZeVZySzLE_5serde3ser5implsTRNtNtCshRBVfIqfJKm_13fvm_ipld_hamt8bitfield8BitfieldRINtNtCsjYc3JqMxxfa_5alloc3vec3VecINtNtBL_7pointer7PointerNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtB1C_6string6StringNtNtBL_14hash_algorithm6Sha256EEENtB9_9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
  314|    102|                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  315|    102|                where
  316|    102|                    S: Serializer,
  317|    102|                {
  318|    102|                    let mut tuple = try!(serializer.serialize_tuple($len));
  319|       |                    $(
  320|    102|                        try!(tuple.serialize_element(&self.$n));
  321|       |                    )+
  322|    102|                    tuple.end()
  323|    102|                }
_RINvXs5_NtNtCslVZeVZySzLE_5serde3ser5implsAuj0_NtB8_9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
  132|    204|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  133|    204|    where
  134|    204|        S: Serializer,
  135|    204|    {
  136|    204|        try!(serializer.serialize_tuple(0)).end()
  137|    204|    }
_RINvXs1G_NtNtCslVZeVZySzLE_5serde3ser5implsRyNtB9_9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
  386|    408|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|    408|            where
  388|    408|                S: Serializer,
  389|    408|            {
  390|    408|                (**self).serialize(serializer)
  391|    408|            }

_RINvNtCslVZeVZySzLE_5serde3ser17iterator_len_hintINtNtNtCshM4Il2Z0i4R_4core5slice4iter4IterINtNtCshRBVfIqfJKm_13fvm_ipld_hamt7pointer7PointerNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtB1w_14hash_algorithm6Sha256EEECsitTtQF8ArIt_8fvm_fuzz:
 1982|    102|    match iter.size_hint() {
 1983|    102|        (lo, Some(hi)) if lo == hi => Some(lo),
 1984|      0|        _ => None,
 1985|       |    }
 1986|    102|}
_RINvYQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterENtNtCslVZeVZySzLE_5serde3ser10Serializer11collect_seqRINtNtCsjYc3JqMxxfa_5alloc3vec3VecINtCshRBVfIqfJKm_13fvm_ipld_hamt12KeyValuePairNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateEEECsitTtQF8ArIt_8fvm_fuzz:
 1275|    306|    fn collect_seq<I>(self, iter: I) -> Result<Self::Ok, Self::Error>
 1276|    306|    where
 1277|    306|        I: IntoIterator,
 1278|    306|        <I as IntoIterator>::Item: Serialize,
 1279|    306|    {
 1280|    306|        let iter = iter.into_iter();
 1281|    306|        let mut serializer = try!(self.serialize_seq(iterator_len_hint(&iter)));
 1282|       |
 1283|       |        #[cfg(not(no_iterator_try_fold))]
 1284|       |        {
 1285|    306|            let mut iter = iter;
 1286|    306|            try!(iter.try_for_each(|item| serializer.serialize_element(&item)));
 1287|       |        }
 1288|       |
 1289|       |        #[cfg(no_iterator_try_fold)]
 1290|       |        {
 1291|       |            for item in iter {
 1292|       |                try!(serializer.serialize_element(&item));
 1293|       |            }
 1294|       |        }
 1295|       |
 1296|    306|        serializer.end()
 1297|    306|    }
_RINvNtCslVZeVZySzLE_5serde3ser17iterator_len_hintINtNtNtCshM4Il2Z0i4R_4core5slice4iter4IterINtCshRBVfIqfJKm_13fvm_ipld_hamt12KeyValuePairNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateEEECsitTtQF8ArIt_8fvm_fuzz:
 1982|    306|    match iter.size_hint() {
 1983|    306|        (lo, Some(hi)) if lo == hi => Some(lo),
 1984|      0|        _ => None,
 1985|       |    }
 1986|    306|}
_RINvYQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterENtNtCslVZeVZySzLE_5serde3ser10Serializer11collect_seqRINtNtCsjYc3JqMxxfa_5alloc3vec3VecINtNtCshRBVfIqfJKm_13fvm_ipld_hamt7pointer7PointerNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtB2H_6string6StringNtNtB3e_14hash_algorithm6Sha256EEECsitTtQF8ArIt_8fvm_fuzz:
 1275|    102|    fn collect_seq<I>(self, iter: I) -> Result<Self::Ok, Self::Error>
 1276|    102|    where
 1277|    102|        I: IntoIterator,
 1278|    102|        <I as IntoIterator>::Item: Serialize,
 1279|    102|    {
 1280|    102|        let iter = iter.into_iter();
 1281|    102|        let mut serializer = try!(self.serialize_seq(iterator_len_hint(&iter)));
 1282|       |
 1283|       |        #[cfg(not(no_iterator_try_fold))]
 1284|       |        {
 1285|    102|            let mut iter = iter;
 1286|    102|            try!(iter.try_for_each(|item| serializer.serialize_element(&item)));
 1287|       |        }
 1288|       |
 1289|       |        #[cfg(no_iterator_try_fold)]
 1290|       |        {
 1291|       |            for item in iter {
 1292|       |                try!(serializer.serialize_element(&item));
 1293|       |            }
 1294|       |        }
 1295|       |
 1296|    102|        serializer.end()
 1297|    102|    }
_RNCINvYQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterENtNtCslVZeVZySzLE_5serde3ser10Serializer11collect_seqRINtNtCsjYc3JqMxxfa_5alloc3vec3VecINtCshRBVfIqfJKm_13fvm_ipld_hamt12KeyValuePairNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateEEE0CsitTtQF8ArIt_8fvm_fuzz:
 1286|    306|            try!(iter.try_for_each(|item| serializer.serialize_element(&item)));
_RNCINvYQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterENtNtCslVZeVZySzLE_5serde3ser10Serializer11collect_seqRINtNtCsjYc3JqMxxfa_5alloc3vec3VecINtNtCshRBVfIqfJKm_13fvm_ipld_hamt7pointer7PointerNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtB3g_14hash_algorithm6Sha256EEE0CsitTtQF8ArIt_8fvm_fuzz:
 1286|    306|            try!(iter.try_for_each(|item| serializer.serialize_element(&item)));
_RINvNtCslVZeVZySzLE_5serde3ser17iterator_len_hintINtNtNtCshM4Il2Z0i4R_4core5slice4iter4IterINtNtCshRBVfIqfJKm_13fvm_ipld_hamt7pointer7PointerNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCsjYc3JqMxxfa_5alloc6string6StringNtNtB1w_14hash_algorithm6Sha256EEECsitTtQF8ArIt_8fvm_fuzz:
 1982|    102|    match iter.size_hint() {
 1983|    102|        (lo, Some(hi)) if lo == hi => Some(lo),
 1984|      0|        _ => None,
 1985|       |    }
 1986|    102|}
_RINvYQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterENtNtCslVZeVZySzLE_5serde3ser10Serializer11collect_seqRINtNtCsjYc3JqMxxfa_5alloc3vec3VecINtNtCshRBVfIqfJKm_13fvm_ipld_hamt7pointer7PointerNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtB3e_14hash_algorithm6Sha256EEECsitTtQF8ArIt_8fvm_fuzz:
 1275|    102|    fn collect_seq<I>(self, iter: I) -> Result<Self::Ok, Self::Error>
 1276|    102|    where
 1277|    102|        I: IntoIterator,
 1278|    102|        <I as IntoIterator>::Item: Serialize,
 1279|    102|    {
 1280|    102|        let iter = iter.into_iter();
 1281|    102|        let mut serializer = try!(self.serialize_seq(iterator_len_hint(&iter)));
 1282|       |
 1283|       |        #[cfg(not(no_iterator_try_fold))]
 1284|       |        {
 1285|    102|            let mut iter = iter;
 1286|    102|            try!(iter.try_for_each(|item| serializer.serialize_element(&item)));
 1287|       |        }
 1288|       |
 1289|       |        #[cfg(no_iterator_try_fold)]
 1290|       |        {
 1291|       |            for item in iter {
 1292|       |                try!(serializer.serialize_element(&item));
 1293|       |            }
 1294|       |        }
 1295|       |
 1296|    102|        serializer.end()
 1297|    102|    }

_RINvMNtCskRLky7pABTx_11serde_bytes7bytebufNtB3_7ByteBuf4fromINtNtCsjYc3JqMxxfa_5alloc3vec3VechEECsitTtQF8ArIt_8fvm_fuzz:
   60|  1.02k|    pub fn from<T: Into<Vec<u8>>>(bytes: T) -> Self {
   61|  1.02k|        ByteBuf {
   62|  1.02k|            bytes: bytes.into(),
   63|  1.02k|        }
   64|  1.02k|    }
_RINvXsc_NtCskRLky7pABTx_11serde_bytes7bytebufNtB6_7ByteBufNtNtCslVZeVZySzLE_5serde3ser9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser13CidSerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
  186|  1.02k|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  187|  1.02k|    where
  188|  1.02k|        S: Serializer,
  189|  1.02k|    {
  190|  1.02k|        serializer.serialize_bytes(&self.bytes)
  191|  1.02k|    }

_RINvNtCs8loA9e5gPGU_18serde_ipld_dagcbor14cbor4ii_nonpub8peek_oneNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderECsitTtQF8ArIt_8fvm_fuzz:
   26|  7.65k|pub(crate) fn peek_one<'a, R: dec::Read<'a>>(reader: &mut R) -> Result<u8, DecodeError<R::Error>> {
   27|  7.65k|    let buf = match reader.fill(1)? {
   28|  7.65k|        dec::Reference::Long(buf) => buf,
   29|      0|        dec::Reference::Short(buf) => buf,
   30|       |    };
   31|  7.65k|    let byte = buf.get(0).copied().ok_or(DecodeError::Eof)?;
   32|  6.93k|    Ok(byte)
   33|  7.65k|}

_RINvXs7_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deQINtB6_15CidDeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de12Deserializer17deserialize_bytesNtNtCs1slUOa8tBso_3cid5serde17BytesToCidVisitorECsitTtQF8ArIt_8fvm_fuzz:
  646|  4.18k|    fn deserialize_bytes<V: de::Visitor<'de>>(self, visitor: V) -> Result<V::Value, Self::Error> {
  647|  4.18k|        let byte = peek_one(&mut self.0.reader)?;
  648|  4.18k|        match dec::if_major(byte) {
  649|       |            major::BYTES => {
  650|       |                // CBOR encoded CIDs have a zero byte prefix we have to remove.
  651|  4.18k|                match <types::Bytes<Cow<[u8]>>>::decode(&mut self.0.reader)?.0 {
  652|  4.18k|                    Cow::Borrowed(buf) => {
  653|  4.18k|                        if buf.len() <= 1 || buf[0] != 0 {
  654|      0|                            Err(DecodeError::Msg("Invalid CID".into()))
  655|       |                        } else {
  656|  4.18k|                            visitor.visit_borrowed_bytes(&buf[1..])
  657|       |                        }
  658|       |                    }
  659|      0|                    Cow::Owned(mut buf) => {
  660|      0|                        if buf.len() <= 1 || buf[0] != 0 {
  661|      0|                            Err(DecodeError::Msg("Invalid CID".into()))
  662|       |                        } else {
  663|      0|                            buf.remove(0);
  664|      0|                            visitor.visit_byte_buf(buf)
  665|       |                        }
  666|       |                    }
  667|       |                }
  668|       |            }
  669|      0|            _ => Err(DecodeError::Unsupported { byte }),
  670|       |        }
  671|  4.18k|    }
_RINvXs2_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de9SeqAccess17next_element_seedINtNtCshM4Il2Z0i4R_4core6marker11PhantomDataINtNtCshRBVfIqfJKm_13fvm_ipld_hamt7pointer7PointerNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtB3v_14hash_algorithm6Sha256EEECsitTtQF8ArIt_8fvm_fuzz:
  484|    408|        if let Some(len) = self.len.as_mut() {
  485|    408|            if *len > 0 {
  486|    306|                *len -= 1;
  487|    306|                Ok(Some(seed.deserialize(&mut *self.de)?))
  488|       |            } else {
  489|    102|                Ok(None)
  490|       |            }
  491|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  492|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  493|       |        } else {
  494|      0|            self.de.reader.advance(1);
  495|      0|            Ok(None)
  496|       |        }
  497|    408|    }
_RINvXs0_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de12Deserializer17deserialize_tupleINtNvXs2M_NtB1W_5implsTppENtB1W_11Deserialize11deserialize12TupleVisitorNtNtCshRBVfIqfJKm_13fvm_ipld_hamt8bitfield8BitfieldINtNtCsjYc3JqMxxfa_5alloc3vec3VecINtNtB46_7pointer7PointerNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtB46_14hash_algorithm6Sha256EEEECsitTtQF8ArIt_8fvm_fuzz:
  344|    102|    fn deserialize_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>
  345|    102|    where
  346|    102|        V: Visitor<'de>,
  347|    102|    {
  348|    102|        let mut de = self.try_step()?;
  349|    102|        let seq = Accessor::tuple(&mut de, len)?;
  350|    102|        visitor.visit_seq(seq)
  351|    102|    }
_RINvXs0_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de12Deserializer15deserialize_seqNtNvXNtNtCsalhrieD8kwf_12libipld_core5serde2deNtNtB2Z_4ipld4IpldNtB1W_11Deserialize11deserialize11IpldVisitorECsitTtQF8ArIt_8fvm_fuzz:
  334|    918|    fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  335|    918|    where
  336|    918|        V: Visitor<'de>,
  337|    918|    {
  338|    918|        let mut de = self.try_step()?;
  339|    918|        let seq = Accessor::array(&mut de)?;
  340|    918|        visitor.visit_seq(seq)
  341|    918|    }
_RINvXs2_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de9SeqAccess17next_element_seedINtNtCshM4Il2Z0i4R_4core6marker11PhantomDataINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EEECsitTtQF8ArIt_8fvm_fuzz:
  484|  3.67k|        if let Some(len) = self.len.as_mut() {
  485|  3.67k|            if *len > 0 {
  486|  3.57k|                *len -= 1;
  487|  3.57k|                Ok(Some(seed.deserialize(&mut *self.de)?))
  488|       |            } else {
  489|    102|                Ok(None)
  490|       |            }
  491|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  492|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  493|       |        } else {
  494|      0|            self.de.reader.advance(1);
  495|      0|            Ok(None)
  496|       |        }
  497|  3.67k|    }
_RINvXs2_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de9SeqAccess17next_element_seedINtNtCshM4Il2Z0i4R_4core6marker11PhantomDataNtNtCsalhrieD8kwf_12libipld_core4ipld4IpldEECsitTtQF8ArIt_8fvm_fuzz:
  484|  3.36k|        if let Some(len) = self.len.as_mut() {
  485|  3.36k|            if *len > 0 {
  486|  2.44k|                *len -= 1;
  487|  2.44k|                Ok(Some(seed.deserialize(&mut *self.de)?))
  488|       |            } else {
  489|    918|                Ok(None)
  490|       |            }
  491|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  492|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  493|       |        } else {
  494|      0|            self.de.reader.advance(1);
  495|      0|            Ok(None)
  496|       |        }
  497|  3.36k|    }
_RINvXs3_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de9MapAccess15next_value_seedINtNtCshM4Il2Z0i4R_4core6marker11PhantomDatayEECsitTtQF8ArIt_8fvm_fuzz:
  529|    102|    fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>
  530|    102|    where
  531|    102|        V: de::DeserializeSeed<'de>,
  532|    102|    {
  533|    102|        seed.deserialize(&mut *self.de)
  534|    102|    }
_RINvXs0_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de12Deserializer15deserialize_u64NtNvXsX_NtB1W_5implsyNtB1W_11Deserialize11deserialize16PrimitiveVisitorECsitTtQF8ArIt_8fvm_fuzz:
  142|    204|        fn $name<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  143|    204|        where V: Visitor<'de>
  144|    204|        {
  145|    204|            let value = <$t>::decode(&mut self.reader)?;
  146|    204|            visitor.$visit(value)
  147|    204|        }
_RINvXs2_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de9SeqAccess17next_element_seedINtNtCshM4Il2Z0i4R_4core6marker11PhantomDatamEECsitTtQF8ArIt_8fvm_fuzz:
  484|    204|        if let Some(len) = self.len.as_mut() {
  485|    204|            if *len > 0 {
  486|    204|                *len -= 1;
  487|    204|                Ok(Some(seed.deserialize(&mut *self.de)?))
  488|       |            } else {
  489|      0|                Ok(None)
  490|       |            }
  491|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  492|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  493|       |        } else {
  494|      0|            self.de.reader.advance(1);
  495|      0|            Ok(None)
  496|       |        }
  497|    204|    }
_RINvXs0_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de12Deserializer17deserialize_tupleNtNvXNvNvXs9_NtCs4pVfV2XJudO_10fvm_shared5stateNtB35_9StateRootNtB1W_11Deserialize11deserialize1__NtB2Z_5InnerB3T_11deserialize9___VisitorECsitTtQF8ArIt_8fvm_fuzz:
  344|    102|    fn deserialize_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>
  345|    102|    where
  346|    102|        V: Visitor<'de>,
  347|    102|    {
  348|    102|        let mut de = self.try_step()?;
  349|    102|        let seq = Accessor::tuple(&mut de, len)?;
  350|    102|        visitor.visit_seq(seq)
  351|    102|    }
_RNCNvMs_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deINtB6_12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderE8try_step0CsitTtQF8ArIt_8fvm_fuzz:
  106|  39.4k|            Ok(scopeguard::guard(self, |de| de.reader.step_out()))
_RINvXs0_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de12Deserializer15deserialize_u64NtNvXNtNtCsalhrieD8kwf_12libipld_core5serde2deNtNtB2Z_4ipld4IpldNtB1W_11Deserialize11deserialize11IpldVisitorECsitTtQF8ArIt_8fvm_fuzz:
  142|    306|        fn $name<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  143|    306|        where V: Visitor<'de>
  144|    306|        {
  145|    306|            let value = <$t>::decode(&mut self.reader)?;
  146|    306|            visitor.$visit(value)
  147|    306|        }
_RINvMs_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deINtB5_12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderE15deserialize_cidINtNvXs0_NtCs1slUOa8tBso_3cid5serdeINtNtB2k_3cid3CidKpENtNtCslVZeVZySzLE_5serde2de11Deserialize11deserialize16MainEntryVisitorKj40_EECsitTtQF8ArIt_8fvm_fuzz:
  113|  3.57k|    fn deserialize_cid<V>(&mut self, visitor: V) -> Result<V::Value, DecodeError<R::Error>>
  114|  3.57k|    where
  115|  3.57k|        V: Visitor<'de>,
  116|  3.57k|    {
  117|  3.57k|        let tag = dec::TagStart::decode(&mut self.reader)?;
  118|       |
  119|  3.57k|        match tag.0 {
  120|  3.57k|            CBOR_TAGS_CID => visitor.visit_newtype_struct(&mut CidDeserializer(self)),
  121|      0|            _ => Err(DecodeError::TypeMismatch {
  122|      0|                name: "CBOR tag",
  123|      0|                byte: tag.0 as u8,
  124|      0|            }),
  125|       |        }
  126|  3.57k|    }
_RINvXs2_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de9SeqAccess17next_element_seedINtNtCshM4Il2Z0i4R_4core6marker11PhantomDataNtNtCs4pVfV2XJudO_10fvm_shared5state16StateTreeVersionEECsitTtQF8ArIt_8fvm_fuzz:
  484|    102|        if let Some(len) = self.len.as_mut() {
  485|    102|            if *len > 0 {
  486|    102|                *len -= 1;
  487|    102|                Ok(Some(seed.deserialize(&mut *self.de)?))
  488|       |            } else {
  489|      0|                Ok(None)
  490|       |            }
  491|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  492|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  493|       |        } else {
  494|      0|            self.de.reader.advance(1);
  495|      0|            Ok(None)
  496|       |        }
  497|    102|    }
_RINvXs0_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de12Deserializer26deserialize_newtype_structINtNvXs0_NtCs1slUOa8tBso_3cid5serdeINtNtB3c_3cid3CidKpENtB1W_11Deserialize11deserialize16MainEntryVisitorKj40_EECsitTtQF8ArIt_8fvm_fuzz:
  318|  3.57k|    fn deserialize_newtype_struct<V>(
  319|  3.57k|        self,
  320|  3.57k|        name: &'static str,
  321|  3.57k|        visitor: V,
  322|  3.57k|    ) -> Result<V::Value, Self::Error>
  323|  3.57k|    where
  324|  3.57k|        V: Visitor<'de>,
  325|  3.57k|    {
  326|  3.57k|        if name == CID_SERDE_PRIVATE_IDENTIFIER {
  327|  3.57k|            self.deserialize_cid(visitor)
  328|       |        } else {
  329|      0|            visitor.visit_newtype_struct(self)
  330|       |        }
  331|  3.57k|    }
_RINvXs0_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de12Deserializer18deserialize_stringNtNtB1W_5impls13StringVisitorECsitTtQF8ArIt_8fvm_fuzz:
  270|  3.06k|    fn deserialize_string<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  271|  3.06k|    where
  272|  3.06k|        V: Visitor<'de>,
  273|  3.06k|    {
  274|  3.06k|        self.deserialize_str(visitor)
  275|  3.06k|    }
_RINvXs0_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de12Deserializer18deserialize_structNtNvXNvCsFqKNUWW8VZ_12fvm_ipld_cars_1__NtB30_9CarHeaderNtB1W_11Deserialize11deserialize9___VisitorECsitTtQF8ArIt_8fvm_fuzz:
  377|    102|    fn deserialize_struct<V>(
  378|    102|        self,
  379|    102|        _name: &'static str,
  380|    102|        _fields: &'static [&'static str],
  381|    102|        visitor: V,
  382|    102|    ) -> Result<V::Value, Self::Error>
  383|    102|    where
  384|    102|        V: Visitor<'de>,
  385|    102|    {
  386|    102|        self.deserialize_map(visitor)
  387|    102|    }
_RINvNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de10from_sliceINtNtCsjYc3JqMxxfa_5alloc3vec3VecTNtNtBW_6string6StringINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EEEECsitTtQF8ArIt_8fvm_fuzz:
   40|    204|pub fn from_slice<'a, T>(buf: &'a [u8]) -> Result<T, DecodeError<Infallible>>
   41|    204|where
   42|    204|    T: de::Deserialize<'a>,
   43|    204|{
   44|    204|    let reader = SliceReader::new(buf);
   45|    204|    let mut deserializer = Deserializer::from_reader(reader);
   46|    204|    let value = serde::Deserialize::deserialize(&mut deserializer)?;
   47|    204|    deserializer.end()?;
   48|    204|    Ok(value)
   49|    204|}
_RINvXs0_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de12Deserializer22deserialize_identifierNtNvXNvCsFqKNUWW8VZ_12fvm_ipld_cars_1__NtB34_9CarHeaderNtB1W_11Deserialize11deserialize14___FieldVisitorECsitTtQF8ArIt_8fvm_fuzz:
  405|    204|    fn deserialize_identifier<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  406|    204|    where
  407|    204|        V: Visitor<'de>,
  408|    204|    {
  409|    204|        self.deserialize_str(visitor)
  410|    204|    }
_RINvXs0_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de12Deserializer15deserialize_anyNtNvXNtNtCsalhrieD8kwf_12libipld_core5serde2deNtNtB2Z_4ipld4IpldNtB1W_11Deserialize11deserialize11IpldVisitorECsitTtQF8ArIt_8fvm_fuzz:
  159|  2.75k|    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  160|  2.75k|    where
  161|  2.75k|        V: Visitor<'de>,
  162|  2.75k|    {
  163|  2.75k|        let mut de = self.try_step()?;
  164|  2.75k|        let de = &mut *de;
  165|       |
  166|  2.75k|        let byte = peek_one(&mut de.reader)?;
  167|  2.75k|        match dec::if_major(byte) {
  168|    306|            major::UNSIGNED => de.deserialize_u64(visitor),
  169|      0|            major::NEGATIVE => de.deserialize_i64(visitor),
  170|    612|            major::BYTES => de.deserialize_byte_buf(visitor),
  171|      0|            major::STRING => de.deserialize_string(visitor),
  172|    918|            major::ARRAY => de.deserialize_seq(visitor),
  173|      0|            major::MAP => de.deserialize_map(visitor),
  174|       |            // The only supported tag is tag 42 (CID).
  175|    612|            major::TAG => de.deserialize_cid(visitor),
  176|    306|            major::SIMPLE => match byte {
  177|       |                marker::FALSE => {
  178|      0|                    de.reader.advance(1);
  179|      0|                    visitor.visit_bool(false)
  180|       |                }
  181|       |                marker::TRUE => {
  182|      0|                    de.reader.advance(1);
  183|      0|                    visitor.visit_bool(true)
  184|       |                }
  185|       |                marker::NULL | marker::UNDEFINED => {
  186|    306|                    de.reader.advance(1);
  187|    306|                    visitor.visit_none()
  188|       |                }
  189|      0|                marker::F32 => de.deserialize_f32(visitor),
  190|      0|                marker::F64 => de.deserialize_f64(visitor),
  191|      0|                _ => Err(DecodeError::Unsupported { byte }),
  192|       |            },
  193|      0|            _ => Err(DecodeError::Unsupported { byte }),
  194|       |        }
  195|  2.75k|    }
_RINvXs0_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de12Deserializer15deserialize_strNtNtB1W_5impls13StringVisitorECsitTtQF8ArIt_8fvm_fuzz:
  252|  3.06k|        match <Cow<str>>::decode(&mut self.reader)? {
  253|  3.06k|            Cow::Borrowed(buf) => visitor.visit_borrowed_str(buf),
  254|      0|            Cow::Owned(buf) => visitor.visit_string(buf),
  255|       |        }
  256|       |
  257|       |        // Don't use this. This can lead to random panics and invalid CBOR.
  258|       |        #[cfg(feature = "_do_not_use_its_unsafe_and_invalid_cbor")]
  259|       |        match types::BadStr::<Cow<[u8]>>::decode(&mut self.reader)? {
  260|       |            types::BadStr(Cow::Borrowed(buf)) => {
  261|       |                visitor.visit_borrowed_str(unsafe { std::str::from_utf8_unchecked(buf) })
  262|       |            }
  263|       |            types::BadStr(Cow::Owned(buf)) => {
  264|       |                visitor.visit_string(unsafe { String::from_utf8_unchecked(buf) })
  265|       |            }
  266|       |        }
  267|  3.06k|    }
_RINvXs0_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de12Deserializer17deserialize_bytesNtNvXNtNtCsalhrieD8kwf_12libipld_core5serde2deNtNtB31_4ipld4IpldNtB1W_11Deserialize11deserialize11IpldVisitorECsitTtQF8ArIt_8fvm_fuzz:
  228|    612|    fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  229|    612|    where
  230|    612|        V: Visitor<'de>,
  231|    612|    {
  232|    612|        match <types::Bytes<Cow<[u8]>>>::decode(&mut self.reader)?.0 {
  233|    612|            Cow::Borrowed(buf) => visitor.visit_borrowed_bytes(buf),
  234|      0|            Cow::Owned(buf) => visitor.visit_byte_buf(buf),
  235|       |        }
  236|    612|    }
_RNvMs1_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deINtB5_8AccessorNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderE5tupleCsitTtQF8ArIt_8fvm_fuzz:
  443|  3.46k|    pub fn tuple(
  444|  3.46k|        de: &'a mut Deserializer<R>,
  445|  3.46k|        len: usize,
  446|  3.46k|    ) -> Result<Accessor<'a, R>, DecodeError<R::Error>> {
  447|  3.46k|        let array_start = dec::ArrayStart::decode(&mut de.reader)?;
  448|       |
  449|  3.46k|        if array_start.0 == Some(len) {
  450|  3.46k|            Ok(Accessor {
  451|  3.46k|                de,
  452|  3.46k|                len: array_start.0,
  453|  3.46k|            })
  454|       |        } else {
  455|      0|            Err(DecodeError::RequireLength {
  456|      0|                name: "tuple",
  457|      0|                expect: len,
  458|      0|                value: array_start.0.unwrap_or(0),
  459|      0|            })
  460|       |        }
  461|  3.46k|    }
_RNvMNtCs8loA9e5gPGU_18serde_ipld_dagcbor2deINtB2_12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderE11from_readerCsitTtQF8ArIt_8fvm_fuzz:
   93|  32.4k|    pub fn from_reader(reader: R) -> Deserializer<R> {
   94|  32.4k|        Deserializer { reader }
   95|  32.4k|    }
_RINvXs2_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de9SeqAccess17next_element_seedINtNtCshM4Il2Z0i4R_4core6marker11PhantomDataNtNtCsjYc3JqMxxfa_5alloc6string6StringEECsitTtQF8ArIt_8fvm_fuzz:
  484|  3.06k|        if let Some(len) = self.len.as_mut() {
  485|  3.06k|            if *len > 0 {
  486|  3.06k|                *len -= 1;
  487|  3.06k|                Ok(Some(seed.deserialize(&mut *self.de)?))
  488|       |            } else {
  489|      0|                Ok(None)
  490|       |            }
  491|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  492|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  493|       |        } else {
  494|      0|            self.de.reader.advance(1);
  495|      0|            Ok(None)
  496|       |        }
  497|  3.06k|    }
_RINvXs0_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de12Deserializer15deserialize_seqINtNvXsh_NtB1W_5implsINtNtCsjYc3JqMxxfa_5alloc3vec3VecpENtB1W_11Deserialize11deserialize10VecVisitorINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EEECsitTtQF8ArIt_8fvm_fuzz:
  334|    102|    fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  335|    102|    where
  336|    102|        V: Visitor<'de>,
  337|    102|    {
  338|    102|        let mut de = self.try_step()?;
  339|    102|        let seq = Accessor::array(&mut de)?;
  340|    102|        visitor.visit_seq(seq)
  341|    102|    }
_RINvXs2_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de9SeqAccess17next_element_seedINtNtCshM4Il2Z0i4R_4core6marker11PhantomDataTNtNtCsjYc3JqMxxfa_5alloc6string6StringINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EEEECsitTtQF8ArIt_8fvm_fuzz:
  484|  3.26k|        if let Some(len) = self.len.as_mut() {
  485|  3.26k|            if *len > 0 {
  486|  3.06k|                *len -= 1;
  487|  3.06k|                Ok(Some(seed.deserialize(&mut *self.de)?))
  488|       |            } else {
  489|    204|                Ok(None)
  490|       |            }
  491|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  492|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  493|       |        } else {
  494|      0|            self.de.reader.advance(1);
  495|      0|            Ok(None)
  496|       |        }
  497|  3.26k|    }
_RINvMs_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deINtB5_12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderE15deserialize_cidNtNvXNtNtCsalhrieD8kwf_12libipld_core5serde2deNtNtB2i_4ipld4IpldNtNtCslVZeVZySzLE_5serde2de11Deserialize11deserialize11IpldVisitorECsitTtQF8ArIt_8fvm_fuzz:
  113|    612|    fn deserialize_cid<V>(&mut self, visitor: V) -> Result<V::Value, DecodeError<R::Error>>
  114|    612|    where
  115|    612|        V: Visitor<'de>,
  116|    612|    {
  117|    612|        let tag = dec::TagStart::decode(&mut self.reader)?;
  118|       |
  119|    612|        match tag.0 {
  120|    612|            CBOR_TAGS_CID => visitor.visit_newtype_struct(&mut CidDeserializer(self)),
  121|      0|            _ => Err(DecodeError::TypeMismatch {
  122|      0|                name: "CBOR tag",
  123|      0|                byte: tag.0 as u8,
  124|      0|            }),
  125|       |        }
  126|    612|    }
_RINvXs0_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de12Deserializer15deserialize_mapNtNvXNvCsFqKNUWW8VZ_12fvm_ipld_cars_1__NtB2X_9CarHeaderNtB1W_11Deserialize11deserialize9___VisitorECsitTtQF8ArIt_8fvm_fuzz:
  367|    102|    fn deserialize_map<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  368|    102|    where
  369|    102|        V: Visitor<'de>,
  370|    102|    {
  371|    102|        let mut de = self.try_step()?;
  372|    102|        let map = Accessor::map(&mut de)?;
  373|    102|        visitor.visit_map(map)
  374|    102|    }
_RINvXs2_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de9SeqAccess17next_element_seedINtNtCshM4Il2Z0i4R_4core6marker11PhantomDataNtNtCshRBVfIqfJKm_13fvm_ipld_hamt8bitfield8BitfieldEECsitTtQF8ArIt_8fvm_fuzz:
  484|    102|        if let Some(len) = self.len.as_mut() {
  485|    102|            if *len > 0 {
  486|    102|                *len -= 1;
  487|    102|                Ok(Some(seed.deserialize(&mut *self.de)?))
  488|       |            } else {
  489|      0|                Ok(None)
  490|       |            }
  491|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  492|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  493|       |        } else {
  494|      0|            self.de.reader.advance(1);
  495|      0|            Ok(None)
  496|       |        }
  497|    102|    }
_RINvNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de10from_sliceINtNtCsjYc3JqMxxfa_5alloc3vec3VecNtNtCs4pVfV2XJudO_10fvm_shared5piece9PieceInfoEECsitTtQF8ArIt_8fvm_fuzz:
   40|  31.7k|pub fn from_slice<'a, T>(buf: &'a [u8]) -> Result<T, DecodeError<Infallible>>
   41|  31.7k|where
   42|  31.7k|    T: de::Deserialize<'a>,
   43|  31.7k|{
   44|  31.7k|    let reader = SliceReader::new(buf);
   45|  31.7k|    let mut deserializer = Deserializer::from_reader(reader);
   46|  31.7k|    let value = serde::Deserialize::deserialize(&mut deserializer)?;
   47|      0|    deserializer.end()?;
   48|      0|    Ok(value)
   49|  31.7k|}
_RNvXs2_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deINtB5_8AccessorNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de9SeqAccess9size_hintCsitTtQF8ArIt_8fvm_fuzz:
  500|  1.32k|    fn size_hint(&self) -> Option<usize> {
  501|  1.32k|        self.len
  502|  1.32k|    }
_RINvXs0_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de12Deserializer17deserialize_tupleINtNvXs2M_NtB1W_5implsTppENtB1W_11Deserialize11deserialize12TupleVisitormINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EEECsitTtQF8ArIt_8fvm_fuzz:
  344|    204|    fn deserialize_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>
  345|    204|    where
  346|    204|        V: Visitor<'de>,
  347|    204|    {
  348|    204|        let mut de = self.try_step()?;
  349|    204|        let seq = Accessor::tuple(&mut de, len)?;
  350|    204|        visitor.visit_seq(seq)
  351|    204|    }
_RINvXs0_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de12Deserializer17deserialize_tupleINtNvXs2M_NtB1W_5implsTppENtB1W_11Deserialize11deserialize12TupleVisitorNtNtCsjYc3JqMxxfa_5alloc6string6StringINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EEECsitTtQF8ArIt_8fvm_fuzz:
  344|  3.06k|    fn deserialize_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>
  345|  3.06k|    where
  346|  3.06k|        V: Visitor<'de>,
  347|  3.06k|    {
  348|  3.06k|        let mut de = self.try_step()?;
  349|  3.06k|        let seq = Accessor::tuple(&mut de, len)?;
  350|  3.06k|        visitor.visit_seq(seq)
  351|  3.06k|    }
_RINvNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de10from_sliceNtNtCs4pVfV2XJudO_10fvm_shared5state9StateRootECsitTtQF8ArIt_8fvm_fuzz:
   40|    102|pub fn from_slice<'a, T>(buf: &'a [u8]) -> Result<T, DecodeError<Infallible>>
   41|    102|where
   42|    102|    T: de::Deserialize<'a>,
   43|    102|{
   44|    102|    let reader = SliceReader::new(buf);
   45|    102|    let mut deserializer = Deserializer::from_reader(reader);
   46|    102|    let value = serde::Deserialize::deserialize(&mut deserializer)?;
   47|    102|    deserializer.end()?;
   48|    102|    Ok(value)
   49|    102|}
_RINvXs0_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de12Deserializer15deserialize_seqINtNvXsh_NtB1W_5implsINtNtCsjYc3JqMxxfa_5alloc3vec3VecpENtB1W_11Deserialize11deserialize10VecVisitorINtNtCshRBVfIqfJKm_13fvm_ipld_hamt7pointer7PointerNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtB4x_14hash_algorithm6Sha256EEECsitTtQF8ArIt_8fvm_fuzz:
  334|    102|    fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  335|    102|    where
  336|    102|        V: Visitor<'de>,
  337|    102|    {
  338|    102|        let mut de = self.try_step()?;
  339|    102|        let seq = Accessor::array(&mut de)?;
  340|    102|        visitor.visit_seq(seq)
  341|    102|    }
_RINvXs0_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de12Deserializer15deserialize_strNtNvXNvCsFqKNUWW8VZ_12fvm_ipld_cars_1__NtB2X_9CarHeaderNtB1W_11Deserialize11deserialize14___FieldVisitorECsitTtQF8ArIt_8fvm_fuzz:
  252|    204|        match <Cow<str>>::decode(&mut self.reader)? {
  253|    204|            Cow::Borrowed(buf) => visitor.visit_borrowed_str(buf),
  254|      0|            Cow::Owned(buf) => visitor.visit_string(buf),
  255|       |        }
  256|       |
  257|       |        // Don't use this. This can lead to random panics and invalid CBOR.
  258|       |        #[cfg(feature = "_do_not_use_its_unsafe_and_invalid_cbor")]
  259|       |        match types::BadStr::<Cow<[u8]>>::decode(&mut self.reader)? {
  260|       |            types::BadStr(Cow::Borrowed(buf)) => {
  261|       |                visitor.visit_borrowed_str(unsafe { std::str::from_utf8_unchecked(buf) })
  262|       |            }
  263|       |            types::BadStr(Cow::Owned(buf)) => {
  264|       |                visitor.visit_string(unsafe { String::from_utf8_unchecked(buf) })
  265|       |            }
  266|       |        }
  267|    204|    }
_RINvXs0_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de12Deserializer20deserialize_byte_bufNtNvXs_NtNtCsbsA1N0ivJJv_17fvm_ipld_encoding5bytes12strict_bytesINtNtCsjYc3JqMxxfa_5alloc3vec3VechENtB32_11Deserialize11deserialize10VecVisitorECsitTtQF8ArIt_8fvm_fuzz:
  239|    102|    fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  240|    102|    where
  241|    102|        V: Visitor<'de>,
  242|    102|    {
  243|    102|        self.deserialize_bytes(visitor)
  244|    102|    }
_RINvXs0_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de12Deserializer15deserialize_seqINtNvXsh_NtB1W_5implsINtNtCsjYc3JqMxxfa_5alloc3vec3VecpENtB1W_11Deserialize11deserialize10VecVisitorTNtNtB3g_6string6StringINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EEEECsitTtQF8ArIt_8fvm_fuzz:
  334|    204|    fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  335|    204|    where
  336|    204|        V: Visitor<'de>,
  337|    204|    {
  338|    204|        let mut de = self.try_step()?;
  339|    204|        let seq = Accessor::array(&mut de)?;
  340|    204|        visitor.visit_seq(seq)
  341|    204|    }
_RINvXs0_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de12Deserializer15deserialize_u32NtNvXsV_NtB1W_5implsmNtB1W_11Deserialize11deserialize16PrimitiveVisitorECsitTtQF8ArIt_8fvm_fuzz:
  142|    204|        fn $name<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  143|    204|        where V: Visitor<'de>
  144|    204|        {
  145|    204|            let value = <$t>::decode(&mut self.reader)?;
  146|    204|            visitor.$visit(value)
  147|    204|        }
_RNvMs_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deINtB4_12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderE8try_stepCsitTtQF8ArIt_8fvm_fuzz:
  101|  39.4k|    fn try_step<'a>(
  102|  39.4k|        &'a mut self,
  103|  39.4k|    ) -> Result<scopeguard::ScopeGuard<&'a mut Self, fn(&'a mut Self) -> ()>, DecodeError<R::Error>>
  104|  39.4k|    {
  105|  39.4k|        if self.reader.step_in() {
  106|  39.4k|            Ok(scopeguard::guard(self, |de| de.reader.step_out()))
  107|       |        } else {
  108|      0|            Err(DecodeError::DepthLimit)
  109|       |        }
  110|  39.4k|    }
_RINvXs2_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de9SeqAccess17next_element_seedINtNtCshM4Il2Z0i4R_4core6marker11PhantomDataINtNtCsjYc3JqMxxfa_5alloc3vec3VecINtNtCshRBVfIqfJKm_13fvm_ipld_hamt7pointer7PointerNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtB42_14hash_algorithm6Sha256EEEECsitTtQF8ArIt_8fvm_fuzz:
  484|    102|        if let Some(len) = self.len.as_mut() {
  485|    102|            if *len > 0 {
  486|    102|                *len -= 1;
  487|    102|                Ok(Some(seed.deserialize(&mut *self.de)?))
  488|       |            } else {
  489|      0|                Ok(None)
  490|       |            }
  491|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  492|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  493|       |        } else {
  494|      0|            self.de.reader.advance(1);
  495|      0|            Ok(None)
  496|       |        }
  497|    102|    }
_RINvNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de10from_sliceNtCsFqKNUWW8VZ_12fvm_ipld_car9CarHeaderECsitTtQF8ArIt_8fvm_fuzz:
   40|    102|pub fn from_slice<'a, T>(buf: &'a [u8]) -> Result<T, DecodeError<Infallible>>
   41|    102|where
   42|    102|    T: de::Deserialize<'a>,
   43|    102|{
   44|    102|    let reader = SliceReader::new(buf);
   45|    102|    let mut deserializer = Deserializer::from_reader(reader);
   46|    102|    let value = serde::Deserialize::deserialize(&mut deserializer)?;
   47|    102|    deserializer.end()?;
   48|    102|    Ok(value)
   49|    102|}
_RINvXs0_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de12Deserializer20deserialize_byte_bufNtNvXNtNtCsalhrieD8kwf_12libipld_core5serde2deNtNtB34_4ipld4IpldNtB1W_11Deserialize11deserialize11IpldVisitorECsitTtQF8ArIt_8fvm_fuzz:
  239|    612|    fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  240|    612|    where
  241|    612|        V: Visitor<'de>,
  242|    612|    {
  243|    612|        self.deserialize_bytes(visitor)
  244|    612|    }
_RINvXs3_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de9MapAccess15next_value_seedINtNtCshM4Il2Z0i4R_4core6marker11PhantomDataINtNtCsjYc3JqMxxfa_5alloc3vec3VecINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EEEECsitTtQF8ArIt_8fvm_fuzz:
  529|    102|    fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>
  530|    102|    where
  531|    102|        V: de::DeserializeSeed<'de>,
  532|    102|    {
  533|    102|        seed.deserialize(&mut *self.de)
  534|    102|    }
_RINvNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de10from_sliceINtNtCshRBVfIqfJKm_13fvm_ipld_hamt4node4NodeNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtBW_14hash_algorithm6Sha256EECsitTtQF8ArIt_8fvm_fuzz:
   40|    102|pub fn from_slice<'a, T>(buf: &'a [u8]) -> Result<T, DecodeError<Infallible>>
   41|    102|where
   42|    102|    T: de::Deserialize<'a>,
   43|    102|{
   44|    102|    let reader = SliceReader::new(buf);
   45|    102|    let mut deserializer = Deserializer::from_reader(reader);
   46|    102|    let value = serde::Deserialize::deserialize(&mut deserializer)?;
   47|    102|    deserializer.end()?;
   48|    102|    Ok(value)
   49|    102|}
_RNvMs1_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deINtB5_8AccessorNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderE3mapCsitTtQF8ArIt_8fvm_fuzz:
  464|    102|    pub fn map(de: &'a mut Deserializer<R>) -> Result<Accessor<'a, R>, DecodeError<R::Error>> {
  465|    102|        let map_start = dec::MapStart::decode(&mut de.reader)?;
  466|    102|        Ok(Accessor {
  467|    102|            de,
  468|    102|            len: map_start.0,
  469|    102|        })
  470|    102|    }
_RINvXs0_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de12Deserializer15deserialize_seqINtNvXsh_NtB1W_5implsINtNtCsjYc3JqMxxfa_5alloc3vec3VecpENtB1W_11Deserialize11deserialize10VecVisitorNtNtCs4pVfV2XJudO_10fvm_shared5piece9PieceInfoEECsitTtQF8ArIt_8fvm_fuzz:
  334|  31.7k|    fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  335|  31.7k|    where
  336|  31.7k|        V: Visitor<'de>,
  337|  31.7k|    {
  338|  31.7k|        let mut de = self.try_step()?;
  339|  31.7k|        let seq = Accessor::array(&mut de)?;
  340|      0|        visitor.visit_seq(seq)
  341|  31.7k|    }
_RINvXs0_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de12Deserializer24deserialize_tuple_structNtNvXNvNvXs9_NtCs4pVfV2XJudO_10fvm_shared5stateNtB3c_9StateRootNtB1W_11Deserialize11deserialize1__NtB36_5InnerB40_11deserialize9___VisitorECsitTtQF8ArIt_8fvm_fuzz:
  354|    102|    fn deserialize_tuple_struct<V>(
  355|    102|        self,
  356|    102|        _name: &'static str,
  357|    102|        len: usize,
  358|    102|        visitor: V,
  359|    102|    ) -> Result<V::Value, Self::Error>
  360|    102|    where
  361|    102|        V: Visitor<'de>,
  362|    102|    {
  363|    102|        self.deserialize_tuple(len, visitor)
  364|    102|    }
_RINvXs3_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de9MapAccess13next_key_seedINtNtCshM4Il2Z0i4R_4core6marker11PhantomDataNtNvXNvCsFqKNUWW8VZ_12fvm_ipld_cars_1__NtB3t_9CarHeaderNtB1Q_11Deserialize11deserialize7___FieldEECsitTtQF8ArIt_8fvm_fuzz:
  513|    306|        if let Some(len) = self.len.as_mut() {
  514|    306|            if *len > 0 {
  515|    204|                *len -= 1;
  516|    204|                Ok(Some(seed.deserialize(&mut *self.de)?))
  517|       |            } else {
  518|    102|                Ok(None)
  519|       |            }
  520|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  521|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  522|       |        } else {
  523|      0|            self.de.reader.advance(1);
  524|      0|            Ok(None)
  525|       |        }
  526|    306|    }
_RNvMs_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deINtB4_12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderE3endCsitTtQF8ArIt_8fvm_fuzz:
  131|    714|        match peek_one(&mut self.reader) {
  132|      0|            Ok(_) => Err(DecodeError::TrailingData),
  133|    714|            Err(DecodeError::Eof) => Ok(()),
  134|      0|            Err(error) => Err(error),
  135|       |        }
  136|    714|    }
_RINvXs0_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderENtNtCslVZeVZySzLE_5serde2de12Deserializer17deserialize_bytesNtNvXs_NtNtCsbsA1N0ivJJv_17fvm_ipld_encoding5bytes12strict_bytesINtNtCsjYc3JqMxxfa_5alloc3vec3VechENtB2Z_11Deserialize11deserialize10VecVisitorECsitTtQF8ArIt_8fvm_fuzz:
  228|    102|    fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  229|    102|    where
  230|    102|        V: Visitor<'de>,
  231|    102|    {
  232|    102|        match <types::Bytes<Cow<[u8]>>>::decode(&mut self.reader)?.0 {
  233|    102|            Cow::Borrowed(buf) => visitor.visit_borrowed_bytes(buf),
  234|      0|            Cow::Owned(buf) => visitor.visit_byte_buf(buf),
  235|       |        }
  236|    102|    }
_RNvMs1_NtCs8loA9e5gPGU_18serde_ipld_dagcbor2deINtB5_8AccessorNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderE5arrayCsitTtQF8ArIt_8fvm_fuzz:
  434|  33.0k|    pub fn array(de: &'a mut Deserializer<R>) -> Result<Accessor<'a, R>, DecodeError<R::Error>> {
  435|  33.0k|        let array_start = dec::ArrayStart::decode(&mut de.reader)?;
  436|  1.32k|        Ok(Accessor {
  437|  1.32k|            de,
  438|  1.32k|            len: array_start.0,
  439|  1.32k|        })
  440|  33.0k|    }
_RINvNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de10from_sliceTmINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EEECsitTtQF8ArIt_8fvm_fuzz:
   40|    204|pub fn from_slice<'a, T>(buf: &'a [u8]) -> Result<T, DecodeError<Infallible>>
   41|    204|where
   42|    204|    T: de::Deserialize<'a>,
   43|    204|{
   44|    204|    let reader = SliceReader::new(buf);
   45|    204|    let mut deserializer = Deserializer::from_reader(reader);
   46|    204|    let value = serde::Deserialize::deserialize(&mut deserializer)?;
   47|    204|    deserializer.end()?;
   48|    204|    Ok(value)
   49|    204|}

_RNvXs6_NtCs8loA9e5gPGU_18serde_ipld_dagcbor5errorINtB5_11DecodeErrorNtNtCshM4Il2Z0i4R_4core7convert10InfallibleENtNtB18_3fmt7Display3fmtCsitTtQF8ArIt_8fvm_fuzz:
  161|  31.7k|    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
  162|  31.7k|        fmt::Debug::fmt(self, f)
  163|  31.7k|    }
_RNvXs7_NtCs8loA9e5gPGU_18serde_ipld_dagcbor5errorINtB5_11DecodeErrorNtNtCshM4Il2Z0i4R_4core7convert10InfallibleEINtB16_4FromINtNtCsda7B5SchGu_7cbor4ii5error11DecodeErrorB14_EE4fromCsitTtQF8ArIt_8fvm_fuzz:
  167|  31.7k|    fn from(err: cbor4ii::DecodeError<E>) -> DecodeError<E> {
  168|  31.7k|        match err {
  169|      0|            cbor4ii::DecodeError::Read(read) => DecodeError::Read(read),
  170|  31.7k|            cbor4ii::DecodeError::Eof => DecodeError::Eof,
  171|      0|            cbor4ii::DecodeError::Mismatch { expect_major, byte } => {
  172|      0|                DecodeError::Mismatch { expect_major, byte }
  173|       |            }
  174|      0|            cbor4ii::DecodeError::TypeMismatch { name, byte } => {
  175|      0|                DecodeError::TypeMismatch { name, byte }
  176|       |            }
  177|      0|            cbor4ii::DecodeError::CastOverflow(overflow) => DecodeError::CastOverflow(overflow),
  178|      0|            cbor4ii::DecodeError::Overflow { name } => DecodeError::Overflow { name },
  179|      0|            cbor4ii::DecodeError::RequireBorrowed { name } => DecodeError::RequireBorrowed { name },
  180|       |            cbor4ii::DecodeError::RequireLength {
  181|      0|                name,
  182|      0|                expect,
  183|      0|                value,
  184|      0|            } => DecodeError::RequireLength {
  185|      0|                name,
  186|      0|                expect,
  187|      0|                value,
  188|      0|            },
  189|      0|            cbor4ii::DecodeError::InvalidUtf8(invalid) => DecodeError::InvalidUtf8(invalid),
  190|      0|            cbor4ii::DecodeError::Unsupported { byte } => DecodeError::Unsupported { byte },
  191|      0|            cbor4ii::DecodeError::DepthLimit => DecodeError::DepthLimit,
  192|       |            // Needed as `cbor4ii::EncodeError` is markes as non_exhaustive
  193|      0|            _ => DecodeError::Msg(err.to_string()),
  194|       |        }
  195|  31.7k|    }
_RNvXs9_NtCs8loA9e5gPGU_18serde_ipld_dagcbor5errorINtB5_11DecodeErrorNtNtCshM4Il2Z0i4R_4core7convert10InfallibleENtNtB18_3fmt5Debug3fmtCsitTtQF8ArIt_8fvm_fuzz:
   70|  31.7k|#[derive(Debug)]

_RINvXs2_NtCs8loA9e5gPGU_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterENtNtCslVZeVZySzLE_5serde3ser20SerializeTupleStruct15serialize_fieldNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyECsitTtQF8ArIt_8fvm_fuzz:
  403|    306|    fn serialize_field<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  404|    306|        value.serialize(&mut *self.ser)
  405|    306|    }
_RINvXs2_NtCs8loA9e5gPGU_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterENtNtCslVZeVZySzLE_5serde3ser20SerializeTupleStruct15serialize_fieldRNtNtCsjYc3JqMxxfa_5alloc6string6StringECsitTtQF8ArIt_8fvm_fuzz:
  403|    102|    fn serialize_field<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  404|    102|        value.serialize(&mut *self.ser)
  405|    102|    }
_RINvXs2_NtCs8loA9e5gPGU_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterENtNtCslVZeVZySzLE_5serde3ser20SerializeTupleStruct15serialize_fieldRINtNtCshM4Il2Z0i4R_4core6option6OptionNtNtCs4pVfV2XJudO_10fvm_shared7address7AddressEECsitTtQF8ArIt_8fvm_fuzz:
  403|    306|    fn serialize_field<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  404|    306|        value.serialize(&mut *self.ser)
  405|    306|    }
_RNvXs_NtCs8loA9e5gPGU_18serde_ipld_dagcbor3serQINtB4_10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterENtNtCslVZeVZySzLE_5serde3ser10Serializer13serialize_u64CsitTtQF8ArIt_8fvm_fuzz:
  123|    510|        v.encode(&mut self.writer)?;
  124|    510|        Ok(())
  125|    510|    }
_RNvXs0_NtCs8loA9e5gPGU_18serde_ipld_dagcbor3serINtB5_7CollectNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterENtNtCslVZeVZySzLE_5serde3ser12SerializeSeq3endCsitTtQF8ArIt_8fvm_fuzz:
  374|    510|    fn end(self) -> Result<Self::Ok, Self::Error> {
  375|    510|        if !self.bounded {
  376|      0|            enc::End.encode(&mut self.ser.writer)?;
  377|    510|        }
  378|       |
  379|    510|        Ok(())
  380|    510|    }
_RNvXs_NtCs8loA9e5gPGU_18serde_ipld_dagcbor3serQINtB4_10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterENtNtCslVZeVZySzLE_5serde3ser10Serializer14serialize_noneCsitTtQF8ArIt_8fvm_fuzz:
  166|    306|        types::Null.encode(&mut self.writer)?;
  167|    306|        Ok(())
  168|    306|    }
_RINvNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser6to_vecNtNtCs4pVfV2XJudO_10fvm_shared5state10StateInfo0ECsitTtQF8ArIt_8fvm_fuzz:
   23|    102|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, EncodeError<TryReserveError>>
   24|    102|where
   25|    102|    T: Serialize + ?Sized,
   26|    102|{
   27|    102|    let writer = BufWriter::new(Vec::new());
   28|    102|    let mut serializer = Serializer::new(writer);
   29|    102|    value.serialize(&mut serializer)?;
   30|    102|    Ok(serializer.into_inner().into_inner())
   31|    102|}
_RINvNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser6to_vecNtNtCs7Ei498kZF3p_3fvm10init_actor5StateECsitTtQF8ArIt_8fvm_fuzz:
   23|    102|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, EncodeError<TryReserveError>>
   24|    102|where
   25|    102|    T: Serialize + ?Sized,
   26|    102|{
   27|    102|    let writer = BufWriter::new(Vec::new());
   28|    102|    let mut serializer = Serializer::new(writer);
   29|    102|    value.serialize(&mut serializer)?;
   30|    102|    Ok(serializer.into_inner().into_inner())
   31|    102|}
_RINvXs1_NtCs8loA9e5gPGU_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterENtNtCslVZeVZySzLE_5serde3ser14SerializeTuple17serialize_elementRINtNtCsjYc3JqMxxfa_5alloc3vec3VecINtNtCshRBVfIqfJKm_13fvm_ipld_hamt7pointer7PointerNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtB3x_14hash_algorithm6Sha256EEECsitTtQF8ArIt_8fvm_fuzz:
  388|    102|    fn serialize_element<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  389|    102|        value.serialize(&mut *self.ser)
  390|    102|    }
_RINvXs2_NtCs8loA9e5gPGU_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterENtNtCslVZeVZySzLE_5serde3ser20SerializeTupleStruct15serialize_fieldRNtNtCs4pVfV2XJudO_10fvm_shared4econ11TokenAmountECsitTtQF8ArIt_8fvm_fuzz:
  403|    306|    fn serialize_field<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  404|    306|        value.serialize(&mut *self.ser)
  405|    306|    }
_RNvXs2_NtCs8loA9e5gPGU_18serde_ipld_dagcbor3serINtB5_14BoundedCollectNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterENtNtCslVZeVZySzLE_5serde3ser20SerializeTupleStruct3endCsitTtQF8ArIt_8fvm_fuzz:
  408|    918|    fn end(self) -> Result<Self::Ok, Self::Error> {
  409|    918|        Ok(())
  410|    918|    }
_RINvXs_NtCs8loA9e5gPGU_18serde_ipld_dagcbor3serQINtB5_10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterENtNtCslVZeVZySzLE_5serde3ser10Serializer24serialize_newtype_structNtNtCskRLky7pABTx_11serde_bytes7bytebuf7ByteBufECsitTtQF8ArIt_8fvm_fuzz:
  199|  1.02k|    fn serialize_newtype_struct<T: Serialize + ?Sized>(
  200|  1.02k|        self,
  201|  1.02k|        name: &'static str,
  202|  1.02k|        value: &T,
  203|  1.02k|    ) -> Result<Self::Ok, Self::Error> {
  204|  1.02k|        if name == CID_SERDE_PRIVATE_IDENTIFIER {
  205|  1.02k|            value.serialize(&mut CidSerializer(self))
  206|       |        } else {
  207|      0|            value.serialize(self)
  208|       |        }
  209|  1.02k|    }
_RNvXs_NtCs8loA9e5gPGU_18serde_ipld_dagcbor3serQINtB4_10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterENtNtCslVZeVZySzLE_5serde3ser10Serializer13serialize_seqCsitTtQF8ArIt_8fvm_fuzz:
  226|    510|        if let Some(len) = len {
  227|    510|            enc::ArrayStartBounded(len).encode(&mut self.writer)?;
  228|       |        } else {
  229|      0|            enc::ArrayStartUnbounded.encode(&mut self.writer)?;
  230|       |        }
  231|    510|        Ok(Collect {
  232|    510|            bounded: len.is_some(),
  233|    510|            ser: self,
  234|    510|        })
  235|    510|    }
_RNvXs_NtCs8loA9e5gPGU_18serde_ipld_dagcbor3serQINtB4_10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterENtNtCslVZeVZySzLE_5serde3ser10Serializer13serialize_strCsitTtQF8ArIt_8fvm_fuzz:
  154|    102|        v.encode(&mut self.writer)?;
  155|    102|        Ok(())
  156|    102|    }
_RNvMNtCs8loA9e5gPGU_18serde_ipld_dagcbor3serINtB2_10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterE10into_innerCsitTtQF8ArIt_8fvm_fuzz:
   56|    714|    pub fn into_inner(self) -> W {
   57|    714|        self.writer
   58|    714|    }
_RINvXs2_NtCs8loA9e5gPGU_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterENtNtCslVZeVZySzLE_5serde3ser20SerializeTupleStruct15serialize_fieldRNtNtCs4pVfV2XJudO_10fvm_shared5state16StateTreeVersionECsitTtQF8ArIt_8fvm_fuzz:
  403|    102|    fn serialize_field<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  404|    102|        value.serialize(&mut *self.ser)
  405|    102|    }
_RNvXs_NtCs8loA9e5gPGU_18serde_ipld_dagcbor3serQINtB4_10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterENtNtCslVZeVZySzLE_5serde3ser10Serializer15serialize_tupleCsitTtQF8ArIt_8fvm_fuzz:
  239|  1.32k|        enc::ArrayStartBounded(len).encode(&mut self.writer)?;
  240|  1.32k|        Ok(BoundedCollect { ser: self })
  241|  1.32k|    }
_RINvNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser6to_vecAuj0_ECsitTtQF8ArIt_8fvm_fuzz:
   23|    102|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, EncodeError<TryReserveError>>
   24|    102|where
   25|    102|    T: Serialize + ?Sized,
   26|    102|{
   27|    102|    let writer = BufWriter::new(Vec::new());
   28|    102|    let mut serializer = Serializer::new(writer);
   29|    102|    value.serialize(&mut serializer)?;
   30|    102|    Ok(serializer.into_inner().into_inner())
   31|    102|}
_RINvXs1_NtCs8loA9e5gPGU_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterENtNtCslVZeVZySzLE_5serde3ser14SerializeTuple17serialize_elementRINtNtCsjYc3JqMxxfa_5alloc3vec3VecINtNtCshRBVfIqfJKm_13fvm_ipld_hamt7pointer7PointerNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtB30_6string6StringNtNtB3x_14hash_algorithm6Sha256EEECsitTtQF8ArIt_8fvm_fuzz:
  388|    102|    fn serialize_element<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  389|    102|        value.serialize(&mut *self.ser)
  390|    102|    }
_RINvNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser6to_vecNtNtCs4pVfV2XJudO_10fvm_shared5state9StateRootECsitTtQF8ArIt_8fvm_fuzz:
   23|    102|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, EncodeError<TryReserveError>>
   24|    102|where
   25|    102|    T: Serialize + ?Sized,
   26|    102|{
   27|    102|    let writer = BufWriter::new(Vec::new());
   28|    102|    let mut serializer = Serializer::new(writer);
   29|    102|    value.serialize(&mut serializer)?;
   30|    102|    Ok(serializer.into_inner().into_inner())
   31|    102|}
_RINvXs0_NtCs8loA9e5gPGU_18serde_ipld_dagcbor3serINtB6_7CollectNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterENtNtCslVZeVZySzLE_5serde3ser12SerializeSeq17serialize_elementRINtCshRBVfIqfJKm_13fvm_ipld_hamt12KeyValuePairNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateEECsitTtQF8ArIt_8fvm_fuzz:
  369|    306|    fn serialize_element<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  370|    306|        value.serialize(&mut *self.ser)
  371|    306|    }
_RNvXs_NtCs8loA9e5gPGU_18serde_ipld_dagcbor3serQINtB4_10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterENtNtCslVZeVZySzLE_5serde3ser10Serializer15serialize_bytesCsitTtQF8ArIt_8fvm_fuzz:
  160|    816|        types::Bytes(v).encode(&mut self.writer)?;
  161|    816|        Ok(())
  162|    816|    }
_RINvXs2_NtCs8loA9e5gPGU_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterENtNtCslVZeVZySzLE_5serde3ser20SerializeTupleStruct15serialize_fieldNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateECsitTtQF8ArIt_8fvm_fuzz:
  403|    306|    fn serialize_field<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  404|    306|        value.serialize(&mut *self.ser)
  405|    306|    }
_RNvXs7_NtCs8loA9e5gPGU_18serde_ipld_dagcbor3serQINtB5_13CidSerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterENtNtCslVZeVZySzLE_5serde3ser10Serializer15serialize_bytesCsitTtQF8ArIt_8fvm_fuzz:
  550|  1.02k|    fn serialize_bytes(self, value: &[u8]) -> Result<Self::Ok, Self::Error> {
  551|  1.02k|        // The bytes of the CID is prefixed with a null byte when encoded as CBOR.
  552|  1.02k|        let prefixed = [&[0x00], value].concat();
  553|  1.02k|        // CIDs are serialized with CBOR tag 42.
  554|  1.02k|        types::Tag(CBOR_TAGS_CID, types::Bytes(&prefixed[..])).encode(&mut self.0.writer)?;
  555|  1.02k|        Ok(())
  556|  1.02k|    }
_RINvNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser6to_vecINtNtCshRBVfIqfJKm_13fvm_ipld_hamt4node4NodeNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCsjYc3JqMxxfa_5alloc6string6StringNtNtBS_14hash_algorithm6Sha256EECsitTtQF8ArIt_8fvm_fuzz:
   23|    102|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, EncodeError<TryReserveError>>
   24|    102|where
   25|    102|    T: Serialize + ?Sized,
   26|    102|{
   27|    102|    let writer = BufWriter::new(Vec::new());
   28|    102|    let mut serializer = Serializer::new(writer);
   29|    102|    value.serialize(&mut serializer)?;
   30|    102|    Ok(serializer.into_inner().into_inner())
   31|    102|}
_RINvXs2_NtCs8loA9e5gPGU_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterENtNtCslVZeVZySzLE_5serde3ser20SerializeTupleStruct15serialize_fieldRINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EECsitTtQF8ArIt_8fvm_fuzz:
  403|  1.02k|    fn serialize_field<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  404|  1.02k|        value.serialize(&mut *self.ser)
  405|  1.02k|    }
_RINvNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser6to_vecINtNtCshRBVfIqfJKm_13fvm_ipld_hamt4node4NodeNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtBS_14hash_algorithm6Sha256EECsitTtQF8ArIt_8fvm_fuzz:
   23|    102|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, EncodeError<TryReserveError>>
   24|    102|where
   25|    102|    T: Serialize + ?Sized,
   26|    102|{
   27|    102|    let writer = BufWriter::new(Vec::new());
   28|    102|    let mut serializer = Serializer::new(writer);
   29|    102|    value.serialize(&mut serializer)?;
   30|    102|    Ok(serializer.into_inner().into_inner())
   31|    102|}
_RINvXs0_NtCs8loA9e5gPGU_18serde_ipld_dagcbor3serINtB6_7CollectNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterENtNtCslVZeVZySzLE_5serde3ser12SerializeSeq17serialize_elementRINtNtCshRBVfIqfJKm_13fvm_ipld_hamt7pointer7PointerNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtB2Q_14hash_algorithm6Sha256EECsitTtQF8ArIt_8fvm_fuzz:
  369|    306|    fn serialize_element<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  370|    306|        value.serialize(&mut *self.ser)
  371|    306|    }
_RINvNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser6to_vecNtNtCs7Ei498kZF3p_3fvm12system_actor5StateECsitTtQF8ArIt_8fvm_fuzz:
   23|    102|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, EncodeError<TryReserveError>>
   24|    102|where
   25|    102|    T: Serialize + ?Sized,
   26|    102|{
   27|    102|    let writer = BufWriter::new(Vec::new());
   28|    102|    let mut serializer = Serializer::new(writer);
   29|    102|    value.serialize(&mut serializer)?;
   30|    102|    Ok(serializer.into_inner().into_inner())
   31|    102|}
_RINvXs1_NtCs8loA9e5gPGU_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterENtNtCslVZeVZySzLE_5serde3ser14SerializeTuple17serialize_elementRNtNtCshRBVfIqfJKm_13fvm_ipld_hamt8bitfield8BitfieldECsitTtQF8ArIt_8fvm_fuzz:
  388|    204|    fn serialize_element<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  389|    204|        value.serialize(&mut *self.ser)
  390|    204|    }
_RNvMNtCs8loA9e5gPGU_18serde_ipld_dagcbor3serINtB2_10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterE3newCsitTtQF8ArIt_8fvm_fuzz:
   51|    714|    pub fn new(writer: W) -> Serializer<W> {
   52|    714|        Serializer { writer }
   53|    714|    }
_RNvXs1_NtCs8loA9e5gPGU_18serde_ipld_dagcbor3serINtB5_14BoundedCollectNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterENtNtCslVZeVZySzLE_5serde3ser14SerializeTuple3endCsitTtQF8ArIt_8fvm_fuzz:
  393|    408|    fn end(self) -> Result<Self::Ok, Self::Error> {
  394|    408|        Ok(())
  395|    408|    }
_RNvXs_NtCs8loA9e5gPGU_18serde_ipld_dagcbor3serQINtB4_10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterENtNtCslVZeVZySzLE_5serde3ser10Serializer22serialize_tuple_structCsitTtQF8ArIt_8fvm_fuzz:
  244|    918|    fn serialize_tuple_struct(
  245|    918|        self,
  246|    918|        _name: &'static str,
  247|    918|        len: usize,
  248|    918|    ) -> Result<Self::SerializeTupleStruct, Self::Error> {
  249|    918|        self.serialize_tuple(len)
  250|    918|    }
_RINvXs2_NtCs8loA9e5gPGU_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterENtNtCslVZeVZySzLE_5serde3ser20SerializeTupleStruct15serialize_fieldRyECsitTtQF8ArIt_8fvm_fuzz:
  403|    408|    fn serialize_field<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  404|    408|        value.serialize(&mut *self.ser)
  405|    408|    }

_RNvXCs872nzRHi4k9_11serde_tupleINtB2_10SerializerQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEENtNtCslVZeVZySzLE_5serde3ser10Serializer22serialize_tuple_structCsitTtQF8ArIt_8fvm_fuzz:
  158|    612|    fn serialize_tuple_struct(
  159|    612|        self,
  160|    612|        name: &'static str,
  161|    612|        len: usize,
  162|    612|    ) -> Result<Self::SerializeTupleStruct, Self::Error> {
  163|    612|        self.0.serialize_tuple_struct(name, len)
  164|    612|    }
_RINvXs_Cs872nzRHi4k9_11serde_tupleINtB5_12DeserializerNtNtCsalhrieD8kwf_12libipld_core4ipld4IpldENtNtCslVZeVZySzLE_5serde2de12Deserializer24deserialize_tuple_structNtNvXNvNvXsa_NtCs7Ei498kZF3p_3fvm10state_treeNtB2P_10ActorStateNtB1z_11Deserialize11deserialize1__NtB2J_5InnerB3D_11deserialize9___VisitorECsitTtQF8ArIt_8fvm_fuzz:
  353|    306|    fn deserialize_tuple_struct<V>(
  354|    306|        self,
  355|    306|        name: &'static str,
  356|    306|        len: usize,
  357|    306|        visitor: V,
  358|    306|    ) -> Result<V::Value, Self::Error>
  359|    306|    where
  360|    306|        V: serde::de::Visitor<'de>,
  361|    306|    {
  362|    306|        self.0.deserialize_tuple_struct(name, len, visitor)
  363|    306|    }
_RINvXs_Cs872nzRHi4k9_11serde_tupleINtB5_12DeserializerQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEENtNtCslVZeVZySzLE_5serde2de12Deserializer24deserialize_tuple_structNtNvXNvNvXs9_NtCs4pVfV2XJudO_10fvm_shared5stateNtB3U_9StateRootNtB2E_11Deserialize11deserialize1__NtB3O_5InnerB4I_11deserialize9___VisitorECsitTtQF8ArIt_8fvm_fuzz:
  353|    102|    fn deserialize_tuple_struct<V>(
  354|    102|        self,
  355|    102|        name: &'static str,
  356|    102|        len: usize,
  357|    102|        visitor: V,
  358|    102|    ) -> Result<V::Value, Self::Error>
  359|    102|    where
  360|    102|        V: serde::de::Visitor<'de>,
  361|    102|    {
  362|    102|        self.0.deserialize_tuple_struct(name, len, visitor)
  363|    102|    }
_RINvXCs872nzRHi4k9_11serde_tupleINtB3_10SerializerQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEENtNtCslVZeVZySzLE_5serde3ser10Serializer24serialize_newtype_structRINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EECsitTtQF8ArIt_8fvm_fuzz:
  123|    102|    fn serialize_newtype_struct<T: ?Sized>(
  124|    102|        self,
  125|    102|        name: &'static str,
  126|    102|        value: &T,
  127|    102|    ) -> Result<Self::Ok, Self::Error>
  128|    102|    where
  129|    102|        T: serde::Serialize,
  130|    102|    {
  131|       |        use serde::ser::SerializeTupleStruct;
  132|    102|        let mut out = self.serialize_tuple_struct(name, 1)?;
  133|    102|        out.serialize_field(value)?;
  134|    102|        out.end()
  135|    102|    }

_RNvXs3_NtCsbCQy5qVcCrD_4sha28core_apiNtB5_13Sha256VarCoreNtNtCs9gofsZWUQeH_6digest8core_api18VariableOutputCore22finalize_variable_core:
   60|    306|    fn finalize_variable_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>) {
   61|    306|        let bs = Self::BlockSize::U64;
   62|    306|        let bit_len = 8 * (buffer.get_pos() as u64 + bs * self.block_len);
   63|    306|        buffer.len64_padding_be(bit_len, |b| compress256(&mut self.state, from_ref(b)));
   64|       |
   65|  2.44k|        for (chunk, v) in out.chunks_exact_mut(4).zip(self.state.iter()) {
   66|  2.44k|            chunk.copy_from_slice(&v.to_be_bytes());
   67|  2.44k|        }
   68|    306|    }
_RNvXs3_NtCsbCQy5qVcCrD_4sha28core_apiNtB5_13Sha256VarCoreNtNtCs9gofsZWUQeH_6digest8core_api18VariableOutputCore3new:
   49|    306|    fn new(output_size: usize) -> Result<Self, InvalidOutputSize> {
   50|    306|        let state = match output_size {
   51|      0|            28 => consts::H256_224,
   52|    306|            32 => consts::H256_256,
   53|      0|            _ => return Err(InvalidOutputSize),
   54|       |        };
   55|    306|        let block_len = 0;
   56|    306|        Ok(Self { state, block_len })
   57|    306|    }
_RNCNvXs3_NtCsbCQy5qVcCrD_4sha28core_apiNtB7_13Sha256VarCoreNtNtCs9gofsZWUQeH_6digest8core_api18VariableOutputCore22finalize_variable_core0CsitTtQF8ArIt_8fvm_fuzz:
   63|    306|        buffer.len64_padding_be(bit_len, |b| compress256(&mut self.state, from_ref(b)));

_RNvNtCsbCQy5qVcCrD_4sha26sha25611compress256:
   31|    306|pub fn compress256(state: &mut [u32; 8], blocks: &[GenericArray<u8, U64>]) {
   32|    306|    // SAFETY: GenericArray<u8, U64> and [u8; 64] have
   33|    306|    // exactly the same memory layout
   34|    306|    let p = blocks.as_ptr() as *const [u8; 64];
   35|    306|    let blocks = unsafe { core::slice::from_raw_parts(p, blocks.len()) };
   36|    306|    compress(state, blocks)
   37|    306|}

_RNvNtNtCsbCQy5qVcCrD_4sha26sha2564soft10sha256msg2:
   56|  3.67k|fn sha256msg2(v4: [u32; 4], v3: [u32; 4]) -> [u32; 4] {
   57|  3.67k|    macro_rules! sigma1 {
   58|  3.67k|        ($a:expr) => {
   59|  3.67k|            $a.rotate_right(17) ^ $a.rotate_right(19) ^ ($a >> 10)
   60|  3.67k|        };
   61|  3.67k|    }
   62|  3.67k|
   63|  3.67k|    let [x3, x2, x1, x0] = v4;
   64|  3.67k|    let [w15, w14, _, _] = v3;
   65|  3.67k|
   66|  3.67k|    let w16 = x0.wrapping_add(sigma1!(w14));
   67|  3.67k|    let w17 = x1.wrapping_add(sigma1!(w15));
   68|  3.67k|    let w18 = x2.wrapping_add(sigma1!(w16));
   69|  3.67k|    let w19 = x3.wrapping_add(sigma1!(w17));
   70|  3.67k|
   71|  3.67k|    [w19, w18, w17, w16]
   72|  3.67k|}
_RNvNtNtCsbCQy5qVcCrD_4sha26sha2564soft3shr:
   11|  7.34k|fn shr(v: [u32; 4], o: u32) -> [u32; 4] {
   12|  7.34k|    [v[0] << o, v[1] << o, v[2] << o, v[3] << o]
   13|  7.34k|}
_RNvNtNtCsbCQy5qVcCrD_4sha26sha2564soft3add:
   26|  12.2k|fn add(a: [u32; 4], b: [u32; 4]) -> [u32; 4] {
   27|  12.2k|    [
   28|  12.2k|        a[0].wrapping_add(b[0]),
   29|  12.2k|        a[1].wrapping_add(b[1]),
   30|  12.2k|        a[2].wrapping_add(b[2]),
   31|  12.2k|        a[3].wrapping_add(b[3]),
   32|  12.2k|    ]
   33|  12.2k|}
_RNvNtNtCsbCQy5qVcCrD_4sha26sha2564soft23sha256_digest_block_u32:
  165|    306|fn sha256_digest_block_u32(state: &mut [u32; 8], block: &[u32; 16]) {
  166|    306|    let mut abef = [state[0], state[1], state[4], state[5]];
  167|    306|    let mut cdgh = [state[2], state[3], state[6], state[7]];
  168|    306|
  169|    306|    // Rounds 0..64
  170|    306|    let mut w0 = [block[3], block[2], block[1], block[0]];
  171|    306|    let mut w1 = [block[7], block[6], block[5], block[4]];
  172|    306|    let mut w2 = [block[11], block[10], block[9], block[8]];
  173|    306|    let mut w3 = [block[15], block[14], block[13], block[12]];
  174|    306|    let mut w4;
  175|    306|
  176|    306|    rounds4!(abef, cdgh, w0, 0);
  177|    306|    rounds4!(abef, cdgh, w1, 1);
  178|    306|    rounds4!(abef, cdgh, w2, 2);
  179|    306|    rounds4!(abef, cdgh, w3, 3);
  180|    306|    schedule_rounds4!(abef, cdgh, w0, w1, w2, w3, w4, 4);
  181|    306|    schedule_rounds4!(abef, cdgh, w1, w2, w3, w4, w0, 5);
  182|    306|    schedule_rounds4!(abef, cdgh, w2, w3, w4, w0, w1, 6);
  183|    306|    schedule_rounds4!(abef, cdgh, w3, w4, w0, w1, w2, 7);
  184|    306|    schedule_rounds4!(abef, cdgh, w4, w0, w1, w2, w3, 8);
  185|    306|    schedule_rounds4!(abef, cdgh, w0, w1, w2, w3, w4, 9);
  186|    306|    schedule_rounds4!(abef, cdgh, w1, w2, w3, w4, w0, 10);
  187|    306|    schedule_rounds4!(abef, cdgh, w2, w3, w4, w0, w1, 11);
  188|    306|    schedule_rounds4!(abef, cdgh, w3, w4, w0, w1, w2, 12);
  189|    306|    schedule_rounds4!(abef, cdgh, w4, w0, w1, w2, w3, 13);
  190|    306|    schedule_rounds4!(abef, cdgh, w0, w1, w2, w3, w4, 14);
  191|    306|    schedule_rounds4!(abef, cdgh, w1, w2, w3, w4, w0, 15);
  192|    306|
  193|    306|    let [a, b, e, f] = abef;
  194|    306|    let [c, d, g, h] = cdgh;
  195|    306|
  196|    306|    state[0] = state[0].wrapping_add(a);
  197|    306|    state[1] = state[1].wrapping_add(b);
  198|    306|    state[2] = state[2].wrapping_add(c);
  199|    306|    state[3] = state[3].wrapping_add(d);
  200|    306|    state[4] = state[4].wrapping_add(e);
  201|    306|    state[5] = state[5].wrapping_add(f);
  202|    306|    state[6] = state[6].wrapping_add(g);
  203|    306|    state[7] = state[7].wrapping_add(h);
  204|    306|}
_RNvNtNtCsbCQy5qVcCrD_4sha26sha2564soft2or:
   16|  7.34k|fn or(a: [u32; 4], b: [u32; 4]) -> [u32; 4] {
   17|  7.34k|    [a[0] | b[0], a[1] | b[1], a[2] | b[2], a[3] | b[3]]
   18|  7.34k|}
_RNvNtNtCsbCQy5qVcCrD_4sha26sha2564soft10sha256load:
   35|  7.34k|fn sha256load(v2: [u32; 4], v3: [u32; 4]) -> [u32; 4] {
   36|  7.34k|    [v3[3], v2[0], v2[1], v2[2]]
   37|  7.34k|}
_RNvNtNtCsbCQy5qVcCrD_4sha26sha2564soft3xor:
   21|  7.34k|fn xor(a: [u32; 4], b: [u32; 4]) -> [u32; 4] {
   22|  7.34k|    [a[0] ^ b[0], a[1] ^ b[1], a[2] ^ b[2], a[3] ^ b[3]]
   23|  7.34k|}
_RNvNtNtCsbCQy5qVcCrD_4sha26sha2564soft10sha256swap:
   39|  4.89k|fn sha256swap(v0: [u32; 4]) -> [u32; 4] {
   40|  4.89k|    [v0[2], v0[3], v0[0], v0[1]]
   41|  4.89k|}
_RNvNtNtCsbCQy5qVcCrD_4sha26sha2564soft22sha256_digest_round_x2:
   74|  9.79k|fn sha256_digest_round_x2(cdgh: [u32; 4], abef: [u32; 4], wk: [u32; 4]) -> [u32; 4] {
   75|  9.79k|    macro_rules! big_sigma0 {
   76|  9.79k|        ($a:expr) => {
   77|  9.79k|            ($a.rotate_right(2) ^ $a.rotate_right(13) ^ $a.rotate_right(22))
   78|  9.79k|        };
   79|  9.79k|    }
   80|  9.79k|    macro_rules! big_sigma1 {
   81|  9.79k|        ($a:expr) => {
   82|  9.79k|            ($a.rotate_right(6) ^ $a.rotate_right(11) ^ $a.rotate_right(25))
   83|  9.79k|        };
   84|  9.79k|    }
   85|  9.79k|    macro_rules! bool3ary_202 {
   86|  9.79k|        ($a:expr, $b:expr, $c:expr) => {
   87|  9.79k|            $c ^ ($a & ($b ^ $c))
   88|  9.79k|        };
   89|  9.79k|    } // Choose, MD5F, SHA1C
   90|  9.79k|    macro_rules! bool3ary_232 {
   91|  9.79k|        ($a:expr, $b:expr, $c:expr) => {
   92|  9.79k|            ($a & $b) ^ ($a & $c) ^ ($b & $c)
   93|  9.79k|        };
   94|  9.79k|    } // Majority, SHA1M
   95|  9.79k|
   96|  9.79k|    let [_, _, wk1, wk0] = wk;
   97|  9.79k|    let [a0, b0, e0, f0] = abef;
   98|  9.79k|    let [c0, d0, g0, h0] = cdgh;
   99|  9.79k|
  100|  9.79k|    // a round
  101|  9.79k|    let x0 = big_sigma1!(e0)
  102|  9.79k|        .wrapping_add(bool3ary_202!(e0, f0, g0))
  103|  9.79k|        .wrapping_add(wk0)
  104|  9.79k|        .wrapping_add(h0);
  105|  9.79k|    let y0 = big_sigma0!(a0).wrapping_add(bool3ary_232!(a0, b0, c0));
  106|  9.79k|    let (a1, b1, c1, d1, e1, f1, g1, h1) = (
  107|  9.79k|        x0.wrapping_add(y0),
  108|  9.79k|        a0,
  109|  9.79k|        b0,
  110|  9.79k|        c0,
  111|  9.79k|        x0.wrapping_add(d0),
  112|  9.79k|        e0,
  113|  9.79k|        f0,
  114|  9.79k|        g0,
  115|  9.79k|    );
  116|  9.79k|
  117|  9.79k|    // a round
  118|  9.79k|    let x1 = big_sigma1!(e1)
  119|  9.79k|        .wrapping_add(bool3ary_202!(e1, f1, g1))
  120|  9.79k|        .wrapping_add(wk1)
  121|  9.79k|        .wrapping_add(h1);
  122|  9.79k|    let y1 = big_sigma0!(a1).wrapping_add(bool3ary_232!(a1, b1, c1));
  123|  9.79k|    let (a2, b2, _, _, e2, f2, _, _) = (
  124|  9.79k|        x1.wrapping_add(y1),
  125|  9.79k|        a1,
  126|  9.79k|        b1,
  127|  9.79k|        c1,
  128|  9.79k|        x1.wrapping_add(d1),
  129|  9.79k|        e1,
  130|  9.79k|        f1,
  131|  9.79k|        g1,
  132|  9.79k|    );
  133|  9.79k|
  134|  9.79k|    [a2, b2, e2, f2]
  135|  9.79k|}
_RNvNtNtCsbCQy5qVcCrD_4sha26sha2564soft8schedule:
  137|  3.67k|fn schedule(v0: [u32; 4], v1: [u32; 4], v2: [u32; 4], v3: [u32; 4]) -> [u32; 4] {
  138|  3.67k|    let t1 = sha256msg1(v0, v1);
  139|  3.67k|    let t2 = sha256load(v2, v3);
  140|  3.67k|    let t3 = add(t1, t2);
  141|  3.67k|    sha256msg2(t3, v3)
  142|  3.67k|}
_RNvNtNtCsbCQy5qVcCrD_4sha26sha2564soft10sha256msg1:
   43|  3.67k|fn sha256msg1(v0: [u32; 4], v1: [u32; 4]) -> [u32; 4] {
   44|  3.67k|    // sigma 0 on vectors
   45|  3.67k|    #[inline]
   46|  3.67k|    fn sigma0x4(x: [u32; 4]) -> [u32; 4] {
   47|  3.67k|        let t1 = or(shl(x, 7), shr(x, 25));
   48|  3.67k|        let t2 = or(shl(x, 18), shr(x, 14));
   49|  3.67k|        let t3 = shl(x, 3);
   50|  3.67k|        xor(xor(t1, t2), t3)
   51|  3.67k|    }
   52|  3.67k|
   53|  3.67k|    add(v0, sigma0x4(sha256load(v0, v1)))
   54|  3.67k|}
_RNvNtNtCsbCQy5qVcCrD_4sha26sha2564soft3shl:
    6|  11.0k|fn shl(v: [u32; 4], o: u32) -> [u32; 4] {
    7|  11.0k|    [v[0] >> o, v[1] >> o, v[2] >> o, v[3] >> o]
    8|  11.0k|}
_RNvNtNtCsbCQy5qVcCrD_4sha26sha2564soft8compress:
  206|    306|pub fn compress(state: &mut [u32; 8], blocks: &[[u8; 64]]) {
  207|    306|    let mut block_u32 = [0u32; BLOCK_LEN];
  208|    306|    // since LLVM can't properly use aliasing yet it will make
  209|    306|    // unnecessary state stores without this copy
  210|    306|    let mut state_cpy = *state;
  211|    612|    for block in blocks {
  212|  4.89k|        for (o, chunk) in block_u32.iter_mut().zip(block.chunks_exact(4)) {
  213|  4.89k|            *o = u32::from_be_bytes(chunk.try_into().unwrap());
  214|  4.89k|        }
  215|    306|        sha256_digest_block_u32(&mut state_cpy, &block_u32);
  216|       |    }
  217|    306|    *state = state_cpy;
  218|    306|}
_RNvNvNtNtCsbCQy5qVcCrD_4sha26sha2564soft10sha256msg18sigma0x4:
   46|  3.67k|    fn sigma0x4(x: [u32; 4]) -> [u32; 4] {
   47|  3.67k|        let t1 = or(shl(x, 7), shr(x, 25));
   48|  3.67k|        let t2 = or(shl(x, 18), shr(x, 14));
   49|  3.67k|        let t3 = shl(x, 3);
   50|  3.67k|        xor(xor(t1, t2), t3)
   51|  3.67k|    }

_RNvNtNtCsbCQy5qVcCrD_4sha26sha2563x868compress:
  102|    306|pub fn compress(state: &mut [u32; 8], blocks: &[[u8; 64]]) {
  103|    306|    // TODO: Replace with https://github.com/rust-lang/rfcs/pull/2725
  104|    306|    // after stabilization
  105|    306|    if shani_cpuid::get() {
  106|      0|        unsafe {
  107|      0|            digest_blocks(state, blocks);
  108|      0|        }
  109|    306|    } else {
  110|    306|        super::soft::compress(state, blocks);
  111|    306|    }
  112|    306|}

_RNvXs1G_NtCs8QACEDFNhqS_14target_lexicon7targetsNtB6_15OperatingSystemNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
  434|    204|#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
_RNvXs1y_NtCs8QACEDFNhqS_14target_lexicon7targetsNtB6_6VendorNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
  403|    204|#[derive(Clone, Debug, PartialEq, Eq, Hash)]
_RNvXst_NtCs8QACEDFNhqS_14target_lexicon7targetsNtB5_12ArchitectureNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
   13|    204|#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
_RNvXs1W_NtCs8QACEDFNhqS_14target_lexicon7targetsNtB6_12BinaryFormatNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
  515|    204|#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
_RNvXs1O_NtCs8QACEDFNhqS_14target_lexicon7targetsNtB6_11EnvironmentNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
  476|    204|#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]

_RNvXsr_NtCs8QACEDFNhqS_14target_lexicon6tripleNtB5_6TripleNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
   87|    204|#[derive(Clone, Debug, PartialEq, Eq, Hash)]

_RNvXsl_Cs1tgMkxMbX7R_9termcolorNtB5_6BufferNtB5_10WriteColor9set_color:
 1172|   199k|    fn set_color(&mut self, spec: &ColorSpec) -> io::Result<()> {
 1173|   199k|        match self.0 {
 1174|   199k|            BufferInner::NoColor(ref mut w) => w.set_color(spec),
 1175|      0|            BufferInner::Ansi(ref mut w) => w.set_color(spec),
 1176|       |            #[cfg(windows)]
 1177|       |            BufferInner::Windows(ref mut w) => w.set_color(spec),
 1178|       |        }
 1179|   199k|    }
_RNvXsl_Cs1tgMkxMbX7R_9termcolorNtB5_6BufferNtB5_10WriteColor5reset:
 1182|   199k|    fn reset(&mut self) -> io::Result<()> {
 1183|   199k|        match self.0 {
 1184|   199k|            BufferInner::NoColor(ref mut w) => w.reset(),
 1185|      0|            BufferInner::Ansi(ref mut w) => w.reset(),
 1186|       |            #[cfg(windows)]
 1187|       |            BufferInner::Windows(ref mut w) => w.reset(),
 1188|       |        }
 1189|   199k|    }
_RNvXsn_Cs1tgMkxMbX7R_9termcolorINtB5_7NoColorINtNtCsjYc3JqMxxfa_5alloc3vec3VechEENtNtCsxnqwkJeFav_3std2io5Write5writeCs4DcB2eWstN0_10env_logger:
 1225|  1.25M|    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
 1226|  1.25M|        self.0.write(buf)
 1227|  1.25M|    }
_RNvXsL_Cs1tgMkxMbX7R_9termcolorNtB5_9ColorSpecNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
 1579|   133k|#[derive(Clone, Debug, Eq, PartialEq)]
_RNvXsk_Cs1tgMkxMbX7R_9termcolorNtB5_6BufferNtNtCsxnqwkJeFav_3std2io5Write5write:
 1140|  1.25M|    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
 1141|  1.25M|        match self.0 {
 1142|  1.25M|            BufferInner::NoColor(ref mut w) => w.write(buf),
 1143|      0|            BufferInner::Ansi(ref mut w) => w.write(buf),
 1144|       |            #[cfg(windows)]
 1145|       |            BufferInner::Windows(ref mut w) => w.write(buf),
 1146|       |        }
 1147|  1.25M|    }
_RNvXso_Cs1tgMkxMbX7R_9termcolorINtB5_7NoColorINtNtCsjYc3JqMxxfa_5alloc3vec3VechEENtB5_10WriteColor5resetCs4DcB2eWstN0_10env_logger:
 1247|   199k|    fn reset(&mut self) -> io::Result<()> {
 1248|   199k|        Ok(())
 1249|   199k|    }
_RNvXso_Cs1tgMkxMbX7R_9termcolorINtB5_7NoColorINtNtCsjYc3JqMxxfa_5alloc3vec3VechEENtB5_10WriteColor9set_colorCs4DcB2eWstN0_10env_logger:
 1242|   199k|    fn set_color(&mut self, _: &ColorSpec) -> io::Result<()> {
 1243|   199k|        Ok(())
 1244|   199k|    }
_RNvXsR_Cs1tgMkxMbX7R_9termcolorNtB5_5ColorNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
 1805|   133k|#[derive(Clone, Copy, Debug, Eq, PartialEq)]
_RNvMsB_Cs1tgMkxMbX7R_9termcolorINtB5_19LossyStandardStreamNtB5_16IoStandardStreamE3newB5_:
 2010|    102|    fn new(wtr: W) -> LossyStandardStream<W> {
 2011|    102|        LossyStandardStream { wtr: wtr }
 2012|    102|    }
_RNvXsu_Cs1tgMkxMbX7R_9termcolorNtB5_9ColorSpecNtNtCshM4Il2Z0i4R_4core7default7Default7default:
 1592|   199k|    fn default() -> ColorSpec {
 1593|   199k|        ColorSpec {
 1594|   199k|            fg_color: None,
 1595|   199k|            bg_color: None,
 1596|   199k|            bold: false,
 1597|   199k|            intense: false,
 1598|   199k|            underline: false,
 1599|   199k|            dimmed: false,
 1600|   199k|            italic: false,
 1601|   199k|            reset: true,
 1602|   199k|        }
 1603|   199k|    }
_RINvMsB_Cs1tgMkxMbX7R_9termcolorINtB6_19LossyStandardStreamNtB6_16IoStandardStreamE4wrapNtB6_20IoStandardStreamLockEB6_:
 2022|  66.5k|    fn wrap<Q: io::Write>(&self, wtr: Q) -> LossyStandardStream<Q> {
 2023|  66.5k|        LossyStandardStream::new(wtr)
 2024|  66.5k|    }
_RNvMs1_Cs1tgMkxMbX7R_9termcolorNtB5_16IoStandardStream3new:
  313|    102|    fn new(sty: StandardStreamType) -> IoStandardStream {
  314|    102|        match sty {
  315|       |            StandardStreamType::Stdout => {
  316|      0|                IoStandardStream::Stdout(io::stdout())
  317|       |            }
  318|       |            StandardStreamType::Stderr => {
  319|    102|                IoStandardStream::Stderr(io::stderr())
  320|       |            }
  321|       |            StandardStreamType::StdoutBuffered => {
  322|      0|                let wtr = io::BufWriter::new(io::stdout());
  323|      0|                IoStandardStream::StdoutBuffered(wtr)
  324|       |            }
  325|       |            StandardStreamType::StderrBuffered => {
  326|      0|                let wtr = io::BufWriter::new(io::stderr());
  327|      0|                IoStandardStream::StderrBuffered(wtr)
  328|       |            }
  329|       |        }
  330|    102|    }
_RNvMsi_Cs1tgMkxMbX7R_9termcolorNtB5_12BufferWriter6stderr:
  939|    102|    pub fn stderr(choice: ColorChoice) -> BufferWriter {
  940|    102|        BufferWriter::create(StandardStreamType::Stderr, choice)
  941|    102|    }
_RNvMsj_Cs1tgMkxMbX7R_9termcolorNtB5_6Buffer8no_color:
 1064|      1|    pub fn no_color() -> Buffer {
 1065|      1|        Buffer(BufferInner::NoColor(NoColor(vec![])))
 1066|      1|    }
_RNvMsB_Cs1tgMkxMbX7R_9termcolorINtB5_19LossyStandardStreamNtB5_16IoStandardStreamE7get_refB5_:
 2031|  66.5k|    fn get_ref(&self) -> &W {
 2032|  66.5k|        &self.wtr
 2033|  66.5k|    }
_RNvMsj_Cs1tgMkxMbX7R_9termcolorNtB5_6Buffer5clear:
 1095|  66.5k|    pub fn clear(&mut self) {
 1096|  66.5k|        match self.0 {
 1097|  66.5k|            BufferInner::NoColor(ref mut b) => b.0.clear(),
 1098|      0|            BufferInner::Ansi(ref mut b) => b.0.clear(),
 1099|       |            #[cfg(windows)]
 1100|       |            BufferInner::Windows(ref mut b) => b.clear(),
 1101|       |        }
 1102|  66.5k|    }
_RNvMsv_Cs1tgMkxMbX7R_9termcolorNtB5_9ColorSpec11set_intense:
 1741|   133k|    pub fn set_intense(&mut self, yes: bool) -> &mut ColorSpec {
 1742|   133k|        self.intense = yes;
 1743|   133k|        self
 1744|   133k|    }
_RNvMsi_Cs1tgMkxMbX7R_9termcolorNtB5_12BufferWriter5print:
  974|  66.5k|    pub fn print(&self, buf: &Buffer) -> io::Result<()> {
  975|  66.5k|        if buf.is_empty() {
  976|      0|            return Ok(());
  977|  66.5k|        }
  978|  66.5k|        let mut stream = self.stream.wrap(self.stream.get_ref().lock());
  979|  66.5k|        if let Some(ref sep) = self.separator {
  980|      0|            if self.printed.load(Ordering::SeqCst) {
  981|      0|                stream.write_all(sep)?;
  982|      0|                stream.write_all(b"\n")?;
  983|      0|            }
  984|  66.5k|        }
  985|  66.5k|        match buf.0 {
  986|  66.5k|            BufferInner::NoColor(ref b) => stream.write_all(&b.0)?,
  987|      0|            BufferInner::Ansi(ref b) => stream.write_all(&b.0)?,
  988|       |            #[cfg(windows)]
  989|       |            BufferInner::Windows(ref b) => {
  990|       |                // We guarantee by construction that we have a console here.
  991|       |                // Namely, a BufferWriter is the only way to produce a Buffer.
  992|       |                let console_mutex = self
  993|       |                    .console
  994|       |                    .as_ref()
  995|       |                    .expect("got Windows buffer but have no Console");
  996|       |                let mut console = console_mutex.lock().unwrap();
  997|       |                b.print(&mut *console, &mut stream)?;
  998|       |            }
  999|       |        }
 1000|  66.5k|        self.printed.store(true, Ordering::SeqCst);
 1001|  66.5k|        Ok(())
 1002|  66.5k|    }
_RNvMsj_Cs1tgMkxMbX7R_9termcolorNtB5_6Buffer3len:
 1085|  66.5k|    pub fn len(&self) -> usize {
 1086|  66.5k|        match self.0 {
 1087|  66.5k|            BufferInner::NoColor(ref b) => b.0.len(),
 1088|      0|            BufferInner::Ansi(ref b) => b.0.len(),
 1089|       |            #[cfg(windows)]
 1090|       |            BufferInner::Windows(ref b) => b.buf.len(),
 1091|       |        }
 1092|  66.5k|    }
_RNvXs3_Cs1tgMkxMbX7R_9termcolorNtB5_20IoStandardStreamLockNtNtCsxnqwkJeFav_3std2io5Write5write:
  381|  66.5k|    fn write(&mut self, b: &[u8]) -> io::Result<usize> {
  382|  66.5k|        match *self {
  383|      0|            IoStandardStreamLock::StdoutLock(ref mut s) => s.write(b),
  384|  66.5k|            IoStandardStreamLock::StderrLock(ref mut s) => s.write(b),
  385|       |        }
  386|  66.5k|    }
_RNvMsB_Cs1tgMkxMbX7R_9termcolorINtB5_19LossyStandardStreamNtB5_20IoStandardStreamLockE3newB5_:
 2010|  66.5k|    fn new(wtr: W) -> LossyStandardStream<W> {
 2011|  66.5k|        LossyStandardStream { wtr: wtr }
 2012|  66.5k|    }
_RNvMsi_Cs1tgMkxMbX7R_9termcolorNtB5_12BufferWriter6buffer:
  956|      1|    pub fn buffer(&self) -> Buffer {
  957|      1|        Buffer::new(self.color_choice)
  958|      1|    }
_RNvMsv_Cs1tgMkxMbX7R_9termcolorNtB5_9ColorSpec6set_fg:
 1618|   199k|    pub fn set_fg(&mut self, color: Option<Color>) -> &mut ColorSpec {
 1619|   199k|        self.fg_color = color;
 1620|   199k|        self
 1621|   199k|    }
_RNvMs0_Cs1tgMkxMbX7R_9termcolorNtB5_11ColorChoice20should_attempt_color:
  224|      1|    fn should_attempt_color(&self) -> bool {
  225|      1|        match *self {
  226|      0|            ColorChoice::Always => true,
  227|      0|            ColorChoice::AlwaysAnsi => true,
  228|      1|            ColorChoice::Never => false,
  229|      0|            ColorChoice::Auto => self.env_allows_color(),
  230|       |        }
  231|      1|    }
_RNvMsj_Cs1tgMkxMbX7R_9termcolorNtB5_6Buffer3new:
 1035|      1|    fn new(choice: ColorChoice) -> Buffer {
 1036|      1|        if choice.should_attempt_color() {
 1037|      0|            Buffer::ansi()
 1038|       |        } else {
 1039|      1|            Buffer::no_color()
 1040|       |        }
 1041|      1|    }
_RNvMsv_Cs1tgMkxMbX7R_9termcolorNtB5_9ColorSpec3new:
 1608|   199k|    pub fn new() -> ColorSpec {
 1609|   199k|        ColorSpec::default()
 1610|   199k|    }
_RNvMsi_Cs1tgMkxMbX7R_9termcolorNtB5_12BufferWriter6create:
  874|    102|    fn create(sty: StandardStreamType, choice: ColorChoice) -> BufferWriter {
  875|    102|        BufferWriter {
  876|    102|            stream: LossyStandardStream::new(IoStandardStream::new(sty)),
  877|    102|            printed: AtomicBool::new(false),
  878|    102|            separator: None,
  879|    102|            color_choice: choice,
  880|    102|        }
  881|    102|    }
_RNvMs1_Cs1tgMkxMbX7R_9termcolorNtB5_16IoStandardStream4lock:
  332|  66.5k|    fn lock(&self) -> IoStandardStreamLock<'_> {
  333|  66.5k|        match *self {
  334|      0|            IoStandardStream::Stdout(ref s) => {
  335|      0|                IoStandardStreamLock::StdoutLock(s.lock())
  336|       |            }
  337|  66.5k|            IoStandardStream::Stderr(ref s) => {
  338|  66.5k|                IoStandardStreamLock::StderrLock(s.lock())
  339|       |            }
  340|       |            IoStandardStream::StdoutBuffered(_)
  341|       |            | IoStandardStream::StderrBuffered(_) => {
  342|       |                // We don't permit this case to ever occur in the public API,
  343|       |                // so it's OK to panic.
  344|      0|                panic!("cannot lock a buffered standard stream")
  345|       |            }
  346|       |        }
  347|  66.5k|    }
_RNvMsj_Cs1tgMkxMbX7R_9termcolorNtB5_6Buffer8is_empty:
 1080|  66.5k|    pub fn is_empty(&self) -> bool {
 1081|  66.5k|        self.len() == 0
 1082|  66.5k|    }
_RNvXsD_Cs1tgMkxMbX7R_9termcolorINtB5_19LossyStandardStreamNtB5_20IoStandardStreamLockENtNtCsxnqwkJeFav_3std2io5Write5writeB5_:
 2053|  66.5k|    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
 2054|  66.5k|        self.wtr.write(buf)
 2055|  66.5k|    }

_RNvXNtCs3g0VIT0BX7q_9thiserror7displayRmNtB2_16DisplayAsDisplay10as_displayCs7Ei498kZF3p_3fvm:
    9|    243|    fn as_display(&self) -> Self {
   10|    243|        self
   11|    243|    }
_RNvXNtCs3g0VIT0BX7q_9thiserror7displayRNtNtCsjYc3JqMxxfa_5alloc6string6StringNtB2_16DisplayAsDisplay10as_displayCsbsA1N0ivJJv_17fvm_ipld_encoding:
    9|  31.7k|    fn as_display(&self) -> Self {
   10|  31.7k|        self
   11|  31.7k|    }
_RNvXNtCs3g0VIT0BX7q_9thiserror7displayRNtNtCsbsA1N0ivJJv_17fvm_ipld_encoding6errors13CodecProtocolNtB2_16DisplayAsDisplay10as_displayBF_:
    9|  31.7k|    fn as_display(&self) -> Self {
   10|  31.7k|        self
   11|  31.7k|    }

_RNvNtCsahNQa9khuPr_15unsigned_varint6decode7is_last:
   90|  78.3k|pub fn is_last(b: u8) -> bool {
   91|  78.3k|    b & 0x80 == 0
   92|  78.3k|}
_RNvNtCsahNQa9khuPr_15unsigned_varint6decode3u64:
  122|  26.1k|pub fn u64(buf: &[u8]) -> Result<(u64, &[u8]), Error> {
  123|  26.1k|    decode!(buf, 9, u64)
  124|  26.1k|}

_RNvNtCsahNQa9khuPr_15unsigned_varint6encode3u64:
   69|  5.50k|pub fn u64(number: u64, buf: &mut [u8; U64_LEN]) -> &[u8] {
   70|  5.50k|    encode!(number, buf)
   71|  5.50k|}
_RNvNtCsahNQa9khuPr_15unsigned_varint6encode2u8:
   45|  1.73k|pub fn u8(number: u8, buf: &mut [u8; U8_LEN]) -> &[u8] {
   46|  1.73k|    encode!(number, buf)
   47|  1.73k|}
_RNvNtCsahNQa9khuPr_15unsigned_varint6encode10u64_buffer:
  119|  32.5k|pub fn u64_buffer() -> [u8; U64_LEN] {
  120|  32.5k|    [0; U64_LEN]
  121|  32.5k|}
_RNvNtCsahNQa9khuPr_15unsigned_varint6encode9u8_buffer:
  101|  1.73k|pub fn u8_buffer() -> [u8; U8_LEN] {
  102|  1.73k|    [0; U8_LEN]
  103|  1.73k|}

_RINvNtCsahNQa9khuPr_15unsigned_varint2io8read_u64QQRShECsitTtQF8ArIt_8fvm_fuzz:
   31|  19.1k|            pub fn $name<R: io::Read>(mut reader: R) -> Result<$t, ReadError> {
   32|  19.1k|                let mut b = encode::$b();
   33|  28.7k|                for i in 0 .. b.len() {
   34|  28.7k|                    let n = reader.read(&mut b[i .. i + 1])?;
   35|  28.7k|                    if n == 0 {
   36|      0|                        return Err(ReadError::Io(io::ErrorKind::UnexpectedEof.into()))
   37|  28.7k|                    }
   38|  28.7k|                    if decode::is_last(b[i]) {
   39|  19.1k|                        return Ok(decode::$t(&b[..= i])?.0)
   40|  9.58k|                    }
   41|       |                }
   42|      0|                Err(decode::Error::Overflow.into())
   43|  19.1k|            }
_RINvNtCsahNQa9khuPr_15unsigned_varint2io8read_u64QQINtNtNtCsxnqwkJeFav_3std2io6cursor6CursorRINtNtCsjYc3JqMxxfa_5alloc3vec3VechEEECsitTtQF8ArIt_8fvm_fuzz:
   31|  6.93k|            pub fn $name<R: io::Read>(mut reader: R) -> Result<$t, ReadError> {
   32|  6.93k|                let mut b = encode::$b();
   33|  10.4k|                for i in 0 .. b.len() {
   34|  10.4k|                    let n = reader.read(&mut b[i .. i + 1])?;
   35|  10.4k|                    if n == 0 {
   36|      0|                        return Err(ReadError::Io(io::ErrorKind::UnexpectedEof.into()))
   37|  10.4k|                    }
   38|  10.4k|                    if decode::is_last(b[i]) {
   39|  6.93k|                        return Ok(decode::$t(&b[..= i])?.0)
   40|  3.46k|                    }
   41|       |                }
   42|      0|                Err(decode::Error::Overflow.into())
   43|  6.93k|            }
_RINvNtCsahNQa9khuPr_15unsigned_varint2io8read_u64QRShECs7Ei498kZF3p_3fvm:
   31|    977|            pub fn $name<R: io::Read>(mut reader: R) -> Result<$t, ReadError> {
   32|    977|                let mut b = encode::$b();
   33|    977|                for i in 0 .. b.len() {
   34|    977|                    let n = reader.read(&mut b[i .. i + 1])?;
   35|    977|                    if n == 0 {
   36|    977|                        return Err(ReadError::Io(io::ErrorKind::UnexpectedEof.into()))
   37|      0|                    }
   38|      0|                    if decode::is_last(b[i]) {
   39|      0|                        return Ok(decode::$t(&b[..= i])?.0)
   40|      0|                    }
   41|       |                }
   42|      0|                Err(decode::Error::Overflow.into())
   43|    977|            }

_RNvXse_NtCs28dBy9EVN5z_10wasmparser9validatorNtB5_12WasmFeaturesNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
  208|    204|#[derive(Hash, Debug, Copy, Clone)]
_RNvXs1_NtCs28dBy9EVN5z_10wasmparser9validatorNtB5_12WasmFeaturesNtNtCshM4Il2Z0i4R_4core7default7Default7default:
  267|    204|    fn default() -> WasmFeatures {
  268|    204|        WasmFeatures {
  269|    204|            // off-by-default features
  270|    204|            relaxed_simd: false,
  271|    204|            threads: false,
  272|    204|            tail_call: false,
  273|    204|            multi_memory: false,
  274|    204|            exceptions: false,
  275|    204|            memory64: false,
  276|    204|            extended_const: false,
  277|    204|            component_model: false,
  278|    204|            deterministic_only: cfg!(feature = "deterministic"),
  279|    204|
  280|    204|            // on-by-default features
  281|    204|            mutable_global: true,
  282|    204|            saturating_float_to_int: true,
  283|    204|            sign_extension: true,
  284|    204|            bulk_memory: true,
  285|    204|            multi_value: true,
  286|    204|            reference_types: true,
  287|    204|            simd: true,
  288|    204|        }
  289|    204|    }

_RNvMs3_NtCs3hbrbrmFUf_8wasmtime6configNtB5_6Config18native_unwind_info:
  439|    204|    pub fn native_unwind_info(&mut self, enable: bool) -> &mut Self {
  440|    204|        self.native_unwind_info = enable;
  441|    204|        self
  442|    204|    }
_RNvMs3_NtCs3hbrbrmFUf_8wasmtime6configNtB5_6Config16wasm_multi_value:
  736|    408|    pub fn wasm_multi_value(&mut self, enable: bool) -> &mut Self {
  737|    408|        self.features.multi_value = enable;
  738|    408|        self
  739|    408|    }
_RNvMs3_NtCs3hbrbrmFUf_8wasmtime6configNtB5_6Config14build_profiler:
 1471|    204|    pub(crate) fn build_profiler(&self) -> Result<Box<dyn ProfilingAgent>> {
 1472|    204|        Ok(match self.profiling_strategy {
 1473|      0|            ProfilingStrategy::JitDump => Box::new(JitDumpAgent::new()?) as Box<dyn ProfilingAgent>,
 1474|      0|            ProfilingStrategy::VTune => Box::new(VTuneAgent::new()?) as Box<dyn ProfilingAgent>,
 1475|    204|            ProfilingStrategy::None => Box::new(NullProfilerAgent),
 1476|       |        })
 1477|    204|    }
_RNvXs4_NtCs3hbrbrmFUf_8wasmtime6configNtB5_6ConfigNtNtCshM4Il2Z0i4R_4core7default7Default7default:
 1565|    204|    fn default() -> Config {
 1566|    204|        Config::new()
 1567|    204|    }
_RNvMs3_NtCs3hbrbrmFUf_8wasmtime6configNtB5_6Config9wasm_simd:
  699|    408|    pub fn wasm_simd(&mut self, enable: bool) -> &mut Self {
  700|    408|        self.features.simd = enable;
  701|    408|        self
  702|    408|    }
_RNvMs3_NtCs3hbrbrmFUf_8wasmtime6configNtB5_6Config24cranelift_debug_verifier:
  827|    408|    pub fn cranelift_debug_verifier(&mut self, enable: bool) -> &mut Self {
  828|    408|        let val = if enable { "true" } else { "false" };
  829|    408|        self.compiler_config
  830|    408|            .settings
  831|    408|            .insert("enable_verifier".to_string(), val.to_string());
  832|    408|        self
  833|    408|    }
_RNvMs3_NtCs3hbrbrmFUf_8wasmtime6configNtB5_6Config20generate_address_map:
 1302|    204|    pub fn generate_address_map(&mut self, generate: bool) -> &mut Self {
 1303|    204|        self.tunables.generate_address_map = generate;
 1304|    204|        self
 1305|    204|    }
_RNvMs3_NtCs3hbrbrmFUf_8wasmtime6configNtB5_6Config3new:
  169|    204|    pub fn new() -> Self {
  170|    204|        let mut ret = Self {
  171|    204|            tunables: Tunables::default(),
  172|    204|            #[cfg(compiler)]
  173|    204|            compiler_config: CompilerConfig::default(),
  174|    204|            #[cfg(feature = "cache")]
  175|    204|            cache_config: CacheConfig::new_cache_disabled(),
  176|    204|            profiling_strategy: ProfilingStrategy::None,
  177|    204|            mem_creator: None,
  178|    204|            allocation_strategy: InstanceAllocationStrategy::OnDemand,
  179|    204|            // 512k of stack -- note that this is chosen currently to not be too
  180|    204|            // big, not be too small, and be a good default for most platforms.
  181|    204|            // One platform of particular note is Windows where the stack size
  182|    204|            // of the main thread seems to, by default, be smaller than that of
  183|    204|            // Linux and macOS. This 512k value at least lets our current test
  184|    204|            // suite pass on the main thread of Windows (using `--test-threads
  185|    204|            // 1` forces this), or at least it passed when this change was
  186|    204|            // committed.
  187|    204|            max_wasm_stack: 512 * 1024,
  188|    204|            wasm_backtrace: true,
  189|    204|            wasm_backtrace_details_env_used: false,
  190|    204|            native_unwind_info: true,
  191|    204|            features: WasmFeatures::default(),
  192|    204|            #[cfg(feature = "async")]
  193|    204|            async_stack_size: 2 << 20,
  194|    204|            async_support: false,
  195|    204|            module_version: ModuleVersionStrategy::default(),
  196|    204|            parallel_compilation: true,
  197|    204|            memory_init_cow: true,
  198|    204|            memory_guaranteed_dense_image_size: 16 << 20,
  199|    204|            force_memory_init_memfd: false,
  200|    204|            async_stack_zeroing: false,
  201|    204|        };
  202|    204|        #[cfg(compiler)]
  203|    204|        {
  204|    204|            ret.cranelift_debug_verifier(false);
  205|    204|            ret.cranelift_opt_level(OptLevel::Speed);
  206|    204|        }
  207|    204|        ret.wasm_reference_types(true);
  208|    204|        ret.wasm_multi_value(true);
  209|    204|        ret.wasm_bulk_memory(true);
  210|    204|        ret.wasm_simd(true);
  211|    204|        ret.wasm_backtrace_details(WasmBacktraceDetails::Environment);
  212|    204|        ret
  213|    204|    }
_RNvMs3_NtCs3hbrbrmFUf_8wasmtime6configNtB5_6Config14build_compiler:
 1480|    204|    pub(crate) fn build_compiler(&mut self) -> Result<Box<dyn wasmtime_environ::Compiler>> {
 1481|    204|        let mut compiler = match self.compiler_config.strategy {
 1482|    204|            Strategy::Auto | Strategy::Cranelift => wasmtime_cranelift::builder(),
 1483|       |        };
 1484|    204|        if let Some(target) = &self.compiler_config.target {
 1485|      0|            compiler.target(target.clone())?;
 1486|    204|        }
 1487|       |
 1488|    204|        if self.native_unwind_info ||
 1489|       |            // Windows always needs unwind info, since it is part of the ABI.
 1490|    204|            self
 1491|    204|                .compiler_config
 1492|    204|                .target
 1493|    204|                .as_ref()
 1494|    204|                .map_or(cfg!(target_os = "windows"), |target| {
 1495|       |                    target.operating_system == target_lexicon::OperatingSystem::Windows
 1496|    204|                })
 1497|       |        {
 1498|      0|            if !self
 1499|      0|                .compiler_config
 1500|      0|                .ensure_setting_unset_or_given("unwind_info", "true")
 1501|       |            {
 1502|      0|                bail!("compiler option 'unwind_info' must be enabled profiling");
 1503|      0|            }
 1504|    204|        }
 1505|       |
 1506|       |        // We require frame pointers for correct stack walking, which is safety
 1507|       |        // critical in the presence of reference types, and otherwise it is just
 1508|       |        // really bad developer experience to get wrong.
 1509|    204|        self.compiler_config
 1510|    204|            .settings
 1511|    204|            .insert("preserve_frame_pointers".into(), "true".into());
 1512|    204|
 1513|    204|        // check for incompatible compiler options and set required values
 1514|    204|        if self.features.reference_types {
 1515|      0|            if !self
 1516|      0|                .compiler_config
 1517|      0|                .ensure_setting_unset_or_given("enable_safepoints", "true")
 1518|       |            {
 1519|      0|                bail!("compiler option 'enable_safepoints' must be enabled when 'reference types' is enabled");
 1520|      0|            }
 1521|    204|        }
 1522|    204|        if self.features.simd {
 1523|      0|            if !self
 1524|      0|                .compiler_config
 1525|      0|                .ensure_setting_unset_or_given("enable_simd", "true")
 1526|       |            {
 1527|      0|                bail!("compiler option 'enable_simd' must be enabled when 'simd' is enabled");
 1528|      0|            }
 1529|    204|        }
 1530|       |
 1531|       |        // Apply compiler settings and flags
 1532|    816|        for (k, v) in self.compiler_config.settings.iter() {
 1533|    816|            compiler.set(k, v)?;
 1534|       |        }
 1535|    204|        for flag in self.compiler_config.flags.iter() {
 1536|      0|            compiler.enable(flag)?;
 1537|       |        }
 1538|       |
 1539|    204|        if let Some(cache_store) = &self.compiler_config.cache_store {
 1540|      0|            compiler.enable_incremental_compilation(cache_store.clone());
 1541|    204|        }
 1542|       |
 1543|    204|        compiler.build()
 1544|    204|    }
_RNvXs2_NtCs3hbrbrmFUf_8wasmtime6configNtB5_14CompilerConfigNtNtCshM4Il2Z0i4R_4core7default7Default7default:
  161|    204|    fn default() -> Self {
  162|    204|        Self::new(Strategy::Auto)
  163|    204|    }
_RNvMs3_NtCs3hbrbrmFUf_8wasmtime6configNtB5_6Config14max_wasm_stack:
  604|    204|    pub fn max_wasm_stack(&mut self, size: usize) -> &mut Self {
  605|    204|        self.max_wasm_stack = size;
  606|    204|        self
  607|    204|    }
_RNvMs3_NtCs3hbrbrmFUf_8wasmtime6configNtB5_6Config19cranelift_opt_level:
  844|    408|    pub fn cranelift_opt_level(&mut self, level: OptLevel) -> &mut Self {
  845|    408|        let val = match level {
  846|      0|            OptLevel::None => "none",
  847|    408|            OptLevel::Speed => "speed",
  848|      0|            OptLevel::SpeedAndSize => "speed_and_size",
  849|       |        };
  850|    408|        self.compiler_config
  851|    408|            .settings
  852|    408|            .insert("opt_level".to_string(), val.to_string());
  853|    408|        self
  854|    408|    }
_RNvXs6_NtCs3hbrbrmFUf_8wasmtime6configNtB5_26InstanceAllocationStrategyNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
   23|    204|#[derive(Clone)]
_RNvXsa_NtCs3hbrbrmFUf_8wasmtime6configNtB5_14CompilerConfigNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
  117|    204|#[derive(Debug, Clone)]
_RNvMs3_NtCs3hbrbrmFUf_8wasmtime6configNtB5_6Config26guard_before_linear_memory:
 1257|    204|    pub fn guard_before_linear_memory(&mut self, guard: bool) -> &mut Self {
 1258|    204|        self.tunables.guard_before_linear_memory = guard;
 1259|    204|        self
 1260|    204|    }
_RNvMs3_NtCs3hbrbrmFUf_8wasmtime6configNtB5_6Config19allocation_strategy:
  994|    204|    pub fn allocation_strategy(&mut self, strategy: InstanceAllocationStrategy) -> &mut Self {
  995|    204|        self.allocation_strategy = strategy;
  996|    204|        self
  997|    204|    }
_RNvMs3_NtCs3hbrbrmFUf_8wasmtime6configNtB5_6Config20wasm_reference_types:
  678|    408|    pub fn wasm_reference_types(&mut self, enable: bool) -> &mut Self {
  679|    408|        self.features.reference_types = enable;
  680|    408|        self
  681|    408|    }
_RNvMs3_NtCs3hbrbrmFUf_8wasmtime6configNtB5_6Config12wasm_threads:
  657|    204|    pub fn wasm_threads(&mut self, enable: bool) -> &mut Self {
  658|    204|        self.features.threads = enable;
  659|    204|        self
  660|    204|    }
_RNvXs8_NtCs3hbrbrmFUf_8wasmtime6configNtB5_6ConfigNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
   88|    204|#[derive(Clone)]
_RNvXsb_NtCs3hbrbrmFUf_8wasmtime6configNtB5_8StrategyNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
 1610|    204|#[derive(Clone, Debug, Copy)]
_RNvMs3_NtCs3hbrbrmFUf_8wasmtime6configNtB5_6Config20parallel_compilation:
 1288|    204|    pub fn parallel_compilation(&mut self, parallel: bool) -> &mut Self {
 1289|    204|        self.parallel_compilation = parallel;
 1290|    204|        self
 1291|    204|    }
_RNvMs3_NtCs3hbrbrmFUf_8wasmtime6configNtB5_6Config18epoch_interruption:
  553|    204|    pub fn epoch_interruption(&mut self, enable: bool) -> &mut Self {
  554|    204|        self.tunables.epoch_interruption = enable;
  555|    204|        self
  556|    204|    }
_RNvMs3_NtCs3hbrbrmFUf_8wasmtime6configNtB5_6Config17wasm_multi_memory:
  750|    204|    pub fn wasm_multi_memory(&mut self, enable: bool) -> &mut Self {
  751|    204|        self.features.multi_memory = enable;
  752|    204|        self
  753|    204|    }
_RNvMs3_NtCs3hbrbrmFUf_8wasmtime6configNtB5_6Config26static_memory_maximum_size:
 1087|    204|    pub fn static_memory_maximum_size(&mut self, max_size: u64) -> &mut Self {
 1088|    204|        let max_pages = max_size / u64::from(wasmtime_environ::WASM_PAGE_SIZE);
 1089|    204|        self.tunables.static_memory_bound = max_pages;
 1090|    204|        self
 1091|    204|    }
_RNvXs7_NtCs3hbrbrmFUf_8wasmtime6configNtB5_21ModuleVersionStrategyNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
   63|    204|#[derive(Clone)]
_RNvMs3_NtCs3hbrbrmFUf_8wasmtime6configNtB5_6Config15build_allocator:
 1445|    204|    pub(crate) fn build_allocator(&self) -> Result<Box<dyn InstanceAllocator>> {
 1446|    204|        #[cfg(feature = "async")]
 1447|    204|        let stack_size = self.async_stack_size;
 1448|    204|
 1449|    204|        #[cfg(not(feature = "async"))]
 1450|    204|        let stack_size = 0;
 1451|    204|
 1452|    204|        match self.allocation_strategy {
 1453|      0|            InstanceAllocationStrategy::OnDemand => Ok(Box::new(OnDemandInstanceAllocator::new(
 1454|      0|                self.mem_creator.clone(),
 1455|      0|                stack_size,
 1456|      0|            ))),
 1457|       |            #[cfg(feature = "pooling-allocator")]
 1458|       |            InstanceAllocationStrategy::Pooling {
 1459|    204|                strategy,
 1460|    204|                instance_limits,
 1461|    204|            } => Ok(Box::new(wasmtime_runtime::PoolingInstanceAllocator::new(
 1462|    204|                strategy,
 1463|    204|                instance_limits,
 1464|    204|                stack_size,
 1465|    204|                &self.tunables,
 1466|    204|                self.async_stack_zeroing,
 1467|    204|            )?)),
 1468|       |        }
 1469|    204|    }
_RNvMs3_NtCs3hbrbrmFUf_8wasmtime6configNtB5_6Config14wasm_backtrace:
  395|    204|    pub fn wasm_backtrace(&mut self, enable: bool) -> &mut Self {
  396|    204|        self.wasm_backtrace = enable;
  397|    204|        self
  398|    204|    }
_RNvMs3_NtCs3hbrbrmFUf_8wasmtime6configNtB5_6Config13wasm_memory64:
  765|    204|    pub fn wasm_memory64(&mut self, enable: bool) -> &mut Self {
  766|    204|        self.features.memory64 = enable;
  767|    204|        self
  768|    204|    }
_RNvMs3_NtCs3hbrbrmFUf_8wasmtime6configNtB5_6Config12consume_fuel:
  459|    204|    pub fn consume_fuel(&mut self, enable: bool) -> &mut Self {
  460|    204|        self.tunables.consume_fuel = enable;
  461|    204|        self
  462|    204|    }
_RNvMs3_NtCs3hbrbrmFUf_8wasmtime6configNtB5_6Config8validate:
 1422|    204|    pub(crate) fn validate(&self) -> Result<()> {
 1423|    204|        if self.features.reference_types && !self.features.bulk_memory {
 1424|      0|            bail!("feature 'reference_types' requires 'bulk_memory' to be enabled");
 1425|    204|        }
 1426|    204|        if self.features.threads && !self.features.bulk_memory {
 1427|      0|            bail!("feature 'threads' requires 'bulk_memory' to be enabled");
 1428|    204|        }
 1429|    204|        #[cfg(feature = "async")]
 1430|    204|        if self.max_wasm_stack > self.async_stack_size {
 1431|    204|            bail!("max_wasm_stack size cannot exceed the async_stack_size");
 1432|    204|        }
 1433|    204|        if self.max_wasm_stack == 0 {
 1434|      0|            bail!("max_wasm_stack size cannot be zero");
 1435|    204|        }
 1436|    204|        if self.tunables.static_memory_offset_guard_size
 1437|    204|            < self.tunables.dynamic_memory_offset_guard_size
 1438|       |        {
 1439|      0|            bail!("static memory guard size cannot be smaller than dynamic memory guard size");
 1440|    204|        }
 1441|    204|
 1442|    204|        Ok(())
 1443|    204|    }
_RNvMs1_NtCs3hbrbrmFUf_8wasmtime6configNtB5_14CompilerConfig3new:
  129|    204|    fn new(strategy: Strategy) -> Self {
  130|    204|        Self {
  131|    204|            strategy,
  132|    204|            target: None,
  133|    204|            settings: HashMap::new(),
  134|    204|            flags: HashSet::new(),
  135|    204|            cache_store: None,
  136|    204|        }
  137|    204|    }
_RNvMs3_NtCs3hbrbrmFUf_8wasmtime6configNtB5_6Config22wasm_backtrace_details:
  411|    204|    pub fn wasm_backtrace_details(&mut self, enable: WasmBacktraceDetails) -> &mut Self {
  412|    204|        self.wasm_backtrace_details_env_used = false;
  413|    204|        self.tunables.parse_wasm_debuginfo = match enable {
  414|      0|            WasmBacktraceDetails::Enable => true,
  415|      0|            WasmBacktraceDetails::Disable => false,
  416|       |            WasmBacktraceDetails::Environment => {
  417|    204|                self.wasm_backtrace_details_env_used = true;
  418|    204|                std::env::var("WASMTIME_BACKTRACE_DETAILS")
  419|    204|                    .map(|s| s == "1")
  420|    204|                    .unwrap_or(false)
  421|       |            }
  422|       |        };
  423|    204|        self
  424|    204|    }
_RNvXs0_NtCs3hbrbrmFUf_8wasmtime6configNtB5_21ModuleVersionStrategyNtNtCshM4Il2Z0i4R_4core7default7Default7default:
   75|    204|    fn default() -> Self {
   76|    204|        ModuleVersionStrategy::WasmtimeVersion
   77|    204|    }
_RNvMs3_NtCs3hbrbrmFUf_8wasmtime6configNtB5_6Config10debug_info:
  379|    204|    pub fn debug_info(&mut self, enable: bool) -> &mut Self {
  380|    204|        self.tunables.generate_native_debuginfo = enable;
  381|    204|        self
  382|    204|    }
_RNvMs3_NtCs3hbrbrmFUf_8wasmtime6configNtB5_6Config16wasm_bulk_memory:
  722|    408|    pub fn wasm_bulk_memory(&mut self, enable: bool) -> &mut Self {
  723|    408|        self.features.bulk_memory = enable;
  724|    408|        self
  725|    408|    }
_RNvMs3_NtCs3hbrbrmFUf_8wasmtime6configNtB5_6Config30cranelift_nan_canonicalization:
  866|    204|    pub fn cranelift_nan_canonicalization(&mut self, enable: bool) -> &mut Self {
  867|    204|        let val = if enable { "true" } else { "false" };
  868|    204|        self.compiler_config
  869|    204|            .settings
  870|    204|            .insert("enable_nan_canonicalization".to_string(), val.to_string());
  871|    204|        self
  872|    204|    }
_RNvXsl_NtCs3hbrbrmFUf_8wasmtime6configNtB5_17ProfilingStrategyNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
 1643|    204|#[derive(Debug, Clone, Copy)]
_RNvMs3_NtCs3hbrbrmFUf_8wasmtime6configNtB5_6Config15memory_init_cow:
 1348|    204|    pub fn memory_init_cow(&mut self, enable: bool) -> &mut Self {
 1349|    204|        self.memory_init_cow = enable;
 1350|    204|        self
 1351|    204|    }

_RNvMNtCs3hbrbrmFUf_8wasmtime6engineNtB2_6Engine6config:
  126|    408|    pub fn config(&self) -> &Config {
  127|    408|        &self.inner.config
  128|    408|    }
_RNvXs0_NtCs3hbrbrmFUf_8wasmtime6engineNtB5_6EngineNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
   37|    204|#[derive(Clone)]
_RNvMNtCs3hbrbrmFUf_8wasmtime6engineNtB2_6Engine3new:
   70|    204|    pub fn new(config: &Config) -> Result<Engine> {
   71|    204|        // Ensure that wasmtime_runtime's signal handlers are configured. This
   72|    204|        // is the per-program initialization required for handling traps, such
   73|    204|        // as configuring signals, vectored exception handlers, etc.
   74|    204|        wasmtime_runtime::init_traps(crate::module::is_wasm_trap_pc);
   75|    204|        debug_builtins::ensure_exported();
   76|    204|
   77|    204|        let registry = SignatureRegistry::new();
   78|    204|        let mut config = config.clone();
   79|    204|        config.validate()?;
   80|       |
   81|       |        #[cfg(compiler)]
   82|    204|        let compiler = config.build_compiler()?;
   83|       |
   84|    204|        let allocator = config.build_allocator()?;
   85|    204|        allocator.adjust_tunables(&mut config.tunables);
   86|    204|        let profiler = config.build_profiler()?;
   87|       |
   88|    204|        Ok(Engine {
   89|    204|            inner: Arc::new(EngineInner {
   90|    204|                #[cfg(compiler)]
   91|    204|                compiler,
   92|    204|                config,
   93|    204|                allocator,
   94|    204|                profiler,
   95|    204|                signatures: registry,
   96|    204|                epoch: AtomicU64::new(0),
   97|    204|                unique_id_allocator: CompiledModuleIdAllocator::new(),
   98|    204|                compatible_with_native_host: OnceCell::new(),
   99|    204|            }),
  100|    204|        })
  101|    204|    }
_RNvMNtCs3hbrbrmFUf_8wasmtime6engineNtB2_6Engine13epoch_counter:
  157|    612|    pub(crate) fn epoch_counter(&self) -> &AtomicU64 {
  158|    612|        &self.inner.epoch
  159|    612|    }
_RNvMNtCs3hbrbrmFUf_8wasmtime6engineNtB2_6Engine9allocator:
  135|    204|    pub(crate) fn allocator(&self) -> &dyn InstanceAllocator {
  136|    204|        self.inner.allocator.as_ref()
  137|    204|    }

_RINvMs4_NtCs3hbrbrmFUf_8wasmtime9externalsNtB6_6Global3newQINtNtB8_5store5StoreuEECs7Ei498kZF3p_3fvm:
  244|    204|    pub fn new(mut store: impl AsContextMut, ty: GlobalType, val: Val) -> Result<Global> {
  245|    204|        Global::_new(store.as_context_mut().0, ty, val)
  246|    204|    }
_RNvMs4_NtCs3hbrbrmFUf_8wasmtime9externalsNtB5_6Global4__new:
  248|    204|    fn _new(store: &mut StoreOpaque, ty: GlobalType, val: Val) -> Result<Global> {
  249|    204|        if !val.comes_from_same_store(store) {
  250|      0|            bail!("cross-`Store` globals are not supported");
  251|    204|        }
  252|    204|        if val.ty() != *ty.content() {
  253|      0|            bail!("value provided does not match the type of this global");
  254|    204|        }
  255|       |        unsafe {
  256|    204|            let wasmtime_export = generate_global_export(store, &ty, val)?;
  257|    204|            Ok(Global::from_wasmtime_global(wasmtime_export, store))
  258|       |        }
  259|    204|    }
_RNvMs4_NtCs3hbrbrmFUf_8wasmtime9externalsNtB5_6Global20from_wasmtime_global:
  346|    204|    pub(crate) unsafe fn from_wasmtime_global(
  347|    204|        wasmtime_export: wasmtime_runtime::ExportGlobal,
  348|    204|        store: &mut StoreOpaque,
  349|    204|    ) -> Global {
  350|    204|        Global(store.store_data_mut().insert(wasmtime_export))
  351|    204|    }

_RINvMs0_NtCs3hbrbrmFUf_8wasmtime6memoryNtB6_6Memory3newQINtNtB8_5store5StoreuEECs7Ei498kZF3p_3fvm:
  231|    204|    pub fn new(mut store: impl AsContextMut, ty: MemoryType) -> Result<Memory> {
  232|    204|        Self::_new(store.as_context_mut().0, ty)
  233|    204|    }
_RNvMs0_NtCs3hbrbrmFUf_8wasmtime6memoryNtB5_6Memory20from_wasmtime_memory:
  550|    204|    pub(crate) unsafe fn from_wasmtime_memory(
  551|    204|        wasmtime_export: wasmtime_runtime::ExportMemory,
  552|    204|        store: &mut StoreOpaque,
  553|    204|    ) -> Memory {
  554|    204|        Memory(store.store_data_mut().insert(wasmtime_export))
  555|    204|    }
_RNvMs0_NtCs3hbrbrmFUf_8wasmtime6memoryNtB5_6Memory4__new:
  261|    204|    fn _new(store: &mut StoreOpaque, ty: MemoryType) -> Result<Memory> {
  262|       |        unsafe {
  263|    204|            let export = generate_memory_export(store, &ty, None)?;
  264|    204|            Ok(Memory::from_wasmtime_memory(export, store))
  265|       |        }
  266|    204|    }

_RNvMs3_NtCs3hbrbrmFUf_8wasmtime6moduleNtB5_14BareModuleInfo13into_traitobj:
 1029|    612|    pub(crate) fn into_traitobj(self) -> Arc<dyn wasmtime_runtime::ModuleRuntimeInfo> {
 1030|    612|        Arc::new(self)
 1031|    612|    }
_RNvMs3_NtCs3hbrbrmFUf_8wasmtime6moduleNtB5_14BareModuleInfo19maybe_imported_func:
 1017|    408|    pub(crate) fn maybe_imported_func(
 1018|    408|        module: Arc<wasmtime_environ::Module>,
 1019|    408|        one_signature: Option<(SignatureIndex, VMSharedSignatureIndex)>,
 1020|    408|    ) -> Self {
 1021|    408|        BareModuleInfo {
 1022|    408|            module,
 1023|    408|            image_base: 0,
 1024|    408|            one_signature,
 1025|    408|            function_info: PrimaryMap::default(),
 1026|    408|        }
 1027|    408|    }
_RNvMs3_NtCs3hbrbrmFUf_8wasmtime6moduleNtB5_14BareModuleInfo5empty:
 1008|    204|    pub(crate) fn empty(module: Arc<wasmtime_environ::Module>) -> Self {
 1009|    204|        BareModuleInfo {
 1010|    204|            module,
 1011|    204|            image_base: 0,
 1012|    204|            one_signature: None,
 1013|    204|            function_info: PrimaryMap::default(),
 1014|    204|        }
 1015|    204|    }
_RNvXs4_NtCs3hbrbrmFUf_8wasmtime6moduleNtB5_14BareModuleInfoNtCsa8j9dqGMVk5_16wasmtime_runtime17ModuleRuntimeInfo13signature_ids:
 1067|    612|    fn signature_ids(&self) -> &[VMSharedSignatureIndex] {
 1068|    612|        match &self.one_signature {
 1069|      0|            Some((_, id)) => std::slice::from_ref(id),
 1070|    612|            None => &[],
 1071|       |        }
 1072|    612|    }
_RNvXs4_NtCs3hbrbrmFUf_8wasmtime6moduleNtB5_14BareModuleInfoNtCsa8j9dqGMVk5_16wasmtime_runtime17ModuleRuntimeInfo6module:
 1035|  4.28k|    fn module(&self) -> &Arc<wasmtime_environ::Module> {
 1036|  4.28k|        &self.module
 1037|  4.28k|    }

_RNvXs_NtNtCs3hbrbrmFUf_8wasmtime6module8registryNtB4_14ModuleRegistryNtNtCshM4Il2Z0i4R_4core7default7Default7default:
   28|    204|#[derive(Default)]

_RNvMs2_NtCs3hbrbrmFUf_8wasmtime10signaturesNtB5_17SignatureRegistry3new:
  217|    204|    pub fn new() -> Self {
  218|    204|        Self(Arc::new(RwLock::new(SignatureRegistryInner::default())))
  219|    204|    }
_RNvXs6_NtCs3hbrbrmFUf_8wasmtime10signaturesNtB5_22SignatureRegistryInnerNtNtCshM4Il2Z0i4R_4core7default7Default7default:
   80|    204|#[derive(Debug, Default)]
_RNvXs1_NtCs3hbrbrmFUf_8wasmtime10signaturesNtB5_22SignatureRegistryInnerNtNtNtCshM4Il2Z0i4R_4core3ops4drop4Drop4drop:
  198|    204|    fn drop(&mut self) {
  199|    204|        assert!(
  200|    204|            self.map.is_empty() && self.free.len() == self.entries.len(),
  201|      0|            "signature registry not empty"
  202|       |        );
  203|    204|    }

_RNvMs9_NtCs3hbrbrmFUf_8wasmtime5storeNtB5_11StoreOpaque14store_data_mut:
 1167|    408|    pub fn store_data_mut(&mut self) -> &mut StoreData {
 1168|    408|        &mut self.store_data
 1169|    408|    }
_RNvMs9_NtCs3hbrbrmFUf_8wasmtime5storeNtB5_11StoreOpaque16vmruntime_limits:
 1452|    612|    pub fn vmruntime_limits(&self) -> *mut VMRuntimeLimits {
 1453|    612|        &self.runtime_limits as *const VMRuntimeLimits as *mut VMRuntimeLimits
 1454|    612|    }
_RNvMs9_NtCs3hbrbrmFUf_8wasmtime5storeNtB5_11StoreOpaque6engine:
 1157|    408|    pub fn engine(&self) -> &Engine {
 1158|    408|        &self.engine
 1159|    408|    }
_RNvXsb_NtCs3hbrbrmFUf_8wasmtime5storeINtB5_10StoreInneruENtCsa8j9dqGMVk5_16wasmtime_runtime5Store9epoch_ptrCs7Ei498kZF3p_3fvm:
 1797|    612|    fn epoch_ptr(&self) -> *const AtomicU64 {
 1798|    612|        self.engine.epoch_counter() as *const _
 1799|    612|    }
_RNvMs5_NtCs3hbrbrmFUf_8wasmtime5storeINtB5_5StoreuE3newCs7Ei498kZF3p_3fvm:
  450|    204|    pub fn new(engine: &Engine, data: T) -> Self {
  451|    204|        // Wasmtime uses the callee argument to host functions to learn about
  452|    204|        // the original pointer to the `Store` itself, allowing it to
  453|    204|        // reconstruct a `StoreContextMut<T>`. When we initially call a `Func`,
  454|    204|        // however, there's no "callee" to provide. To fix this we allocate a
  455|    204|        // single "default callee" for the entire `Store`. This is then used as
  456|    204|        // part of `Func::call` to guarantee that the `callee: *mut VMContext`
  457|    204|        // is never null.
  458|    204|        let default_callee = unsafe {
  459|    204|            let module = Arc::new(wasmtime_environ::Module::default());
  460|    204|            let shim = BareModuleInfo::empty(module).into_traitobj();
  461|    204|            OnDemandInstanceAllocator::default()
  462|    204|                .allocate(InstanceAllocationRequest {
  463|    204|                    host_state: Box::new(()),
  464|    204|                    imports: Default::default(),
  465|    204|                    store: StorePtr::empty(),
  466|    204|                    runtime_info: &shim,
  467|    204|                })
  468|    204|                .expect("failed to allocate default callee")
  469|    204|        };
  470|    204|
  471|    204|        let mut inner = Box::new(StoreInner {
  472|    204|            inner: StoreOpaque {
  473|    204|                _marker: marker::PhantomPinned,
  474|    204|                engine: engine.clone(),
  475|    204|                runtime_limits: Default::default(),
  476|    204|                instances: Vec::new(),
  477|    204|                signal_handler: None,
  478|    204|                externref_activations_table: VMExternRefActivationsTable::new(),
  479|    204|                modules: ModuleRegistry::default(),
  480|    204|                host_trampolines: HashMap::default(),
  481|    204|                host_func_trampolines_registered: 0,
  482|    204|                instance_count: 0,
  483|    204|                instance_limit: crate::DEFAULT_INSTANCE_LIMIT,
  484|    204|                memory_count: 0,
  485|    204|                memory_limit: crate::DEFAULT_MEMORY_LIMIT,
  486|    204|                table_count: 0,
  487|    204|                table_limit: crate::DEFAULT_TABLE_LIMIT,
  488|    204|                fuel_adj: 0,
  489|    204|                #[cfg(feature = "async")]
  490|    204|                async_state: AsyncState {
  491|    204|                    current_suspend: UnsafeCell::new(ptr::null()),
  492|    204|                    current_poll_cx: UnsafeCell::new(ptr::null_mut()),
  493|    204|                },
  494|    204|                out_of_gas_behavior: OutOfGas::Trap,
  495|    204|                store_data: ManuallyDrop::new(StoreData::new()),
  496|    204|                default_caller: default_callee,
  497|    204|                hostcall_val_storage: Vec::new(),
  498|    204|                wasm_val_raw_storage: Vec::new(),
  499|    204|                rooted_host_funcs: ManuallyDrop::new(Vec::new()),
  500|    204|            },
  501|    204|            limiter: None,
  502|    204|            call_hook: None,
  503|    204|            epoch_deadline_behavior: EpochDeadline::Trap,
  504|    204|            data: ManuallyDrop::new(data),
  505|    204|        });
  506|    204|
  507|    204|        // Once we've actually allocated the store itself we can configure the
  508|    204|        // trait object pointer of the default callee. Note the erasure of the
  509|    204|        // lifetime here into `'static`, so in general usage of this trait
  510|    204|        // object must be strictly bounded to the `Store` itself, and is a
  511|    204|        // variant that we have to maintain throughout Wasmtime.
  512|    204|        unsafe {
  513|    204|            let traitobj = std::mem::transmute::<
  514|    204|                *mut (dyn wasmtime_runtime::Store + '_),
  515|    204|                *mut (dyn wasmtime_runtime::Store + 'static),
  516|    204|            >(&mut *inner);
  517|    204|            inner.default_caller.set_store(traitobj);
  518|    204|        }
  519|    204|
  520|    204|        Self {
  521|    204|            inner: ManuallyDrop::new(inner),
  522|    204|        }
  523|    204|    }
_RNvXsb_NtCs3hbrbrmFUf_8wasmtime5storeINtB5_10StoreInneruENtCsa8j9dqGMVk5_16wasmtime_runtime5Store16vmruntime_limitsCs7Ei498kZF3p_3fvm:
 1793|    612|    fn vmruntime_limits(&self) -> *mut VMRuntimeLimits {
 1794|    612|        <StoreOpaque>::vmruntime_limits(self)
 1795|    612|    }
_RNvXsf_NtCs3hbrbrmFUf_8wasmtime5storeINtB5_5StoreuENtNtNtCshM4Il2Z0i4R_4core3ops4drop4Drop4dropCs7Ei498kZF3p_3fvm:
 2026|    204|    fn drop(&mut self) {
 2027|    204|        // for documentation on this `unsafe`, see `into_data`.
 2028|    204|        unsafe {
 2029|    204|            ManuallyDrop::drop(&mut self.inner.data);
 2030|    204|            ManuallyDrop::drop(&mut self.inner);
 2031|    204|        }
 2032|    204|    }
_RNvXsb_NtCs3hbrbrmFUf_8wasmtime5storeINtB5_10StoreInneruENtCsa8j9dqGMVk5_16wasmtime_runtime5Store27externref_activations_tableCs7Ei498kZF3p_3fvm:
 1801|    612|    fn externref_activations_table(
 1802|    612|        &mut self,
 1803|    612|    ) -> (
 1804|    612|        &mut VMExternRefActivationsTable,
 1805|    612|        &dyn wasmtime_runtime::ModuleInfoLookup,
 1806|    612|    ) {
 1807|    612|        let inner = &mut self.inner;
 1808|    612|        (&mut inner.externref_activations_table, &inner.modules)
 1809|    612|    }
_RNvXs0_NtCs3hbrbrmFUf_8wasmtime5storeINtB5_10StoreInneruENtNtNtCshM4Il2Z0i4R_4core3ops5deref8DerefMut9deref_mutCs7Ei498kZF3p_3fvm:
  240|    612|    fn deref_mut(&mut self) -> &mut Self::Target {
  241|    612|        &mut self.inner
  242|    612|    }
_RNvXsb_NtCs3hbrbrmFUf_8wasmtime5storeINtB5_10StoreInneruENtCsa8j9dqGMVk5_16wasmtime_runtime5Store14memory_growingCs7Ei498kZF3p_3fvm:
 1811|    204|    fn memory_growing(
 1812|    204|        &mut self,
 1813|    204|        current: usize,
 1814|    204|        desired: usize,
 1815|    204|        maximum: Option<usize>,
 1816|    204|    ) -> Result<bool, anyhow::Error> {
 1817|    204|        match self.limiter {
 1818|      0|            Some(ResourceLimiterInner::Sync(ref mut limiter)) => {
 1819|      0|                Ok(limiter(&mut self.data).memory_growing(current, desired, maximum))
 1820|       |            }
 1821|       |            #[cfg(feature = "async")]
 1822|       |            Some(ResourceLimiterInner::Async(ref mut limiter)) => unsafe {
 1823|       |                Ok(self
 1824|       |                    .inner
 1825|       |                    .async_cx()
 1826|       |                    .expect("ResourceLimiterAsync requires async Store")
 1827|       |                    .block_on(
 1828|       |                        limiter(&mut self.data)
 1829|       |                            .memory_growing(current, desired, maximum)
 1830|       |                            .as_mut(),
 1831|       |                    )?)
 1832|       |            },
 1833|    204|            None => Ok(true),
 1834|       |        }
 1835|    204|    }
_RNvXs_NtCs3hbrbrmFUf_8wasmtime5storeINtB4_10StoreInneruENtNtNtCshM4Il2Z0i4R_4core3ops5deref5Deref5derefCs7Ei498kZF3p_3fvm:
  234|  1.22k|    fn deref(&self) -> &Self::Target {
  235|  1.22k|        &self.inner
  236|  1.22k|    }
_RNvMs9_NtCs3hbrbrmFUf_8wasmtime5storeNtB5_11StoreOpaque8traitobj:
 1465|    612|    pub fn traitobj(&self) -> *mut dyn wasmtime_runtime::Store {
 1466|    612|        self.default_caller.store()
 1467|    612|    }
_RNvMs9_NtCs3hbrbrmFUf_8wasmtime5storeNtB5_11StoreOpaque12instance_mut:
 1193|    408|    pub fn instance_mut(&mut self, id: InstanceId) -> &mut InstanceHandle {
 1194|    408|        &mut self.instances[id.0].handle
 1195|    408|    }
_RNvMs9_NtCs3hbrbrmFUf_8wasmtime5storeNtB5_11StoreOpaque12add_instance:
 1181|    408|    pub unsafe fn add_instance(&mut self, handle: InstanceHandle, ondemand: bool) -> InstanceId {
 1182|    408|        self.instances.push(StoreInstance {
 1183|    408|            handle: handle.clone(),
 1184|    408|            ondemand,
 1185|    408|        });
 1186|    408|        InstanceId(self.instances.len() - 1)
 1187|    408|    }
_RNvXsg_NtCs3hbrbrmFUf_8wasmtime5storeNtB5_11StoreOpaqueNtNtNtCshM4Il2Z0i4R_4core3ops4drop4Drop4drop:
 2036|    204|    fn drop(&mut self) {
 2037|    204|        // NB it's important that this destructor does not access `self.data`.
 2038|    204|        // That is deallocated by `Drop for Store<T>` above.
 2039|    204|
 2040|    204|        unsafe {
 2041|    204|            let allocator = self.engine.allocator();
 2042|    204|            let ondemand = OnDemandInstanceAllocator::default();
 2043|    408|            for instance in self.instances.iter() {
 2044|    408|                if instance.ondemand {
 2045|    408|                    ondemand.deallocate(&instance.handle);
 2046|    408|                } else {
 2047|      0|                    allocator.deallocate(&instance.handle);
 2048|      0|                }
 2049|       |            }
 2050|    204|            ondemand.deallocate(&self.default_caller);
 2051|    204|
 2052|    204|            // See documentation for these fields on `StoreOpaque` for why they
 2053|    204|            // must be dropped in this order.
 2054|    204|            ManuallyDrop::drop(&mut self.store_data);
 2055|    204|            ManuallyDrop::drop(&mut self.rooted_host_funcs);
 2056|    204|        }
 2057|    204|    }

_RNvXs9_NtNtCs3hbrbrmFUf_8wasmtime5store7contextQINtB7_5StoreuENtB5_12AsContextMut14as_context_mutCs7Ei498kZF3p_3fvm:
  214|    408|    fn as_context_mut(&mut self) -> StoreContextMut<'_, T::Data> {
  215|    408|        T::as_context_mut(*self)
  216|    408|    }
_RNvXs0_NtNtCs3hbrbrmFUf_8wasmtime5store7contextINtB7_5StoreuENtB5_12AsContextMut14as_context_mutCs7Ei498kZF3p_3fvm:
  134|    408|    fn as_context_mut(&mut self) -> StoreContextMut<'_, T> {
  135|    408|        StoreContextMut(&mut self.inner)
  136|    408|    }

_RNvXsf_NtNtCs3hbrbrmFUf_8wasmtime5store4dataNtNtCsa8j9dqGMVk5_16wasmtime_runtime6export12ExportGlobalNtB5_10StoredData8list_mut:
   38|    204|            fn list_mut(data: &mut StoreData) -> &mut Vec<Self> { &mut data.$field }
_RNvMs6_NtNtCs3hbrbrmFUf_8wasmtime5store4dataINtB5_6StoredNtNtCsa8j9dqGMVk5_16wasmtime_runtime6export12ExportMemoryE3newB9_:
  238|    204|    fn new(store_id: StoreId, index: usize) -> Stored<T> {
  239|    204|        Stored {
  240|    204|            store_id,
  241|    204|            index,
  242|    204|            _marker: marker::PhantomData,
  243|    204|        }
  244|    204|    }
_RNvMs5_NtNtCs3hbrbrmFUf_8wasmtime5store4dataNtB5_7StoreId8allocate:
  200|    204|    fn allocate() -> StoreId {
  201|    204|        static NEXT_ID: AtomicU64 = AtomicU64::new(0);
  202|    204|
  203|    204|        // Only allow 2^63 stores at which point we start panicking to prevent
  204|    204|        // overflow.
  205|    204|        //
  206|    204|        // If a store is created once per microsecond then this will last the
  207|    204|        // current process for 584,540 years before overflowing.
  208|    204|        //
  209|    204|        // Also note the usage of `Relaxed` ordering here which should be ok
  210|    204|        // since we're only looking for atomicity on this counter and this
  211|    204|        // otherwise isn't used to synchronize memory stored anywhere else.
  212|    204|        let id = NEXT_ID.fetch_add(1, Relaxed);
  213|    204|        if id & (1 << 63) != 0 {
  214|      0|            NEXT_ID.store(1 << 63, Relaxed);
  215|      0|            panic!("store id allocator overflow");
  216|    204|        }
  217|    204|
  218|    204|        StoreId(NonZeroU64::new(id + 1).unwrap())
  219|    204|    }
_RINvMNtNtCs3hbrbrmFUf_8wasmtime5store4dataNtB3_9StoreData6insertNtNtCsa8j9dqGMVk5_16wasmtime_runtime6export12ExportGlobalEB7_:
   69|    204|    pub fn insert<T>(&mut self, data: T) -> Stored<T>
   70|    204|    where
   71|    204|        T: StoredData,
   72|    204|    {
   73|    204|        let list = T::list_mut(self);
   74|    204|        let index = list.len();
   75|    204|        list.push(data);
   76|    204|        Stored::new(self.id, index)
   77|    204|    }
_RNvMNtNtCs3hbrbrmFUf_8wasmtime5store4dataNtB2_9StoreData3new:
   52|    204|    pub fn new() -> StoreData {
   53|    204|        StoreData {
   54|    204|            id: StoreId::allocate(),
   55|    204|            funcs: Vec::new(),
   56|    204|            tables: Vec::new(),
   57|    204|            globals: Vec::new(),
   58|    204|            instances: Vec::new(),
   59|    204|            memories: Vec::new(),
   60|    204|            #[cfg(feature = "component-model")]
   61|    204|            components: Default::default(),
   62|    204|        }
   63|    204|    }
_RNvXsh_NtNtCs3hbrbrmFUf_8wasmtime5store4dataNtNtCsa8j9dqGMVk5_16wasmtime_runtime6export12ExportMemoryNtB5_10StoredData8list_mut:
   38|    204|            fn list_mut(data: &mut StoreData) -> &mut Vec<Self> { &mut data.$field }
_RNvMs6_NtNtCs3hbrbrmFUf_8wasmtime5store4dataINtB5_6StoredNtNtCsa8j9dqGMVk5_16wasmtime_runtime6export12ExportGlobalE3newB9_:
  238|    204|    fn new(store_id: StoreId, index: usize) -> Stored<T> {
  239|    204|        Stored {
  240|    204|            store_id,
  241|    204|            index,
  242|    204|            _marker: marker::PhantomData,
  243|    204|        }
  244|    204|    }
_RINvMNtNtCs3hbrbrmFUf_8wasmtime5store4dataNtB3_9StoreData6insertNtNtCsa8j9dqGMVk5_16wasmtime_runtime6export12ExportMemoryEB7_:
   69|    204|    pub fn insert<T>(&mut self, data: T) -> Stored<T>
   70|    204|    where
   71|    204|        T: StoredData,
   72|    204|    {
   73|    204|        let list = T::list_mut(self);
   74|    204|        let index = list.len();
   75|    204|        list.push(data);
   76|    204|        Stored::new(self.id, index)
   77|    204|    }

_RNvNtCs3hbrbrmFUf_8wasmtime10trampoline22generate_memory_export:
   68|    204|pub fn generate_memory_export(
   69|    204|    store: &mut StoreOpaque,
   70|    204|    m: &MemoryType,
   71|    204|    preallocation: Option<SharedMemory>,
   72|    204|) -> Result<wasmtime_runtime::ExportMemory> {
   73|    204|    let instance = create_memory(store, m, preallocation)?;
   74|    204|    Ok(store
   75|    204|        .instance_mut(instance)
   76|    204|        .get_exported_memory(MemoryIndex::from_u32(0)))
   77|    204|}
_RNvNtCs3hbrbrmFUf_8wasmtime10trampoline13create_handle:
   26|    204|fn create_handle(
   27|    204|    module: Module,
   28|    204|    store: &mut StoreOpaque,
   29|    204|    host_state: Box<dyn Any + Send + Sync>,
   30|    204|    func_imports: &[VMFunctionImport],
   31|    204|    one_signature: Option<(SignatureIndex, VMSharedSignatureIndex)>,
   32|    204|) -> Result<InstanceId> {
   33|    204|    let mut imports = Imports::default();
   34|    204|    imports.functions = func_imports;
   35|    204|
   36|    204|    unsafe {
   37|    204|        let config = store.engine().config();
   38|    204|        // Use the on-demand allocator when creating handles associated with host objects
   39|    204|        // The configured instance allocator should only be used when creating module instances
   40|    204|        // as we don't want host objects to count towards instance limits.
   41|    204|        let module = Arc::new(module);
   42|    204|        let runtime_info =
   43|    204|            &BareModuleInfo::maybe_imported_func(module, one_signature).into_traitobj();
   44|    204|        let handle = OnDemandInstanceAllocator::new(config.mem_creator.clone(), 0).allocate(
   45|    204|            InstanceAllocationRequest {
   46|    204|                imports,
   47|    204|                host_state,
   48|    204|                store: StorePtr::new(store.traitobj()),
   49|    204|                runtime_info,
   50|    204|            },
   51|    204|        )?;
   52|       |
   53|    204|        Ok(store.add_instance(handle, true))
   54|       |    }
   55|    204|}
_RNvNtCs3hbrbrmFUf_8wasmtime10trampoline22generate_global_export:
   57|    204|pub fn generate_global_export(
   58|    204|    store: &mut StoreOpaque,
   59|    204|    gt: &GlobalType,
   60|    204|    val: Val,
   61|    204|) -> Result<wasmtime_runtime::ExportGlobal> {
   62|    204|    let instance = create_global(store, gt, val)?;
   63|    204|    Ok(store
   64|    204|        .instance_mut(instance)
   65|    204|        .get_exported_global(GlobalIndex::from_u32(0)))
   66|    204|}

_RNvNtNtCs3hbrbrmFUf_8wasmtime10trampoline6global13create_global:
   10|    204|pub fn create_global(store: &mut StoreOpaque, gt: &GlobalType, val: Val) -> Result<InstanceId> {
   11|    204|    let mut module = Module::new();
   12|    204|    let mut func_imports = Vec::new();
   13|    204|    let mut externref_init = None;
   14|    204|    let mut one_signature = None;
   15|       |
   16|    204|    let global = Global {
   17|    204|        wasm_ty: gt.content().to_wasm_type(),
   18|    204|        mutability: match gt.mutability() {
   19|      0|            Mutability::Const => false,
   20|    204|            Mutability::Var => true,
   21|       |        },
   22|      0|        initializer: match val {
   23|      0|            Val::I32(i) => GlobalInit::I32Const(i),
   24|    204|            Val::I64(i) => GlobalInit::I64Const(i),
   25|      0|            Val::F32(f) => GlobalInit::F32Const(f),
   26|      0|            Val::F64(f) => GlobalInit::F64Const(f),
   27|      0|            Val::V128(i) => GlobalInit::V128Const(i.into()),
   28|      0|            Val::ExternRef(None) | Val::FuncRef(None) => GlobalInit::RefNullConst,
   29|      0|            Val::ExternRef(Some(x)) => {
   30|      0|                // There is no `GlobalInit` variant for using an existing
   31|      0|                // `externref` that isn't an import (because Wasm can't create
   32|      0|                // an `externref` by itself). Therefore, initialize the global
   33|      0|                // as null, and then monkey patch it after instantiation below.
   34|      0|                externref_init = Some(x);
   35|      0|                GlobalInit::RefNullConst
   36|       |            }
   37|      0|            Val::FuncRef(Some(f)) => {
   38|      0|                // Add a function import to the stub module, and then initialize
   39|      0|                // our global with a `ref.func` to grab that imported function.
   40|      0|                let f = f.caller_checked_anyfunc(store);
   41|      0|                let f = unsafe { f.as_ref() };
   42|      0|                let sig_id = SignatureIndex::from_u32(u32::max_value() - 1);
   43|      0|                one_signature = Some((sig_id, f.type_index));
   44|      0|                module.types.push(ModuleType::Function(sig_id));
   45|      0|                let func_index = module.push_escaped_function(sig_id, AnyfuncIndex::from_u32(0));
   46|      0|                module.num_imported_funcs = 1;
   47|      0|                module.num_escaped_funcs = 1;
   48|      0|                module
   49|      0|                    .initializers
   50|      0|                    .push(wasmtime_environ::Initializer::Import {
   51|      0|                        name: "".into(),
   52|      0|                        field: "".into(),
   53|      0|                        index: EntityIndex::Function(func_index),
   54|      0|                    });
   55|      0|
   56|      0|                func_imports.push(VMFunctionImport {
   57|      0|                    body: f.func_ptr,
   58|      0|                    vmctx: f.vmctx,
   59|      0|                });
   60|      0|
   61|      0|                GlobalInit::RefFunc(func_index)
   62|       |            }
   63|       |        },
   64|       |    };
   65|       |
   66|    204|    let global_id = module.globals.push(global);
   67|    204|    module
   68|    204|        .exports
   69|    204|        .insert(String::new(), EntityIndex::Global(global_id));
   70|    204|    let id = create_handle(module, store, Box::new(()), &func_imports, one_signature)?;
   71|       |
   72|    204|    if let Some(x) = externref_init {
   73|      0|        let instance = store.instance_mut(id);
   74|      0|        let g = instance.get_exported_global(global_id);
   75|      0|        unsafe {
   76|      0|            *(*g.definition).as_externref_mut() = Some(x.inner);
   77|      0|        }
   78|    204|    }
   79|       |
   80|    204|    Ok(id)
   81|    204|}

_RNvNtNtCs3hbrbrmFUf_8wasmtime10trampoline6memory13create_memory:
   20|    204|pub fn create_memory(
   21|    204|    store: &mut StoreOpaque,
   22|    204|    memory_ty: &MemoryType,
   23|    204|    preallocation: Option<SharedMemory>,
   24|    204|) -> Result<InstanceId> {
   25|    204|    let mut module = Module::new();
   26|    204|
   27|    204|    // Create a memory plan for the memory, though it will never be used for
   28|    204|    // constructing a memory with an allocator: instead the memories are either
   29|    204|    // preallocated (i.e., shared memory) or allocated manually below.
   30|    204|    let plan = wasmtime_environ::MemoryPlan::for_memory(
   31|    204|        memory_ty.wasmtime_memory().clone(),
   32|    204|        &store.engine().config().tunables,
   33|    204|    );
   34|    204|    let memory_id = module.memory_plans.push(plan.clone());
   35|       |
   36|    204|    let memory = match &preallocation {
   37|       |        // If we are passing in a pre-allocated shared memory, we can clone its
   38|       |        // `Arc`. We know that a preallocated memory *must* be shared--it could
   39|       |        // be used by several instances.
   40|      0|        Some(shared_memory) => shared_memory.clone().as_memory(),
   41|       |        // If we do not have a pre-allocated memory, then we create it here and
   42|       |        // associate it with the "frankenstein" instance, which now owns it.
   43|       |        None => {
   44|    204|            let creator = &DefaultMemoryCreator;
   45|    204|            let store = unsafe {
   46|    204|                store
   47|    204|                    .traitobj()
   48|    204|                    .as_mut()
   49|    204|                    .expect("the store pointer cannot be null here")
   50|    204|            };
   51|    204|            Memory::new_dynamic(&plan, creator, store, None)
   52|    204|                .map_err(|err| InstantiationError::Resource(err.into()))?
   53|       |        }
   54|       |    };
   55|       |
   56|       |    // Since we have only associated a single memory with the "frankenstein"
   57|       |    // instance, it will be exported at index 0.
   58|    204|    debug_assert_eq!(memory_id.as_u32(), 0);
   59|    204|    module
   60|    204|        .exports
   61|    204|        .insert(String::new(), EntityIndex::Memory(memory_id));
   62|    204|
   63|    204|    // We create an instance in the on-demand allocator when creating handles
   64|    204|    // associated with external objects. The configured instance allocator
   65|    204|    // should only be used when creating module instances as we don't want host
   66|    204|    // objects to count towards instance limits.
   67|    204|    let runtime_info = &BareModuleInfo::maybe_imported_func(Arc::new(module), None).into_traitobj();
   68|    204|    let host_state = Box::new(());
   69|    204|    let imports = Imports::default();
   70|    204|    let request = InstanceAllocationRequest {
   71|    204|        imports,
   72|    204|        host_state,
   73|    204|        store: StorePtr::new(store.traitobj()),
   74|    204|        runtime_info,
   75|    204|    };
   76|       |
   77|       |    unsafe {
   78|    204|        let handle = allocate_single_memory_instance(request, memory)?;
   79|    204|        let instance_id = store.add_instance(handle.clone(), true);
   80|    204|        Ok(instance_id)
   81|       |    }
   82|    204|}

_RNvXsr_NtCs3hbrbrmFUf_8wasmtime5typesNtB5_7ValTypeNtNtCshM4Il2Z0i4R_4core3cmp9PartialEq2eq:
   22|    204|#[derive(Debug, Clone, Hash, Eq, PartialEq)]
_RNvMs6_NtCs3hbrbrmFUf_8wasmtime5typesNtB5_10GlobalType10mutability:
  260|    204|    pub fn mutability(&self) -> Mutability {
  261|    204|        self.mutability
  262|    204|    }
_RNvMs8_NtCs3hbrbrmFUf_8wasmtime5typesNtB5_10MemoryType3new:
  346|    204|    pub fn new(minimum: u32, maximum: Option<u32>) -> MemoryType {
  347|    204|        MemoryType {
  348|    204|            ty: Memory {
  349|    204|                memory64: false,
  350|    204|                shared: false,
  351|    204|                minimum: minimum.into(),
  352|    204|                maximum: maximum.map(|i| i.into()),
  353|    204|            },
  354|    204|        }
  355|    204|    }
_RNvMs_NtCs3hbrbrmFUf_8wasmtime5typesNtB4_7ValType12to_wasm_type:
   74|    204|    pub(crate) fn to_wasm_type(&self) -> WasmType {
   75|    204|        match self {
   76|      0|            Self::I32 => WasmType::I32,
   77|    204|            Self::I64 => WasmType::I64,
   78|      0|            Self::F32 => WasmType::F32,
   79|      0|            Self::F64 => WasmType::F64,
   80|      0|            Self::V128 => WasmType::V128,
   81|      0|            Self::FuncRef => WasmType::FuncRef,
   82|      0|            Self::ExternRef => WasmType::ExternRef,
   83|       |        }
   84|    204|    }
_RNvMs8_NtCs3hbrbrmFUf_8wasmtime5typesNtB5_10MemoryType15wasmtime_memory:
  434|    204|    pub(crate) fn wasmtime_memory(&self) -> &Memory {
  435|    204|        &self.ty
  436|    204|    }
_RNvMs6_NtCs3hbrbrmFUf_8wasmtime5typesNtB5_10GlobalType3new:
  247|    204|    pub fn new(content: ValType, mutability: Mutability) -> GlobalType {
  248|    204|        GlobalType {
  249|    204|            content,
  250|    204|            mutability,
  251|    204|        }
  252|    204|    }
_RNCNvMs8_NtCs3hbrbrmFUf_8wasmtime5typesNtB7_10MemoryType3new0B9_:
  352|    204|                maximum: maximum.map(|i| i.into()),
_RNvMs6_NtCs3hbrbrmFUf_8wasmtime5typesNtB5_10GlobalType7content:
  255|    408|    pub fn content(&self) -> &ValType {
  256|    408|        &self.content
  257|    408|    }

_RNvMNtCs3hbrbrmFUf_8wasmtime6valuesNtB2_3Val21comes_from_same_store:
  212|      0|        match self {
  213|      0|            Val::FuncRef(Some(f)) => f.comes_from_same_store(store),
  214|      0|            Val::FuncRef(None) => true,
  215|       |
  216|       |            // Integers, floats, vectors, and `externref`s have no association
  217|       |            // with any particular store, so they're always considered as "yes I
  218|       |            // came from that store",
  219|       |            Val::I32(_)
  220|       |            | Val::I64(_)
  221|       |            | Val::F32(_)
  222|       |            | Val::F64(_)
  223|       |            | Val::V128(_)
  224|    204|            | Val::ExternRef(_) => true,
  225|       |        }
  226|    204|    }
_RNvMNtCs3hbrbrmFUf_8wasmtime6valuesNtB2_3Val2ty:
   86|    204|    pub fn ty(&self) -> ValType {
   87|    204|        match self {
   88|      0|            Val::I32(_) => ValType::I32,
   89|    204|            Val::I64(_) => ValType::I64,
   90|      0|            Val::F32(_) => ValType::F32,
   91|      0|            Val::F64(_) => ValType::F64,
   92|      0|            Val::ExternRef(_) => ValType::ExternRef,
   93|      0|            Val::FuncRef(_) => ValType::FuncRef,
   94|      0|            Val::V128(_) => ValType::V128,
   95|       |        }
   96|    204|    }

_RNvXNtCs9zPARoPS2ZV_18wasmtime_cranelift7builderNtB2_7BuilderNtNtCshaNIPJAj9Ao_16wasmtime_environ11compilation15CompilerBuilder3set:
   65|    816|    fn set(&mut self, name: &str, value: &str) -> Result<()> {
   66|    816|        // Special wasmtime-cranelift-only settings first
   67|    816|        if name == "wasmtime_linkopt_padding_between_functions" {
   68|      0|            self.linkopts.padding_between_functions = value.parse()?;
   69|      0|            return Ok(());
   70|    816|        }
   71|    816|        if name == "wasmtime_linkopt_force_jump_veneer" {
   72|      0|            self.linkopts.force_jump_veneers = value.parse()?;
   73|      0|            return Ok(());
   74|    816|        }
   75|       |
   76|       |        // ... then forward this to Cranelift
   77|    816|        if let Err(err) = self.flags.set(name, value) {
   78|      0|            match err {
   79|       |                SetError::BadName(_) => {
   80|       |                    // Try the target-specific flags.
   81|      0|                    self.isa_flags.set(name, value)?;
   82|       |                }
   83|      0|                _ => return Err(err.into()),
   84|       |            }
   85|    816|        }
   86|    816|        Ok(())
   87|    816|    }
_RNvNtCs9zPARoPS2ZV_18wasmtime_cranelift7builder7builder:
   33|    204|pub fn builder() -> Box<dyn CompilerBuilder> {
   34|    204|    let mut flags = settings::builder();
   35|    204|
   36|    204|    // There are two possible traps for division, and this way
   37|    204|    // we get the proper one if code traps.
   38|    204|    flags
   39|    204|        .enable("avoid_div_traps")
   40|    204|        .expect("should be valid flag");
   41|    204|
   42|    204|    // We don't use probestack as a stack limit mechanism
   43|    204|    flags
   44|    204|        .set("enable_probestack", "false")
   45|    204|        .expect("should be valid flag");
   46|    204|
   47|    204|    Box::new(Builder {
   48|    204|        flags,
   49|    204|        isa_flags: cranelift_native::builder().expect("host machine is not a supported target"),
   50|    204|        linkopts: LinkOptions::default(),
   51|    204|        cache_store: None,
   52|    204|    })
   53|    204|}
_RNvXNtCs9zPARoPS2ZV_18wasmtime_cranelift7builderNtB2_7BuilderNtNtCshaNIPJAj9Ao_16wasmtime_environ11compilation15CompilerBuilder5build:
  102|    204|    fn build(&self) -> Result<Box<dyn wasmtime_environ::Compiler>> {
  103|    204|        let isa = self
  104|    204|            .isa_flags
  105|    204|            .clone()
  106|    204|            .finish(settings::Flags::new(self.flags.clone()))?;
  107|    204|        Ok(Box::new(crate::compiler::Compiler::new(
  108|    204|            isa,
  109|    204|            self.cache_store.clone(),
  110|    204|            self.linkopts.clone(),
  111|    204|        )))
  112|    204|    }
_RNvXs0_NtCs9zPARoPS2ZV_18wasmtime_cranelift7builderNtB5_11LinkOptionsNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
   20|    204|#[derive(Clone, Default)]
_RNvXs1_NtCs9zPARoPS2ZV_18wasmtime_cranelift7builderNtB5_11LinkOptionsNtNtCshM4Il2Z0i4R_4core7default7Default7default:
   20|    204|#[derive(Clone, Default)]

_RNvMs0_NtCs9zPARoPS2ZV_18wasmtime_cranelift8compilerNtB5_8Compiler3new:
  104|    204|    pub(crate) fn new(
  105|    204|        isa: Box<dyn TargetIsa>,
  106|    204|        cache_store: Option<Arc<dyn CacheStore>>,
  107|    204|        linkopts: LinkOptions,
  108|    204|    ) -> Compiler {
  109|    204|        Compiler {
  110|    204|            contexts: Default::default(),
  111|    204|            isa,
  112|    204|            linkopts,
  113|    204|            cache_store,
  114|    204|        }
  115|    204|    }
_RNvXs_NtCs9zPARoPS2ZV_18wasmtime_cranelift8compilerNtB4_8CompilerNtNtNtCshM4Il2Z0i4R_4core3ops4drop4Drop4drop:
   76|    204|    fn drop(&mut self) {
   77|    204|        if self.cache_store.is_none() {
   78|    204|            return;
   79|      0|        }
   80|      0|
   81|      0|        let mut num_hits = 0;
   82|      0|        let mut num_cached = 0;
   83|      0|        for ctx in self.contexts.lock().unwrap().iter() {
   84|      0|            if let Some(ref cache_ctx) = ctx.incremental_cache_ctx {
   85|      0|                num_hits += cache_ctx.num_hits;
   86|      0|                num_cached += cache_ctx.num_cached;
   87|      0|            }
   88|       |        }
   89|       |
   90|      0|        let total = num_hits + num_cached;
   91|      0|        if num_hits + num_cached > 0 {
   92|      0|            log::trace!(
   93|      0|                "Incremental compilation cache stats: {}/{} = {}% (hits/lookup)\ncached: {}",
   94|      0|                num_hits,
   95|      0|                total,
   96|      0|                (num_hits as f32) / (total as f32) * 100.0,
   97|       |                num_cached
   98|       |            );
   99|      0|        }
  100|    204|    }

_RNvXsw_NtCshaNIPJAj9Ao_16wasmtime_environ6moduleNtB5_6ModuleNtNtCshM4Il2Z0i4R_4core7default7Default7default:
  767|    612|#[derive(Default, Debug, Serialize, Deserialize)]
_RNvXsd_NtCshaNIPJAj9Ao_16wasmtime_environ6moduleNtB5_10MemoryPlanNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
   73|    408|#[derive(Debug, Clone, Hash, Serialize, Deserialize)]
_RNvXsa_NtCshaNIPJAj9Ao_16wasmtime_environ6moduleNtB5_11MemoryStyleNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
   14|    408|#[derive(Debug, Clone, Hash, Serialize, Deserialize)]
_RNvMs7_NtCshaNIPJAj9Ao_16wasmtime_environ6moduleNtB5_6Module20defined_global_index:
  959|    612|    pub fn defined_global_index(&self, global: GlobalIndex) -> Option<DefinedGlobalIndex> {
  960|    612|        if global.index() < self.num_imported_globals {
  961|      0|            None
  962|       |        } else {
  963|    612|            Some(DefinedGlobalIndex::new(
  964|    612|                global.index() - self.num_imported_globals,
  965|    612|            ))
  966|       |        }
  967|    612|    }
_RNvMs7_NtCshaNIPJAj9Ao_16wasmtime_environ6moduleNtB5_6Module20defined_memory_index:
  912|    204|    pub fn defined_memory_index(&self, memory: MemoryIndex) -> Option<DefinedMemoryIndex> {
  913|    204|        if memory.index() < self.num_imported_memories {
  914|      0|            None
  915|       |        } else {
  916|    204|            Some(DefinedMemoryIndex::new(
  917|    204|                memory.index() - self.num_imported_memories,
  918|    204|            ))
  919|       |        }
  920|    204|    }
_RNvMs7_NtCshaNIPJAj9Ao_16wasmtime_environ6moduleNtB5_6Module12memory_index:
  905|    204|    pub fn memory_index(&self, defined_memory: DefinedMemoryIndex) -> MemoryIndex {
  906|    204|        MemoryIndex::new(self.num_imported_memories + defined_memory.index())
  907|    204|    }
_RNvMs7_NtCshaNIPJAj9Ao_16wasmtime_environ6moduleNtB5_6Module3new:
  849|    408|    pub fn new() -> Self {
  850|    408|        Module::default()
  851|    408|    }
_RNvMs_NtCshaNIPJAj9Ao_16wasmtime_environ6moduleNtB4_10MemoryPlan10for_memory:
   87|    204|    pub fn for_memory(memory: Memory, tunables: &Tunables) -> Self {
   88|    204|        let (style, offset_guard_size) = MemoryStyle::for_memory(memory, tunables);
   89|    204|        Self {
   90|    204|            memory,
   91|    204|            style,
   92|    204|            offset_guard_size,
   93|    204|            pre_guard_size: if tunables.guard_before_linear_memory {
   94|    204|                offset_guard_size
   95|       |            } else {
   96|      0|                0
   97|       |            },
   98|       |        }
   99|    204|    }
_RNvXs1_NtCshaNIPJAj9Ao_16wasmtime_environ6moduleNtB5_20MemoryInitializationNtNtCshM4Il2Z0i4R_4core7default7Default7default:
  481|    612|    fn default() -> Self {
  482|    612|        Self::Segmented(Vec::new())
  483|    612|    }
_RNvXs5_NtCshaNIPJAj9Ao_16wasmtime_environ6moduleNtB5_19TableInitializationNtNtCshM4Il2Z0i4R_4core7default7Default7default:
  740|    612|    fn default() -> Self {
  741|    612|        TableInitialization::Segments { segments: vec![] }
  742|    612|    }
_RNvMNtCshaNIPJAj9Ao_16wasmtime_environ6moduleNtB2_11MemoryStyle10for_memory:
   30|    204|    pub fn for_memory(memory: Memory, tunables: &Tunables) -> (Self, u64) {
   31|       |        // A heap with a maximum that doesn't exceed the static memory bound specified by the
   32|       |        // tunables make it static.
   33|       |        //
   34|       |        // If the module doesn't declare an explicit maximum treat it as 4GiB when not
   35|       |        // requested to use the static memory bound itself as the maximum.
   36|    204|        let absolute_max_pages = if memory.memory64 {
   37|      0|            crate::WASM64_MAX_PAGES
   38|       |        } else {
   39|    204|            crate::WASM32_MAX_PAGES
   40|       |        };
   41|    204|        let maximum = std::cmp::min(
   42|    204|            memory.maximum.unwrap_or(absolute_max_pages),
   43|    204|            if tunables.static_memory_bound_is_maximum {
   44|    204|                std::cmp::min(tunables.static_memory_bound, absolute_max_pages)
   45|       |            } else {
   46|      0|                absolute_max_pages
   47|       |            },
   48|       |        );
   49|       |
   50|       |        // Ensure the minimum is less than the maximum; the minimum might exceed the maximum
   51|       |        // when the memory is artificially bounded via `static_memory_bound_is_maximum` above
   52|    204|        if memory.minimum <= maximum && maximum <= tunables.static_memory_bound {
   53|    204|            return (
   54|    204|                Self::Static {
   55|    204|                    bound: tunables.static_memory_bound,
   56|    204|                },
   57|    204|                tunables.static_memory_offset_guard_size,
   58|    204|            );
   59|      0|        }
   60|      0|
   61|      0|        // Otherwise, make it dynamic.
   62|      0|        (
   63|      0|            Self::Dynamic {
   64|      0|                reserve: tunables.dynamic_memory_growth_reserve,
   65|      0|            },
   66|      0|            tunables.dynamic_memory_offset_guard_size,
   67|      0|        )
   68|    204|    }

_RNvXs_NtCshaNIPJAj9Ao_16wasmtime_environ8tunablesNtB4_8TunablesNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
    4|    204|#[derive(Clone, Hash, Serialize, Deserialize)]
_RNvXNtCshaNIPJAj9Ao_16wasmtime_environ8tunablesNtB2_8TunablesNtNtCshM4Il2Z0i4R_4core7default7Default7default:
   51|    204|    fn default() -> Self {
   52|    204|        let (static_memory_bound, static_memory_offset_guard_size) =
   53|    204|            if cfg!(target_pointer_width = "64") {
   54|       |                // 64-bit has tons of address space to static memories can have 4gb
   55|       |                // address space reservations liberally by default, allowing us to
   56|       |                // help eliminate bounds checks.
   57|       |                //
   58|       |                // Coupled with a 2 GiB address space guard it lets us translate
   59|       |                // wasm offsets into x86 offsets as aggressively as we can.
   60|    204|                (0x1_0000, 0x8000_0000)
   61|      0|            } else if cfg!(target_pointer_width = "32") {
   62|       |                // For 32-bit we scale way down to 10MB of reserved memory. This
   63|       |                // impacts performance severely but allows us to have more than a
   64|       |                // few instances running around.
   65|      0|                ((10 * (1 << 20)) / crate::WASM_PAGE_SIZE as u64, 0x1_0000)
   66|       |            } else {
   67|      0|                panic!("unsupported target_pointer_width");
   68|       |            };
   69|    204|        Self {
   70|    204|            static_memory_bound,
   71|    204|            static_memory_offset_guard_size,
   72|    204|
   73|    204|            // Size in bytes of the offset guard for dynamic memories.
   74|    204|            //
   75|    204|            // Allocate a small guard to optimize common cases but without
   76|    204|            // wasting too much memory.
   77|    204|            dynamic_memory_offset_guard_size: 0x1_0000,
   78|    204|
   79|    204|            // We've got lots of address space on 64-bit so use a larger
   80|    204|            // grow-into-this area, but on 32-bit we aren't as lucky.
   81|    204|            #[cfg(target_pointer_width = "64")]
   82|    204|            dynamic_memory_growth_reserve: 2 << 30, // 2GB
   83|    204|            #[cfg(target_pointer_width = "32")]
   84|    204|            dynamic_memory_growth_reserve: 1 << 20, // 1MB
   85|    204|
   86|    204|            generate_native_debuginfo: false,
   87|    204|            parse_wasm_debuginfo: true,
   88|    204|            consume_fuel: false,
   89|    204|            epoch_interruption: false,
   90|    204|            static_memory_bound_is_maximum: false,
   91|    204|            guard_before_linear_memory: true,
   92|    204|            generate_address_map: true,
   93|    204|            debug_adapter_modules: false,
   94|    204|        }
   95|    204|    }

_RNvMs9_NtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE11vmctx_storeCs3hbrbrmFUf_8wasmtime:
  616|    612|    pub fn vmctx_store(&self) -> u32 {
  617|    612|        self.store
  618|    612|    }
_RNvNvXs1_NtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsetsINtB7_9VMOffsetspEINtNtCshM4Il2Z0i4R_4core7convert4FromINtB7_15VMOffsetsFieldspEE4from4cmul:
  388|  5.50k|        fn cmul(count: u32, size: u8) -> u32 {
  389|  5.50k|            count.checked_mul(u32::from(size)).unwrap()
  390|  5.50k|        }
_RNvNtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsets5align:
   50|  1.22k|fn align(offset: u32, width: u32) -> u32 {
   51|  1.22k|    (offset + (width - 1)) / width * width
   52|  1.22k|}
_RNvNvXs1_NtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsetsINtB7_9VMOffsetspEINtNtCshM4Il2Z0i4R_4core7convert4FromINtB7_15VMOffsetsFieldspEE4from4cadd:
  383|  10.4k|        fn cadd(count: u32, size: u32) -> u32 {
  384|  10.4k|            count.checked_add(size).unwrap()
  385|  10.4k|        }
_RNvYNtNtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsets7HostPtrNtB4_7PtrSize24size_of_vmmemory_pointerCsa8j9dqGMVk5_16wasmtime_runtime:
  198|    816|    fn size_of_vmmemory_pointer(&self) -> u8 {
  199|    816|        self.size()
  200|    816|    }
_RNCNvMs0_NtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsetsINtB7_9VMOffsetsNtB7_7HostPtrE3new0Csa8j9dqGMVk5_16wasmtime_runtime:
  253|    204|            .filter(|p| !p.1.memory.shared)
_RNvMs9_NtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE28vmctx_imported_globals_beginCsa8j9dqGMVk5_16wasmtime_runtime:
  648|    612|    pub fn vmctx_imported_globals_begin(&self) -> u32 {
  649|    612|        self.imported_globals
  650|    612|    }
_RNvMs9_NtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE33vmctx_externref_activations_tableCsa8j9dqGMVk5_16wasmtime_runtime:
  610|    816|    pub fn vmctx_externref_activations_table(&self) -> u32 {
  611|    816|        self.externref_activations_table
  612|    816|    }
_RNvMs4_NtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE22size_of_vmtable_importCsa8j9dqGMVk5_16wasmtime_runtime:
  500|    612|    pub fn size_of_vmtable_import(&self) -> u8 {
  501|    612|        2 * self.pointer_size()
  502|    612|    }
_RNvMs9_NtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE25vmctx_vmglobal_definitionCsa8j9dqGMVk5_16wasmtime_runtime:
  751|    408|    pub fn vmctx_vmglobal_definition(&self, index: DefinedGlobalIndex) -> u32 {
  752|    408|        assert!(index.as_u32() < self.num_defined_globals);
  753|    408|        self.vmctx_globals_begin()
  754|    408|            + index.as_u32() * u32::from(self.ptr.size_of_vmglobal_definition())
  755|    408|    }
_RNvMs9_NtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE27vmctx_imported_tables_beginCsa8j9dqGMVk5_16wasmtime_runtime:
  636|    612|    pub fn vmctx_imported_tables_begin(&self) -> u32 {
  637|    612|        self.imported_tables
  638|    612|    }
_RNvMs9_NtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE11vmctx_magicCsa8j9dqGMVk5_16wasmtime_runtime:
  586|    612|    pub fn vmctx_magic(&self) -> u32 {
  587|    612|        self.magic
  588|    612|    }
_RNvXNtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsetsNtB2_7HostPtrNtB2_7PtrSize4size:
  208|  9.99k|    fn size(&self) -> u8 {
  209|  9.99k|        std::mem::size_of::<usize>() as u8
  210|  9.99k|    }
_RNvMs9_NtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE29vmctx_imported_memories_beginCsa8j9dqGMVk5_16wasmtime_runtime:
  642|    612|    pub fn vmctx_imported_memories_begin(&self) -> u32 {
  643|    612|        self.imported_memories
  644|    612|    }
_RNvMs9_NtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE23vmctx_builtin_functionsCsa8j9dqGMVk5_16wasmtime_runtime:
  684|    612|    pub fn vmctx_builtin_functions(&self) -> u32 {
  685|    612|        self.builtin_functions
  686|    612|    }
_RNvMs7_NtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE23size_of_vmglobal_importCsa8j9dqGMVk5_16wasmtime_runtime:
  568|    612|    pub fn size_of_vmglobal_import(&self) -> u8 {
  569|    612|        1 * self.pointer_size()
  570|    612|    }
_RNvMs5_NtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE26size_of_vmtable_definitionCsa8j9dqGMVk5_16wasmtime_runtime:
  528|    612|    pub fn size_of_vmtable_definition(&self) -> u8 {
  529|    612|        2 * self.pointer_size()
  530|    612|    }
_RNvXs1_NtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrEINtNtCshM4Il2Z0i4R_4core7convert4FromINtB5_15VMOffsetsFieldsB13_EE4fromCsa8j9dqGMVk5_16wasmtime_runtime:
  346|    612|    fn from(fields: VMOffsetsFields<P>) -> VMOffsets<P> {
  347|    612|        let mut ret = Self {
  348|    612|            ptr: fields.ptr,
  349|    612|            num_imported_functions: fields.num_imported_functions,
  350|    612|            num_imported_tables: fields.num_imported_tables,
  351|    612|            num_imported_memories: fields.num_imported_memories,
  352|    612|            num_imported_globals: fields.num_imported_globals,
  353|    612|            num_defined_tables: fields.num_defined_tables,
  354|    612|            num_defined_memories: fields.num_defined_memories,
  355|    612|            num_owned_memories: fields.num_owned_memories,
  356|    612|            num_defined_globals: fields.num_defined_globals,
  357|    612|            num_escaped_funcs: fields.num_escaped_funcs,
  358|    612|            magic: 0,
  359|    612|            runtime_limits: 0,
  360|    612|            callee: 0,
  361|    612|            epoch_ptr: 0,
  362|    612|            externref_activations_table: 0,
  363|    612|            store: 0,
  364|    612|            builtin_functions: 0,
  365|    612|            signature_ids: 0,
  366|    612|            imported_functions: 0,
  367|    612|            imported_tables: 0,
  368|    612|            imported_memories: 0,
  369|    612|            imported_globals: 0,
  370|    612|            defined_tables: 0,
  371|    612|            defined_memories: 0,
  372|    612|            owned_memories: 0,
  373|    612|            defined_globals: 0,
  374|    612|            defined_anyfuncs: 0,
  375|    612|            size: 0,
  376|    612|        };
  377|    612|
  378|    612|        // Convenience functions for checked addition and multiplication.
  379|    612|        // As side effect this reduces binary size by using only a single
  380|    612|        // `#[track_caller]` location for each function instead of one for
  381|    612|        // each individual invocation.
  382|    612|        #[inline]
  383|    612|        fn cadd(count: u32, size: u32) -> u32 {
  384|    612|            count.checked_add(size).unwrap()
  385|    612|        }
  386|    612|
  387|    612|        #[inline]
  388|    612|        fn cmul(count: u32, size: u8) -> u32 {
  389|    612|            count.checked_mul(u32::from(size)).unwrap()
  390|    612|        }
  391|    612|
  392|    612|        let mut next_field_offset = 0;
  393|    612|
  394|    612|        macro_rules! fields {
  395|    612|            (size($field:ident) = $size:expr, $($rest:tt)*) => {
  396|    612|                ret.$field = next_field_offset;
  397|    612|                next_field_offset = cadd(next_field_offset, u32::from($size));
  398|    612|                fields!($($rest)*);
  399|    612|            };
  400|    612|            (align($align:expr), $($rest:tt)*) => {
  401|    612|                next_field_offset = align(next_field_offset, $align);
  402|    612|                fields!($($rest)*);
  403|    612|            };
  404|    612|            () => {};
  405|    612|        }
  406|    612|
  407|    612|        fields! {
  408|    612|            size(magic) = 4u32,
  409|    612|            align(u32::from(ret.ptr.size())),
  410|    612|            size(runtime_limits) = ret.ptr.size(),
  411|    612|            size(callee) = ret.ptr.size(),
  412|    612|            size(epoch_ptr) = ret.ptr.size(),
  413|    612|            size(externref_activations_table) = ret.ptr.size(),
  414|    612|            size(store) = ret.ptr.size() * 2,
  415|    612|            size(builtin_functions) = ret.pointer_size(),
  416|    612|            size(signature_ids) = ret.ptr.size(),
  417|    612|            size(imported_functions)
  418|    612|                = cmul(ret.num_imported_functions, ret.size_of_vmfunction_import()),
  419|    612|            size(imported_tables)
  420|    612|                = cmul(ret.num_imported_tables, ret.size_of_vmtable_import()),
  421|    612|            size(imported_memories)
  422|    612|                = cmul(ret.num_imported_memories, ret.size_of_vmmemory_import()),
  423|    612|            size(imported_globals)
  424|    612|                = cmul(ret.num_imported_globals, ret.size_of_vmglobal_import()),
  425|    612|            size(defined_tables)
  426|    612|                = cmul(ret.num_defined_tables, ret.size_of_vmtable_definition()),
  427|    612|            size(defined_memories)
  428|    612|                = cmul(ret.num_defined_memories, ret.ptr.size_of_vmmemory_pointer()),
  429|    612|            size(owned_memories)
  430|    612|                = cmul(ret.num_owned_memories, ret.ptr.size_of_vmmemory_definition()),
  431|    612|            align(16),
  432|    612|            size(defined_globals)
  433|    612|                = cmul(ret.num_defined_globals, ret.ptr.size_of_vmglobal_definition()),
  434|    612|            size(defined_anyfuncs) = cmul(
  435|    612|                ret.num_escaped_funcs,
  436|    612|                ret.ptr.size_of_vmcaller_checked_anyfunc(),
  437|    612|            ),
  438|    612|        }
  439|    612|
  440|    612|        ret.size = next_field_offset;
  441|    612|
  442|    612|        // This is required by the implementation of `VMContext::instance` and
  443|    612|        // `VMContext::instance_mut`. If this value changes then those locations
  444|    612|        // need to be updated.
  445|    612|        assert_eq!(ret.magic, 0);
  446|       |
  447|    612|        return ret;
  448|    612|    }
_RNvMs9_NtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE22vmctx_vmmemory_pointerCsa8j9dqGMVk5_16wasmtime_runtime:
  735|    204|    pub fn vmctx_vmmemory_pointer(&self, index: DefinedMemoryIndex) -> u32 {
  736|    204|        assert!(index.as_u32() < self.num_defined_memories);
  737|    204|        self.vmctx_memories_begin()
  738|    204|            + index.as_u32() * u32::from(self.ptr.size_of_vmmemory_pointer())
  739|    204|    }
_RNvYNtNtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsets7HostPtrNtB4_7PtrSize32size_of_vmcaller_checked_anyfuncCsa8j9dqGMVk5_16wasmtime_runtime:
  128|    612|    fn size_of_vmcaller_checked_anyfunc(&self) -> u8 {
  129|    612|        3 * self.size()
  130|    612|    }
_RNvMs9_NtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE20vmctx_runtime_limitsCsa8j9dqGMVk5_16wasmtime_runtime:
  592|    816|    pub fn vmctx_runtime_limits(&self) -> u32 {
  593|    816|        self.runtime_limits
  594|    816|    }
_RNvMs9_NtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE13size_of_vmctxCsa8j9dqGMVk5_16wasmtime_runtime:
  690|  1.83k|    pub fn size_of_vmctx(&self) -> u32 {
  691|  1.83k|        self.size
  692|  1.83k|    }
_RNvMs9_NtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE26vmctx_owned_memories_beginCsa8j9dqGMVk5_16wasmtime_runtime:
  666|    612|    pub fn vmctx_owned_memories_begin(&self) -> u32 {
  667|    612|        self.owned_memories
  668|    612|    }
_RNvMs2_NtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE25size_of_vmfunction_importCsa8j9dqGMVk5_16wasmtime_runtime:
  468|    612|    pub fn size_of_vmfunction_import(&self) -> u8 {
  469|    612|        2 * self.pointer_size()
  470|    612|    }
_RNvYNtNtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsets7HostPtrNtB4_7PtrSize27size_of_vmmemory_definitionCsa8j9dqGMVk5_16wasmtime_runtime:
  192|    612|    fn size_of_vmmemory_definition(&self) -> u8 {
  193|    612|        2 * self.size()
  194|    612|    }
_RNvMs9_NtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE11vmctx_storeCsa8j9dqGMVk5_16wasmtime_runtime:
  616|    816|    pub fn vmctx_store(&self) -> u32 {
  617|    816|        self.store
  618|    816|    }
_RNvYNtNtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsets7HostPtrNtB4_7PtrSize27size_of_vmglobal_definitionCsa8j9dqGMVk5_16wasmtime_runtime:
  135|  1.02k|    fn size_of_vmglobal_definition(&self) -> u8 {
  136|  1.02k|        16
  137|  1.02k|    }
_RNvMs0_NtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE12pointer_sizeCsa8j9dqGMVk5_16wasmtime_runtime:
  275|  3.67k|    pub fn pointer_size(&self) -> u8 {
  276|  3.67k|        self.ptr.size()
  277|  3.67k|    }
_RNvMs9_NtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE20vmctx_memories_beginCsa8j9dqGMVk5_16wasmtime_runtime:
  660|    816|    pub fn vmctx_memories_begin(&self) -> u32 {
  661|    816|        self.defined_memories
  662|    816|    }
_RNvMs6_NtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE23size_of_vmmemory_importCsa8j9dqGMVk5_16wasmtime_runtime:
  551|    612|    pub fn size_of_vmmemory_import(&self) -> u8 {
  552|    612|        3 * self.pointer_size()
  553|    612|    }
_RNvMs9_NtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE15vmctx_epoch_ptrCsa8j9dqGMVk5_16wasmtime_runtime:
  604|    816|    pub fn vmctx_epoch_ptr(&self) -> u32 {
  605|    816|        self.epoch_ptr
  606|    816|    }
_RNvMs9_NtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE18vmctx_tables_beginCsa8j9dqGMVk5_16wasmtime_runtime:
  654|    612|    pub fn vmctx_tables_begin(&self) -> u32 {
  655|    612|        self.defined_tables
  656|    612|    }
_RNvMs9_NtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE25vmctx_signature_ids_arrayCsa8j9dqGMVk5_16wasmtime_runtime:
  622|    612|    pub fn vmctx_signature_ids_array(&self) -> u32 {
  623|    612|        self.signature_ids
  624|    612|    }
_RNvMs9_NtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE19vmctx_globals_beginCsa8j9dqGMVk5_16wasmtime_runtime:
  672|    408|    pub fn vmctx_globals_begin(&self) -> u32 {
  673|    408|        self.defined_globals
  674|    408|    }
_RNvMs0_NtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE3newCsa8j9dqGMVk5_16wasmtime_runtime:
  248|    612|    pub fn new(ptr: P, module: &Module) -> Self {
  249|    612|        let num_owned_memories = module
  250|    612|            .memory_plans
  251|    612|            .iter()
  252|    612|            .skip(module.num_imported_memories)
  253|    612|            .filter(|p| !p.1.memory.shared)
  254|    612|            .count()
  255|    612|            .try_into()
  256|    612|            .unwrap();
  257|    612|        VMOffsets::from(VMOffsetsFields {
  258|    612|            ptr,
  259|    612|            num_imported_functions: cast_to_u32(module.num_imported_funcs),
  260|    612|            num_imported_tables: cast_to_u32(module.num_imported_tables),
  261|    612|            num_imported_memories: cast_to_u32(module.num_imported_memories),
  262|    612|            num_imported_globals: cast_to_u32(module.num_imported_globals),
  263|    612|            num_defined_tables: cast_to_u32(module.table_plans.len() - module.num_imported_tables),
  264|    612|            num_defined_memories: cast_to_u32(
  265|    612|                module.memory_plans.len() - module.num_imported_memories,
  266|    612|            ),
  267|    612|            num_owned_memories,
  268|    612|            num_defined_globals: cast_to_u32(module.globals.len() - module.num_imported_globals),
  269|    612|            num_escaped_funcs: cast_to_u32(module.num_escaped_funcs),
  270|    612|        })
  271|    612|    }
_RNvMs9_NtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE30vmctx_imported_functions_beginCsa8j9dqGMVk5_16wasmtime_runtime:
  629|    612|    pub fn vmctx_imported_functions_begin(&self) -> u32 {
  630|    612|        self.imported_functions
  631|    612|    }
_RNvMs9_NtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE12vmctx_calleeCsa8j9dqGMVk5_16wasmtime_runtime:
  597|    612|    pub fn vmctx_callee(&self) -> u32 {
  598|    612|        self.callee
  599|    612|    }
_RNvNtCshaNIPJAj9Ao_16wasmtime_environ9vmoffsets11cast_to_u32:
   44|  4.89k|fn cast_to_u32(sz: usize) -> u32 {
   45|  4.89k|    u32::try_from(sz).expect("overflow in cast from usize to u32")
   46|  4.89k|}

_RNvNtCsa8j9dqGMVk5_16wasmtime_runtime14debug_builtins15ensure_exported:
   47|    204|pub fn ensure_exported() {
   48|    204|    unsafe {
   49|    204|        std::ptr::read_volatile(resolve_vmctx_memory_ptr as *const u8);
   50|    204|        std::ptr::read_volatile(set_vmctx_memory as *const u8);
   51|    204|        std::ptr::read_volatile(resolve_vmctx_memory as *const u8);
   52|    204|    }
   53|    204|}

_RNvMsc_NtCsa8j9dqGMVk5_16wasmtime_runtime9externrefNtB5_27VMExternRefActivationsTable3new:
  576|    204|    pub fn new() -> Self {
  577|    204|        // Start with an empty chunk in case this activations table isn't used.
  578|    204|        // This means that there's no space in the bump-allocation area which
  579|    204|        // will force any path trying to use this to the slow gc path. The first
  580|    204|        // time this happens, though, the slow gc path will allocate a new chunk
  581|    204|        // for actual fast-bumping.
  582|    204|        let mut chunk: Box<[TableElem]> = Box::new([]);
  583|    204|        let next = chunk.as_mut_ptr();
  584|    204|        let end = unsafe { next.add(chunk.len()) };
  585|    204|
  586|    204|        VMExternRefActivationsTable {
  587|    204|            alloc: VMExternRefTableAlloc {
  588|    204|                next: UnsafeCell::new(NonNull::new(next).unwrap()),
  589|    204|                end: NonNull::new(end).unwrap(),
  590|    204|                chunk,
  591|    204|            },
  592|    204|            over_approximated_stack_roots: HashSet::new(),
  593|    204|            precise_stack_roots: HashSet::new(),
  594|    204|            #[cfg(debug_assertions)]
  595|    204|            gc_okay: true,
  596|    204|        }
  597|    204|    }

_RNvXNtCsa8j9dqGMVk5_16wasmtime_runtime7importsNtB2_7ImportsNtNtCshM4Il2Z0i4R_4core7default7Default7default:
   14|    612|#[derive(Default)]

_RNvMNtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB2_8Instance5vmctx:
  300|  11.4k|    pub fn vmctx(&self) -> &VMContext {
  301|  11.4k|        &self.vmctx
  302|  11.4k|    }
_RNvMNtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB2_8Instance9vmctx_ptr:
  306|  11.4k|    pub fn vmctx_ptr(&self) -> *mut VMContext {
  307|  11.4k|        self.vmctx() as *const VMContext as *mut VMContext
  308|  11.4k|    }
_RNvMNtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB2_8Instance5store:
  267|    612|    pub fn store(&self) -> *mut dyn Store {
  268|    612|        let ptr = unsafe { *self.vmctx_plus_offset::<*mut dyn Store>(self.offsets.vmctx_store()) };
  269|    612|        assert!(!ptr.is_null());
  270|    612|        ptr
  271|    612|    }
_RNvMs2_NtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB5_14InstanceHandle8instance:
 1158|  1.22k|    pub(crate) fn instance(&self) -> &Instance {
 1159|  1.22k|        unsafe { &*(self.instance as *const Instance) }
 1160|  1.22k|    }
_RNvMs2_NtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB5_14InstanceHandle5store:
 1168|    612|    pub fn store(&self) -> *mut dyn Store {
 1169|    612|        self.instance().store()
 1170|    612|    }
_RINvMNtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetODNtB5_5StoreEL_ECs3hbrbrmFUf_8wasmtime:
  141|    612|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|    612|        (self.vmctx_ptr().cast::<u8>())
  143|    612|            .add(usize::try_from(offset).unwrap())
  144|    612|            .cast()
  145|    612|    }
_RNvMs2_NtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB5_14InstanceHandle5clone:
 1187|    612|    pub unsafe fn clone(&self) -> InstanceHandle {
 1188|    612|        InstanceHandle {
 1189|    612|            instance: self.instance,
 1190|    612|        }
 1191|    612|    }
_RNvMNtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB2_8Instance19get_exported_global:
  347|    204|    fn get_exported_global(&mut self, index: GlobalIndex) -> ExportGlobal {
  348|       |        ExportGlobal {
  349|    204|            definition: if let Some(def_index) = self.module().defined_global_index(index) {
  350|    204|                self.global_ptr(def_index)
  351|       |            } else {
  352|      0|                self.imported_global(index).from
  353|       |            },
  354|    204|            global: self.module().globals[index],
  355|    204|        }
  356|    204|    }
_RINvMNtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetPNtNtB5_9vmcontext22VMSharedSignatureIndexEB5_:
  141|    612|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|    612|        (self.vmctx_ptr().cast::<u8>())
  143|    612|            .add(usize::try_from(offset).unwrap())
  144|    612|            .cast()
  145|    612|    }
_RNvMNtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB2_8Instance24initialize_vmctx_globals:
  972|    612|    unsafe fn initialize_vmctx_globals(&mut self, module: &Module) {
  973|    612|        let num_imports = module.num_imported_globals;
  974|    612|        for (index, global) in module.globals.iter().skip(num_imports) {
  975|    204|            let def_index = module.defined_global_index(index).unwrap();
  976|    204|            let to = self.global_ptr(def_index);
  977|    204|
  978|    204|            // Initialize the global before writing to it
  979|    204|            ptr::write(to, VMGlobalDefinition::new());
  980|    204|
  981|    204|            match global.initializer {
  982|      0|                GlobalInit::I32Const(x) => *(*to).as_i32_mut() = x,
  983|    204|                GlobalInit::I64Const(x) => *(*to).as_i64_mut() = x,
  984|      0|                GlobalInit::F32Const(x) => *(*to).as_f32_bits_mut() = x,
  985|      0|                GlobalInit::F64Const(x) => *(*to).as_f64_bits_mut() = x,
  986|      0|                GlobalInit::V128Const(x) => *(*to).as_u128_mut() = x,
  987|      0|                GlobalInit::GetGlobal(x) => {
  988|      0|                    let from = if let Some(def_x) = module.defined_global_index(x) {
  989|      0|                        self.global(def_x)
  990|       |                    } else {
  991|      0|                        &*self.imported_global(x).from
  992|       |                    };
  993|       |                    // Globals of type `externref` need to manage the reference
  994|       |                    // count as values move between globals, everything else is just
  995|       |                    // copy-able bits.
  996|      0|                    match global.wasm_ty {
  997|       |                        WasmType::ExternRef => {
  998|      0|                            *(*to).as_externref_mut() = from.as_externref().clone()
  999|       |                        }
 1000|      0|                        _ => ptr::copy_nonoverlapping(from, to, 1),
 1001|       |                    }
 1002|       |                }
 1003|      0|                GlobalInit::RefFunc(f) => {
 1004|      0|                    *(*to).as_anyfunc_mut() = self.get_caller_checked_anyfunc(f).unwrap()
 1005|      0|                        as *const VMCallerCheckedAnyfunc;
 1006|      0|                }
 1007|      0|                GlobalInit::RefNullConst => match global.wasm_ty {
 1008|       |                    // `VMGlobalDefinition::new()` already zeroed out the bits
 1009|      0|                    WasmType::FuncRef => {}
 1010|      0|                    WasmType::ExternRef => {}
 1011|      0|                    ty => panic!("unsupported reference type for global: {:?}", ty),
 1012|       |                },
 1013|      0|                GlobalInit::Import => panic!("locally-defined global initialized as import"),
 1014|       |            }
 1015|       |        }
 1016|    612|    }
_RNvMNtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB2_8Instance16initialize_vmctx:
  890|    612|    unsafe fn initialize_vmctx(&mut self, module: &Module, store: StorePtr, imports: Imports) {
  891|    612|        assert!(std::ptr::eq(module, self.module().as_ref()));
  892|       |
  893|    612|        *self.vmctx_plus_offset(self.offsets.vmctx_magic()) = VMCONTEXT_MAGIC;
  894|    612|        self.set_callee(None);
  895|    612|        self.set_store(store.as_raw());
  896|    612|
  897|    612|        // Initialize shared signatures
  898|    612|        let signatures = self.runtime_info.signature_ids();
  899|    612|        *self.vmctx_plus_offset(self.offsets.vmctx_signature_ids_array()) = signatures.as_ptr();
  900|    612|
  901|    612|        // Initialize the built-in functions
  902|    612|        *self.vmctx_plus_offset(self.offsets.vmctx_builtin_functions()) =
  903|    612|            &VMBuiltinFunctionsArray::INIT;
  904|       |
  905|       |        // Initialize the imports
  906|    612|        debug_assert_eq!(imports.functions.len(), module.num_imported_funcs);
  907|    612|        ptr::copy_nonoverlapping(
  908|    612|            imports.functions.as_ptr(),
  909|    612|            self.vmctx_plus_offset(self.offsets.vmctx_imported_functions_begin()),
  910|    612|            imports.functions.len(),
  911|    612|        );
  912|    612|        debug_assert_eq!(imports.tables.len(), module.num_imported_tables);
  913|    612|        ptr::copy_nonoverlapping(
  914|    612|            imports.tables.as_ptr(),
  915|    612|            self.vmctx_plus_offset(self.offsets.vmctx_imported_tables_begin()),
  916|    612|            imports.tables.len(),
  917|    612|        );
  918|    612|        debug_assert_eq!(imports.memories.len(), module.num_imported_memories);
  919|    612|        ptr::copy_nonoverlapping(
  920|    612|            imports.memories.as_ptr(),
  921|    612|            self.vmctx_plus_offset(self.offsets.vmctx_imported_memories_begin()),
  922|    612|            imports.memories.len(),
  923|    612|        );
  924|    612|        debug_assert_eq!(imports.globals.len(), module.num_imported_globals);
  925|    612|        ptr::copy_nonoverlapping(
  926|    612|            imports.globals.as_ptr(),
  927|    612|            self.vmctx_plus_offset(self.offsets.vmctx_imported_globals_begin()),
  928|    612|            imports.globals.len(),
  929|    612|        );
  930|    612|
  931|    612|        // N.B.: there is no need to initialize the anyfuncs array because
  932|    612|        // we eagerly construct each element in it whenever asked for a
  933|    612|        // reference to that element. In other words, there is no state
  934|    612|        // needed to track the lazy-init, so we don't need to initialize
  935|    612|        // any state now.
  936|    612|
  937|    612|        // Initialize the defined tables
  938|    612|        let mut ptr = self.vmctx_plus_offset(self.offsets.vmctx_tables_begin());
  939|    612|        for i in 0..module.table_plans.len() - module.num_imported_tables {
  940|      0|            ptr::write(ptr, self.tables[DefinedTableIndex::new(i)].vmtable());
  941|      0|            ptr = ptr.add(1);
  942|      0|        }
  943|       |
  944|       |        // Initialize the defined memories. This fills in both the
  945|       |        // `defined_memories` table and the `owned_memories` table at the same
  946|       |        // time. Entries in `defined_memories` hold a pointer to a definition
  947|       |        // (all memories) whereas the `owned_memories` hold the actual
  948|       |        // definitions of memories owned (not shared) in the module.
  949|    612|        let mut ptr = self.vmctx_plus_offset(self.offsets.vmctx_memories_begin());
  950|    612|        let mut owned_ptr = self.vmctx_plus_offset(self.offsets.vmctx_owned_memories_begin());
  951|    612|        for i in 0..module.memory_plans.len() - module.num_imported_memories {
  952|    204|            let defined_memory_index = DefinedMemoryIndex::new(i);
  953|    204|            let memory_index = module.memory_index(defined_memory_index);
  954|    204|            if module.memory_plans[memory_index].memory.shared {
  955|      0|                let def_ptr = self.memories[defined_memory_index]
  956|      0|                    .as_shared_memory()
  957|      0|                    .unwrap()
  958|      0|                    .vmmemory_ptr_mut();
  959|      0|                ptr::write(ptr, def_ptr);
  960|    204|            } else {
  961|    204|                ptr::write(owned_ptr, self.memories[defined_memory_index].vmmemory());
  962|    204|                ptr::write(ptr, owned_ptr);
  963|    204|                owned_ptr = owned_ptr.add(1);
  964|    204|            }
  965|    204|            ptr = ptr.add(1);
  966|       |        }
  967|       |
  968|       |        // Initialize the defined globals
  969|    612|        self.initialize_vmctx_globals(module);
  970|    612|    }
_RNvXs_NtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB4_8InstanceNtNtNtCshM4Il2Z0i4R_4core3ops4drop4Drop4drop:
 1020|    612|    fn drop(&mut self) {
 1021|       |        // Drop any defined globals
 1022|    612|        for (idx, global) in self.module().globals.iter() {
 1023|    204|            let idx = match self.module().defined_global_index(idx) {
 1024|    204|                Some(idx) => idx,
 1025|      0|                None => continue,
 1026|       |            };
 1027|    204|            match global.wasm_ty {
 1028|       |                // For now only externref globals need to get destroyed
 1029|      0|                WasmType::ExternRef => {}
 1030|    204|                _ => continue,
 1031|       |            }
 1032|      0|            unsafe {
 1033|      0|                drop((*self.global_ptr(idx)).as_externref_mut().take());
 1034|      0|            }
 1035|       |        }
 1036|    612|    }
_RNvMNtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB2_8Instance6module:
  147|  2.24k|    pub(crate) fn module(&self) -> &Arc<Module> {
  148|  2.24k|        self.runtime_info.module()
  149|  2.24k|    }
_RINvMNtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetODNtB5_5StoreEL_EB5_:
  141|    612|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|    612|        (self.vmctx_ptr().cast::<u8>())
  143|    612|            .add(usize::try_from(offset).unwrap())
  144|    612|            .cast()
  145|    612|    }
_RNvMs2_NtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB5_14InstanceHandle19get_exported_memory:
 1097|    204|    pub fn get_exported_memory(&mut self, export: MemoryIndex) -> ExportMemory {
 1098|    204|        self.instance_mut().get_exported_memory(export)
 1099|    204|    }
_RNvMNtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB2_8Instance9epoch_ptr:
  247|    816|    pub fn epoch_ptr(&self) -> *mut *const AtomicU64 {
  248|    816|        unsafe { self.vmctx_plus_offset(self.offsets.vmctx_epoch_ptr()) }
  249|    816|    }
_RNvMNtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB2_8Instance14runtime_limits:
  242|    816|    pub fn runtime_limits(&self) -> *mut *const VMRuntimeLimits {
  243|    816|        unsafe { self.vmctx_plus_offset(self.offsets.vmctx_runtime_limits()) }
  244|    816|    }
_RINvMNtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetNtNtB5_9vmcontext18VMMemoryDefinitionEB5_:
  141|    612|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|    612|        (self.vmctx_ptr().cast::<u8>())
  143|    612|            .add(usize::try_from(offset).unwrap())
  144|    612|            .cast()
  145|    612|    }
_RNvMNtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB2_8Instance27externref_activations_table:
  252|    816|    pub fn externref_activations_table(&self) -> *mut *mut VMExternRefActivationsTable {
  253|    816|        unsafe { self.vmctx_plus_offset(self.offsets.vmctx_externref_activations_table()) }
  254|    816|    }
_RINvMNtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetPNtNtB5_9vmcontext15VMRuntimeLimitsEB5_:
  141|    816|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|    816|        (self.vmctx_ptr().cast::<u8>())
  143|    816|            .add(usize::try_from(offset).unwrap())
  144|    816|            .cast()
  145|    816|    }
_RNvMs2_NtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB5_14InstanceHandle12instance_mut:
 1162|    612|    pub(crate) fn instance_mut(&mut self) -> &mut Instance {
 1163|    612|        unsafe { &mut *self.instance }
 1164|    612|    }
_RNvMNtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB2_8Instance10memory_ptr:
  212|    204|    fn memory_ptr(&self, index: DefinedMemoryIndex) -> *mut VMMemoryDefinition {
  213|    204|        unsafe { *self.vmctx_plus_offset(self.offsets.vmctx_vmmemory_pointer(index)) }
  214|    204|    }
_RNvMNtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB2_8Instance19get_exported_memory:
  331|    204|    fn get_exported_memory(&mut self, index: MemoryIndex) -> ExportMemory {
  332|    204|        let (definition, vmctx, def_index) =
  333|    204|            if let Some(def_index) = self.module().defined_memory_index(index) {
  334|    204|                (self.memory_ptr(def_index), self.vmctx_ptr(), def_index)
  335|       |            } else {
  336|      0|                let import = self.imported_memory(index);
  337|      0|                (import.from, import.vmctx, import.index)
  338|       |            };
  339|    204|        ExportMemory {
  340|    204|            definition,
  341|    204|            vmctx,
  342|    204|            memory: self.module().memory_plans[index].clone(),
  343|    204|            index: def_index,
  344|    204|        }
  345|    204|    }
_RINvMNtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetNtNtB5_9vmcontext14VMGlobalImportEB5_:
  141|    612|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|    612|        (self.vmctx_ptr().cast::<u8>())
  143|    612|            .add(usize::try_from(offset).unwrap())
  144|    612|            .cast()
  145|    612|    }
_RNvMNtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB2_8Instance12alloc_layout:
  468|  1.83k|    fn alloc_layout(offsets: &VMOffsets<HostPtr>) -> Layout {
  469|  1.83k|        let size = mem::size_of::<Self>()
  470|  1.83k|            .checked_add(usize::try_from(offsets.size_of_vmctx()).unwrap())
  471|  1.83k|            .unwrap();
  472|  1.83k|        let align = mem::align_of::<Self>();
  473|  1.83k|        Layout::from_size_align(size, align).unwrap()
  474|  1.83k|    }
_RINvMNtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetONtNtB5_9vmcontext14VMFunctionBodyEB5_:
  141|    612|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|    612|        (self.vmctx_ptr().cast::<u8>())
  143|    612|            .add(usize::try_from(offset).unwrap())
  144|    612|            .cast()
  145|    612|    }
_RNvMNtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB2_8Instance10global_ptr:
  222|    408|    fn global_ptr(&self, index: DefinedGlobalIndex) -> *mut VMGlobalDefinition {
  223|    408|        unsafe { self.vmctx_plus_offset(self.offsets.vmctx_vmglobal_definition(index)) }
  224|    408|    }
_RINvMNtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetmEB5_:
  141|    612|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|    612|        (self.vmctx_ptr().cast::<u8>())
  143|    612|            .add(usize::try_from(offset).unwrap())
  144|    612|            .cast()
  145|    612|    }
_RINvMNtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetNtNtB5_9vmcontext16VMFunctionImportEB5_:
  141|    612|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|    612|        (self.vmctx_ptr().cast::<u8>())
  143|    612|            .add(usize::try_from(offset).unwrap())
  144|    612|            .cast()
  145|    612|    }
_RINvMNtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetAOuj2_EB5_:
  141|    204|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|    204|        (self.vmctx_ptr().cast::<u8>())
  143|    204|            .add(usize::try_from(offset).unwrap())
  144|    204|            .cast()
  145|    204|    }
_RINvMNtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetNtNtB5_9vmcontext14VMMemoryImportEB5_:
  141|    612|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|    612|        (self.vmctx_ptr().cast::<u8>())
  143|    612|            .add(usize::try_from(offset).unwrap())
  144|    612|            .cast()
  145|    612|    }
_RNvMs2_NtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB5_14InstanceHandle19get_exported_global:
 1092|    204|    pub fn get_exported_global(&mut self, export: GlobalIndex) -> ExportGlobal {
 1093|    204|        self.instance_mut().get_exported_global(export)
 1094|    204|    }
_RINvMNtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetNtNtB5_9vmcontext18VMGlobalDefinitionEB5_:
  141|    408|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|    408|        (self.vmctx_ptr().cast::<u8>())
  143|    408|            .add(usize::try_from(offset).unwrap())
  144|    408|            .cast()
  145|    408|    }
_RINvMNtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetONtNtB5_9vmcontext18VMMemoryDefinitionEB5_:
  141|    816|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|    816|        (self.vmctx_ptr().cast::<u8>())
  143|    816|            .add(usize::try_from(offset).unwrap())
  144|    816|            .cast()
  145|    816|    }
_RINvMNtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetRNtNtB5_9vmcontext23VMBuiltinFunctionsArrayEB5_:
  141|    612|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|    612|        (self.vmctx_ptr().cast::<u8>())
  143|    612|            .add(usize::try_from(offset).unwrap())
  144|    612|            .cast()
  145|    612|    }
_RINvMNtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetONtNtB5_9externref27VMExternRefActivationsTableEB5_:
  141|    816|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|    816|        (self.vmctx_ptr().cast::<u8>())
  143|    816|            .add(usize::try_from(offset).unwrap())
  144|    816|            .cast()
  145|    816|    }
_RNvMs2_NtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB5_14InstanceHandle9set_store:
 1176|    204|    pub unsafe fn set_store(&mut self, store: *mut dyn Store) {
 1177|    204|        self.instance_mut().set_store(Some(store));
 1178|    204|    }
_RINvMNtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetNtNtB5_9vmcontext13VMTableImportEB5_:
  141|    612|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|    612|        (self.vmctx_ptr().cast::<u8>())
  143|    612|            .add(usize::try_from(offset).unwrap())
  144|    612|            .cast()
  145|    612|    }
_RINvMNtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetNtNtB5_9vmcontext17VMTableDefinitionEB5_:
  141|    612|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|    612|        (self.vmctx_ptr().cast::<u8>())
  143|    612|            .add(usize::try_from(offset).unwrap())
  144|    612|            .cast()
  145|    612|    }
_RINvMNtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetPNtNtNtCshM4Il2Z0i4R_4core4sync6atomic9AtomicU64EB5_:
  141|    816|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|    816|        (self.vmctx_ptr().cast::<u8>())
  143|    816|            .add(usize::try_from(offset).unwrap())
  144|    816|            .cast()
  145|    816|    }
_RNvMNtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB2_8Instance9set_store:
  273|    816|    pub unsafe fn set_store(&mut self, store: Option<*mut dyn Store>) {
  274|    816|        if let Some(store) = store {
  275|    612|            *self.vmctx_plus_offset(self.offsets.vmctx_store()) = store;
  276|    612|            *self.runtime_limits() = (*store).vmruntime_limits();
  277|    612|            *self.epoch_ptr() = (*store).epoch_ptr();
  278|    612|            *self.externref_activations_table() = (*store).externref_activations_table().0;
  279|    612|        } else {
  280|    204|            assert_eq!(
  281|    204|                mem::size_of::<*mut dyn Store>(),
  282|    204|                mem::size_of::<[*mut (); 2]>()
  283|    204|            );
  284|    204|            *self.vmctx_plus_offset::<[*mut (); 2]>(self.offsets.vmctx_store()) =
  285|    204|                [ptr::null_mut(), ptr::null_mut()];
  286|    204|
  287|    204|            *self.runtime_limits() = ptr::null_mut();
  288|    204|            *self.epoch_ptr() = ptr::null_mut();
  289|    204|            *self.externref_activations_table() = ptr::null_mut();
  290|       |        }
  291|    816|    }
_RNvMNtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB2_8Instance6new_at:
  105|    612|    unsafe fn new_at(
  106|    612|        ptr: *mut Instance,
  107|    612|        alloc_size: usize,
  108|    612|        offsets: VMOffsets<HostPtr>,
  109|    612|        req: InstanceAllocationRequest,
  110|    612|        memories: PrimaryMap<DefinedMemoryIndex, Memory>,
  111|    612|        tables: PrimaryMap<DefinedTableIndex, Table>,
  112|    612|    ) {
  113|    612|        // The allocation must be *at least* the size required of `Instance`.
  114|    612|        assert!(alloc_size >= Self::alloc_layout(&offsets).size());
  115|       |
  116|    612|        let module = req.runtime_info.module();
  117|    612|        let dropped_elements = EntitySet::with_capacity(module.passive_elements.len());
  118|    612|        let dropped_data = EntitySet::with_capacity(module.passive_data_map.len());
  119|    612|
  120|    612|        ptr::write(
  121|    612|            ptr,
  122|    612|            Instance {
  123|    612|                runtime_info: req.runtime_info.clone(),
  124|    612|                offsets,
  125|    612|                memories,
  126|    612|                tables,
  127|    612|                dropped_elements,
  128|    612|                dropped_data,
  129|    612|                host_state: req.host_state,
  130|    612|                vmctx: VMContext {
  131|    612|                    _marker: std::marker::PhantomPinned,
  132|    612|                },
  133|    612|            },
  134|    612|        );
  135|    612|
  136|    612|        (*ptr).initialize_vmctx(module, req.store, req.imports);
  137|    612|    }
_RNvMNtCsa8j9dqGMVk5_16wasmtime_runtime8instanceNtB2_8Instance10set_callee:
  293|    612|    pub(crate) unsafe fn set_callee(&mut self, callee: Option<NonNull<VMFunctionBody>>) {
  294|    612|        *self.vmctx_plus_offset(self.offsets.vmctx_callee()) =
  295|    612|            callee.map_or(ptr::null_mut(), |c| c.as_ptr());
  296|    612|    }

_RNvMs_NtNtCsa8j9dqGMVk5_16wasmtime_runtime8instance9allocatorNtB4_25OnDemandInstanceAllocator3new:
  438|    204|    pub fn new(mem_creator: Option<Arc<dyn RuntimeMemoryCreator>>, stack_size: usize) -> Self {
  439|    204|        drop(stack_size); // suppress unused warnings w/o async feature
  440|    204|        Self {
  441|    204|            mem_creator,
  442|    204|            #[cfg(feature = "async")]
  443|    204|            stack_size,
  444|    204|        }
  445|    204|    }
_RNvXs1_NtNtCsa8j9dqGMVk5_16wasmtime_runtime8instance9allocatorNtB5_25OnDemandInstanceAllocatorNtB5_17InstanceAllocator8allocate:
  548|    408|    unsafe fn allocate(
  549|    408|        &self,
  550|    408|        mut req: InstanceAllocationRequest,
  551|    408|    ) -> Result<InstanceHandle, InstantiationError> {
  552|    408|        let memories = self.create_memories(&mut req.store, &req.runtime_info)?;
  553|    408|        let tables = Self::create_tables(&mut req.store, &req.runtime_info)?;
  554|    408|        let module = req.runtime_info.module();
  555|    408|        let offsets = VMOffsets::new(HostPtr, module);
  556|    408|        let layout = Instance::alloc_layout(&offsets);
  557|    408|        let instance_ptr = alloc::alloc(layout) as *mut Instance;
  558|    408|
  559|    408|        Instance::new_at(instance_ptr, layout.size(), offsets, req, memories, tables);
  560|    408|
  561|    408|        Ok(InstanceHandle {
  562|    408|            instance: instance_ptr,
  563|    408|        })
  564|    408|    }
_RNCNvMs_NtNtCsa8j9dqGMVk5_16wasmtime_runtime8instance9allocatorNtB6_25OnDemandInstanceAllocator15create_memories0Ba_:
  477|    408|            .unwrap_or_else(|| &DefaultMemoryCreator);
_RNvNtNtCsa8j9dqGMVk5_16wasmtime_runtime8instance9allocator31allocate_single_memory_instance:
  523|    204|pub unsafe fn allocate_single_memory_instance(
  524|    204|    req: InstanceAllocationRequest,
  525|    204|    memory: Memory,
  526|    204|) -> Result<InstanceHandle, InstantiationError> {
  527|    204|    let mut memories = PrimaryMap::default();
  528|    204|    memories.push(memory);
  529|    204|    let tables = PrimaryMap::default();
  530|    204|    let module = req.runtime_info.module();
  531|    204|    let offsets = VMOffsets::new(HostPtr, module);
  532|    204|    let layout = Instance::alloc_layout(&offsets);
  533|    204|    let instance = alloc::alloc(layout) as *mut Instance;
  534|    204|    Instance::new_at(instance, layout.size(), offsets, req, memories, tables);
  535|    204|    Ok(InstanceHandle { instance })
  536|    204|}
_RNvMs_NtNtCsa8j9dqGMVk5_16wasmtime_runtime8instance9allocatorNtB4_25OnDemandInstanceAllocator13create_tables:
  447|    408|    fn create_tables(
  448|    408|        store: &mut StorePtr,
  449|    408|        runtime_info: &Arc<dyn ModuleRuntimeInfo>,
  450|    408|    ) -> Result<PrimaryMap<DefinedTableIndex, Table>, InstantiationError> {
  451|    408|        let module = runtime_info.module();
  452|    408|        let num_imports = module.num_imported_tables;
  453|    408|        let mut tables: PrimaryMap<DefinedTableIndex, _> =
  454|    408|            PrimaryMap::with_capacity(module.table_plans.len() - num_imports);
  455|    408|        for (_, table) in module.table_plans.iter().skip(num_imports) {
  456|       |            tables.push(
  457|      0|                Table::new_dynamic(table, unsafe {
  458|      0|                    store
  459|      0|                        .get()
  460|      0|                        .expect("if module has table plans, store is not empty")
  461|      0|                })
  462|      0|                .map_err(InstantiationError::Resource)?,
  463|       |            );
  464|       |        }
  465|    408|        Ok(tables)
  466|    408|    }
_RNvMNtNtCsa8j9dqGMVk5_16wasmtime_runtime8instance9allocatorNtB2_8StorePtr3new:
   70|    408|    pub fn new(ptr: *mut dyn Store) -> Self {
   71|    408|        Self(Some(ptr))
   72|    408|    }
_RNvNtNtCsa8j9dqGMVk5_16wasmtime_runtime8instance9allocator10deallocate:
  541|    612|pub unsafe fn deallocate(handle: &InstanceHandle) {
  542|    612|    let layout = Instance::alloc_layout(&handle.instance().offsets);
  543|    612|    ptr::drop_in_place(handle.instance);
  544|    612|    alloc::dealloc(handle.instance.cast(), layout);
  545|    612|}
_RNvMs_NtNtCsa8j9dqGMVk5_16wasmtime_runtime8instance9allocatorNtB4_25OnDemandInstanceAllocator15create_memories:
  468|    408|    fn create_memories(
  469|    408|        &self,
  470|    408|        store: &mut StorePtr,
  471|    408|        runtime_info: &Arc<dyn ModuleRuntimeInfo>,
  472|    408|    ) -> Result<PrimaryMap<DefinedMemoryIndex, Memory>, InstantiationError> {
  473|    408|        let module = runtime_info.module();
  474|    408|        let creator = self
  475|    408|            .mem_creator
  476|    408|            .as_deref()
  477|    408|            .unwrap_or_else(|| &DefaultMemoryCreator);
  478|    408|        let num_imports = module.num_imported_memories;
  479|    408|        let mut memories: PrimaryMap<DefinedMemoryIndex, _> =
  480|    408|            PrimaryMap::with_capacity(module.memory_plans.len() - num_imports);
  481|    408|        for (memory_idx, plan) in module.memory_plans.iter().skip(num_imports) {
  482|      0|            let defined_memory_idx = module
  483|      0|                .defined_memory_index(memory_idx)
  484|      0|                .expect("Skipped imports, should never be None");
  485|      0|            let image = runtime_info
  486|      0|                .memory_image(defined_memory_idx)
  487|      0|                .map_err(|err| InstantiationError::Resource(err.into()))?;
  488|       |
  489|       |            memories.push(
  490|      0|                Memory::new_dynamic(
  491|      0|                    plan,
  492|      0|                    creator,
  493|      0|                    unsafe {
  494|      0|                        store
  495|      0|                            .get()
  496|      0|                            .expect("if module has memory plans, store is not empty")
  497|      0|                    },
  498|      0|                    image,
  499|      0|                )
  500|      0|                .map_err(InstantiationError::Resource)?,
  501|       |            );
  502|       |        }
  503|    408|        Ok(memories)
  504|    408|    }
_RNvMNtNtCsa8j9dqGMVk5_16wasmtime_runtime8instance9allocatorNtB2_8StorePtr6as_raw:
   74|    612|    pub fn as_raw(&self) -> Option<*mut dyn Store> {
   75|    612|        self.0.clone()
   76|    612|    }
_RNvMNtNtCsa8j9dqGMVk5_16wasmtime_runtime8instance9allocatorNtB2_8StorePtr5empty:
   66|    204|    pub fn empty() -> Self {
   67|    204|        Self(None)
   68|    204|    }
_RNvXs1_NtNtCsa8j9dqGMVk5_16wasmtime_runtime8instance9allocatorNtB5_25OnDemandInstanceAllocatorNtB5_17InstanceAllocator10deallocate:
  575|    612|    unsafe fn deallocate(&self, handle: &InstanceHandle) {
  576|    612|        deallocate(handle)
  577|    612|    }
_RNvXs0_NtNtCsa8j9dqGMVk5_16wasmtime_runtime8instance9allocatorNtB5_25OnDemandInstanceAllocatorNtNtCshM4Il2Z0i4R_4core7default7Default7default:
  508|    408|    fn default() -> Self {
  509|    408|        Self {
  510|    408|            mem_creator: None,
  511|    408|            #[cfg(feature = "async")]
  512|    408|            stack_size: 0,
  513|    408|        }
  514|    408|    }

_RNvXs8_NtNtNtCsa8j9dqGMVk5_16wasmtime_runtime8instance9allocator7poolingNtB5_14InstanceLimitsNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
   54|    204|#[derive(Debug, Copy, Clone)]
_RNvXsa_NtNtNtCsa8j9dqGMVk5_16wasmtime_runtime8instance9allocator7poolingNtB5_25PoolingAllocationStrategyNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
  173|    204|#[derive(Debug, Clone, Copy, PartialEq, Eq)]
_RNvXs5_NtNtNtCsa8j9dqGMVk5_16wasmtime_runtime8instance9allocator7poolingNtB5_24PoolingInstanceAllocatorNtB7_17InstanceAllocator15adjust_tunables:
 1091|    204|    fn adjust_tunables(&self, tunables: &mut Tunables) {
 1092|    204|        // Treat the static memory bound as the maximum for unbounded Wasm memories
 1093|    204|        // Because we guarantee a module cannot compile unless it fits in the limits of
 1094|    204|        // the pool allocator, this ensures all memories are treated as static (i.e. immovable).
 1095|    204|        tunables.static_memory_bound_is_maximum = true;
 1096|    204|    }
_RNvMs4_NtNtNtCsa8j9dqGMVk5_16wasmtime_runtime8instance9allocator7poolingNtB5_24PoolingInstanceAllocator3new:
 1049|    204|    pub fn new(
 1050|    204|        strategy: PoolingAllocationStrategy,
 1051|    204|        instance_limits: InstanceLimits,
 1052|    204|        stack_size: usize,
 1053|    204|        tunables: &Tunables,
 1054|    204|        async_stack_zeroing: bool,
 1055|    204|    ) -> Result<Self> {
 1056|    204|        if instance_limits.count == 0 {
 1057|      0|            bail!("the instance count limit cannot be zero");
 1058|    204|        }
 1059|       |
 1060|    204|        let instances = InstancePool::new(strategy, &instance_limits, tunables)?;
 1061|       |
 1062|    204|        drop(stack_size); // suppress unused warnings w/o async feature
 1063|    204|        drop(async_stack_zeroing); // suppress unused warnings w/o async feature
 1064|    204|
 1065|    204|        Ok(Self {
 1066|    204|            instances: instances,
 1067|    204|            #[cfg(all(feature = "async", unix))]
 1068|    204|            stacks: StackPool::new(&instance_limits, stack_size, async_stack_zeroing)?,
 1069|    204|            #[cfg(all(feature = "async", windows))]
 1070|    204|            stack_size,
 1071|    204|        })
 1072|    204|    }
_RNCNvMs3_NtNtNtCsa8j9dqGMVk5_16wasmtime_runtime8instance9allocator7poolingNtB7_9TablePool3news_0Bd_:
  861|    204|            .and_then(|c| c.checked_mul(max_instances))
_RNCNvMs1_NtNtNtCsa8j9dqGMVk5_16wasmtime_runtime8instance9allocator7poolingNtB7_10MemoryPool3news2_0Bd_:
  753|   209k|        let image_slots: Vec<_> = std::iter::repeat_with(|| Mutex::new(None))
_RNvXNtNtNtCsa8j9dqGMVk5_16wasmtime_runtime8instance9allocator7poolingNtB2_14InstanceLimitsNtNtCshM4Il2Z0i4R_4core7default7Default7default:
  159|    204|    fn default() -> Self {
  160|    204|        // See doc comments for `wasmtime::InstanceLimits` for these default values
  161|    204|        Self {
  162|    204|            count: 1000,
  163|    204|            size: 1 << 20, // 1 MB
  164|    204|            tables: 1,
  165|    204|            table_elements: 10_000,
  166|    204|            memories: 1,
  167|    204|            memory_pages: 160,
  168|    204|        }
  169|    204|    }
_RNCNvMs1_NtNtNtCsa8j9dqGMVk5_16wasmtime_runtime8instance9allocator7poolingNtB7_10MemoryPool3news0_0Bd_:
  739|    204|            .and_then(|c| c.checked_add(initial_memory_offset))
_RNCNvMs1_NtNtNtCsa8j9dqGMVk5_16wasmtime_runtime8instance9allocator7poolingNtB7_10MemoryPool3news_0Bd_:
  738|    204|            .and_then(|c| c.checked_mul(max_instances))
_RNvMs0_NtNtNtCsa8j9dqGMVk5_16wasmtime_runtime8instance9allocator7poolingNtB5_12InstancePool3new:
  212|    204|    fn new(
  213|    204|        strategy: PoolingAllocationStrategy,
  214|    204|        instance_limits: &InstanceLimits,
  215|    204|        tunables: &Tunables,
  216|    204|    ) -> Result<Self> {
  217|    204|        let page_size = crate::page_size();
  218|    204|
  219|    204|        let instance_size = round_up_to_pow2(instance_limits.size, mem::align_of::<Instance>());
  220|    204|
  221|    204|        let max_instances = instance_limits.count as usize;
  222|       |
  223|    204|        let allocation_size = round_up_to_pow2(
  224|    204|            instance_size
  225|    204|                .checked_mul(max_instances)
  226|    204|                .ok_or_else(|| anyhow!("total size of instance data exceeds addressable memory"))?,
  227|    204|            page_size,
  228|       |        );
  229|       |
  230|    204|        let mapping = Mmap::accessible_reserved(allocation_size, allocation_size)
  231|    204|            .context("failed to create instance pool mapping")?;
  232|       |
  233|    204|        let pool = Self {
  234|    204|            mapping,
  235|    204|            instance_size,
  236|    204|            max_instances,
  237|    204|            index_allocator: Mutex::new(PoolingAllocationState::new(strategy, max_instances)),
  238|    204|            memories: MemoryPool::new(instance_limits, tunables)?,
  239|    204|            tables: TablePool::new(instance_limits)?,
  240|       |        };
  241|       |
  242|    204|        Ok(pool)
  243|    204|    }
_RNvNtNtNtCsa8j9dqGMVk5_16wasmtime_runtime8instance9allocator7pooling16round_up_to_pow2:
   47|    612|fn round_up_to_pow2(n: usize, to: usize) -> usize {
   48|    612|    debug_assert!(to > 0);
   49|    612|    debug_assert!(to.is_power_of_two());
   50|    612|    (n + to - 1) & !(to - 1)
   51|    612|}
_RNvMs1_NtNtNtCsa8j9dqGMVk5_16wasmtime_runtime8instance9allocator7poolingNtB5_10MemoryPool3new:
  685|    204|    fn new(instance_limits: &InstanceLimits, tunables: &Tunables) -> Result<Self> {
  686|    204|        // The maximum module memory page count cannot exceed 65536 pages
  687|    204|        if instance_limits.memory_pages > 0x10000 {
  688|      0|            bail!(
  689|      0|                "module memory page limit of {} exceeds the maximum of 65536",
  690|      0|                instance_limits.memory_pages
  691|      0|            );
  692|    204|        }
  693|    204|
  694|    204|        // The maximum module memory page count cannot exceed the memory reservation size
  695|    204|        if u64::from(instance_limits.memory_pages) > tunables.static_memory_bound {
  696|      0|            bail!(
  697|      0|                "module memory page limit of {} pages exceeds maximum static memory limit of {} pages",
  698|      0|                instance_limits.memory_pages,
  699|      0|                tunables.static_memory_bound,
  700|      0|            );
  701|    204|        }
  702|    204|
  703|    204|        let static_memory_bound =
  704|    204|            u64::from(tunables.static_memory_bound) * u64::from(WASM_PAGE_SIZE);
  705|    204|        let memory_size =
  706|    204|            usize::try_from(static_memory_bound + tunables.static_memory_offset_guard_size)
  707|    204|                .map_err(|_| anyhow!("memory reservation size exceeds addressable memory"))?;
  708|       |
  709|    204|        assert!(
  710|    204|            memory_size % crate::page_size() == 0,
  711|      0|            "memory size {} is not a multiple of system page size",
  712|       |            memory_size
  713|       |        );
  714|       |
  715|    204|        let max_instances = instance_limits.count as usize;
  716|    204|        let max_memories = instance_limits.memories as usize;
  717|    204|        let initial_memory_offset = if tunables.guard_before_linear_memory {
  718|    204|            usize::try_from(tunables.static_memory_offset_guard_size).unwrap()
  719|       |        } else {
  720|      0|            0
  721|       |        };
  722|       |
  723|       |        // The entire allocation here is the size of each memory times the
  724|       |        // max memories per instance times the number of instances allowed in
  725|       |        // this pool, plus guard regions.
  726|       |        //
  727|       |        // Note, though, that guard regions are required to be after each linear
  728|       |        // memory. If the `guard_before_linear_memory` setting is specified,
  729|       |        // then due to the contiguous layout of linear memories the guard pages
  730|       |        // after one memory are also guard pages preceding the next linear
  731|       |        // memory. This means that we only need to handle pre-guard-page sizes
  732|       |        // specially for the first linear memory, hence the
  733|       |        // `initial_memory_offset` variable here. If guards aren't specified
  734|       |        // before linear memories this is set to `0`, otherwise it's set to
  735|       |        // the same size as guard regions for other memories.
  736|    204|        let allocation_size = memory_size
  737|    204|            .checked_mul(max_memories)
  738|    204|            .and_then(|c| c.checked_mul(max_instances))
  739|    204|            .and_then(|c| c.checked_add(initial_memory_offset))
  740|    204|            .ok_or_else(|| {
  741|       |                anyhow!("total size of memory reservation exceeds addressable memory")
  742|    204|            })?;
  743|       |
  744|       |        // Create a completely inaccessible region to start
  745|    204|        let mapping = Mmap::accessible_reserved(0, allocation_size)
  746|    204|            .context("failed to create memory pool mapping")?;
  747|       |
  748|    204|        let num_image_slots = if cfg!(memory_init_cow) {
  749|    204|            max_instances * max_memories
  750|       |        } else {
  751|      0|            0
  752|       |        };
  753|    204|        let image_slots: Vec<_> = std::iter::repeat_with(|| Mutex::new(None))
  754|    204|            .take(num_image_slots)
  755|    204|            .collect();
  756|    204|
  757|    204|        let pool = Self {
  758|    204|            mapping,
  759|    204|            image_slots,
  760|    204|            memory_reservation_size: memory_size,
  761|    204|            initial_memory_offset,
  762|    204|            max_memories,
  763|    204|            max_instances,
  764|    204|            max_memory_size: (instance_limits.memory_pages as usize) * (WASM_PAGE_SIZE as usize),
  765|    204|            static_memory_bound,
  766|    204|        };
  767|    204|
  768|    204|        Ok(pool)
  769|    204|    }
_RNvXs2_NtNtNtCsa8j9dqGMVk5_16wasmtime_runtime8instance9allocator7poolingNtB5_10MemoryPoolNtNtNtCshM4Il2Z0i4R_4core3ops4drop4Drop4drop:
  818|    204|    fn drop(&mut self) {
  819|       |        // Clear the `clear_no_drop` flag (i.e., ask to *not* clear on
  820|       |        // drop) for all slots, and then drop them here. This is
  821|       |        // valid because the one `Mmap` that covers the whole region
  822|       |        // can just do its one munmap.
  823|   209k|        for mut slot in std::mem::take(&mut self.image_slots) {
  824|   209k|            if let Some(slot) = slot.get_mut().unwrap() {
  825|      0|                slot.no_clear_on_drop();
  826|   209k|            }
  827|       |        }
  828|    204|    }
_RNvMs3_NtNtNtCsa8j9dqGMVk5_16wasmtime_runtime8instance9allocator7poolingNtB5_9TablePool3new:
  846|    204|    fn new(instance_limits: &InstanceLimits) -> Result<Self> {
  847|    204|        let page_size = crate::page_size();
  848|       |
  849|    204|        let table_size = round_up_to_pow2(
  850|    204|            mem::size_of::<*mut u8>()
  851|    204|                .checked_mul(instance_limits.table_elements as usize)
  852|    204|                .ok_or_else(|| anyhow!("table size exceeds addressable memory"))?,
  853|    204|            page_size,
  854|    204|        );
  855|    204|
  856|    204|        let max_instances = instance_limits.count as usize;
  857|    204|        let max_tables = instance_limits.tables as usize;
  858|       |
  859|    204|        let allocation_size = table_size
  860|    204|            .checked_mul(max_tables)
  861|    204|            .and_then(|c| c.checked_mul(max_instances))
  862|    204|            .ok_or_else(|| anyhow!("total size of instance tables exceeds addressable memory"))?;
  863|       |
  864|    204|        let mapping = Mmap::accessible_reserved(allocation_size, allocation_size)
  865|    204|            .context("failed to create table pool mapping")?;
  866|       |
  867|    204|        Ok(Self {
  868|    204|            mapping,
  869|    204|            table_size,
  870|    204|            max_tables,
  871|    204|            max_instances,
  872|    204|            page_size,
  873|    204|            max_elements: instance_limits.table_elements,
  874|    204|        })
  875|    204|    }

_RNvMs3_NtNtNtNtCsa8j9dqGMVk5_16wasmtime_runtime8instance9allocator7pooling15index_allocatorNtB5_22PoolingAllocationState3new:
  251|    204|    pub(crate) fn new(strategy: PoolingAllocationStrategy, max_instances: usize) -> Self {
  252|    204|        let ids = (0..max_instances).map(|i| SlotId(i)).collect::<Vec<_>>();
  253|    204|        match strategy {
  254|      0|            PoolingAllocationStrategy::NextAvailable => PoolingAllocationState::NextAvailable(ids),
  255|      0|            PoolingAllocationStrategy::Random => PoolingAllocationState::Random(ids),
  256|    204|            PoolingAllocationStrategy::ReuseAffinity => PoolingAllocationState::ReuseAffinity {
  257|    204|                free_list: ids,
  258|    204|                per_module: HashMap::new(),
  259|    204|                slot_state: (0..max_instances)
  260|    204|                    .map(|i| {
  261|       |                        SlotState::Free(FreeSlotState::NoAffinity {
  262|       |                            free_list_index: GlobalFreeListIndex(i),
  263|       |                        })
  264|    204|                    })
  265|    204|                    .collect(),
  266|    204|            },
  267|       |        }
  268|    204|    }
_RNCNvMs3_NtNtNtNtCsa8j9dqGMVk5_16wasmtime_runtime8instance9allocator7pooling15index_allocatorNtB7_22PoolingAllocationState3new0Bf_:
  252|   209k|        let ids = (0..max_instances).map(|i| SlotId(i)).collect::<Vec<_>>();
_RNCNvMs3_NtNtNtNtCsa8j9dqGMVk5_16wasmtime_runtime8instance9allocator7pooling15index_allocatorNtB7_22PoolingAllocationState3news_0Bf_:
  260|   209k|                    .map(|i| {
  261|   209k|                        SlotState::Free(FreeSlotState::NoAffinity {
  262|   209k|                            free_list_index: GlobalFreeListIndex(i),
  263|   209k|                        })
  264|   209k|                    })

_RNvCsa8j9dqGMVk5_16wasmtime_runtime9page_size:
  207|  1.42k|pub fn page_size() -> usize {
  208|  1.42k|    static PAGE_SIZE: AtomicUsize = AtomicUsize::new(0);
  209|  1.42k|
  210|  1.42k|    return match PAGE_SIZE.load(Ordering::Relaxed) {
  211|       |        0 => {
  212|      1|            let size = get_page_size();
  213|      1|            assert!(size != 0);
  214|      1|            PAGE_SIZE.store(size, Ordering::Relaxed);
  215|      1|            size
  216|       |        }
  217|  1.42k|        n => n,
  218|       |    };
  219|       |
  220|       |    #[cfg(windows)]
  221|       |    fn get_page_size() -> usize {
  222|       |        use std::mem::MaybeUninit;
  223|       |        use windows_sys::Win32::System::SystemInformation::*;
  224|       |
  225|       |        unsafe {
  226|       |            let mut info = MaybeUninit::uninit();
  227|       |            GetSystemInfo(info.as_mut_ptr());
  228|       |            info.assume_init_ref().dwPageSize as usize
  229|       |        }
  230|       |    }
  231|       |
  232|       |    #[cfg(unix)]
  233|       |    fn get_page_size() -> usize {
  234|       |        unsafe { libc::sysconf(libc::_SC_PAGESIZE) as usize }
  235|       |    }
  236|  1.42k|}
_RNvNvCsa8j9dqGMVk5_16wasmtime_runtime9page_size13get_page_size:
  233|      1|    fn get_page_size() -> usize {
  234|      1|        unsafe { libc::sysconf(libc::_SC_PAGESIZE) as usize }
  235|      1|    }

_RNvMs7_NtCsa8j9dqGMVk5_16wasmtime_runtime6memoryNtB5_6Memory9limit_new:
  654|    204|    fn limit_new(
  655|    204|        plan: &MemoryPlan,
  656|    204|        store: Option<&mut dyn Store>,
  657|    204|    ) -> Result<(usize, Option<usize>)> {
  658|       |        // Sanity-check what should already be true from wasm module validation.
  659|    204|        let absolute_max = if plan.memory.memory64 {
  660|      0|            WASM64_MAX_PAGES
  661|       |        } else {
  662|    204|            WASM32_MAX_PAGES
  663|       |        };
  664|    204|        assert!(plan.memory.minimum <= absolute_max);
  665|    204|        assert!(plan.memory.maximum.is_none() || plan.memory.maximum.unwrap() <= absolute_max);
  666|       |
  667|       |        // This is the absolute possible maximum that the module can try to
  668|       |        // allocate, which is our entire address space minus a wasm page. That
  669|       |        // shouldn't ever actually work in terms of an allocation because
  670|       |        // presumably the kernel wants *something* for itself, but this is used
  671|       |        // to pass to the `store`'s limiter for a requested size
  672|       |        // to approximate the scale of the request that the wasm module is
  673|       |        // making. This is necessary because the limiter works on `usize` bytes
  674|       |        // whereas we're working with possibly-overflowing `u64` calculations
  675|       |        // here. To actually faithfully represent the byte requests of modules
  676|       |        // we'd have to represent things as `u128`, but that's kinda
  677|       |        // overkill for this purpose.
  678|    204|        let absolute_max = 0usize.wrapping_sub(WASM_PAGE_SIZE);
  679|    204|
  680|    204|        // If the minimum memory size overflows the size of our own address
  681|    204|        // space, then we can't satisfy this request, but defer the error to
  682|    204|        // later so the `store` can be informed that an effective oom is
  683|    204|        // happening.
  684|    204|        let minimum = plan
  685|    204|            .memory
  686|    204|            .minimum
  687|    204|            .checked_mul(WASM_PAGE_SIZE_U64)
  688|    204|            .and_then(|m| usize::try_from(m).ok());
  689|    204|
  690|    204|        // The plan stores the maximum size in units of wasm pages, but we
  691|    204|        // use units of bytes. Unlike for the `minimum` size we silently clamp
  692|    204|        // the effective maximum size to `absolute_max` above if the maximum is
  693|    204|        // too large. This should be ok since as a wasm runtime we get to
  694|    204|        // arbitrarily decide the actual maximum size of memory, regardless of
  695|    204|        // what's actually listed on the memory itself.
  696|    204|        let mut maximum = plan.memory.maximum.map(|max| {
  697|       |            usize::try_from(max)
  698|       |                .ok()
  699|       |                .and_then(|m| m.checked_mul(WASM_PAGE_SIZE))
  700|       |                .unwrap_or(absolute_max)
  701|    204|        });
  702|    204|
  703|    204|        // If this is a 32-bit memory and no maximum is otherwise listed then we
  704|    204|        // need to still specify a maximum size of 4GB. If the host platform is
  705|    204|        // 32-bit then there's no need to limit the maximum this way since no
  706|    204|        // allocation of 4GB can succeed, but for 64-bit platforms this is
  707|    204|        // required to limit memories to 4GB.
  708|    204|        if !plan.memory.memory64 && maximum.is_none() {
  709|      0|            maximum = usize::try_from(1u64 << 32).ok();
  710|    204|        }
  711|       |
  712|       |        // Inform the store's limiter what's about to happen. This will let the
  713|       |        // limiter reject anything if necessary, and this also guarantees that
  714|       |        // we should call the limiter for all requested memories, even if our
  715|       |        // `minimum` calculation overflowed. This means that the `minimum` we're
  716|       |        // informing the limiter is lossy and may not be 100% accurate, but for
  717|       |        // now the expected uses of limiter means that's ok.
  718|    204|        if let Some(store) = store {
  719|       |            // We ignore the store limits for shared memories since they are
  720|       |            // technically not created within a store (though, trickily, they
  721|       |            // may be associated with one in order to get a `vmctx`).
  722|    204|            if !plan.memory.shared {
  723|    204|                if !store.memory_growing(0, minimum.unwrap_or(absolute_max), maximum)? {
  724|      0|                    bail!(
  725|      0|                        "memory minimum size of {} pages exceeds memory limits",
  726|      0|                        plan.memory.minimum
  727|      0|                    );
  728|    204|                }
  729|      0|            }
  730|      0|        }
  731|       |
  732|       |        // At this point we need to actually handle overflows, so bail out with
  733|       |        // an error if we made it this far.
  734|    204|        let minimum = minimum.ok_or_else(|| {
  735|       |            format_err!(
  736|       |                "memory minimum size of {} pages exceeds memory limits",
  737|       |                plan.memory.minimum
  738|       |            )
  739|    204|        })?;
  740|    204|        Ok((minimum, maximum))
  741|    204|    }
_RNCNvMs7_NtCsa8j9dqGMVk5_16wasmtime_runtime6memoryNtB7_6Memory9limit_new0B9_:
  688|    204|            .and_then(|m| usize::try_from(m).ok());
_RNCNCNvMs7_NtCsa8j9dqGMVk5_16wasmtime_runtime6memoryNtB9_6Memory9limit_news_00Bb_:
  699|    204|                .and_then(|m| m.checked_mul(WASM_PAGE_SIZE))
_RNCNvMs_NtCsa8j9dqGMVk5_16wasmtime_runtime6memoryNtB6_10MmapMemory3new0B8_:
  226|    204|            .and_then(|i| i.checked_add(extra_to_reserve_on_growth))
_RNCNvMs_NtCsa8j9dqGMVk5_16wasmtime_runtime6memoryNtB6_10MmapMemory3news_0B8_:
  227|    204|            .and_then(|i| i.checked_add(offset_guard_bytes))
_RNCNvMs7_NtCsa8j9dqGMVk5_16wasmtime_runtime6memoryNtB7_6Memory9limit_news_0B9_:
  696|    204|        let mut maximum = plan.memory.maximum.map(|max| {
  697|    204|            usize::try_from(max)
  698|    204|                .ok()
  699|    204|                .and_then(|m| m.checked_mul(WASM_PAGE_SIZE))
  700|    204|                .unwrap_or(absolute_max)
  701|    204|        });
_RNvMs7_NtCsa8j9dqGMVk5_16wasmtime_runtime6memoryNtB5_6Memory8vmmemory:
  793|    204|    pub fn vmmemory(&mut self) -> VMMemoryDefinition {
  794|    204|        self.0.vmmemory()
  795|    204|    }
_RNvXNtCsa8j9dqGMVk5_16wasmtime_runtime6memoryNtB2_20DefaultMemoryCreatorNtB2_20RuntimeMemoryCreator10new_memory:
   38|    204|    fn new_memory(
   39|    204|        &self,
   40|    204|        plan: &MemoryPlan,
   41|    204|        minimum: usize,
   42|    204|        maximum: Option<usize>,
   43|    204|        memory_image: Option<&Arc<MemoryImage>>,
   44|    204|    ) -> Result<Box<dyn RuntimeLinearMemory>> {
   45|    204|        Ok(Box::new(MmapMemory::new(
   46|    204|            plan,
   47|    204|            minimum,
   48|    204|            maximum,
   49|    204|            memory_image,
   50|    204|        )?))
   51|    204|    }
_RNvMs_NtCsa8j9dqGMVk5_16wasmtime_runtime6memoryNtB4_10MmapMemory3new:
  193|    204|    pub fn new(
  194|    204|        plan: &MemoryPlan,
  195|    204|        minimum: usize,
  196|    204|        mut maximum: Option<usize>,
  197|    204|        memory_image: Option<&Arc<MemoryImage>>,
  198|    204|    ) -> Result<Self> {
  199|    204|        // It's a programmer error for these two configuration values to exceed
  200|    204|        // the host available address space, so panic if such a configuration is
  201|    204|        // found (mostly an issue for hypothetical 32-bit hosts).
  202|    204|        let offset_guard_bytes = usize::try_from(plan.offset_guard_size).unwrap();
  203|    204|        let pre_guard_bytes = usize::try_from(plan.pre_guard_size).unwrap();
  204|       |
  205|    204|        let (alloc_bytes, extra_to_reserve_on_growth) = match plan.style {
  206|       |            // Dynamic memories start with the minimum size plus the `reserve`
  207|       |            // amount specified to grow into.
  208|      0|            MemoryStyle::Dynamic { reserve } => (minimum, usize::try_from(reserve).unwrap()),
  209|       |
  210|       |            // Static memories will never move in memory and consequently get
  211|       |            // their entire allocation up-front with no extra room to grow into.
  212|       |            // Note that the `maximum` is adjusted here to whatever the smaller
  213|       |            // of the two is, the `maximum` given or the `bound` specified for
  214|       |            // this memory.
  215|    204|            MemoryStyle::Static { bound } => {
  216|    204|                assert!(bound >= plan.memory.minimum);
  217|    204|                let bound_bytes =
  218|    204|                    usize::try_from(bound.checked_mul(WASM_PAGE_SIZE_U64).unwrap()).unwrap();
  219|    204|                maximum = Some(bound_bytes.min(maximum.unwrap_or(usize::MAX)));
  220|    204|                (bound_bytes, 0)
  221|       |            }
  222|       |        };
  223|       |
  224|    204|        let request_bytes = pre_guard_bytes
  225|    204|            .checked_add(alloc_bytes)
  226|    204|            .and_then(|i| i.checked_add(extra_to_reserve_on_growth))
  227|    204|            .and_then(|i| i.checked_add(offset_guard_bytes))
  228|    204|            .ok_or_else(|| format_err!("cannot allocate {} with guard regions", minimum))?;
  229|    204|        let mut mmap = Mmap::accessible_reserved(0, request_bytes)?;
  230|       |
  231|    204|        if minimum > 0 {
  232|      0|            mmap.make_accessible(pre_guard_bytes, minimum)?;
  233|    204|        }
  234|       |
  235|       |        // If a memory image was specified, try to create the MemoryImageSlot on
  236|       |        // top of our mmap.
  237|    204|        let memory_image = match memory_image {
  238|      0|            Some(image) => {
  239|      0|                let base = unsafe { mmap.as_mut_ptr().add(pre_guard_bytes) };
  240|      0|                let mut slot = MemoryImageSlot::create(
  241|      0|                    base.cast(),
  242|      0|                    minimum,
  243|      0|                    alloc_bytes + extra_to_reserve_on_growth,
  244|      0|                );
  245|      0|                slot.instantiate(minimum, Some(image))?;
  246|       |                // On drop, we will unmap our mmap'd range that this slot was
  247|       |                // mapped on top of, so there is no need for the slot to wipe
  248|       |                // it with an anonymous mapping first.
  249|      0|                slot.no_clear_on_drop();
  250|      0|                Some(slot)
  251|       |            }
  252|    204|            None => None,
  253|       |        };
  254|       |
  255|    204|        Ok(Self {
  256|    204|            mmap,
  257|    204|            accessible: minimum,
  258|    204|            maximum,
  259|    204|            pre_guard_size: pre_guard_bytes,
  260|    204|            offset_guard_size: offset_guard_bytes,
  261|    204|            extra_to_reserve_on_growth,
  262|    204|            memory_image,
  263|    204|        })
  264|    204|    }
_RNvXs0_NtCsa8j9dqGMVk5_16wasmtime_runtime6memoryNtB5_10MmapMemoryNtB5_19RuntimeLinearMemory8vmmemory:
  326|    204|    fn vmmemory(&mut self) -> VMMemoryDefinition {
  327|    204|        VMMemoryDefinition {
  328|    204|            base: unsafe { self.mmap.as_mut_ptr().add(self.pre_guard_size) },
  329|    204|            current_length: self.accessible.into(),
  330|    204|        }
  331|    204|    }
_RNvMs7_NtCsa8j9dqGMVk5_16wasmtime_runtime6memoryNtB5_6Memory11new_dynamic:
  610|    204|    pub fn new_dynamic(
  611|    204|        plan: &MemoryPlan,
  612|    204|        creator: &dyn RuntimeMemoryCreator,
  613|    204|        store: &mut dyn Store,
  614|    204|        memory_image: Option<&Arc<MemoryImage>>,
  615|    204|    ) -> Result<Self> {
  616|    204|        let (minimum, maximum) = Self::limit_new(plan, Some(store))?;
  617|    204|        let allocation = creator.new_memory(plan, minimum, maximum, memory_image)?;
  618|    204|        let allocation = if plan.memory.shared {
  619|      0|            Box::new(SharedMemory::wrap(plan, allocation, plan.memory)?)
  620|       |        } else {
  621|    204|            allocation
  622|       |        };
  623|    204|        Ok(Memory(allocation))
  624|    204|    }

_RNvMNtCsa8j9dqGMVk5_16wasmtime_runtime4mmapNtB2_4Mmap10as_mut_ptr:
  353|    204|    pub fn as_mut_ptr(&self) -> *mut u8 {
  354|    204|        self.ptr as *mut u8
  355|    204|    }
_RNvXs_NtCsa8j9dqGMVk5_16wasmtime_runtime4mmapNtB4_4MmapNtNtNtCshM4Il2Z0i4R_4core3ops4drop4Drop4drop:
  454|    816|    fn drop(&mut self) {
  455|    816|        if self.len != 0 {
  456|    816|            unsafe { rustix::mm::munmap(self.ptr as *mut std::ffi::c_void, self.len) }
  457|    816|                .expect("munmap failed");
  458|    816|        }
  459|    816|    }
_RNvMNtCsa8j9dqGMVk5_16wasmtime_runtime4mmapNtB2_4Mmap19accessible_reserved:
  160|    816|    pub fn accessible_reserved(accessible_size: usize, mapping_size: usize) -> Result<Self> {
  161|    816|        let page_size = crate::page_size();
  162|    816|        assert!(accessible_size <= mapping_size);
  163|    816|        assert_eq!(mapping_size & (page_size - 1), 0);
  164|    816|        assert_eq!(accessible_size & (page_size - 1), 0);
  165|       |
  166|       |        // Mmap may return EINVAL if the size is zero, so just
  167|       |        // special-case that.
  168|    816|        if mapping_size == 0 {
  169|      0|            return Ok(Self::new());
  170|    816|        }
  171|    816|
  172|    816|        Ok(if accessible_size == mapping_size {
  173|       |            // Allocate a single read-write region at once.
  174|    408|            let ptr = unsafe {
  175|    408|                rustix::mm::mmap_anonymous(
  176|    408|                    ptr::null_mut(),
  177|    408|                    mapping_size,
  178|    408|                    rustix::mm::ProtFlags::READ | rustix::mm::ProtFlags::WRITE,
  179|    408|                    rustix::mm::MapFlags::PRIVATE,
  180|    408|                )
  181|    408|                .context(format!("mmap failed to allocate {:#x} bytes", mapping_size))?
  182|       |            };
  183|       |
  184|    408|            Self {
  185|    408|                ptr: ptr as usize,
  186|    408|                len: mapping_size,
  187|    408|                file: None,
  188|    408|            }
  189|       |        } else {
  190|       |            // Reserve the mapping size.
  191|    408|            let ptr = unsafe {
  192|    408|                rustix::mm::mmap_anonymous(
  193|    408|                    ptr::null_mut(),
  194|    408|                    mapping_size,
  195|    408|                    rustix::mm::ProtFlags::empty(),
  196|    408|                    rustix::mm::MapFlags::PRIVATE,
  197|    408|                )
  198|    408|                .context(format!("mmap failed to allocate {:#x} bytes", mapping_size))?
  199|       |            };
  200|       |
  201|    408|            let mut result = Self {
  202|    408|                ptr: ptr as usize,
  203|    408|                len: mapping_size,
  204|    408|                file: None,
  205|    408|            };
  206|    408|
  207|    408|            if accessible_size != 0 {
  208|       |                // Commit the accessible size.
  209|      0|                result.make_accessible(0, accessible_size)?;
  210|    408|            }
  211|       |
  212|    408|            result
  213|       |        })
  214|    816|    }

_RNvMNtCsa8j9dqGMVk5_16wasmtime_runtime9module_idNtB2_25CompiledModuleIdAllocator3new:
   20|    204|    pub fn new() -> Self {
   21|    204|        Self {
   22|    204|            next: AtomicU64::new(1),
   23|    204|        }
   24|    204|    }

_RNCNvNtCsa8j9dqGMVk5_16wasmtime_runtime12traphandlers10init_traps0B5_:
   67|      1|    INIT.call_once(|| unsafe {
   68|      1|        IS_WASM_PC = is_wasm_pc;
   69|      1|        sys::platform_init();
   70|      1|    });
_RNvNtCsa8j9dqGMVk5_16wasmtime_runtime12traphandlers10init_traps:
   65|    204|pub fn init_traps(is_wasm_pc: fn(usize) -> bool) {
   66|    204|    static INIT: Once = Once::new();
   67|    204|    INIT.call_once(|| unsafe {
   68|       |        IS_WASM_PC = is_wasm_pc;
   69|       |        sys::platform_init();
   70|    204|    });
   71|    204|}

_RNvNtNtCsa8j9dqGMVk5_16wasmtime_runtime12traphandlers4unix13platform_init:
   16|      1|pub unsafe fn platform_init() {
   17|      1|    let register = |slot: &mut MaybeUninit<libc::sigaction>, signal: i32| {
   18|       |        let mut handler: libc::sigaction = mem::zeroed();
   19|       |        // The flags here are relatively careful, and they are...
   20|       |        //
   21|       |        // SA_SIGINFO gives us access to information like the program
   22|       |        // counter from where the fault happened.
   23|       |        //
   24|       |        // SA_ONSTACK allows us to handle signals on an alternate stack,
   25|       |        // so that the handler can run in response to running out of
   26|       |        // stack space on the main stack. Rust installs an alternate
   27|       |        // stack with sigaltstack, so we rely on that.
   28|       |        //
   29|       |        // SA_NODEFER allows us to reenter the signal handler if we
   30|       |        // crash while handling the signal, and fall through to the
   31|       |        // Breakpad handler by testing handlingSegFault.
   32|       |        handler.sa_flags = libc::SA_SIGINFO | libc::SA_NODEFER | libc::SA_ONSTACK;
   33|       |        handler.sa_sigaction = trap_handler as usize;
   34|       |        libc::sigemptyset(&mut handler.sa_mask);
   35|       |        if libc::sigaction(signal, &handler, slot.as_mut_ptr()) != 0 {
   36|       |            panic!(
   37|       |                "unable to install signal handler: {}",
   38|       |                io::Error::last_os_error(),
   39|       |            );
   40|       |        }
   41|       |    };
   42|       |
   43|       |    // Allow handling OOB with signals on all architectures
   44|      1|    register(&mut PREV_SIGSEGV, libc::SIGSEGV);
   45|      1|
   46|      1|    // Handle `unreachable` instructions which execute `ud2` right now
   47|      1|    register(&mut PREV_SIGILL, libc::SIGILL);
   48|       |
   49|       |    // x86 and s390x use SIGFPE to report division by zero
   50|      1|    if cfg!(target_arch = "x86") || cfg!(target_arch = "x86_64") || cfg!(target_arch = "s390x") {
   51|      1|        register(&mut PREV_SIGFPE, libc::SIGFPE);
   52|      1|    }
   53|       |
   54|       |    // Sometimes we need to handle SIGBUS too:
   55|       |    // - On ARM, handle Unaligned Accesses.
   56|       |    // - On Darwin, guard page accesses are raised as SIGBUS.
   57|      1|    if cfg!(target_arch = "arm") || cfg!(target_os = "macos") || cfg!(target_os = "freebsd") {
   58|      0|        register(&mut PREV_SIGBUS, libc::SIGBUS);
   59|      1|    }
   60|      1|}
_RNCNvNtNtCsa8j9dqGMVk5_16wasmtime_runtime12traphandlers4unix13platform_init0B7_:
   17|      3|    let register = |slot: &mut MaybeUninit<libc::sigaction>, signal: i32| {
   18|      3|        let mut handler: libc::sigaction = mem::zeroed();
   19|      3|        // The flags here are relatively careful, and they are...
   20|      3|        //
   21|      3|        // SA_SIGINFO gives us access to information like the program
   22|      3|        // counter from where the fault happened.
   23|      3|        //
   24|      3|        // SA_ONSTACK allows us to handle signals on an alternate stack,
   25|      3|        // so that the handler can run in response to running out of
   26|      3|        // stack space on the main stack. Rust installs an alternate
   27|      3|        // stack with sigaltstack, so we rely on that.
   28|      3|        //
   29|      3|        // SA_NODEFER allows us to reenter the signal handler if we
   30|      3|        // crash while handling the signal, and fall through to the
   31|      3|        // Breakpad handler by testing handlingSegFault.
   32|      3|        handler.sa_flags = libc::SA_SIGINFO | libc::SA_NODEFER | libc::SA_ONSTACK;
   33|      3|        handler.sa_sigaction = trap_handler as usize;
   34|      3|        libc::sigemptyset(&mut handler.sa_mask);
   35|      3|        if libc::sigaction(signal, &handler, slot.as_mut_ptr()) != 0 {
   36|      0|            panic!(
   37|      0|                "unable to install signal handler: {}",
   38|      0|                io::Error::last_os_error(),
   39|      0|            );
   40|      3|        }
   41|      3|    };

_RNvMs7_NtCsa8j9dqGMVk5_16wasmtime_runtime9vmcontextNtB5_18VMGlobalDefinition3new:
  375|    204|    pub fn new() -> Self {
  376|    204|        Self { storage: [0; 16] }
  377|    204|    }
_RNvXsf_NtCsa8j9dqGMVk5_16wasmtime_runtime9vmcontextNtB5_15VMRuntimeLimitsNtNtCshM4Il2Z0i4R_4core7default7Default7default:
  777|    204|    fn default() -> VMRuntimeLimits {
  778|    204|        VMRuntimeLimits {
  779|    204|            stack_limit: UnsafeCell::new(usize::max_value()),
  780|    204|            fuel_consumed: UnsafeCell::new(0),
  781|    204|            epoch_deadline: UnsafeCell::new(0),
  782|    204|            last_wasm_exit_fp: UnsafeCell::new(0),
  783|    204|            last_wasm_exit_pc: UnsafeCell::new(0),
  784|    204|            last_wasm_entry_sp: UnsafeCell::new(0),
  785|    204|        }
  786|    204|    }
_RNvMs7_NtCsa8j9dqGMVk5_16wasmtime_runtime9vmcontextNtB5_18VMGlobalDefinition10as_i64_mut:
  411|    204|    pub unsafe fn as_i64_mut(&mut self) -> &mut i64 {
  412|    204|        &mut *(self.storage.as_mut().as_mut_ptr().cast::<i64>())
  413|    204|    }

_RNvXs3X_Csf9ABzndBH7D_14wasmtime_typesNtB6_6MemoryNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
  347|    612|#[derive(Debug, Clone, Copy, Hash, Eq, PartialEq, Serialize, Deserialize)]

_RNvNvNvXs0_Cs4DcB2eWstN0_10env_loggerNtB9_6LoggerNtCs6vrtZ9rvsjP_3log3Log3log9FORMATTER6___init:
  294|      1|            fn __init() -> $t { $init }
_RNvNvNvXs0_Cs4DcB2eWstN0_10env_loggerNtB9_6LoggerNtCs6vrtZ9rvsjP_3log3Log3log9FORMATTER7___getit:
  319|  66.5k|            unsafe fn __getit(
  320|  66.5k|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
  321|  66.5k|            ) -> $crate::option::Option<&'static $t> {
  322|  66.5k|                #[cfg(all(target_family = "wasm", not(target_feature = "atomics")))]
  323|  66.5k|                static __KEY: $crate::thread::__StaticLocalKeyInner<$t> =
  324|  66.5k|                    $crate::thread::__StaticLocalKeyInner::new();
  325|  66.5k|
  326|  66.5k|                #[thread_local]
  327|  66.5k|                #[cfg(all(
  328|  66.5k|                    target_thread_local,
  329|  66.5k|                    not(all(target_family = "wasm", not(target_feature = "atomics"))),
  330|  66.5k|                ))]
  331|  66.5k|                static __KEY: $crate::thread::__FastLocalKeyInner<$t> =
  332|  66.5k|                    $crate::thread::__FastLocalKeyInner::new();
  333|  66.5k|
  334|  66.5k|                #[cfg(all(
  335|  66.5k|                    not(target_thread_local),
  336|  66.5k|                    not(all(target_family = "wasm", not(target_feature = "atomics"))),
  337|  66.5k|                ))]
  338|  66.5k|                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =
  339|  66.5k|                    $crate::thread::__OsLocalKeyInner::new();
  340|  66.5k|
  341|  66.5k|                // FIXME: remove the #[allow(...)] marker when macros don't
  342|  66.5k|                // raise warning for missing/extraneous unsafe blocks anymore.
  343|  66.5k|                // See https://github.com/rust-lang/rust/issues/74838.
  344|  66.5k|                #[allow(unused_unsafe)]
  345|  66.5k|                unsafe {
  346|  66.5k|                    __KEY.get(move || {
  347|       |                        if let $crate::option::Option::Some(init) = init {
  348|       |                            if let $crate::option::Option::Some(value) = init.take() {
  349|       |                                return value;
  350|       |                            } else if $crate::cfg!(debug_assertions) {
  351|       |                                $crate::unreachable!("missing default value");
  352|       |                            }
  353|       |                        }
  354|       |                        __init()
  355|  66.5k|                    })
  356|  66.5k|                }
  357|  66.5k|            }
_RNvNvNtCs69RocqTkFxx_16futures_executor10local_pool21CURRENT_THREAD_NOTIFY7___getit:
  319|    102|            unsafe fn __getit(
  320|    102|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
  321|    102|            ) -> $crate::option::Option<&'static $t> {
  322|    102|                #[cfg(all(target_family = "wasm", not(target_feature = "atomics")))]
  323|    102|                static __KEY: $crate::thread::__StaticLocalKeyInner<$t> =
  324|    102|                    $crate::thread::__StaticLocalKeyInner::new();
  325|    102|
  326|    102|                #[thread_local]
  327|    102|                #[cfg(all(
  328|    102|                    target_thread_local,
  329|    102|                    not(all(target_family = "wasm", not(target_feature = "atomics"))),
  330|    102|                ))]
  331|    102|                static __KEY: $crate::thread::__FastLocalKeyInner<$t> =
  332|    102|                    $crate::thread::__FastLocalKeyInner::new();
  333|    102|
  334|    102|                #[cfg(all(
  335|    102|                    not(target_thread_local),
  336|    102|                    not(all(target_family = "wasm", not(target_feature = "atomics"))),
  337|    102|                ))]
  338|    102|                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =
  339|    102|                    $crate::thread::__OsLocalKeyInner::new();
  340|    102|
  341|    102|                // FIXME: remove the #[allow(...)] marker when macros don't
  342|    102|                // raise warning for missing/extraneous unsafe blocks anymore.
  343|    102|                // See https://github.com/rust-lang/rust/issues/74838.
  344|    102|                #[allow(unused_unsafe)]
  345|    102|                unsafe {
  346|    102|                    __KEY.get(move || {
  347|       |                        if let $crate::option::Option::Some(init) = init {
  348|       |                            if let $crate::option::Option::Some(value) = init.take() {
  349|       |                                return value;
  350|       |                            } else if $crate::cfg!(debug_assertions) {
  351|       |                                $crate::unreachable!("missing default value");
  352|       |                            }
  353|       |                        }
  354|       |                        __init()
  355|    102|                    })
  356|    102|                }
  357|    102|            }
_RNvNvNtCs69RocqTkFxx_16futures_executor10local_pool21CURRENT_THREAD_NOTIFY6___init:
  294|      1|            fn __init() -> $t { $init }
_RNvNvNtCs69RocqTkFxx_16futures_executor5enter7ENTERED7___getit:
  319|    204|            unsafe fn __getit(
  320|    204|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
  321|    204|            ) -> $crate::option::Option<&'static $t> {
  322|    204|                #[cfg(all(target_family = "wasm", not(target_feature = "atomics")))]
  323|    204|                static __KEY: $crate::thread::__StaticLocalKeyInner<$t> =
  324|    204|                    $crate::thread::__StaticLocalKeyInner::new();
  325|    204|
  326|    204|                #[thread_local]
  327|    204|                #[cfg(all(
  328|    204|                    target_thread_local,
  329|    204|                    not(all(target_family = "wasm", not(target_feature = "atomics"))),
  330|    204|                ))]
  331|    204|                static __KEY: $crate::thread::__FastLocalKeyInner<$t> =
  332|    204|                    $crate::thread::__FastLocalKeyInner::new();
  333|    204|
  334|    204|                #[cfg(all(
  335|    204|                    not(target_thread_local),
  336|    204|                    not(all(target_family = "wasm", not(target_feature = "atomics"))),
  337|    204|                ))]
  338|    204|                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =
  339|    204|                    $crate::thread::__OsLocalKeyInner::new();
  340|    204|
  341|    204|                // FIXME: remove the #[allow(...)] marker when macros don't
  342|    204|                // raise warning for missing/extraneous unsafe blocks anymore.
  343|    204|                // See https://github.com/rust-lang/rust/issues/74838.
  344|    204|                #[allow(unused_unsafe)]
  345|    204|                unsafe {
  346|    204|                    __KEY.get(move || {
  347|       |                        if let $crate::option::Option::Some(init) = init {
  348|       |                            if let $crate::option::Option::Some(value) = init.take() {
  349|       |                                return value;
  350|       |                            } else if $crate::cfg!(debug_assertions) {
  351|       |                                $crate::unreachable!("missing default value");
  352|       |                            }
  353|       |                        }
  354|       |                        __init()
  355|    204|                    })
  356|    204|                }
  357|    204|            }
_RNvNvNtCs69RocqTkFxx_16futures_executor5enter7ENTERED6___init:
  294|      1|            fn __init() -> $t { $init }
_RNvNvNtNtCsk2tDUwjDqRE_4rand4rngs6thread14THREAD_RNG_KEY7___getit:
  319|    102|            unsafe fn __getit(
  320|    102|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
  321|    102|            ) -> $crate::option::Option<&'static $t> {
  322|    102|                #[cfg(all(target_family = "wasm", not(target_feature = "atomics")))]
  323|    102|                static __KEY: $crate::thread::__StaticLocalKeyInner<$t> =
  324|    102|                    $crate::thread::__StaticLocalKeyInner::new();
  325|    102|
  326|    102|                #[thread_local]
  327|    102|                #[cfg(all(
  328|    102|                    target_thread_local,
  329|    102|                    not(all(target_family = "wasm", not(target_feature = "atomics"))),
  330|    102|                ))]
  331|    102|                static __KEY: $crate::thread::__FastLocalKeyInner<$t> =
  332|    102|                    $crate::thread::__FastLocalKeyInner::new();
  333|    102|
  334|    102|                #[cfg(all(
  335|    102|                    not(target_thread_local),
  336|    102|                    not(all(target_family = "wasm", not(target_feature = "atomics"))),
  337|    102|                ))]
  338|    102|                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =
  339|    102|                    $crate::thread::__OsLocalKeyInner::new();
  340|    102|
  341|    102|                // FIXME: remove the #[allow(...)] marker when macros don't
  342|    102|                // raise warning for missing/extraneous unsafe blocks anymore.
  343|    102|                // See https://github.com/rust-lang/rust/issues/74838.
  344|    102|                #[allow(unused_unsafe)]
  345|    102|                unsafe {
  346|    102|                    __KEY.get(move || {
  347|       |                        if let $crate::option::Option::Some(init) = init {
  348|       |                            if let $crate::option::Option::Some(value) = init.take() {
  349|       |                                return value;
  350|       |                            } else if $crate::cfg!(debug_assertions) {
  351|       |                                $crate::unreachable!("missing default value");
  352|       |                            }
  353|       |                        }
  354|       |                        __init()
  355|    102|                    })
  356|    102|                }
  357|    102|            }
_RNvNvNtNtCsk2tDUwjDqRE_4rand4rngs6thread14THREAD_RNG_KEY6___init:
  294|      1|            fn __init() -> $t { $init }

_RNvCsitTtQF8ArIt_8fvm_fuzz10get_tester:
  311|    102|pub fn get_tester() -> Tester<MemoryBlockstore, DummyExterns> {
  312|    102|    let bs = MemoryBlockstore::default();
  313|    102|    let bundle_root = import_bundle(&bs, actors_v10::BUNDLE_CAR).unwrap();
  314|    102|
  315|    102|    Tester::new(NetworkVersion::V18, StateTreeVersion::V5, bundle_root, bs).unwrap()
  316|    102|}

_RNvNtCsitTtQF8ArIt_8fvm_fuzz15stress_syscalls20get_valid_offset_len:
   62|  63.8k|fn get_valid_offset_len(memlen: usize, u: &mut Unstructured) -> AResult<(usize, usize)> {
   63|  63.8k|    let data_offset = u.int_in_range(0..=memlen);
   64|       |
   65|  63.8k|    if let Ok(data_offset) = data_offset {
   66|       |        // TODO, set a rational len here
   67|  63.8k|        if memlen - data_offset >= 2 {
   68|    266|            let len = u.int_in_range(1..=memlen - data_offset);
   69|    266|            if let Ok(len) = len {
   70|    266|                return Ok((data_offset, len));
   71|      0|            }
   72|  63.6k|        }
   73|      0|    }
   74|       |    // randomly decide if error or invalid offset, len in 1/3 cases
   75|  63.6k|    if u.arbitrary::<u32>().unwrap() % 3 == 0 {
   76|  63.6k|        Ok((u.arbitrary().unwrap(), u.arbitrary().unwrap()))
   77|       |    } else {
   78|     13|        Err(fuzzing_core::error::FuzzError::Any(
   79|     13|            "Invalid offset len".into(),
   80|     13|        ))
   81|       |    }
   82|  63.8k|}
_RNvNtCsitTtQF8ArIt_8fvm_fuzz15stress_syscalls15stress_syscalls:
   85|    102|pub fn stress_syscalls<'a>(u: &mut Unstructured, reuse: u32) {
   86|    102|    let nc = NetworkConfig::new(NetworkVersion::V18);
   87|    102|    let ec = EngineConfig::from(&nc);
   88|    102|
   89|    102|    let mut tester = get_tester();
   90|    102|    tester.instantiate_machine(DummyExterns).unwrap();
   91|    102|
   92|    102|    // TODO, this size should be random
   93|    102|    let mut cp: Vec<u8> = u.arbitrary().unwrap();
   94|    102|    let mem = fvm::syscalls::context::Memory::new(&mut cp);
   95|    102|
   96|    102|    let machine = tester.executor.unwrap().into_machine().unwrap();
   97|    102|
   98|    102|    let pool = EnginePool::new_default(ec).unwrap();
   99|    102|
  100|    102|    let engine = pool.acquire();
  101|    102|
  102|    102|    let bignumber: u128 = u.arbitrary().unwrap();
  103|    102|    let bigint = BigInt::from_str(&format!("{}", bignumber));
  104|    102|
  105|    102|    let bignumber2: u128 = u.arbitrary().unwrap();
  106|    102|    let bigint2 = BigInt::from_str(&format!("{}", bignumber2));
  107|    102|
  108|    102|    let call_manager = DefaultCallManager::new(
  109|    102|        machine,
  110|    102|        engine,
  111|    102|        u.arbitrary().unwrap(),
  112|    102|        u.arbitrary().unwrap(),
  113|    102|        Address::new_id(u.arbitrary().unwrap()),
  114|    102|        u.arbitrary().unwrap(),
  115|    102|        // Try different froms
  116|    102|        TokenAmount::from_atto(bigint.unwrap()),
  117|    102|    );
  118|    102|
  119|    102|    let block_registry = BlockRegistry::default();
  120|    102|
  121|    102|    let mut default_kernel = DefaultKernel::new(
  122|    102|        call_manager,
  123|    102|        block_registry,
  124|    102|        // This should be the same as line 54?
  125|    102|        u.arbitrary().unwrap(),
  126|    102|        // TODO, get the ids from the builtin actors
  127|    102|        u.arbitrary().unwrap(),
  128|    102|        // In theory is always method number 0 ?
  129|    102|        u.arbitrary().unwrap(),
  130|    102|        TokenAmount::from_atto(bigint2.unwrap()),
  131|    102|    );
  132|    102|
  133|    102|    // Just to get some stats
  134|    102|    let val = GENERATED.fetch_add(1, std::sync::atomic::Ordering::SeqCst);
  135|    102|    if val % 100 == 99 {
  136|      1|        let non_error = NON_ERROR.load(std::sync::atomic::Ordering::SeqCst);
  137|      1|        log::debug!(
  138|      1|            "Non error {}/{} ({:.2}%)",
  139|      1|            non_error,
  140|      1|            val,
  141|      1|            100.0 * non_error as f64 / val as f64
  142|       |        );
  143|    101|    }
  144|       |
  145|    102|    let method: u64 = u.int_in_range(0..=35).unwrap();
  146|    102|    let memlen = mem.len();
  147|    102|
  148|    102|    u.arbitrary_loop(Some(1), Some(reuse), move |u| {
  149|       |        let context = fvm::syscalls::context::Context {
  150|       |            kernel: &mut default_kernel,
  151|       |            memory: mem,
  152|       |        };
  153|       |        // All run now independently, but the idea is to chain them with a component
  154|       |        // base fuzzing
  155|       |        match method {
  156|       |            0 => {
  157|       |                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  158|       |                    let codec = [
  159|       |                        DAG_CBOR,
  160|       |                        IPLD_RAW,
  161|       |                        u.arbitrary::<u64>().unwrap(), /* Some crap as well */
  162|       |                    ];
  163|       |                    branch!(block_create(
  164|       |                        context,
  165|       |                        *u.choose(&codec).unwrap(),
  166|       |                        offset as u32,   // No larger than the mem size
  167|       |                        data_len as u32, // No larger thatn the mem size - offset
  168|       |                    ));
  169|       |                }
  170|       |            }
  171|       |            1 => {
  172|       |                branch!(block_open(context, u.arbitrary().unwrap()));
  173|       |            }
  174|       |            2 => {
  175|       |                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  176|       |                    branch!(block_link(
  177|       |                        context,
  178|       |                        u.arbitrary().unwrap(),
  179|       |                        u.arbitrary().unwrap(),
  180|       |                        u.arbitrary().unwrap(),
  181|       |                        offset as u32,
  182|       |                        data_len as u32,
  183|       |                    ));
  184|       |                }
  185|       |            }
  186|       |            3 => {
  187|       |                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  188|       |                    branch!(block_read(
  189|       |                        context,
  190|       |                        u.arbitrary().unwrap(),
  191|       |                        u.arbitrary().unwrap(),
  192|       |                        offset as u32,
  193|       |                        data_len as u32,
  194|       |                    ));
  195|       |                }
  196|       |            }
  197|       |            4 => {
  198|       |                branch!(block_stat(context, u.arbitrary().unwrap()));
  199|       |            }
  200|       |            5 => {
  201|       |                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  202|       |                    branch!(resolve_address(context, offset as u32, data_len as u32));
  203|       |                }
  204|       |            }
  205|       |            6 => {
  206|       |                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  207|       |                    branch!(lookup_address(
  208|       |                        context,
  209|       |                        u.arbitrary().unwrap(),
  210|       |                        offset as u32,
  211|       |                        data_len as u32,
  212|       |                    ));
  213|       |                }
  214|       |            }
  215|       |            7 => {
  216|       |                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  217|       |                    branch!(get_actor_code_cid(
  218|       |                        context,
  219|       |                        u.arbitrary().unwrap(),
  220|       |                        offset as u32,
  221|       |                        data_len as u32,
  222|       |                    ));
  223|       |                }
  224|       |            }
  225|       |            8 => {
  226|       |                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  227|       |                    branch!(next_actor_address(context, offset as u32, data_len as u32,));
  228|       |                }
  229|       |            }
  230|       |            9 => {
  231|       |                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  232|       |                    branch!(create_actor(
  233|       |                        context,
  234|       |                        u.arbitrary().unwrap(),
  235|       |                        u.arbitrary().unwrap(),
  236|       |                        offset as u32,
  237|       |                        data_len as u32,
  238|       |                    ));
  239|       |                }
  240|       |            }
  241|       |            10 => {
  242|       |                branch!(get_builtin_actor_type(context, u.arbitrary().unwrap()));
  243|       |            }
  244|       |            11 => {
  245|       |                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  246|       |                    branch!(get_code_cid_for_type(
  247|       |                        context,
  248|       |                        u.arbitrary().unwrap(),
  249|       |                        offset as u32,
  250|       |                        data_len as u32,
  251|       |                    ));
  252|       |                }
  253|       |            }
  254|       |            12 => {
  255|       |                branch!(balance_of(context, u.arbitrary().unwrap()));
  256|       |            }
  257|       |            13 => {
  258|       |                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  259|       |                    if let Ok((offset1, data_len1)) = get_valid_offset_len(memlen, u) {
  260|       |                        if let Ok((offset2, data_len2)) = get_valid_offset_len(memlen, u) {
  261|       |                            branch!(verify_signature(
  262|       |                                context,
  263|       |                                u.arbitrary().unwrap(),
  264|       |                                offset as u32,
  265|       |                                data_len as u32,
  266|       |                                offset1 as u32,
  267|       |                                data_len1 as u32,
  268|       |                                offset2 as u32,
  269|       |                                data_len2 as u32
  270|       |                            ));
  271|       |                        }
  272|       |                    }
  273|       |                }
  274|       |            }
  275|       |            14 => {
  276|       |                branch!(recover_secp_public_key(
  277|       |                    context,
  278|       |                    u.arbitrary().unwrap(),
  279|       |                    u.arbitrary().unwrap(),
  280|       |                ));
  281|       |            }
  282|       |            15 => {
  283|       |                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  284|       |                    if let Ok((offset1, data_len1)) = get_valid_offset_len(memlen, u) {
  285|       |                        branch!(hash(
  286|       |                            context,
  287|       |                            u.arbitrary().unwrap(),
  288|       |                            offset as u32,
  289|       |                            data_len as u32,
  290|       |                            offset1 as u32,
  291|       |                            data_len1 as u32,
  292|       |                        ));
  293|       |                    }
  294|       |                }
  295|       |            }
  296|       |            16 => {
  297|       |                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  298|       |                    if let Ok((offset1, data_len1)) = get_valid_offset_len(memlen, u) {
  299|       |                        branch!(compute_unsealed_sector_cid(
  300|       |                            context,
  301|       |                            u.arbitrary().unwrap(),
  302|       |                            offset as u32,
  303|       |                            data_len as u32,
  304|       |                            offset1 as u32,
  305|       |                            data_len1 as u32,
  306|       |                        ));
  307|       |                    }
  308|       |                }
  309|       |            }
  310|       |            17 => {
  311|       |                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  312|       |                    branch!(verify_seal(context, offset as u32, data_len as u32));
  313|       |                }
  314|       |            }
  315|       |            18 => {
  316|       |                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  317|       |                    branch!(verify_post(context, offset as u32, data_len as u32));
  318|       |                }
  319|       |            }
  320|       |            19 => {
  321|       |                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  322|       |                    if let Ok((offset1, data_len1)) = get_valid_offset_len(memlen, u) {
  323|       |                        if let Ok((offset2, data_len2)) = get_valid_offset_len(memlen, u) {
  324|       |                            branch!(verify_consensus_fault(
  325|       |                                context,
  326|       |                                offset as u32,
  327|       |                                data_len as u32,
  328|       |                                offset1 as u32,
  329|       |                                data_len1 as u32,
  330|       |                                offset2 as u32,
  331|       |                                data_len2 as u32
  332|       |                            ));
  333|       |                        }
  334|       |                    }
  335|       |                }
  336|       |            }
  337|       |            20 => {
  338|       |                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  339|       |                    branch!(verify_aggregate_seals(
  340|       |                        context,
  341|       |                        offset as u32,
  342|       |                        data_len as u32
  343|       |                    ));
  344|       |                }
  345|       |            }
  346|       |            21 => {
  347|       |                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  348|       |                    branch!(verify_replica_update(
  349|       |                        context,
  350|       |                        offset as u32,
  351|       |                        data_len as u32,
  352|       |                    ));
  353|       |                }
  354|       |            }
  355|       |            22 => {
  356|       |                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  357|       |                    branch!(batch_verify_seals(
  358|       |                        context,
  359|       |                        offset as u32,
  360|       |                        data_len as u32,
  361|       |                        u.arbitrary().unwrap(),
  362|       |                    ));
  363|       |                }
  364|       |            }
  365|       |            // debug
  366|       |            23 => {
  367|       |                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  368|       |                    branch!(exit(
  369|       |                        context,
  370|       |                        u.arbitrary().unwrap(),
  371|       |                        u.arbitrary().unwrap(),
  372|       |                        offset as u32,
  373|       |                        data_len as u32,
  374|       |                    ));
  375|       |                }
  376|       |            }
  377|       |            24 => {
  378|       |                branch!(message_context(context));
  379|       |            }
  380|       |            // event
  381|       |            25 => {
  382|       |                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  383|       |                    branch!(emit_event(context, offset as u32, data_len as u32));
  384|       |                }
  385|       |            }
  386|       |            // gas
  387|       |            26 => {
  388|       |                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  389|       |                    branch!(charge_gas(
  390|       |                        context,
  391|       |                        offset as u32,
  392|       |                        data_len as u32,
  393|       |                        u.arbitrary().unwrap(),
  394|       |                    ));
  395|       |                }
  396|       |            }
  397|       |            27 => {
  398|       |                branch!(available(context));
  399|       |            }
  400|       |            // rand
  401|       |            28 => {
  402|       |                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  403|       |                    branch!(get_chain_randomness(
  404|       |                        context,
  405|       |                        u.arbitrary().unwrap(),
  406|       |                        u.arbitrary().unwrap(),
  407|       |                        offset as u32,
  408|       |                        data_len as u32,
  409|       |                    ));
  410|       |                }
  411|       |            }
  412|       |            29 => {
  413|       |                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  414|       |                    branch!(get_beacon_randomness(
  415|       |                        context,
  416|       |                        u.arbitrary().unwrap(),
  417|       |                        u.arbitrary().unwrap(),
  418|       |                        offset as u32,
  419|       |                        data_len as u32,
  420|       |                    ));
  421|       |                }
  422|       |            }
  423|       |            30 => {
  424|       |                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  425|       |                    branch!(send(
  426|       |                        context,
  427|       |                        offset as u32,
  428|       |                        data_len as u32,
  429|       |                        u.arbitrary().unwrap(),
  430|       |                        u.arbitrary().unwrap(),
  431|       |                        u.arbitrary().unwrap(),
  432|       |                        u.arbitrary().unwrap(),
  433|       |                        u.arbitrary().unwrap(),
  434|       |                        u.arbitrary().unwrap(),
  435|       |                    ));
  436|       |                }
  437|       |            }
  438|       |            // self
  439|       |            31 => {
  440|       |                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  441|       |                    branch!(root(context, offset as u32, data_len as u32,));
  442|       |                }
  443|       |            }
  444|       |            32 => {
  445|       |                branch!(set_root(context, u.arbitrary().unwrap(),));
  446|       |            }
  447|       |            33 => {
  448|       |                branch!(current_balance(context));
  449|       |            }
  450|       |            34 => {
  451|       |                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  452|       |                    branch!(self_destruct(context, offset as u32, data_len as u32,));
  453|       |                }
  454|       |            }
  455|       |            _ => {
  456|       |                // Do nothing
  457|       |            }
  458|       |        };
  459|       |        Ok(ControlFlow::Continue(()))
  460|    102|    })
  461|    102|    .unwrap();
  462|    102|}
_RNCNvNtCsitTtQF8ArIt_8fvm_fuzz15stress_syscalls15stress_syscalls0B5_:
  148|  33.1k|    u.arbitrary_loop(Some(1), Some(reuse), move |u| {
  149|  33.1k|        let context = fvm::syscalls::context::Context {
  150|  33.1k|            kernel: &mut default_kernel,
  151|  33.1k|            memory: mem,
  152|  33.1k|        };
  153|  33.1k|        // All run now independently, but the idea is to chain them with a component
  154|  33.1k|        // base fuzzing
  155|  33.1k|        match method {
  156|       |            0 => {
  157|     90|                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  158|     88|                    let codec = [
  159|     88|                        DAG_CBOR,
  160|     88|                        IPLD_RAW,
  161|     88|                        u.arbitrary::<u64>().unwrap(), /* Some crap as well */
  162|     88|                    ];
  163|     88|                    branch!(block_create(
  164|     88|                        context,
  165|     88|                        *u.choose(&codec).unwrap(),
  166|     88|                        offset as u32,   // No larger than the mem size
  167|     88|                        data_len as u32, // No larger thatn the mem size - offset
  168|     88|                    ));
  169|      2|                }
  170|       |            }
  171|       |            1 => {
  172|      0|                branch!(block_open(context, u.arbitrary().unwrap()));
  173|       |            }
  174|       |            2 => {
  175|      0|                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  176|      0|                    branch!(block_link(
  177|      0|                        context,
  178|      0|                        u.arbitrary().unwrap(),
  179|      0|                        u.arbitrary().unwrap(),
  180|      0|                        u.arbitrary().unwrap(),
  181|      0|                        offset as u32,
  182|      0|                        data_len as u32,
  183|      0|                    ));
  184|      0|                }
  185|       |            }
  186|       |            3 => {
  187|    249|                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  188|    248|                    branch!(block_read(
  189|    248|                        context,
  190|    248|                        u.arbitrary().unwrap(),
  191|    248|                        u.arbitrary().unwrap(),
  192|    248|                        offset as u32,
  193|    248|                        data_len as u32,
  194|    248|                    ));
  195|      1|                }
  196|       |            }
  197|       |            4 => {
  198|      1|                branch!(block_stat(context, u.arbitrary().unwrap()));
  199|       |            }
  200|       |            5 => {
  201|      0|                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  202|      0|                    branch!(resolve_address(context, offset as u32, data_len as u32));
  203|      0|                }
  204|       |            }
  205|       |            6 => {
  206|      0|                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  207|      0|                    branch!(lookup_address(
  208|      0|                        context,
  209|      0|                        u.arbitrary().unwrap(),
  210|      0|                        offset as u32,
  211|      0|                        data_len as u32,
  212|      0|                    ));
  213|      0|                }
  214|       |            }
  215|       |            7 => {
  216|      0|                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  217|      0|                    branch!(get_actor_code_cid(
  218|      0|                        context,
  219|      0|                        u.arbitrary().unwrap(),
  220|      0|                        offset as u32,
  221|      0|                        data_len as u32,
  222|      0|                    ));
  223|      0|                }
  224|       |            }
  225|       |            8 => {
  226|      0|                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  227|      0|                    branch!(next_actor_address(context, offset as u32, data_len as u32,));
  228|      0|                }
  229|       |            }
  230|       |            9 => {
  231|      0|                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  232|      0|                    branch!(create_actor(
  233|      0|                        context,
  234|      0|                        u.arbitrary().unwrap(),
  235|      0|                        u.arbitrary().unwrap(),
  236|      0|                        offset as u32,
  237|      0|                        data_len as u32,
  238|      0|                    ));
  239|      0|                }
  240|       |            }
  241|       |            10 => {
  242|      0|                branch!(get_builtin_actor_type(context, u.arbitrary().unwrap()));
  243|       |            }
  244|       |            11 => {
  245|      0|                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  246|      0|                    branch!(get_code_cid_for_type(
  247|      0|                        context,
  248|      0|                        u.arbitrary().unwrap(),
  249|      0|                        offset as u32,
  250|      0|                        data_len as u32,
  251|      0|                    ));
  252|      0|                }
  253|       |            }
  254|       |            12 => {
  255|      0|                branch!(balance_of(context, u.arbitrary().unwrap()));
  256|       |            }
  257|       |            13 => {
  258|      0|                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  259|      0|                    if let Ok((offset1, data_len1)) = get_valid_offset_len(memlen, u) {
  260|      0|                        if let Ok((offset2, data_len2)) = get_valid_offset_len(memlen, u) {
  261|      0|                            branch!(verify_signature(
  262|      0|                                context,
  263|      0|                                u.arbitrary().unwrap(),
  264|      0|                                offset as u32,
  265|      0|                                data_len as u32,
  266|      0|                                offset1 as u32,
  267|      0|                                data_len1 as u32,
  268|      0|                                offset2 as u32,
  269|      0|                                data_len2 as u32
  270|      0|                            ));
  271|      0|                        }
  272|      0|                    }
  273|      0|                }
  274|       |            }
  275|       |            14 => {
  276|      0|                branch!(recover_secp_public_key(
  277|      0|                    context,
  278|      0|                    u.arbitrary().unwrap(),
  279|      0|                    u.arbitrary().unwrap(),
  280|      0|                ));
  281|       |            }
  282|       |            15 => {
  283|      0|                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  284|      0|                    if let Ok((offset1, data_len1)) = get_valid_offset_len(memlen, u) {
  285|      0|                        branch!(hash(
  286|      0|                            context,
  287|      0|                            u.arbitrary().unwrap(),
  288|      0|                            offset as u32,
  289|      0|                            data_len as u32,
  290|      0|                            offset1 as u32,
  291|      0|                            data_len1 as u32,
  292|      0|                        ));
  293|      0|                    }
  294|      0|                }
  295|       |            }
  296|       |            16 => {
  297|  31.7k|                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  298|  31.7k|                    if let Ok((offset1, data_len1)) = get_valid_offset_len(memlen, u) {
  299|  31.7k|                        branch!(compute_unsealed_sector_cid(
  300|  31.7k|                            context,
  301|  31.7k|                            u.arbitrary().unwrap(),
  302|  31.7k|                            offset as u32,
  303|  31.7k|                            data_len as u32,
  304|  31.7k|                            offset1 as u32,
  305|  31.7k|                            data_len1 as u32,
  306|  31.7k|                        ));
  307|      0|                    }
  308|     10|                }
  309|       |            }
  310|       |            17 => {
  311|      0|                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  312|      0|                    branch!(verify_seal(context, offset as u32, data_len as u32));
  313|      0|                }
  314|       |            }
  315|       |            18 => {
  316|      0|                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  317|      0|                    branch!(verify_post(context, offset as u32, data_len as u32));
  318|      0|                }
  319|       |            }
  320|       |            19 => {
  321|      0|                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  322|      0|                    if let Ok((offset1, data_len1)) = get_valid_offset_len(memlen, u) {
  323|      0|                        if let Ok((offset2, data_len2)) = get_valid_offset_len(memlen, u) {
  324|      0|                            branch!(verify_consensus_fault(
  325|      0|                                context,
  326|      0|                                offset as u32,
  327|      0|                                data_len as u32,
  328|      0|                                offset1 as u32,
  329|      0|                                data_len1 as u32,
  330|      0|                                offset2 as u32,
  331|      0|                                data_len2 as u32
  332|      0|                            ));
  333|      0|                        }
  334|      0|                    }
  335|      0|                }
  336|       |            }
  337|       |            20 => {
  338|      0|                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  339|      0|                    branch!(verify_aggregate_seals(
  340|      0|                        context,
  341|      0|                        offset as u32,
  342|      0|                        data_len as u32
  343|      0|                    ));
  344|      0|                }
  345|       |            }
  346|       |            21 => {
  347|      0|                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  348|      0|                    branch!(verify_replica_update(
  349|      0|                        context,
  350|      0|                        offset as u32,
  351|      0|                        data_len as u32,
  352|      0|                    ));
  353|      0|                }
  354|       |            }
  355|       |            22 => {
  356|      0|                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  357|      0|                    branch!(batch_verify_seals(
  358|      0|                        context,
  359|      0|                        offset as u32,
  360|      0|                        data_len as u32,
  361|      0|                        u.arbitrary().unwrap(),
  362|      0|                    ));
  363|      0|                }
  364|       |            }
  365|       |            // debug
  366|       |            23 => {
  367|      0|                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  368|      0|                    branch!(exit(
  369|      0|                        context,
  370|      0|                        u.arbitrary().unwrap(),
  371|      0|                        u.arbitrary().unwrap(),
  372|      0|                        offset as u32,
  373|      0|                        data_len as u32,
  374|      0|                    ));
  375|      0|                }
  376|       |            }
  377|       |            24 => {
  378|      0|                branch!(message_context(context));
  379|       |            }
  380|       |            // event
  381|       |            25 => {
  382|      0|                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  383|      0|                    branch!(emit_event(context, offset as u32, data_len as u32));
  384|      0|                }
  385|       |            }
  386|       |            // gas
  387|       |            26 => {
  388|      0|                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  389|      0|                    branch!(charge_gas(
  390|      0|                        context,
  391|      0|                        offset as u32,
  392|      0|                        data_len as u32,
  393|      0|                        u.arbitrary().unwrap(),
  394|      0|                    ));
  395|      0|                }
  396|       |            }
  397|       |            27 => {
  398|      0|                branch!(available(context));
  399|       |            }
  400|       |            // rand
  401|       |            28 => {
  402|      0|                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  403|      0|                    branch!(get_chain_randomness(
  404|      0|                        context,
  405|      0|                        u.arbitrary().unwrap(),
  406|      0|                        u.arbitrary().unwrap(),
  407|      0|                        offset as u32,
  408|      0|                        data_len as u32,
  409|      0|                    ));
  410|      0|                }
  411|       |            }
  412|       |            29 => {
  413|      0|                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  414|      0|                    branch!(get_beacon_randomness(
  415|      0|                        context,
  416|      0|                        u.arbitrary().unwrap(),
  417|      0|                        u.arbitrary().unwrap(),
  418|      0|                        offset as u32,
  419|      0|                        data_len as u32,
  420|      0|                    ));
  421|      0|                }
  422|       |            }
  423|       |            30 => {
  424|      0|                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  425|      0|                    branch!(send(
  426|      0|                        context,
  427|      0|                        offset as u32,
  428|      0|                        data_len as u32,
  429|      0|                        u.arbitrary().unwrap(),
  430|      0|                        u.arbitrary().unwrap(),
  431|      0|                        u.arbitrary().unwrap(),
  432|      0|                        u.arbitrary().unwrap(),
  433|      0|                        u.arbitrary().unwrap(),
  434|      0|                        u.arbitrary().unwrap(),
  435|      0|                    ));
  436|      0|                }
  437|       |            }
  438|       |            // self
  439|       |            31 => {
  440|      0|                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  441|      0|                    branch!(root(context, offset as u32, data_len as u32,));
  442|      0|                }
  443|       |            }
  444|       |            32 => {
  445|  1.06k|                branch!(set_root(context, u.arbitrary().unwrap(),));
  446|       |            }
  447|       |            33 => {
  448|      0|                branch!(current_balance(context));
  449|       |            }
  450|       |            34 => {
  451|      0|                if let Ok((offset, data_len)) = get_valid_offset_len(memlen, u) {
  452|      0|                    branch!(self_destruct(context, offset as u32, data_len as u32,));
  453|      0|                }
  454|       |            }
  455|      0|            _ => {
  456|      0|                // Do nothing
  457|      0|            }
  458|       |        };
  459|  33.1k|        Ok(ControlFlow::Continue(()))
  460|  33.1k|    })

_RNvMs0_NtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x648settingsNtB5_5Flags8has_bmi1:
  186|    204|    pub fn has_bmi1(&self) -> bool {
  187|    204|        self.numbered_predicate(13)
  188|    204|    }
_RNvMs0_NtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x648settingsNtB5_5Flags18numbered_predicate:
  116|  2.04k|    fn numbered_predicate(&self, p: usize) -> bool {
  117|  2.04k|        self.bytes[0 + p / 8] & (1 << (p % 8)) != 0
  118|  2.04k|    }
_RNvMs0_NtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x648settingsNtB5_5Flags7has_fma:
  151|    204|    pub fn has_fma(&self) -> bool {
  152|    204|        self.numbered_predicate(6)
  153|    204|    }
_RNvMs0_NtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x648settingsNtB5_5Flags10has_popcnt:
  181|    204|    pub fn has_popcnt(&self) -> bool {
  182|    204|        self.numbered_predicate(12)
  183|    204|    }
_RNvMNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x648settingsNtB2_5Flags3new:
    9|    204|    pub fn new(shared: &settings::Flags, builder: Builder) -> Self {
   10|    204|        let bvec = builder.state_for("x86");
   11|    204|        let mut x86 = Self { bytes: [0; 5] };
   12|    204|        debug_assert_eq!(bvec.len(), 2);
   13|    204|        x86.bytes[0..2].copy_from_slice(&bvec);
   14|    204|        // Precompute #16.
   15|    204|        if shared.is_pic() {
   16|      0|            x86.bytes[2] |= 1 << 0;
   17|    204|        }
   18|       |        // Precompute #17.
   19|    204|        if !(shared.is_pic()) {
   20|    204|            x86.bytes[2] |= 1 << 1;
   21|    204|        }
   22|       |        // Precompute #18.
   23|    204|        if shared.enable_simd() && x86.has_avx2() {
   24|      0|            x86.bytes[2] |= 1 << 2;
   25|    204|        }
   26|       |        // Precompute #19.
   27|    204|        if shared.enable_simd() && x86.has_avx512bitalg() {
   28|      0|            x86.bytes[2] |= 1 << 3;
   29|    204|        }
   30|       |        // Precompute #20.
   31|    204|        if shared.enable_simd() && x86.has_avx512dq() {
   32|      0|            x86.bytes[2] |= 1 << 4;
   33|    204|        }
   34|       |        // Precompute #21.
   35|    204|        if shared.enable_simd() && x86.has_avx512f() {
   36|      0|            x86.bytes[2] |= 1 << 5;
   37|    204|        }
   38|       |        // Precompute #22.
   39|    204|        if shared.enable_simd() && x86.has_avx512vbmi() {
   40|      0|            x86.bytes[2] |= 1 << 6;
   41|    204|        }
   42|       |        // Precompute #23.
   43|    204|        if shared.enable_simd() && x86.has_avx512vl() {
   44|      0|            x86.bytes[2] |= 1 << 7;
   45|    204|        }
   46|       |        // Precompute #24.
   47|    204|        if shared.enable_simd() && x86.has_avx() {
   48|      0|            x86.bytes[3] |= 1 << 0;
   49|    204|        }
   50|       |        // Precompute #25.
   51|    204|        if x86.has_bmi1() {
   52|    204|            x86.bytes[3] |= 1 << 1;
   53|    204|        }
   54|       |        // Precompute #26.
   55|    204|        if x86.has_avx() && x86.has_fma() {
   56|    204|            x86.bytes[3] |= 1 << 2;
   57|    204|        }
   58|       |        // Precompute #27.
   59|    204|        if x86.has_lzcnt() {
   60|    204|            x86.bytes[3] |= 1 << 3;
   61|    204|        }
   62|       |        // Precompute #28.
   63|    204|        if x86.has_popcnt() && x86.has_sse42() {
   64|    204|            x86.bytes[3] |= 1 << 4;
   65|    204|        }
   66|       |        // Precompute #29.
   67|    204|        if x86.has_sse41() {
   68|    204|            x86.bytes[3] |= 1 << 5;
   69|    204|        }
   70|       |        // Precompute #30.
   71|    204|        if shared.enable_simd() && x86.has_sse41() {
   72|      0|            x86.bytes[3] |= 1 << 6;
   73|    204|        }
   74|       |        // Precompute #31.
   75|    204|        if x86.has_sse41() && x86.has_sse42() {
   76|    204|            x86.bytes[3] |= 1 << 7;
   77|    204|        }
   78|       |        // Precompute #32.
   79|    204|        if shared.enable_simd() && x86.has_sse41() && x86.has_sse42() {
   80|      0|            x86.bytes[4] |= 1 << 0;
   81|    204|        }
   82|       |        // Precompute #33.
   83|    204|        if x86.has_ssse3() {
   84|    204|            x86.bytes[4] |= 1 << 1;
   85|    204|        }
   86|       |        // Precompute #34.
   87|    204|        if shared.enable_simd() && x86.has_ssse3() {
   88|      0|            x86.bytes[4] |= 1 << 2;
   89|    204|        }
   90|    204|        x86
   91|    204|    }
_RNvMs0_NtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x648settingsNtB5_5Flags9has_sse41:
  131|    408|    pub fn has_sse41(&self) -> bool {
  132|    408|        self.numbered_predicate(2)
  133|    408|    }
_RNvMs0_NtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x648settingsNtB5_5Flags7has_avx:
  141|    204|    pub fn has_avx(&self) -> bool {
  142|    204|        self.numbered_predicate(4)
  143|    204|    }
_RNvMs0_NtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x648settingsNtB5_5Flags9has_lzcnt:
  196|    204|    pub fn has_lzcnt(&self) -> bool {
  197|    204|        self.numbered_predicate(15)
  198|    204|    }
_RNvMs0_NtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x648settingsNtB5_5Flags9has_sse42:
  136|    408|    pub fn has_sse42(&self) -> bool {
  137|    408|        self.numbered_predicate(3)
  138|    408|    }
_RNvMs0_NtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x648settingsNtB5_5Flags9has_ssse3:
  126|    204|    pub fn has_ssse3(&self) -> bool {
  127|    204|        self.numbered_predicate(1)
  128|    204|    }
_RNvNtNtNtCsaCEcwVhukSb_17cranelift_codegen3isa3x648settings7builder:
  493|    204|pub fn builder() -> Builder {
  494|    204|    Builder::new(&TEMPLATE)
  495|    204|}

_RNvMsB_NtCsaCEcwVhukSb_17cranelift_codegen8settingsNtB5_5Flags6is_pic:
  323|    408|    pub fn is_pic(&self) -> bool {
  324|    408|        self.numbered_predicate(4)
  325|    408|    }
_RNvMsr_NtCsaCEcwVhukSb_17cranelift_codegen8settingsNtB5_5Flags3new:
    9|    204|    pub fn new(builder: Builder) -> Self {
   10|    204|        let bvec = builder.state_for("shared");
   11|    204|        let mut shared = Self { bytes: [0; 8] };
   12|    204|        debug_assert_eq!(bvec.len(), 8);
   13|    204|        shared.bytes[0..8].copy_from_slice(&bvec);
   14|    204|        shared
   15|    204|    }
_RNvNtCsaCEcwVhukSb_17cranelift_codegen8settings7builder:
  761|    204|pub fn builder() -> Builder {
  762|    204|    Builder::new(&TEMPLATE)
  763|    204|}
_RNvMsB_NtCsaCEcwVhukSb_17cranelift_codegen8settingsNtB5_5Flags11enable_simd:
  379|  2.24k|    pub fn enable_simd(&self) -> bool {
  380|  2.24k|        self.numbered_predicate(11)
  381|  2.24k|    }
_RNvMsB_NtCsaCEcwVhukSb_17cranelift_codegen8settingsNtB5_5Flags18numbered_predicate:
  176|  2.85k|    fn numbered_predicate(&self, p: usize) -> bool {
  177|  2.85k|        self.bytes[5 + p / 8] & (1 << (p % 8)) != 0
  178|  2.85k|    }
_RNvMsB_NtCsaCEcwVhukSb_17cranelift_codegen8settingsNtB5_5Flags17enable_pinned_reg:
  363|    204|    pub fn enable_pinned_reg(&self) -> bool {
  364|    204|        self.numbered_predicate(9)
  365|    204|    }

_RNvMs3_NtCs8QACEDFNhqS_14target_lexicon4hostNtNtB7_6triple6Triple4host:
   64|    204|    pub const fn host() -> Self {
   65|    204|        Self {
   66|    204|            architecture: Architecture::X86_64,
   67|    204|            vendor: Vendor::Unknown,
   68|    204|            operating_system: OperatingSystem::Linux,
   69|    204|            environment: Environment::Gnu,
   70|    204|            binary_format: BinaryFormat::Elf,
   71|    204|        }
   72|    204|    }

_RNvXs0_NtNtCs7Ei498kZF3p_3fvm10blockstore8bufferedINtB5_18BufferedBlockstoreNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreENtB1g_10Blockstore3getCsitTtQF8ArIt_8fvm_fuzz:
  235|    408|    fn get(&self, cid: &Cid) -> Result<Option<Vec<u8>>> {
  236|    408|        Ok(if let Some(data) = self.write.borrow().get(cid) {
  237|      0|            Some(data.clone())
  238|       |        } else {
  239|    408|            self.base.get(cid)?
  240|       |        })
  241|    408|    }
_RNvMNtNtCs7Ei498kZF3p_3fvm10blockstore8bufferedINtB2_18BufferedBlockstoreNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreE3newCsitTtQF8ArIt_8fvm_fuzz:
   28|    102|    pub fn new(base: BS) -> Self {
   29|    102|        Self {
   30|    102|            base,
   31|    102|            write: Default::default(),
   32|    102|        }
   33|    102|    }

_RNvXs4_NtNtCs7Ei498kZF3p_3fvm12call_manager9backtraceNtB5_9BacktraceNtNtCshM4Il2Z0i4R_4core7default7Default7default:
   14|    102|#[derive(Debug, Default, Clone)]

_RNvXNtNtCs7Ei498kZF3p_3fvm12call_manager7defaultINtB2_18DefaultCallManagerINtNtNtB6_7machine7default14DefaultMachineNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs6UoH8pR2orC_21fvm_integration_tests5dummy12DummyExternsEENtNtNtCshM4Il2Z0i4R_4core3ops5deref5Deref5derefCsitTtQF8ArIt_8fvm_fuzz:
   85|    170|    fn deref(&self) -> &Self::Target {
   86|    170|        self.0.as_ref().expect("call manager is poisoned")
   87|    170|    }
_RNvXs5_NtNtCs7Ei498kZF3p_3fvm12call_manager7defaultNtB5_17EventsAccumulatorNtNtCshM4Il2Z0i4R_4core7default7Default7default:
  761|    102|#[derive(Default)]
_RNvXs0_NtNtCs7Ei498kZF3p_3fvm12call_manager7defaultINtB5_18DefaultCallManagerINtNtNtB9_7machine7default14DefaultMachineNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs6UoH8pR2orC_21fvm_integration_tests5dummy12DummyExternsEENtB7_11CallManager7machineCsitTtQF8ArIt_8fvm_fuzz:
  268|     85|    fn machine(&self) -> &Self::Machine {
  269|     85|        &self.machine
  270|     85|    }
_RNvXs0_NtNtCs7Ei498kZF3p_3fvm12call_manager7defaultINtB5_18DefaultCallManagerINtNtNtB9_7machine7default14DefaultMachineNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs6UoH8pR2orC_21fvm_integration_tests5dummy12DummyExternsEENtB7_11CallManager3newCsitTtQF8ArIt_8fvm_fuzz:
  103|    102|    fn new(
  104|    102|        machine: M,
  105|    102|        engine: Engine,
  106|    102|        gas_limit: i64,
  107|    102|        origin: ActorID,
  108|    102|        origin_address: Address,
  109|    102|        nonce: u64,
  110|    102|        gas_premium: TokenAmount,
  111|    102|    ) -> Self {
  112|    102|        let limits = machine.new_limiter();
  113|    102|        let gas_tracker =
  114|    102|            GasTracker::new(Gas::new(gas_limit), Gas::zero(), machine.context().tracing);
  115|    102|
  116|    102|        DefaultCallManager(Some(Box::new(InnerDefaultCallManager {
  117|    102|            engine: Rc::new(engine),
  118|    102|            machine,
  119|    102|            gas_tracker,
  120|    102|            gas_premium,
  121|    102|            origin,
  122|    102|            origin_address,
  123|    102|            nonce,
  124|    102|            num_actors_created: 0,
  125|    102|            call_stack_depth: 0,
  126|    102|            backtrace: Backtrace::default(),
  127|    102|            exec_trace: vec![],
  128|    102|            invocation_count: 0,
  129|    102|            limits,
  130|    102|            events: Default::default(),
  131|    102|        })))
  132|    102|    }
_RNvXs0_NtNtCs7Ei498kZF3p_3fvm12call_manager7defaultINtB5_18DefaultCallManagerINtNtNtB9_7machine7default14DefaultMachineNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs6UoH8pR2orC_21fvm_integration_tests5dummy12DummyExternsEENtB7_11CallManager11gas_trackerCsitTtQF8ArIt_8fvm_fuzz:
  280|     85|    fn gas_tracker(&self) -> &GasTracker {
  281|     85|        &self.gas_tracker
  282|     85|    }

_RNvYINtNtNtCs7Ei498kZF3p_3fvm12call_manager7default18DefaultCallManagerINtNtNtB9_7machine7default14DefaultMachineNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs6UoH8pR2orC_21fvm_integration_tests5dummy12DummyExternsEENtB7_11CallManager10charge_gasCsitTtQF8ArIt_8fvm_fuzz:
  150|     85|    fn charge_gas(&self, charge: GasCharge) -> Result<GasTimer> {
  151|     85|        self.gas_tracker().apply_charge(charge)
  152|     85|    }
_RNvYINtNtNtCs7Ei498kZF3p_3fvm12call_manager7default18DefaultCallManagerINtNtNtB9_7machine7default14DefaultMachineNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs6UoH8pR2orC_21fvm_integration_tests5dummy12DummyExternsEENtB7_11CallManager10price_listCsitTtQF8ArIt_8fvm_fuzz:
  120|     85|    fn price_list(&self) -> &PriceList {
  121|     85|        self.machine().context().price_list
  122|     85|    }

_RINvMs4_NtCs7Ei498kZF3p_3fvm6engineNtB6_6Engine7preloadRNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreRINtNtCsjYc3JqMxxfa_5alloc3vec3VecINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EEECsitTtQF8ArIt_8fvm_fuzz:
  358|    102|    pub fn preload<'a, BS, I>(&self, blockstore: BS, cids: I) -> anyhow::Result<usize>
  359|    102|    where
  360|    102|        BS: Blockstore,
  361|    102|        I: IntoIterator<Item = &'a Cid>,
  362|    102|    {
  363|    102|        let mut total_size = 0usize;
  364|    102|        for cid in cids {
  365|      0|            log::trace!("preloading code CID {cid}");
  366|      0|            let size = self.prepare_actor_code(cid, &blockstore).with_context(|| {
  367|       |                anyhow!("could not prepare actor with code CID {}", &cid.to_string())
  368|      0|            })?;
  369|      0|            total_size += size;
  370|       |        }
  371|    102|        Ok(total_size)
  372|    102|    }
_RNvMs1_NtCs7Ei498kZF3p_3fvm6engineNtB5_10EnginePool3new:
  268|    204|    pub fn new(c: &wasmtime::Config, ec: EngineConfig) -> anyhow::Result<Self> {
  269|    204|        let engine = wasmtime::Engine::new(c)?;
  270|       |
  271|    204|        let mut dummy_store = wasmtime::Store::new(&engine, ());
  272|    204|        let gg_type = GlobalType::new(ValType::I64, Mutability::Var);
  273|    204|        let dummy_gg = Global::new(&mut dummy_store, gg_type, Val::I64(0))
  274|    204|            .expect("failed to create dummy gas global");
  275|    204|
  276|    204|        let dummy_memory = Memory::new(&mut dummy_store, MemoryType::new(0, Some(0)))
  277|    204|            .expect("failed to create dummy memory");
  278|    204|
  279|    204|        let actor_redirect = ec.actor_redirect.iter().cloned().collect();
  280|    204|
  281|    204|        Ok(EnginePool(Arc::new(EngineInner {
  282|    204|            limit: Mutex::new(ec.concurrency),
  283|    204|            condv: Condvar::new(),
  284|    204|            engine,
  285|    204|            dummy_memory,
  286|    204|            dummy_gas_global: dummy_gg,
  287|    204|            module_cache: Default::default(),
  288|    204|            instance_cache: Mutex::new(HashMap::new()),
  289|    204|            config: ec,
  290|    204|            actor_redirect,
  291|    204|        })))
  292|    204|    }
_RNvXs3_NtCs7Ei498kZF3p_3fvm6engineNtB5_6EngineNtNtNtCshM4Il2Z0i4R_4core3ops4drop4Drop4drop:
  314|    204|    fn drop(&mut self) {
  315|    204|        let mut limit = self.0.limit.lock().unwrap();
  316|    204|        *limit += 1;
  317|    204|        self.0.condv.notify_one();
  318|    204|    }
_RNvMs1_NtCs7Ei498kZF3p_3fvm6engineNtB5_10EnginePool11new_default:
  263|    204|    pub fn new_default(ec: EngineConfig) -> anyhow::Result<Self> {
  264|    204|        EnginePool::new(&wasmtime_config(&ec)?, ec)
  265|    204|    }
_RNCNvMs1_NtCs7Ei498kZF3p_3fvm6engineNtB7_10EnginePool7acquire0B9_:
  242|    204|            .wait_while(self.0.limit.lock().unwrap(), |limit| *limit == 0)
_RNvXNtCs7Ei498kZF3p_3fvm6engineNtB2_12EngineConfigINtNtCshM4Il2Z0i4R_4core7convert4FromRNtNtB4_7machine13NetworkConfigE4from:
   55|    204|    fn from(nc: &NetworkConfig) -> Self {
   56|    204|        EngineConfig {
   57|    204|            max_call_depth: nc.max_call_depth,
   58|    204|            max_wasm_stack: nc.max_wasm_stack,
   59|    204|            max_inst_memory_bytes: nc.max_inst_memory_bytes,
   60|    204|            wasm_prices: &nc.price_list.wasm_rules,
   61|    204|            actor_redirect: nc.actor_redirect.clone(),
   62|    204|            concurrency: 1,
   63|    204|        }
   64|    204|    }
_RNvMs1_NtCs7Ei498kZF3p_3fvm6engineNtB5_10EnginePool7acquire:
  238|    204|    pub fn acquire(&self) -> Engine {
  239|    204|        *self
  240|    204|            .0
  241|    204|            .condv
  242|    204|            .wait_while(self.0.limit.lock().unwrap(), |limit| *limit == 0)
  243|    204|            .unwrap() -= 1;
  244|    204|        Engine(self.0.clone())
  245|    204|    }
_RNvNtCs7Ei498kZF3p_3fvm6engine15wasmtime_config:
  102|    204|fn wasmtime_config(ec: &EngineConfig) -> anyhow::Result<wasmtime::Config> {
  103|    204|    let instance_count = (1 + ec.max_call_depth) * ec.concurrency;
  104|    204|    let instance_memory_maximum_size = ec.max_inst_memory_bytes;
  105|    204|    if instance_memory_maximum_size % wasmtime_environ::WASM_PAGE_SIZE as u64 != 0 {
  106|      0|        return Err(anyhow!(
  107|      0|            "requested memory limit {} not a multiple of the WASM_PAGE_SIZE {}",
  108|      0|            instance_memory_maximum_size,
  109|      0|            wasmtime_environ::WASM_PAGE_SIZE
  110|      0|        ));
  111|    204|    }
  112|    204|
  113|    204|    let mut c = wasmtime::Config::default();
  114|    204|
  115|    204|    // wasmtime default: OnDemand
  116|    204|    // We want to pre-allocate all permissible memory to support the maximum allowed recursion limit.
  117|    204|    c.allocation_strategy(InstanceAllocationStrategy::Pooling {
  118|    204|        strategy: PoolingAllocationStrategy::ReuseAffinity,
  119|    204|        instance_limits: InstanceLimits {
  120|    204|            count: instance_count,
  121|    204|            // Adjust the maximum amount of host memory that can be committed to an instance to
  122|    204|            // match the static linear memory size we reserve for each slot.
  123|    204|            memory_pages: instance_memory_maximum_size / (wasmtime_environ::WASM_PAGE_SIZE as u64),
  124|    204|            ..Default::default()
  125|    204|        },
  126|    204|    });
  127|    204|
  128|    204|    // wasmtime default: true
  129|    204|    // We disable this as we always charge for memory regardless and `memory_init_cow` can baloon compiled wasm modules.
  130|    204|    c.memory_init_cow(false);
  131|    204|
  132|    204|    // wasmtime default: 4GB
  133|    204|    c.static_memory_maximum_size(instance_memory_maximum_size);
  134|    204|
  135|    204|    // wasmtime default: false
  136|    204|    // We don't want threads, there is no way to ensure determisism
  137|    204|    c.wasm_threads(false);
  138|    204|
  139|    204|    // wasmtime default: true
  140|    204|    // simd isn't supported in wasm-instrument, but if we add support there, we can probably enable this.
  141|    204|    // Note: stack limits may need adjusting after this is enabled
  142|    204|    c.wasm_simd(false);
  143|    204|
  144|    204|    // wasmtime default: false
  145|    204|    c.wasm_multi_memory(false);
  146|    204|
  147|    204|    // wasmtime default: false
  148|    204|    c.wasm_memory64(false);
  149|    204|
  150|    204|    // wasmtime default: true
  151|    204|    // Note: wasm-instrument only supports this at a basic level, for M2 we will
  152|    204|    // need to add more advanced support
  153|    204|    c.wasm_bulk_memory(true);
  154|    204|
  155|    204|    // wasmtime default: true
  156|    204|    // we should be able to enable this for M2, just need to make sure that it's
  157|    204|    // handled correctly in wasm-instrument
  158|    204|    c.wasm_multi_value(false);
  159|    204|
  160|    204|    // wasmtime default: false
  161|    204|    //
  162|    204|    // from wasmtime docs:
  163|    204|    // > When Cranelift is used as a code generation backend this will
  164|    204|    // > configure it to replace NaNs with a single canonical value. This
  165|    204|    // > is useful for users requiring entirely deterministic WebAssembly
  166|    204|    // > computation. This is not required by the WebAssembly spec, so it is
  167|    204|    // > not enabled by default.
  168|    204|    c.cranelift_nan_canonicalization(true);
  169|    204|
  170|    204|    // wasmtime default: 512KiB
  171|    204|    // Set to something much higher than the instrumented limiter.
  172|    204|    // Note: This is in bytes, while the instrumented limit is in stack elements
  173|    204|    c.max_wasm_stack(4 << 20);
  174|    204|
  175|    204|    // Execution cost accouting is done through wasm instrumentation,
  176|    204|    c.consume_fuel(false);
  177|    204|    c.epoch_interruption(false);
  178|    204|
  179|    204|    // Disable debug-related things, wasm-instrument doesn't fix debug info
  180|    204|    // yet, so those aren't useful, just add overhead
  181|    204|    c.debug_info(false);
  182|    204|    c.generate_address_map(false);
  183|    204|    c.cranelift_debug_verifier(false);
  184|    204|    c.native_unwind_info(false);
  185|    204|    #[allow(deprecated)] // TODO https://github.com/bytecodealliance/wasmtime/issues/5037
  186|    204|    c.wasm_backtrace(false);
  187|    204|    c.wasm_reference_types(false);
  188|    204|
  189|    204|    // Reiterate some defaults
  190|    204|    c.guard_before_linear_memory(true);
  191|    204|    c.parallel_compilation(true);
  192|    204|
  193|    204|    #[cfg(feature = "wasmtime/async")]
  194|    204|    c.async_support(false);
  195|    204|
  196|    204|    // Doesn't seem to have significant impact on the time it takes to load code
  197|    204|    // todo(M2): make sure this is guaranteed to run in linear time.
  198|    204|    c.cranelift_opt_level(Speed);
  199|    204|
  200|    204|    Ok(c)
  201|    204|}

_RNvMs1_NtNtCs7Ei498kZF3p_3fvm8executor7defaultINtB5_15DefaultExecutorINtNtNtB9_6kernel7default13DefaultKernelINtNtNtB9_12call_manager7default18DefaultCallManagerINtNtNtB9_7machine7default14DefaultMachineNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs6UoH8pR2orC_21fvm_integration_tests5dummy12DummyExternsEEEE3newCsitTtQF8ArIt_8fvm_fuzz:
  334|    102|    pub fn new(
  335|    102|        engine_pool: EnginePool,
  336|    102|        machine: <K::CallManager as CallManager>::Machine,
  337|    102|    ) -> anyhow::Result<Self> {
  338|    102|        // Skip preloading all builtin actors when testing.
  339|    102|        #[cfg(not(any(test, feature = "testing")))]
  340|    102|        {
  341|    102|            // Preload any uncached modules.
  342|    102|            // This interface works for now because we know all actor CIDs
  343|    102|            // ahead of time, but with user-supplied code, we won't have that
  344|    102|            // guarantee.
  345|    102|            engine_pool.acquire().preload(
  346|    102|                machine.blockstore(),
  347|    102|                machine.builtin_actors().builtin_actor_codes(),
  348|    102|            )?;
  349|    102|        }
  350|    102|        Ok(Self {
  351|    102|            engine_pool,
  352|    102|            machine: Some(machine),
  353|    102|        })
  354|    102|    }
_RNvMs1_NtNtCs7Ei498kZF3p_3fvm8executor7defaultINtB5_15DefaultExecutorINtNtNtB9_6kernel7default13DefaultKernelINtNtNtB9_12call_manager7default18DefaultCallManagerINtNtNtB9_7machine7default14DefaultMachineNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs6UoH8pR2orC_21fvm_integration_tests5dummy12DummyExternsEEEE12into_machineCsitTtQF8ArIt_8fvm_fuzz:
  358|    102|    pub fn into_machine(self) -> Option<<K::CallManager as CallManager>::Machine> {
  359|    102|        self.machine
  360|    102|    }

_RINvMNtNtCs7Ei498kZF3p_3fvm3gas6chargeNtB3_9GasCharge3newReECsitTtQF8ArIt_8fvm_fuzz:
   24|     85|    pub fn new(name: impl Into<Cow<'static, str>>, compute_gas: Gas, storage_gas: Gas) -> Self {
   25|     85|        let name = name.into();
   26|     85|        Self {
   27|     85|            name,
   28|     85|            compute_gas,
   29|     85|            storage_gas,
   30|     85|            elapsed: GasDuration::default(),
   31|     85|        }
   32|     85|    }
_RNvMNtNtCs7Ei498kZF3p_3fvm3gas6chargeNtB2_9GasCharge5total:
   36|     85|    pub fn total(&self) -> Gas {
   37|     85|        self.compute_gas + self.storage_gas
   38|     85|    }

_RNvXsa_NtCs7Ei498kZF3p_3fvm3gasNtB5_3GasINtNtNtCshM4Il2Z0i4R_4core3ops5arith3MuljE3mul:
  179|    168|    fn mul(self, rhs: usize) -> Self::Output {
  180|    168|        Self(self.0.saturating_mul(rhs.try_into().unwrap_or(i64::MAX)))
  181|    168|    }
_RNvMs0_NtCs7Ei498kZF3p_3fvm3gasNtB5_3Gas13from_milligas:
   62|      1|    pub const fn from_milligas(milligas: i64) -> Gas {
   63|      1|        Gas(milligas)
   64|      1|    }
_RNvXs2_NtCs7Ei498kZF3p_3fvm3gasNtB5_3GasNtNtNtCshM4Il2Z0i4R_4core3ops5arith3Add3add:
  111|    338|    fn add(self, rhs: Self) -> Self::Output {
  112|    338|        Self(self.0.saturating_add(rhs.0))
  113|    338|    }
_RNvMs0_NtCs7Ei498kZF3p_3fvm3gasNtB5_3Gas3new:
   69|    153|    pub const fn new(gas: i64) -> Gas {
   70|    153|        Gas(gas.saturating_mul(MILLIGAS_PRECISION))
   71|    153|    }
_RNvMsb_NtCs7Ei498kZF3p_3fvm3gasNtB5_10GasTracker12apply_charge:
  230|     85|    pub fn apply_charge(&self, mut charge: GasCharge) -> Result<GasTimer> {
  231|     85|        let to_use = charge.total();
  232|     85|        log::trace!("charging gas: {} {}", &charge.name, to_use);
  233|     85|        let res = self.charge_gas_inner(to_use);
  234|     85|        if let Some(trace) = &self.trace {
  235|     85|            let timer = GasTimer::new(&mut charge.elapsed);
  236|     85|            trace.borrow_mut().push(charge);
  237|     85|            res.map(|_| timer)
  238|       |        } else {
  239|      0|            res.map(|_| GasTimer::empty())
  240|       |        }
  241|     85|    }
_RNvMsb_NtCs7Ei498kZF3p_3fvm3gasNtB5_10GasTracker16charge_gas_inner:
  201|     85|    fn charge_gas_inner(&self, to_use: Gas) -> Result<()> {
  202|     85|        // The gas type uses saturating math.
  203|     85|        let gas_used = self.gas_used.get() + to_use;
  204|     85|        if gas_used > self.gas_limit {
  205|     26|            log::trace!("gas limit reached");
  206|     26|            self.gas_used.set(self.gas_limit);
  207|     26|            Err(ExecutionError::OutOfGas)
  208|       |        } else {
  209|     59|            self.gas_used.set(gas_used);
  210|     59|            Ok(())
  211|       |        }
  212|     85|    }
_RNCNvMsb_NtCs7Ei498kZF3p_3fvm3gasNtB7_10GasTracker12apply_charge0B9_:
  237|     59|            res.map(|_| timer)
_RNvXsi_NtCs7Ei498kZF3p_3fvm3gasNtB5_3GasNtNtCshM4Il2Z0i4R_4core3cmp10PartialOrd11partial_cmp:
   30|     85|#[derive(Hash, Eq, PartialEq, Ord, PartialOrd, Copy, Clone, Default)]
_RNvMsb_NtCs7Ei498kZF3p_3fvm3gasNtB5_10GasTracker3new:
  193|    102|    pub fn new(gas_limit: Gas, gas_used: Gas, enable_tracing: bool) -> Self {
  194|    102|        Self {
  195|    102|            gas_limit,
  196|    102|            gas_used: Cell::new(gas_used),
  197|    102|            trace: enable_tracing.then_some(Default::default()),
  198|    102|        }
  199|    102|    }
_RNvXs_NtCs7Ei498kZF3p_3fvm3gasNtB4_3GasNtNtCshM4Il2Z0i4R_4core3fmt7Display3fmt:
   48|     85|    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
   49|     85|        if self.0 == 0 {
   50|     61|            f.write_str("0")
   51|       |        } else {
   52|     24|            let integral = self.0 / MILLIGAS_PRECISION;
   53|     24|            let fractional = self.0 % MILLIGAS_PRECISION;
   54|     24|            write!(f, "{integral}.{fractional:03}")
   55|       |        }
   56|     85|    }
_RNvXs1_NtCs7Ei498kZF3p_3fvm3gasNtB5_3GasNtNtCs4qz2OQMshGu_10num_traits10identities4Zero4zero:
   98|    206|    fn zero() -> Self {
   99|    206|        Gas(0)
  100|    206|    }

_RNvMs_NtNtCs7Ei498kZF3p_3fvm3gas10price_listNtB4_9PriceList15on_block_create:
  884|     84|    pub fn on_block_create(&self, data_size: usize) -> GasCharge {
  885|     84|        let mem_costs = (self.block_create_memret_per_byte_cost * data_size)
  886|     84|            + (self.block_memcpy_per_byte_cost * data_size);
  887|     84|        GasCharge::new(
  888|     84|            "OnBlockCreate",
  889|     84|            self.block_create_base + mem_costs,
  890|     84|            Zero::zero(),
  891|     84|        )
  892|     84|    }
_RNvMs_NtNtCs7Ei498kZF3p_3fvm3gas10price_listNtB4_9PriceList13on_block_stat:
  911|      1|    pub fn on_block_stat(&self) -> GasCharge {
  912|      1|        GasCharge::new("OnBlockStat", self.block_stat_base, Zero::zero())
  913|      1|    }
_RNvNtNtCs7Ei498kZF3p_3fvm3gas10price_list29price_list_by_network_version:
 1045|    204|pub fn price_list_by_network_version(network_version: NetworkVersion) -> &'static PriceList {
 1046|    204|    match network_version {
 1047|      0|        NetworkVersion::V15 => &OH_SNAP_PRICES,
 1048|      0|        NetworkVersion::V16 | NetworkVersion::V17 => &SKYR_PRICES,
 1049|    204|        NetworkVersion::V18 => &HYGGE_PRICES,
 1050|      0|        _ => panic!("network version {nv} not supported", nv = network_version),
 1051|       |    }
 1052|    204|}
_RNvXse_NtNtCs7Ei498kZF3p_3fvm3gas10price_listNtB5_8StepCostNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
  472|      2|#[derive(Clone, Debug, PartialEq, Eq)]

_RNvXs0_NtNtCs7Ei498kZF3p_3fvm3gas5timerNtB5_11GasDurationNtNtCshM4Il2Z0i4R_4core7default7Default7default:
   16|     85|#[derive(Default, Debug, Clone)]
_RINvMs_NtNtCs7Ei498kZF3p_3fvm3gas5timerNtB5_8GasTimer6recordmNtNtNtB9_6kernel5error14ExecutionErrorECsitTtQF8ArIt_8fvm_fuzz:
  100|     59|    pub fn record<R, E>(self, result: Result<R, E>) -> Result<R, E> {
  101|     59|        if result.is_ok() {
  102|     59|            self.stop()
  103|      0|        }
  104|     59|        result
  105|     59|    }
_RNvMs_NtNtCs7Ei498kZF3p_3fvm3gas5timerNtB4_8GasTimer11set_elapsed:
   89|     59|    fn set_elapsed(elapsed: Arc<OnceCell<Duration>>, start: GasInstant) {
   90|     59|        elapsed
   91|     59|            .set(start.elapsed())
   92|     59|            .expect("GasCharge::elapsed already set!")
   93|     59|    }
_RNvMNtNtCs7Ei498kZF3p_3fvm3gas5timerNtB2_11GasDuration3get:
   20|     85|    pub fn get(&self) -> Option<&Duration> {
   21|     85|        self.0.as_ref().and_then(|d| d.get())
   22|     85|    }
_RNvMs_NtNtCs7Ei498kZF3p_3fvm3gas5timerNtB4_8GasTimer4stop:
   77|     59|        if let Some(timer) = self.0 {
   78|     59|            Self::set_elapsed(timer.elapsed, timer.start)
   79|      0|        }
   80|     59|    }
_RNvMs_NtNtCs7Ei498kZF3p_3fvm3gas5timerNtB4_8GasTimer3new:
   57|     85|    pub fn new(duration: &mut GasDuration) -> Self {
   58|     85|        assert!(duration.get().is_none(), "GasCharge::elapsed already set!");
   59|       |
   60|     85|        let cell = match &duration.0 {
   61|      0|            Some(cell) => cell.clone(),
   62|       |            None => {
   63|     85|                let cell = DurationCell::default();
   64|     85|                duration.0 = Some(cell.clone());
   65|     85|                cell
   66|       |            }
   67|       |        };
   68|       |
   69|     85|        Self(Some(GasTimerInner {
   70|     85|            start: Self::start(),
   71|     85|            elapsed: cell,
   72|     85|        }))
   73|     85|    }
_RNvMs_NtNtCs7Ei498kZF3p_3fvm3gas5timerNtB4_8GasTimer5start:
   45|    328|    pub fn start() -> GasInstant {
   46|    328|        GasInstant::now()
   47|    328|    }

_RINvXNvNvXs0_NtCs7Ei498kZF3p_3fvm10init_actorNtBb_5StateNtNtCslVZeVZySzLE_5serde3ser9Serialize9serialize1__NtB5_5InnerBS_9serializeINtCs872nzRHi4k9_11serde_tuple10SerializerQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEEECsitTtQF8ArIt_8fvm_fuzz:
   33|    102|#[derive(Serialize_tuple, Deserialize_tuple, Debug)]
_RINvXs0_NtCs7Ei498kZF3p_3fvm10init_actorNtB6_5StateNtNtCslVZeVZySzLE_5serde3ser9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
   33|    102|#[derive(Serialize_tuple, Deserialize_tuple, Debug)]
_RINvMs_NtCs7Ei498kZF3p_3fvm10init_actorNtB5_5State8new_testNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreECsitTtQF8ArIt_8fvm_fuzz:
   48|    102|    pub fn new_test<B: Blockstore>(store: &B) -> Self {
   49|    102|        #[cfg(feature = "m2-native")]
   50|    102|        use cid::multihash::Code::Blake2b256;
   51|    102|
   52|    102|        // Empty hamt Cid used for testing
   53|    102|        let e_cid = Hamt::<_, String>::new_with_bit_width(&store, 5)
   54|    102|            .flush()
   55|    102|            .unwrap();
   56|    102|
   57|    102|        // Empty list Cid used for testing
   58|    102|        #[cfg(feature = "m2-native")]
   59|    102|        let el_cid = store.put_cbor(&Vec::<Cid>::new(), Blake2b256).unwrap();
   60|    102|
   61|    102|        State {
   62|    102|            address_map: e_cid,
   63|    102|            next_id: 100,
   64|    102|            network_name: "test".to_owned(),
   65|    102|            #[cfg(feature = "m2-native")]
   66|    102|            installed_actors: el_cid,
   67|    102|        }
   68|    102|    }

_RINvMNtNtCs7Ei498kZF3p_3fvm6kernel6blocksNtB3_5Block3newRShECsitTtQF8ArIt_8fvm_fuzz:
   45|     59|    pub fn new(codec: u64, data: impl Into<Box<[u8]>>) -> Self {
   46|     59|        // This requires an extra allocation (ew) but no extra copy on send.
   47|     59|        // The extra allocation is basically nothing.
   48|     59|        Self {
   49|     59|            codec,
   50|     59|            data: Rc::new(data.into()),
   51|     59|        }
   52|     59|    }
_RNvXs5_NtNtCs7Ei498kZF3p_3fvm6kernel6blocksNtB5_13BlockRegistryNtNtCshM4Il2Z0i4R_4core7default7Default7default:
   13|    102|#[derive(Default)]
_RNvXs1_NtNtCs7Ei498kZF3p_3fvm6kernel6blocksNtNtB7_5error12SyscallErrorINtNtCshM4Il2Z0i4R_4core7convert4FromNtB5_18InvalidHandleErrorE4from:
  106|    243|    fn from(e: InvalidHandleError) -> Self {
  107|    243|        syscall_error!(InvalidHandle; "{}", e)
  108|    243|    }
_RNvMs4_NtNtCs7Ei498kZF3p_3fvm6kernel6blocksNtB5_13BlockRegistry3put:
  125|     59|    pub fn put(&mut self, block: Block) -> Result<BlockId, BlockPutError> {
  126|     59|        if self.is_full() {
  127|      0|            return Err(BlockPutError::TooManyBlocks);
  128|     59|        }
  129|     59|
  130|     59|        if !ALLOWED_CODECS.contains(&block.codec) {
  131|      0|            return Err(BlockPutError::InvalidCodec(block.codec));
  132|     59|        }
  133|     59|
  134|     59|        let id = FIRST_ID + self.blocks.len() as u32;
  135|     59|        self.blocks.push(block);
  136|     59|        Ok(id)
  137|     59|    }
_RNvXsf_NtNtCs7Ei498kZF3p_3fvm6kernel6blocksNtB5_18InvalidHandleErrorNtNtCshM4Il2Z0i4R_4core3fmt7Display3fmt:
  101|    243|#[derive(Error, Debug)]
_RNvXs2_NtNtCs7Ei498kZF3p_3fvm6kernel6blocksNtNtB7_5error14ExecutionErrorINtNtCshM4Il2Z0i4R_4core7convert4FromNtB5_18InvalidHandleErrorE4from:
  112|    243|    fn from(e: InvalidHandleError) -> Self {
  113|    243|        ExecutionError::Syscall(e.into())
  114|    243|    }
_RNvMs4_NtNtCs7Ei498kZF3p_3fvm6kernel6blocksNtB5_13BlockRegistry3get:
  140|    243|    pub fn get(&self, id: BlockId) -> Result<&Block, InvalidHandleError> {
  141|    243|        if id < FIRST_ID {
  142|    243|            return Err(InvalidHandleError(id));
  143|      0|        }
  144|      0|        id.try_into()
  145|      0|            .ok()
  146|      0|            .and_then(|idx: usize| self.blocks.get(idx - FIRST_ID as usize))
  147|      0|            .ok_or(InvalidHandleError(id))
  148|    243|    }
_RNvMs4_NtNtCs7Ei498kZF3p_3fvm6kernel6blocksNtB5_13BlockRegistry7is_full:
  165|     59|    pub fn is_full(&self) -> bool {
  166|     59|        self.blocks.len() as u32 == MAX_BLOCKS
  167|     59|    }

_RNvXs1_NtNtCs7Ei498kZF3p_3fvm6kernel7defaultINtB5_13DefaultKernelINtNtNtB9_12call_manager7default18DefaultCallManagerINtNtNtB9_7machine7default14DefaultMachineNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs6UoH8pR2orC_21fvm_integration_tests5dummy12DummyExternsEEENtB7_12IpldBlockOps10block_readCsitTtQF8ArIt_8fvm_fuzz:
  290|    243|    fn block_read(&self, id: BlockId, offset: u32, buf: &mut [u8]) -> Result<i32> {
  291|    243|        let tstart = GasTimer::start();
  292|       |        // First, find the end of the _logical_ buffer (taking the offset into account).
  293|       |        // This must fit into an i32.
  294|       |
  295|       |        // We perform operations as u64, because we know that the buffer length and offset must fit
  296|       |        // in a u32.
  297|    243|        let end = i32::try_from((offset as u64) + (buf.len() as u64))
  298|    243|            .map_err(|_|syscall_error!(IllegalArgument; "offset plus buffer length did not fit into an i32"))?;
  299|       |
  300|       |        // Then get the block.
  301|    243|        let block = self.blocks.get(id)?;
  302|      0|        let data = block.data();
  303|      0|
  304|      0|        // We start reading at this offset.
  305|      0|        let start = offset as usize;
  306|      0|
  307|      0|        // We read (block_length - start) bytes, or until we fill the buffer.
  308|      0|        let to_read = std::cmp::min(data.len().saturating_sub(start), buf.len());
  309|       |
  310|       |        // We can now _charge_, because we actually know how many bytes we need to read.
  311|      0|        let t = self
  312|      0|            .call_manager
  313|      0|            .charge_gas(self.call_manager.price_list().on_block_read(to_read))?;
  314|       |
  315|       |        // Copy into the output buffer, but only if were're reading. If to_read == 0, start may be
  316|       |        // past the end of the block.
  317|      0|        if to_read != 0 {
  318|      0|            buf[..to_read].copy_from_slice(&data[start..(start + to_read)]);
  319|      0|        }
  320|      0|        t.stop_with(tstart);
  321|      0|        // Returns the difference between the end of the block, and offset + buf.len()
  322|      0|        Ok((data.len() as i32) - end)
  323|    243|    }
_RNvXNtNtCs7Ei498kZF3p_3fvm6kernel7defaultINtB2_13DefaultKernelINtNtNtB6_12call_manager7default18DefaultCallManagerINtNtNtB6_7machine7default14DefaultMachineNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs6UoH8pR2orC_21fvm_integration_tests5dummy12DummyExternsEEENtB4_6Kernel3newCsitTtQF8ArIt_8fvm_fuzz:
   83|    102|    fn new(
   84|    102|        mgr: C,
   85|    102|        blocks: BlockRegistry,
   86|    102|        caller: ActorID,
   87|    102|        actor_id: ActorID,
   88|    102|        method: MethodNum,
   89|    102|        value_received: TokenAmount,
   90|    102|    ) -> Self {
   91|    102|        DefaultKernel {
   92|    102|            call_manager: mgr,
   93|    102|            blocks,
   94|    102|            caller,
   95|    102|            actor_id,
   96|    102|            method,
   97|    102|            value_received,
   98|    102|        }
   99|    102|    }
_RNvXs1_NtNtCs7Ei498kZF3p_3fvm6kernel7defaultINtB5_13DefaultKernelINtNtNtB9_12call_manager7default18DefaultCallManagerINtNtNtB9_7machine7default14DefaultMachineNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs6UoH8pR2orC_21fvm_integration_tests5dummy12DummyExternsEEENtB7_12IpldBlockOps12block_createCsitTtQF8ArIt_8fvm_fuzz:
  251|     84|    fn block_create(&mut self, codec: u64, data: &[u8]) -> Result<BlockId> {
  252|     84|        let t = self
  253|     84|            .call_manager
  254|     84|            .charge_gas(self.call_manager.price_list().on_block_create(data.len()))?;
  255|       |
  256|     59|        t.record(Ok(self.blocks.put(Block::new(codec, data))?))
  257|     84|    }
_RNvXs1_NtNtCs7Ei498kZF3p_3fvm6kernel7defaultINtB5_13DefaultKernelINtNtNtB9_12call_manager7default18DefaultCallManagerINtNtNtB9_7machine7default14DefaultMachineNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs6UoH8pR2orC_21fvm_integration_tests5dummy12DummyExternsEEENtB7_12IpldBlockOps10block_statCsitTtQF8ArIt_8fvm_fuzz:
  325|      1|    fn block_stat(&self, id: BlockId) -> Result<BlockStat> {
  326|      1|        let t = self
  327|      1|            .call_manager
  328|      1|            .charge_gas(self.call_manager.price_list().on_block_stat())?;
  329|       |
  330|      0|        t.record(Ok(self.blocks.stat(id)?))
  331|      1|    }

_RNvXs0_NtNtCs7Ei498kZF3p_3fvm6kernel5errorINtNtCshM4Il2Z0i4R_4core6result6ResultINtNtBJ_6option6OptionNtNtB9_10state_tree10ActorStateENtNtCshRBVfIqfJKm_13fvm_ipld_hamt5error5ErrorENtB5_14ClassifyResult8or_fatalCsitTtQF8ArIt_8fvm_fuzz:
  100|    306|    fn or_fatal(self) -> Result<Self::Value>
  101|    306|    where
  102|    306|        Self::Error: Into<anyhow::Error>,
  103|    306|    {
  104|    306|        self.map_err(|e| ExecutionError::Fatal(e.into()))
  105|    306|    }
_RNvXs0_NtNtCs7Ei498kZF3p_3fvm6kernel5errorINtNtCshM4Il2Z0i4R_4core6result6ResultINtNtCs1slUOa8tBso_3cid3cid3CidKj40_ENtNtCshRBVfIqfJKm_13fvm_ipld_hamt5error5ErrorENtB5_14ClassifyResult8or_fatalCsitTtQF8ArIt_8fvm_fuzz:
  100|    102|    fn or_fatal(self) -> Result<Self::Value>
  101|    102|    where
  102|    102|        Self::Error: Into<anyhow::Error>,
  103|    102|    {
  104|    102|        self.map_err(|e| ExecutionError::Fatal(e.into()))
  105|    102|    }
_RNvXs0_NtNtCs7Ei498kZF3p_3fvm6kernel5errorINtNtCshM4Il2Z0i4R_4core6result6ResultINtNtCsjYc3JqMxxfa_5alloc3vec3VecNtNtCs4pVfV2XJudO_10fvm_shared5piece9PieceInfoENtNtCsbsA1N0ivJJv_17fvm_ipld_encoding6errors5ErrorENtB5_14ClassifyResult8or_errorCsitTtQF8ArIt_8fvm_fuzz:
  106|  31.7k|    fn or_error(self, code: ErrorNumber) -> Result<Self::Value>
  107|  31.7k|    where
  108|  31.7k|        Self::Error: Display,
  109|  31.7k|    {
  110|  31.7k|        self.map_err(|e| ExecutionError::Syscall(SyscallError(e.to_string(), code)))
  111|  31.7k|    }
_RNvXs0_NtNtCs7Ei498kZF3p_3fvm6kernel5errorINtNtCshM4Il2Z0i4R_4core6result6ResultINtNtCshRBVfIqfJKm_13fvm_ipld_hamt4hamt4HamtINtNtNtB9_10blockstore8buffered18BufferedBlockstoreNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreENtNtB9_10state_tree10ActorStateENtCs8HwUKyRtzLJ_6anyhow5ErrorENtB5_14ClassifyResult8or_fatalCsitTtQF8ArIt_8fvm_fuzz:
  100|    102|    fn or_fatal(self) -> Result<Self::Value>
  101|    102|    where
  102|    102|        Self::Error: Into<anyhow::Error>,
  103|    102|    {
  104|    102|        self.map_err(|e| ExecutionError::Fatal(e.into()))
  105|    102|    }
_RNCNvXs0_NtNtCs7Ei498kZF3p_3fvm6kernel5errorINtNtCshM4Il2Z0i4R_4core6result6ResultINtNtCsjYc3JqMxxfa_5alloc3vec3VecNtNtCs4pVfV2XJudO_10fvm_shared5piece9PieceInfoENtNtCsbsA1N0ivJJv_17fvm_ipld_encoding6errors5ErrorENtB7_14ClassifyResult8or_error0CsitTtQF8ArIt_8fvm_fuzz:
  110|  31.7k|        self.map_err(|e| ExecutionError::Syscall(SyscallError(e.to_string(), code)))
_RNvXs0_NtNtCs7Ei498kZF3p_3fvm6kernel5errorINtNtCshM4Il2Z0i4R_4core6result6ResultINtNtCs1slUOa8tBso_3cid3cid3CidKj40_ENtCs8HwUKyRtzLJ_6anyhow5ErrorENtB5_14ClassifyResult8or_fatalCsitTtQF8ArIt_8fvm_fuzz:
  100|    204|    fn or_fatal(self) -> Result<Self::Value>
  101|    204|    where
  102|    204|        Self::Error: Into<anyhow::Error>,
  103|    204|    {
  104|    204|        self.map_err(|e| ExecutionError::Fatal(e.into()))
  105|    204|    }
_RINvMs4_NtNtCs7Ei498kZF3p_3fvm6kernel5errorNtB6_12SyscallError3newNtNtCshM4Il2Z0i4R_4core3fmt9ArgumentsEBa_:
  185|    243|    pub fn new<D: Display>(c: ErrorNumber, d: D) -> Self {
  186|    243|        SyscallError(d.to_string(), c)
  187|    243|    }
_RINvXs2_NtNtCs7Ei498kZF3p_3fvm6kernel5errorNtB6_14ExecutionErrorNtB6_7Context7contextReEBa_:
  145|    977|    fn context<D: Display>(self, context: D) -> Self {
  146|    977|        use ExecutionError::*;
  147|    977|        match self {
  148|    977|            Syscall(e) => Syscall(SyscallError(format!("{}: {}", context, e.0), e.1)),
  149|      0|            Fatal(e) => Fatal(e.context(context.to_string())),
  150|      0|            OutOfGas => OutOfGas, // no reason necessary
  151|       |        }
  152|    977|    }
_RNCNvXs0_NtNtCs7Ei498kZF3p_3fvm6kernel5errorINtNtCshM4Il2Z0i4R_4core6result6ResultINtNtCs1slUOa8tBso_3cid3cid3CidKj40_ENtNtB1n_5error5ErrorENtB7_14ClassifyResult8or_error0Bb_:
  110|    977|        self.map_err(|e| ExecutionError::Syscall(SyscallError(e.to_string(), code)))
_RNCINvXs1_NtNtCs7Ei498kZF3p_3fvm6kernel5errorINtNtCshM4Il2Z0i4R_4core6result6ResultINtNtCs1slUOa8tBso_3cid3cid3CidKj40_ENtB8_14ExecutionErrorENtB8_7Context7contextReE0Bc_:
  131|    977|        self.map_err(|e| e.context(context))
_RNvXs0_NtNtCs7Ei498kZF3p_3fvm6kernel5errorINtNtCshM4Il2Z0i4R_4core6result6ResultRShNtNtCsjYc3JqMxxfa_5alloc6string6StringENtB5_14ClassifyResult8or_errorB9_:
  106|  32.9k|    fn or_error(self, code: ErrorNumber) -> Result<Self::Value>
  107|  32.9k|    where
  108|  32.9k|        Self::Error: Display,
  109|  32.9k|    {
  110|  32.9k|        self.map_err(|e| ExecutionError::Syscall(SyscallError(e.to_string(), code)))
  111|  32.9k|    }
_RNCNvXs0_NtNtCs7Ei498kZF3p_3fvm6kernel5errorINtNtCshM4Il2Z0i4R_4core6result6ResultRShNtNtCsjYc3JqMxxfa_5alloc6string6StringENtB7_14ClassifyResult8or_error0Bb_:
  110|     87|        self.map_err(|e| ExecutionError::Syscall(SyscallError(e.to_string(), code)))
_RNvXs0_NtNtCs7Ei498kZF3p_3fvm6kernel5errorINtNtCshM4Il2Z0i4R_4core6result6ResultINtNtCs1slUOa8tBso_3cid3cid3CidKj40_ENtNtB1l_5error5ErrorENtB5_14ClassifyResult8or_errorB9_:
  106|    977|    fn or_error(self, code: ErrorNumber) -> Result<Self::Value>
  107|    977|    where
  108|    977|        Self::Error: Display,
  109|    977|    {
  110|    977|        self.map_err(|e| ExecutionError::Syscall(SyscallError(e.to_string(), code)))
  111|    977|    }
_RNCNvXs0_NtNtCs7Ei498kZF3p_3fvm6kernel5errorINtNtCshM4Il2Z0i4R_4core6result6ResultQShNtNtCsjYc3JqMxxfa_5alloc6string6StringENtB7_14ClassifyResult8or_error0Bb_:
  110|      5|        self.map_err(|e| ExecutionError::Syscall(SyscallError(e.to_string(), code)))
_RNvXs0_NtNtCs7Ei498kZF3p_3fvm6kernel5errorINtNtCshM4Il2Z0i4R_4core6result6ResultRNtNtB9_10state_tree14StateSnapLayerNtCs8HwUKyRtzLJ_6anyhow5ErrorENtB5_14ClassifyResult8or_fatalB9_:
  100|    306|    fn or_fatal(self) -> Result<Self::Value>
  101|    306|    where
  102|    306|        Self::Error: Into<anyhow::Error>,
  103|    306|    {
  104|    306|        self.map_err(|e| ExecutionError::Fatal(e.into()))
  105|    306|    }
_RNvXs6_NtNtCs7Ei498kZF3p_3fvm6kernel5errorNtB5_14ExecutionErrorNtNtCshM4Il2Z0i4R_4core3fmt5Debug3fmt:
   33|  33.1k|#[derive(Display, Debug)]
_RNvXs9_NtNtCs7Ei498kZF3p_3fvm6kernel5errorNtB5_12SyscallErrorNtNtCshM4Il2Z0i4R_4core3fmt5Debug3fmt:
  180|  33.0k|#[derive(thiserror::Error, Debug, Clone)]
_RNvXs0_NtNtCs7Ei498kZF3p_3fvm6kernel5errorINtNtCshM4Il2Z0i4R_4core6result6ResultQShNtNtCsjYc3JqMxxfa_5alloc6string6StringENtB5_14ClassifyResult8or_errorB9_:
  106|    248|    fn or_error(self, code: ErrorNumber) -> Result<Self::Value>
  107|    248|    where
  108|    248|        Self::Error: Display,
  109|    248|    {
  110|    248|        self.map_err(|e| ExecutionError::Syscall(SyscallError(e.to_string(), code)))
  111|    248|    }
_RINvXs1_NtNtCs7Ei498kZF3p_3fvm6kernel5errorINtNtCshM4Il2Z0i4R_4core6result6ResultINtNtCs1slUOa8tBso_3cid3cid3CidKj40_ENtB6_14ExecutionErrorENtB6_7Context7contextReEBa_:
  130|    977|    fn context<D: Display>(self, context: D) -> Self::WithContext {
  131|    977|        self.map_err(|e| e.context(context))
  132|    977|    }

_RNvXs_NtNtCs7Ei498kZF3p_3fvm7machine7defaultINtB4_14DefaultMachineNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs6UoH8pR2orC_21fvm_integration_tests5dummy12DummyExternsENtB6_7Machine11new_limiterCsitTtQF8ArIt_8fvm_fuzz:
  260|    102|    fn new_limiter(&self) -> Self::Limiter {
  261|    102|        ExecResourceLimiter::for_network(&self.context().network)
  262|    102|    }
_RNvMNtNtCs7Ei498kZF3p_3fvm7machine7defaultINtB2_14DefaultMachineNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs6UoH8pR2orC_21fvm_integration_tests5dummy12DummyExternsE3newCsitTtQF8ArIt_8fvm_fuzz:
   63|    102|    pub fn new(context: &MachineContext, blockstore: B, externs: E) -> anyhow::Result<Self> {
   64|    102|        const SUPPORTED_VERSIONS: RangeInclusive<NetworkVersion> =
   65|    102|            NetworkVersion::V18..=NetworkVersion::V18;
   66|    102|
   67|    102|        debug!(
   68|    102|            "initializing a new machine, epoch={}, base_fee={}, nv={:?}, root={}",
   69|    102|            context.epoch, &context.base_fee, context.network_version, context.initial_state_root
   70|       |        );
   71|       |
   72|    102|        if !SUPPORTED_VERSIONS.contains(&context.network_version) {
   73|      0|            return Err(anyhow!(
   74|      0|                "unsupported network version: {}",
   75|      0|                context.network_version
   76|      0|            ));
   77|    102|        }
   78|    102|
   79|    102|        // Sanity check that the blockstore contains the supplied state root.
   80|    102|        if !blockstore
   81|    102|            .has(&context.initial_state_root)
   82|    102|            .context("failed to load initial state-root")?
   83|       |        {
   84|      0|            return Err(anyhow!(
   85|      0|                "blockstore doesn't have the initial state-root {}",
   86|      0|                &context.initial_state_root
   87|      0|            ));
   88|    102|        }
   89|       |
   90|       |        // Create a new state tree from the supplied root.
   91|    102|        let state_tree = {
   92|    102|            let bstore = BufferedBlockstore::new(blockstore);
   93|    102|            StateTree::new_from_root(bstore, &context.initial_state_root)?
   94|       |        };
   95|       |
   96|       |        // Load the built-in actors manifest.
   97|    102|        let (builtin_actors_cid, manifest_version) = match context.builtin_actors_override {
   98|    102|            Some(manifest_cid) => {
   99|    102|                let (version, cid): (u32, Cid) = state_tree
  100|    102|                    .store()
  101|    102|                    .get_cbor(&manifest_cid)?
  102|    102|                    .context("failed to load actor manifest")?;
  103|    102|                (cid, version)
  104|       |            }
  105|       |            None => {
  106|      0|                let (state, _) = SystemActorState::load(&state_tree)?;
  107|      0|                (state.builtin_actors, 1)
  108|       |            }
  109|       |        };
  110|    102|        let builtin_actors =
  111|    102|            Manifest::load(state_tree.store(), &builtin_actors_cid, manifest_version)?;
  112|       |
  113|       |        // 16 bytes is random _enough_
  114|    102|        let randomness: [u8; 16] = rand::random();
  115|    102|
  116|    102|        Ok(DefaultMachine {
  117|    102|            context: context.clone(),
  118|    102|            externs,
  119|    102|            state_tree,
  120|    102|            builtin_actors,
  121|    102|            id: format!(
  122|    102|                "{}-{}",
  123|    102|                context.epoch,
  124|    102|                cid::multibase::encode(cid::multibase::Base::Base32Lower, randomness)
  125|    102|            ),
  126|    102|        })
  127|    102|    }
_RNvXs_NtNtCs7Ei498kZF3p_3fvm7machine7defaultINtB4_14DefaultMachineNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs6UoH8pR2orC_21fvm_integration_tests5dummy12DummyExternsENtB6_7Machine7contextCsitTtQF8ArIt_8fvm_fuzz:
  143|    289|    fn context(&self) -> &MachineContext {
  144|    289|        &self.context
  145|    289|    }

_RNvMNtNtCs7Ei498kZF3p_3fvm7machine7limiterNtB2_19ExecResourceLimiter11for_network:
   43|    102|    pub fn for_network(config: &NetworkConfig) -> Self {
   44|    102|        Self::new(
   45|    102|            config.max_inst_memory_bytes as usize,
   46|    102|            config.max_exec_memory_bytes as usize,
   47|    102|        )
   48|    102|    }
_RNvMNtNtCs7Ei498kZF3p_3fvm7machine7limiterNtB2_19ExecResourceLimiter3new:
   35|    102|    pub fn new(max_inst_memory_bytes: usize, max_exec_memory_bytes: usize) -> Self {
   36|    102|        Self {
   37|    102|            max_inst_memory_bytes,
   38|    102|            max_exec_memory_bytes,
   39|    102|            curr_exec_memory_bytes: 0,
   40|    102|        }
   41|    102|    }

_RINvMNtNtCs7Ei498kZF3p_3fvm7machine8manifestNtB3_8Manifest4loadINtNtNtB7_10blockstore8buffered18BufferedBlockstoreNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreEECsitTtQF8ArIt_8fvm_fuzz:
   73|    102|    pub fn load<B: Blockstore>(bs: &B, root_cid: &Cid, ver: u32) -> anyhow::Result<Manifest> {
   74|    102|        if ver != 1 {
   75|      0|            return Err(anyhow!("unsupported manifest version {}", ver));
   76|    102|        }
   77|       |
   78|    102|        let vec: Vec<(String, Cid)> = match bs.get_cbor(root_cid)? {
   79|    102|            Some(vec) => vec,
   80|       |            None => {
   81|      0|                return Err(anyhow!("cannot find manifest root cid {}", root_cid));
   82|       |            }
   83|       |        };
   84|    102|        Manifest::new(vec)
   85|    102|    }
_RINvMNtNtCs7Ei498kZF3p_3fvm7machine8manifestNtB3_8Manifest3newNtNtCsjYc3JqMxxfa_5alloc6string6StringINtNtB12_3vec3VecTBY_INtNtCs1slUOa8tBso_3cid3cid3CidKj40_EEEECsitTtQF8ArIt_8fvm_fuzz:
   88|    204|    pub fn new(iter: impl IntoIterator<Item = (impl Into<String>, Cid)>) -> anyhow::Result<Self> {
   89|    204|        let mut by_name = HashMap::new();
   90|    204|        let mut by_id = HashMap::new();
   91|    204|        let mut by_code = HashMap::new();
   92|       |
   93|       |        // Actors are indexed sequentially, starting at 1, in the order in which they appear in the
   94|       |        // manifest. 0 is reserved for "everything else" (i.e., not a builtin actor).
   95|  3.06k|        for ((name, code_cid), id) in iter.into_iter().zip(1u32..) {
   96|  3.06k|            let name = name.into();
   97|  3.06k|            by_id.insert(id, code_cid);
   98|  3.06k|            by_code.insert(code_cid, id);
   99|  3.06k|            by_name.insert(name, code_cid);
  100|  3.06k|        }
  101|       |
  102|    204|        let account_code = *by_name
  103|    204|            .get(ACCOUNT_ACTOR_NAME)
  104|    204|            .context("manifest missing account actor")?;
  105|       |
  106|    204|        let system_code = *by_name
  107|    204|            .get(SYSTEM_ACTOR_NAME)
  108|    204|            .context("manifest missing system actor")?;
  109|       |
  110|    204|        let init_code = *by_name
  111|    204|            .get(INIT_ACTOR_NAME)
  112|    204|            .context("manifest missing init actor")?;
  113|       |
  114|    204|        let embryo_code = *by_name
  115|    204|            .get(EMBRYO_ACTOR_NAME)
  116|    204|            .context("manifest missing embryo actor")?;
  117|       |
  118|    204|        let eam_code = *by_name
  119|    204|            .get(EAM_ACTOR_NAME)
  120|    204|            .context("manifest missing eam actor")?;
  121|       |
  122|    204|        let ethaccount_code = *by_name
  123|    204|            .get(ETHACCOUNT_ACTOR_NAME)
  124|    204|            .context("manifest missing ethaccount actor")?;
  125|       |
  126|    204|        Ok(Self {
  127|    204|            account_code,
  128|    204|            system_code,
  129|    204|            init_code,
  130|    204|            embryo_code,
  131|    204|            eam_code,
  132|    204|            ethaccount_code,
  133|    204|            by_id,
  134|    204|            by_code,
  135|    204|        })
  136|    204|    }
_RINvMNtNtCs7Ei498kZF3p_3fvm7machine8manifestNtB3_8Manifest4loadNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreECsitTtQF8ArIt_8fvm_fuzz:
   73|    102|    pub fn load<B: Blockstore>(bs: &B, root_cid: &Cid, ver: u32) -> anyhow::Result<Manifest> {
   74|    102|        if ver != 1 {
   75|      0|            return Err(anyhow!("unsupported manifest version {}", ver));
   76|    102|        }
   77|       |
   78|    102|        let vec: Vec<(String, Cid)> = match bs.get_cbor(root_cid)? {
   79|    102|            Some(vec) => vec,
   80|       |            None => {
   81|      0|                return Err(anyhow!("cannot find manifest root cid {}", root_cid));
   82|       |            }
   83|       |        };
   84|    102|        Manifest::new(vec)
   85|    102|    }
_RNvMNtNtCs7Ei498kZF3p_3fvm7machine8manifestNtB2_8Manifest12get_eam_code:
  183|    102|    pub fn get_eam_code(&self) -> &Cid {
  184|    102|        &self.eam_code
  185|    102|    }
_RNvMNtNtCs7Ei498kZF3p_3fvm7machine8manifestNtB2_8Manifest13get_init_code:
  173|    102|    pub fn get_init_code(&self) -> &Cid {
  174|    102|        &self.init_code
  175|    102|    }
_RNvMNtNtCs7Ei498kZF3p_3fvm7machine8manifestNtB2_8Manifest16get_account_code:
  168|    102|    pub fn get_account_code(&self) -> &Cid {
  169|    102|        &self.account_code
  170|    102|    }
_RNvMNtNtCs7Ei498kZF3p_3fvm7machine8manifestNtB2_8Manifest15get_system_code:
  178|    102|    pub fn get_system_code(&self) -> &Cid {
  179|    102|        &self.system_code
  180|    102|    }
_RNvMNtNtCs7Ei498kZF3p_3fvm7machine8manifestNtB2_8Manifest15get_embryo_code:
  188|    102|    pub fn get_embryo_code(&self) -> &Cid {
  189|    102|        &self.embryo_code
  190|    102|    }

_RNvXs2_NtCs7Ei498kZF3p_3fvm7machineNtB5_14MachineContextNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
  216|    102|#[derive(Clone, Debug, Deref, DerefMut)]
_RNvXs4_NtCs7Ei498kZF3p_3fvm7machineNtB5_14MachineContextNtNtNtCshM4Il2Z0i4R_4core3ops5deref5Deref5deref:
  216|    391|#[derive(Clone, Debug, Deref, DerefMut)]
_RNvXs1_NtCs7Ei498kZF3p_3fvm7machineNtB5_13NetworkConfigNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
  104|    306|#[derive(Debug, Clone)]
_RNvMs_NtCs7Ei498kZF3p_3fvm7machineNtB4_14MachineContext14enable_tracing:
  267|    102|    pub fn enable_tracing(&mut self) -> &mut Self {
  268|    102|        self.tracing = true;
  269|    102|        self
  270|    102|    }
_RNvMNtCs7Ei498kZF3p_3fvm7machineNtB2_13NetworkConfig15override_actors:
  179|    102|    pub fn override_actors(&mut self, manifest: Cid) -> &mut Self {
  180|    102|        self.builtin_actors_override = Some(manifest);
  181|    102|        self
  182|    102|    }
_RNvMNtCs7Ei498kZF3p_3fvm7machineNtB2_13NetworkConfig3new:
  155|    204|    pub fn new(network_version: NetworkVersion) -> Self {
  156|    204|        NetworkConfig {
  157|    204|            chain_id: ChainID::from(0u64),
  158|    204|            network_version,
  159|    204|            max_call_depth: 1024,
  160|    204|            max_wasm_stack: 2048,
  161|    204|            max_inst_memory_bytes: 512 * (1 << 20),
  162|    204|            max_exec_memory_bytes: 2 * (1 << 30),
  163|    204|            actor_debugging: false,
  164|    204|            builtin_actors_override: None,
  165|    204|            price_list: price_list_by_network_version(network_version),
  166|    204|            actor_redirect: vec![],
  167|    204|        }
  168|    204|    }
_RNvMs_NtCs7Ei498kZF3p_3fvm7machineNtB4_14MachineContext12set_base_fee:
  255|    102|    pub fn set_base_fee(&mut self, amt: TokenAmount) -> &mut Self {
  256|    102|        self.base_fee = amt;
  257|    102|        self
  258|    102|    }
_RNvMNtCs7Ei498kZF3p_3fvm7machineNtB2_13NetworkConfig9for_epoch:
  191|    102|    pub fn for_epoch(
  192|    102|        &self,
  193|    102|        epoch: ChainEpoch,
  194|    102|        timestamp: u64,
  195|    102|        initial_state: Cid,
  196|    102|    ) -> MachineContext {
  197|    102|        MachineContext {
  198|    102|            network: self.clone(),
  199|    102|            base_fee: TokenAmount::zero(),
  200|    102|            epoch,
  201|    102|            timestamp,
  202|    102|            initial_state_root: initial_state,
  203|    102|            circ_supply: fvm_shared::TOTAL_FILECOIN.clone(),
  204|    102|            tracing: false,
  205|    102|        }
  206|    102|    }
_RNvMNtCs7Ei498kZF3p_3fvm7machineNtB2_13NetworkConfig22enable_actor_debugging:
  172|    102|    pub fn enable_actor_debugging(&mut self) -> &mut Self {
  173|    102|        self.actor_debugging = true;
  174|    102|        self
  175|    102|    }

_RNvMs_NtCs7Ei498kZF3p_3fvm10state_treeINtB4_9StateTreeNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreE5flushCsitTtQF8ArIt_8fvm_fuzz:
  444|    102|    pub fn flush(&mut self) -> Result<Cid> {
  445|    102|        if self.snaps.layers.len() != 1 {
  446|      0|            return Err(ExecutionError::Fatal(anyhow!(
  447|      0|                "tried to flush state tree with snapshots on the stack: {:?}",
  448|      0|                self.snaps.layers.len()
  449|      0|            )));
  450|    102|        }
  451|       |
  452|    306|        for (&id, sto) in self.snaps.layers[0].actors.borrow().iter() {
  453|    306|            let addr = Address::new_id(id);
  454|    306|            match sto {
  455|       |                None => {
  456|      0|                    self.hamt.delete(&addr.to_bytes()).or_fatal()?;
  457|       |                }
  458|    306|                Some(ref state) => {
  459|    306|                    self.hamt
  460|    306|                        .set(addr.to_bytes().into(), state.clone())
  461|    306|                        .or_fatal()?;
  462|       |                }
  463|       |            }
  464|       |        }
  465|       |
  466|    102|        let root = self.hamt.flush().or_fatal()?;
  467|       |
  468|    102|        match self.version {
  469|      0|            StateTreeVersion::V0 => Ok(root),
  470|       |            _ => {
  471|    102|                let cid = self
  472|    102|                    .info
  473|    102|                    .expect("malformed state tree, version 1+ require info");
  474|    102|                let obj = &StateRoot {
  475|    102|                    version: self.version,
  476|    102|                    actors: root,
  477|    102|                    info: cid,
  478|    102|                };
  479|    102|                let root = self
  480|    102|                    .store()
  481|    102|                    .put_cbor(obj, multihash::Code::Blake2b256)
  482|    102|                    .or_fatal()?;
  483|    102|                Ok(root)
  484|       |            }
  485|       |        }
  486|    102|    }
_RINvXs9_NtCs7Ei498kZF3p_3fvm10state_treeNtB6_10ActorStateNtNtCslVZeVZySzLE_5serde3ser9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
  510|    306|#[derive(PartialEq, Eq, Clone, Debug, Serialize_tuple, Deserialize_tuple)]
_RNvMs_NtCs7Ei498kZF3p_3fvm10state_treeINtB4_9StateTreeNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreE5storeCsitTtQF8ArIt_8fvm_fuzz:
  303|    408|    pub fn store(&self) -> &S {
  304|    408|        self.hamt.store()
  305|    408|    }
_RNvMs_NtCs7Ei498kZF3p_3fvm10state_treeINtB4_9StateTreeNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreE9set_actorCsitTtQF8ArIt_8fvm_fuzz:
  344|    306|    pub fn set_actor(&mut self, id: ActorID, actor: ActorState) -> Result<()> {
  345|    306|        self.snaps.set_actor(id, actor)
  346|    306|    }
_RNvMs_NtCs7Ei498kZF3p_3fvm10state_treeINtB4_9StateTreeINtNtNtB6_10blockstore8buffered18BufferedBlockstoreNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreEE5storeCsitTtQF8ArIt_8fvm_fuzz:
  303|    204|    pub fn store(&self) -> &S {
  304|    204|        self.hamt.store()
  305|    204|    }
_RINvXNvNvXs9_NtCs7Ei498kZF3p_3fvm10state_treeNtBb_10ActorStateNtNtCslVZeVZySzLE_5serde3ser9Serialize9serialize1__NtB5_5InnerBY_9serializeINtCs872nzRHi4k9_11serde_tuple10SerializerQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEEECsitTtQF8ArIt_8fvm_fuzz:
  510|    306|#[derive(PartialEq, Eq, Clone, Debug, Serialize_tuple, Deserialize_tuple)]
_RINvXNvXNvNvXsa_NtCs7Ei498kZF3p_3fvm10state_treeNtBe_10ActorStateNtNtCslVZeVZySzLE_5serde2de11Deserialize11deserialize1__NtB8_5InnerB11_11deserializeNtB3_9___VisitorNtB13_7Visitor9visit_seqQNtNtNtCsalhrieD8kwf_12libipld_core5serde2de15SeqDeserializerECsitTtQF8ArIt_8fvm_fuzz:
  510|    306|#[derive(PartialEq, Eq, Clone, Debug, Serialize_tuple, Deserialize_tuple)]
_RINvXsa_NtCs7Ei498kZF3p_3fvm10state_treeNtB6_10ActorStateNtNtCslVZeVZySzLE_5serde2de11Deserialize11deserializeNtNtCsalhrieD8kwf_12libipld_core4ipld4IpldECsitTtQF8ArIt_8fvm_fuzz:
  510|    306|#[derive(PartialEq, Eq, Clone, Debug, Serialize_tuple, Deserialize_tuple)]
_RNvMs_NtCs7Ei498kZF3p_3fvm10state_treeINtB4_9StateTreeNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreE10into_storeCsitTtQF8ArIt_8fvm_fuzz:
  489|    102|    pub fn into_store(self) -> S {
  490|    102|        self.hamt.into_store()
  491|    102|    }
_RNvMNtCs7Ei498kZF3p_3fvm10state_treeNtB2_14StateSnapshots12is_read_only:
  152|    306|    fn is_read_only(&self) -> bool {
  153|    306|        self.read_only_layers > 0
  154|    306|    }
_RNvMs_NtCs7Ei498kZF3p_3fvm10state_treeINtB4_9StateTreeINtNtNtB6_10blockstore8buffered18BufferedBlockstoreNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreEE13new_from_rootCsitTtQF8ArIt_8fvm_fuzz:
  254|    102|    pub fn new_from_root(store: S, c: &Cid) -> Result<Self> {
  255|       |        // Try to load state root, if versioned
  256|    102|        let (version, info, actors) = match store.get_cbor(c) {
  257|       |            Ok(Some(StateRoot {
  258|    102|                version,
  259|    102|                info,
  260|    102|                actors,
  261|    102|            })) => (version, Some(info), actors),
  262|       |            Ok(None) => {
  263|      0|                return Err(ExecutionError::Fatal(anyhow!(
  264|      0|                    "failed to find state tree {}",
  265|      0|                    c
  266|      0|                )))
  267|       |            }
  268|      0|            Err(e) => {
  269|      0|                return Err(ExecutionError::Fatal(anyhow!(
  270|      0|                    "failed to load state tree {}: {}",
  271|      0|                    c,
  272|      0|                    e
  273|      0|                )))
  274|       |            }
  275|       |        };
  276|       |
  277|    102|        match version {
  278|       |            StateTreeVersion::V0
  279|       |            | StateTreeVersion::V1
  280|       |            | StateTreeVersion::V2
  281|       |            | StateTreeVersion::V3
  282|      0|            | StateTreeVersion::V4 => Err(ExecutionError::Fatal(anyhow!(
  283|      0|                "unsupported state tree version: {:?}",
  284|      0|                version
  285|      0|            ))),
  286|       |
  287|       |            StateTreeVersion::V5 => {
  288|    102|                let hamt = Hamt::load_with_bit_width(&actors, store, HAMT_BIT_WIDTH)
  289|    102|                    .context("failed to load state tree")
  290|    102|                    .or_fatal()?;
  291|       |
  292|    102|                Ok(Self {
  293|    102|                    hamt,
  294|    102|                    version,
  295|    102|                    info,
  296|    102|                    snaps: StateSnapshots::new(),
  297|    102|                })
  298|       |            }
  299|       |        }
  300|    102|    }
_RNvXs7_NtCs7Ei498kZF3p_3fvm10state_treeNtB5_10ActorStateNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
  510|    306|#[derive(PartialEq, Eq, Clone, Debug, Serialize_tuple, Deserialize_tuple)]
_RINvXNvNvXsa_NtCs7Ei498kZF3p_3fvm10state_treeNtBb_10ActorStateNtNtCslVZeVZySzLE_5serde2de11Deserialize11deserialize1__NtB5_5InnerBY_11deserializeINtCs872nzRHi4k9_11serde_tuple12DeserializerNtNtCsalhrieD8kwf_12libipld_core4ipld4IpldEECsitTtQF8ArIt_8fvm_fuzz:
  510|    306|#[derive(PartialEq, Eq, Clone, Debug, Serialize_tuple, Deserialize_tuple)]
_RNvMs_NtCs7Ei498kZF3p_3fvm10state_treeINtB4_9StateTreeNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreE3newCsitTtQF8ArIt_8fvm_fuzz:
  222|    102|    pub fn new(store: S, version: StateTreeVersion) -> Result<Self> {
  223|    102|        let info = match version {
  224|       |            StateTreeVersion::V0
  225|       |            | StateTreeVersion::V1
  226|       |            | StateTreeVersion::V2
  227|       |            | StateTreeVersion::V3
  228|       |            | StateTreeVersion::V4 => {
  229|      0|                return Err(ExecutionError::Fatal(anyhow!(
  230|      0|                    "unsupported state tree version: {:?}",
  231|      0|                    version
  232|      0|                )))
  233|       |            }
  234|       |            StateTreeVersion::V5 => {
  235|    102|                let cid = store
  236|    102|                    .put_cbor(&StateInfo0::default(), multihash::Code::Blake2b256)
  237|    102|                    .context("failed to put state info")
  238|    102|                    .or_fatal()?;
  239|    102|                Some(cid)
  240|    102|            }
  241|    102|        };
  242|    102|
  243|    102|        // Both V3 and V4 use bitwidt=5.
  244|    102|        let hamt = Hamt::new_with_bit_width(store, HAMT_BIT_WIDTH);
  245|    102|        Ok(Self {
  246|    102|            hamt,
  247|    102|            version,
  248|    102|            info,
  249|    102|            snaps: StateSnapshots::new(),
  250|    102|        })
  251|    102|    }
_RNvMNtCs7Ei498kZF3p_3fvm10state_treeNtB2_14StateSnapshots15assert_writable:
  156|    306|    fn assert_writable(&self) -> Result<()> {
  157|    306|        if self.is_read_only() {
  158|      0|            Err(syscall_error!(ReadOnly; "cannot mutate state while in read-only mode").into())
  159|       |        } else {
  160|    306|            Ok(())
  161|       |        }
  162|    306|    }
_RNvMNtCs7Ei498kZF3p_3fvm10state_treeNtB2_14StateSnapshots9top_layer:
  144|    306|    fn top_layer(&self) -> Result<&StateSnapLayer> {
  145|    306|        self.layers
  146|    306|            .last()
  147|    306|            .context("state snapshots empty")
  148|    306|            .or_fatal()
  149|    306|    }
_RNvMNtCs7Ei498kZF3p_3fvm10state_treeNtB2_14StateSnapshots3new:
   65|    204|    fn new() -> Self {
   66|    204|        Self {
   67|    204|            layers: vec![StateSnapLayer::default()],
   68|    204|            read_only_layers: 0,
   69|    204|        }
   70|    204|    }
_RNvXs2_NtCs7Ei498kZF3p_3fvm10state_treeNtB5_14StateSnapLayerNtNtCshM4Il2Z0i4R_4core7default7Default7default:
   50|    204|#[derive(Debug, Default)]
_RNvMNtCs7Ei498kZF3p_3fvm10state_treeNtB2_14StateSnapshots9set_actor:
  200|    306|        self.assert_writable()?;
  201|       |
  202|    306|        self.top_layer()?
  203|       |            .actors
  204|    306|            .borrow_mut()
  205|    306|            .insert(id, Some(actor));
  206|    306|        Ok(())
  207|    306|    }

_RNCINvMs0_NtNtCs7Ei498kZF3p_3fvm8syscalls7contextNtB8_6Memory9read_cborINtNtCsjYc3JqMxxfa_5alloc3vec3VecNtNtCs4pVfV2XJudO_10fvm_shared5piece9PieceInfoEE0CsitTtQF8ArIt_8fvm_fuzz:
  112|  31.7k|        match panic::catch_unwind(|| from_slice(bytes).or_error(ErrorNumber::IllegalArgument)) {
_RINvMs0_NtNtCs7Ei498kZF3p_3fvm8syscalls7contextNtB6_6Memory9read_cborINtNtCsjYc3JqMxxfa_5alloc3vec3VecNtNtCs4pVfV2XJudO_10fvm_shared5piece9PieceInfoEECsitTtQF8ArIt_8fvm_fuzz:
  109|  31.7k|    pub fn read_cbor<T: Cbor>(&self, offset: u32, len: u32) -> Result<T> {
  110|  31.7k|        let bytes = self.try_slice(offset, len)?;
  111|       |        // Catch panics when decoding cbor from actors, _just_ in case.
  112|  31.7k|        match panic::catch_unwind(|| from_slice(bytes).or_error(ErrorNumber::IllegalArgument)) {
  113|  31.7k|            Ok(v) => v,
  114|      0|            Err(e) => {
  115|      0|                log::error!("panic when decoding cbor from actor: {:?}", e);
  116|      0|                Err(syscall_error!(IllegalArgument; "panic when decoding cbor from actor").into())
  117|       |            }
  118|       |        }
  119|  31.7k|    }
_RNvMs0_NtNtCs7Ei498kZF3p_3fvm8syscalls7contextNtB5_6Memory3new:
   40|    102|    pub fn new<'a>(m: &'a mut [u8]) -> &'a mut Memory {
   41|    102|        // We explicitly specify the lifetimes here to ensure that the cast doesn't inadvertently
   42|    102|        // change them.
   43|    102|        unsafe { &mut *(m as *mut [u8] as *mut Memory) }
   44|    102|    }
_RNvXNtNtCs7Ei498kZF3p_3fvm8syscalls7contextNtB2_6MemoryNtNtNtCshM4Il2Z0i4R_4core3ops5deref5Deref5deref:
   27|  31.9k|    fn deref(&self) -> &Self::Target {
   28|  31.9k|        &self.0
   29|  31.9k|    }
_RNCNvMs0_NtNtCs7Ei498kZF3p_3fvm8syscalls7contextNtB7_6Memory13try_slice_mut0Bb_:
   65|    243|            .and_then(|data| data.get_mut(..len as usize))
_RNCNvMs0_NtNtCs7Ei498kZF3p_3fvm8syscalls7contextNtB7_6Memory8read_cid0Bb_:
   82|     83|                .ok_or_else(|| format!("cid at offset {} is out of bounds", offset))
_RNvXs_NtNtCs7Ei498kZF3p_3fvm8syscalls7contextNtB4_6MemoryNtNtNtCshM4Il2Z0i4R_4core3ops5deref8DerefMut9deref_mut:
   33|    248|    fn deref_mut(&mut self) -> &mut Self::Target {
   34|    248|        &mut self.0
   35|    248|    }
_RNvMs0_NtNtCs7Ei498kZF3p_3fvm8syscalls7contextNtB5_6Memory8read_cid:
   70|  1.06k|    pub fn read_cid(&self, offset: u32) -> Result<Cid> {
   71|  1.06k|        // NOTE: Be very careful when changing this code.
   72|  1.06k|        //
   73|  1.06k|        // We intentionally read the CID till the end of memory. We intentionally do not "slice"
   74|  1.06k|        // with a fixed end.
   75|  1.06k|        // - We _can't_ slice MAX_CID_LEN because there may not be MAX_CID_LEN addressable memory
   76|  1.06k|        //   after the offset.
   77|  1.06k|        // - We can safely read from an "arbitrary" sized slice because `Cid::read_bytes` will never
   78|  1.06k|        //   read more than 4 u64 varints and 64 bytes of digest.
   79|  1.06k|        Cid::read_bytes(
   80|  1.06k|            self.0
   81|  1.06k|                .get(offset as usize..)
   82|  1.06k|                .ok_or_else(|| format!("cid at offset {} is out of bounds", offset))
   83|  1.06k|                .or_error(ErrorNumber::IllegalArgument)?,
   84|       |        )
   85|    977|        .or_error(ErrorNumber::IllegalArgument)
   86|    977|        .context("failed to parse cid")
   87|  1.06k|    }
_RNCNvMs0_NtNtCs7Ei498kZF3p_3fvm8syscalls7contextNtB7_6Memory9try_slices_0Bb_:
   60|      4|            .ok_or_else(|| format!("buffer {} (length {}) out of bounds", offset, len))
_RNCNvMs0_NtNtCs7Ei498kZF3p_3fvm8syscalls7contextNtB7_6Memory9try_slice0Bb_:
   59|  31.8k|            .and_then(|data| data.get(..len as usize))
_RNCNvMs0_NtNtCs7Ei498kZF3p_3fvm8syscalls7contextNtB7_6Memory13try_slice_muts_0Bb_:
   66|      5|            .ok_or_else(|| format!("buffer {} (length {}) out of bounds", offset, len))
_RNvMs0_NtNtCs7Ei498kZF3p_3fvm8syscalls7contextNtB5_6Memory9try_slice:
   57|  31.8k|    pub fn try_slice(&self, offset: u32, len: u32) -> Result<&[u8]> {
   58|  31.8k|        self.get(offset as usize..)
   59|  31.8k|            .and_then(|data| data.get(..len as usize))
   60|  31.8k|            .ok_or_else(|| format!("buffer {} (length {}) out of bounds", offset, len))
   61|  31.8k|            .or_error(ErrorNumber::IllegalArgument)
   62|  31.8k|    }
_RNvMs0_NtNtCs7Ei498kZF3p_3fvm8syscalls7contextNtB5_6Memory13try_slice_mut:
   63|    248|    pub fn try_slice_mut(&mut self, offset: u32, len: u32) -> Result<&mut [u8]> {
   64|    248|        self.get_mut(offset as usize..)
   65|    248|            .and_then(|data| data.get_mut(..len as usize))
   66|    248|            .ok_or_else(|| format!("buffer {} (length {}) out of bounds", offset, len))
   67|    248|            .or_error(ErrorNumber::IllegalArgument)
   68|    248|    }

_RINvNtNtCs7Ei498kZF3p_3fvm8syscalls6crypto27compute_unsealed_sector_cidINtNtNtB6_6kernel7default13DefaultKernelINtNtNtB6_12call_manager7default18DefaultCallManagerINtNtNtB6_7machine7default14DefaultMachineNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs6UoH8pR2orC_21fvm_integration_tests5dummy12DummyExternsEEEECsitTtQF8ArIt_8fvm_fuzz:
  114|  31.7k|pub fn compute_unsealed_sector_cid(
  115|  31.7k|    context: Context<'_, impl Kernel>,
  116|  31.7k|    proof_type: i64, // RegisteredSealProof,
  117|  31.7k|    pieces_off: u32, // [PieceInfo]
  118|  31.7k|    pieces_len: u32,
  119|  31.7k|    cid_off: u32,
  120|  31.7k|    cid_len: u32,
  121|  31.7k|) -> Result<u32> {
  122|  31.7k|    // Check/read all arguments.
  123|  31.7k|    #[cfg(feature = "instrument-syscalls")]
  124|  31.7k|    unsafe { set_syscall_probe("syscall.crypto.compute_unsealed_sector_cid") };
  125|  31.7k|    let typ = RegisteredSealProof::from(proof_type);
  126|  31.7k|    if let RegisteredSealProof::Invalid(invalid) = typ {
  127|      0|        return Err(syscall_error!(IllegalArgument; "invalid proof type {}", invalid).into());
  128|  31.7k|    }
  129|  31.7k|    let pieces: Vec<PieceInfo> = context.memory.read_cbor(pieces_off, pieces_len)?;
  130|      0|    context.memory.check_bounds(cid_off, cid_len)?;
  131|       |
  132|       |    // Compute
  133|      0|    let cid = context
  134|      0|        .kernel
  135|      0|        .compute_unsealed_sector_cid(typ, pieces.as_slice())?;
  136|       |
  137|       |    // REturn
  138|      0|    context.memory.write_cid(&cid, cid_off, cid_len)
  139|  31.7k|}

_RINvNtNtCs7Ei498kZF3p_3fvm8syscalls4ipld10block_statINtNtNtB6_6kernel7default13DefaultKernelINtNtNtB6_12call_manager7default18DefaultCallManagerINtNtNtB6_7machine7default14DefaultMachineNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs6UoH8pR2orC_21fvm_integration_tests5dummy12DummyExternsEEEECsitTtQF8ArIt_8fvm_fuzz:
   72|      1|pub fn block_stat(context: Context<'_, impl Kernel>, id: u32) -> Result<sys::out::ipld::IpldStat> {
   73|      1|    #[cfg(feature = "instrument-syscalls")]
   74|      1|    unsafe { set_syscall_probe("syscall.ipld.block_stat") };
   75|      1|    context
   76|      1|        .kernel
   77|      1|        .block_stat(id)
   78|      1|        .map(|stat| sys::out::ipld::IpldStat {
   79|       |            codec: stat.codec,
   80|       |            size: stat.size,
   81|      1|        })
   82|      1|}
_RINvNtNtCs7Ei498kZF3p_3fvm8syscalls4ipld12block_createINtNtNtB6_6kernel7default13DefaultKernelINtNtNtB6_12call_manager7default18DefaultCallManagerINtNtNtB6_7machine7default14DefaultMachineNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs6UoH8pR2orC_21fvm_integration_tests5dummy12DummyExternsEEEECsitTtQF8ArIt_8fvm_fuzz:
   27|     88|pub fn block_create(
   28|     88|    context: Context<'_, impl Kernel>,
   29|     88|    codec: u64,
   30|     88|    data_off: u32,
   31|     88|    data_len: u32,
   32|     88|) -> Result<u32> {
   33|       |    #[cfg(feature = "instrument-syscalls")]
   34|       |    unsafe { set_syscall_probe("syscall.ipld.block_create") };
   35|     88|    let data = context.memory.try_slice(data_off, data_len)?;
   36|     84|    context.kernel.block_create(codec, data)
   37|     88|}
_RINvNtNtCs7Ei498kZF3p_3fvm8syscalls4ipld10block_readINtNtNtB6_6kernel7default13DefaultKernelINtNtNtB6_12call_manager7default18DefaultCallManagerINtNtNtB6_7machine7default14DefaultMachineNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs6UoH8pR2orC_21fvm_integration_tests5dummy12DummyExternsEEEECsitTtQF8ArIt_8fvm_fuzz:
   59|    248|pub fn block_read(
   60|    248|    context: Context<'_, impl Kernel>,
   61|    248|    id: u32,
   62|    248|    offset: u32,
   63|    248|    obuf_off: u32,
   64|    248|    obuf_len: u32,
   65|    248|) -> Result<i32> {
   66|       |    #[cfg(feature = "instrument-syscalls")]
   67|       |    unsafe { set_syscall_probe("syscall.ipld.block_read") };
   68|    248|    let data = context.memory.try_slice_mut(obuf_off, obuf_len)?;
   69|    243|    context.kernel.block_read(id, offset, data)
   70|    248|}

_RINvNtNtCs7Ei498kZF3p_3fvm8syscalls5sself8set_rootINtNtNtB6_6kernel7default13DefaultKernelINtNtNtB6_12call_manager7default18DefaultCallManagerINtNtNtB6_7machine7default14DefaultMachineNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs6UoH8pR2orC_21fvm_integration_tests5dummy12DummyExternsEEEECsitTtQF8ArIt_8fvm_fuzz:
   30|  1.06k|pub fn set_root(context: Context<'_, impl Kernel>, cid_off: u32) -> Result<()> {
   31|       |    #[cfg(feature = "instrument-syscalls")]
   32|       |    unsafe { set_syscall_probe("syscall.self.set_root") };
   33|  1.06k|    let cid = context.memory.read_cid(cid_off)?;
   34|      0|    context.kernel.set_root(cid)?;
   35|      0|    Ok(())
   36|  1.06k|}

_RINvXs2_NtCs7Ei498kZF3p_3fvm12system_actorNtB6_5StateNtNtCslVZeVZySzLE_5serde3ser9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
   15|    102|#[derive(Default, Deserialize_tuple, Serialize_tuple)]
_RINvXNvNvXs2_NtCs7Ei498kZF3p_3fvm12system_actorNtBb_5StateNtNtCslVZeVZySzLE_5serde3ser9Serialize9serialize1__NtB5_5InnerBU_9serializeINtCs872nzRHi4k9_11serde_tuple10SerializerQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEEECsitTtQF8ArIt_8fvm_fuzz:
   15|    102|#[derive(Default, Deserialize_tuple, Serialize_tuple)]

_RNvMNtCs6SqvG5Yde5c_19fvm_ipld_blockstore5blockINtB2_5BlockRINtNtCsjYc3JqMxxfa_5alloc3vec3VechEE3cidCsitTtQF8ArIt_8fvm_fuzz:
   28|    714|    pub fn cid(&self, mh_code: multihash::Code) -> Cid {
   29|    714|        Cid::new_v1(self.codec, mh_code.digest(self.data.as_ref()))
   30|    714|    }
_RNvXs_NtCs6SqvG5Yde5c_19fvm_ipld_blockstore5blockINtB4_5BlockRINtNtCsjYc3JqMxxfa_5alloc3vec3VechEEINtNtCshM4Il2Z0i4R_4core7convert5AsRefShE6as_refCsitTtQF8ArIt_8fvm_fuzz:
   42|    714|    fn as_ref(&self) -> &[u8] {
   43|    714|        self.data.as_ref()
   44|    714|    }

_RINvXCs6SqvG5Yde5c_19fvm_ipld_blockstoreRRNtNtB3_6memory16MemoryBlockstoreNtB3_10Blockstore3putRINtNtCsjYc3JqMxxfa_5alloc3vec3VechEECsitTtQF8ArIt_8fvm_fuzz:
  106|    102|    fn put<D>(&self, mh_code: multihash::Code, block: &Block<D>) -> Result<Cid>
  107|    102|    where
  108|    102|        Self: Sized,
  109|    102|        D: AsRef<[u8]>,
  110|    102|    {
  111|    102|        (*self).put(mh_code, block)
  112|    102|    }
_RINvYNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtB7_10Blockstore14put_many_keyedRINtNtCsjYc3JqMxxfa_5alloc3vec3VechEINtNtNtNtCshM4Il2Z0i4R_4core4iter8adapters3map3MapINtNtNtB2l_5slice4iter4IterTINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EB1D_EENCNCINvCsFqKNUWW8VZ_12fvm_ipld_car14load_car_innerRShB3_E0s0_0EECsitTtQF8ArIt_8fvm_fuzz:
   73|    102|    fn put_many_keyed<D, I>(&self, blocks: I) -> Result<()>
   74|    102|    where
   75|    102|        Self: Sized,
   76|    102|        D: AsRef<[u8]>,
   77|    102|        I: IntoIterator<Item = (Cid, D)>,
   78|    102|    {
   79|  1.83k|        for (c, b) in blocks {
   80|  1.73k|            self.put_keyed(&c, b.as_ref())?
   81|       |        }
   82|    102|        Ok(())
   83|    102|    }
_RINvYNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtB7_10Blockstore3putRINtNtCsjYc3JqMxxfa_5alloc3vec3VechEECsitTtQF8ArIt_8fvm_fuzz:
   39|    714|    fn put<D>(&self, mh_code: multihash::Code, block: &Block<D>) -> Result<Cid>
   40|    714|    where
   41|    714|        Self: Sized,
   42|    714|        D: AsRef<[u8]>,
   43|    714|    {
   44|    714|        let k = block.cid(mh_code);
   45|    714|        self.put_keyed(&k, block.as_ref())?;
   46|    714|        Ok(k)
   47|    714|    }
_RINvXCs6SqvG5Yde5c_19fvm_ipld_blockstoreRNtNtB3_6memory16MemoryBlockstoreNtB3_10Blockstore3putRINtNtCsjYc3JqMxxfa_5alloc3vec3VechEECsitTtQF8ArIt_8fvm_fuzz:
  106|    102|    fn put<D>(&self, mh_code: multihash::Code, block: &Block<D>) -> Result<Cid>
  107|    102|    where
  108|    102|        Self: Sized,
  109|    102|        D: AsRef<[u8]>,
  110|    102|    {
  111|    102|        (*self).put(mh_code, block)
  112|    102|    }

_RNvXs1_NtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memoryNtB5_16MemoryBlockstoreNtNtCshM4Il2Z0i4R_4core7default7Default7default:
   11|    102|#[derive(Debug, Default, Clone)]
_RNvXs_NtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memoryNtB4_16MemoryBlockstoreNtB6_10Blockstore3get:
   27|    612|    fn get(&self, k: &Cid) -> Result<Option<Vec<u8>>> {
   28|    612|        Ok(self.blocks.borrow().get(k).cloned())
   29|    612|    }
_RNvXs_NtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memoryNtB4_16MemoryBlockstoreNtB6_10Blockstore9put_keyed:
   31|  2.44k|    fn put_keyed(&self, k: &Cid, block: &[u8]) -> Result<()> {
   32|  2.44k|        self.blocks.borrow_mut().insert(*k, block.into());
   33|  2.44k|        Ok(())
   34|  2.44k|    }
_RNvXs_NtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memoryNtB4_16MemoryBlockstoreNtB6_10Blockstore3has:
   23|    102|    fn has(&self, k: &Cid) -> Result<bool> {
   24|    102|        Ok(self.blocks.borrow().contains_key(k))
   25|    102|    }

_RINvCsFqKNUWW8VZ_12fvm_ipld_car18load_car_uncheckedRShNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreECsitTtQF8ArIt_8fvm_fuzz:
  148|    102|pub async fn load_car_unchecked<R, B>(s: &B, reader: R) -> Result<Vec<Cid>, Error>
  149|    102|where
  150|    102|    B: Blockstore,
  151|    102|    R: AsyncRead + Send + Unpin,
  152|    102|{
_RNCNvMs0_CsFqKNUWW8VZ_12fvm_ipld_carINtB7_9CarReaderRShE13new_unchecked0CsitTtQF8ArIt_8fvm_fuzz:
   92|    102|        let mut reader = Self::new(reader).await?;
   93|    102|        reader.validate = false;
   94|    102|        Ok(reader)
   95|    102|    }
_RINvXNvCsFqKNUWW8VZ_12fvm_ipld_cars_1__NtB5_9CarHeaderNtNtCslVZeVZySzLE_5serde2de11Deserialize11deserializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
   19|    102|#[derive(Debug, Default, Serialize, Deserialize, PartialEq, Eq)]
_RNvMs0_CsFqKNUWW8VZ_12fvm_ipld_carINtB5_9CarReaderRShE10next_blockCsitTtQF8ArIt_8fvm_fuzz:
   98|  1.83k|    pub async fn next_block(&mut self) -> Result<Option<Block>, Error> {
_RNCNCINvCsFqKNUWW8VZ_12fvm_ipld_car14load_car_innerRShNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreE0s0_0CsitTtQF8ArIt_8fvm_fuzz:
  178|  1.73k|    s.put_many_keyed(buf.iter().map(|(k, v)| (*k, v)))
_RINvXNvXNvCsFqKNUWW8VZ_12fvm_ipld_cars_1__NtB8_9CarHeaderNtNtCslVZeVZySzLE_5serde2de11Deserialize11deserializeNtB3_14___FieldVisitorNtBV_7Visitor9visit_strINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor5error11DecodeErrorNtNtCshM4Il2Z0i4R_4core7convert10InfallibleEECsitTtQF8ArIt_8fvm_fuzz:
   19|    204|#[derive(Debug, Default, Serialize, Deserialize, PartialEq, Eq)]
_RNvMs0_CsFqKNUWW8VZ_12fvm_ipld_carINtB5_9CarReaderRShE3newCsitTtQF8ArIt_8fvm_fuzz:
   72|    102|    pub async fn new(mut reader: R) -> Result<Self, Error> {
_RINvXs_NvXNvCsFqKNUWW8VZ_12fvm_ipld_cars_1__NtBa_9CarHeaderNtNtCslVZeVZySzLE_5serde2de11Deserialize11deserializeNtB5_7___FieldBV_11deserializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
   19|    204|#[derive(Debug, Default, Serialize, Deserialize, PartialEq, Eq)]
_RNCNvMs0_CsFqKNUWW8VZ_12fvm_ipld_carINtB7_9CarReaderRShE10next_block0CsitTtQF8ArIt_8fvm_fuzz:
  101|  1.83k|        if let Some((cid, data)) = read_node(&mut self.reader).await? {
  102|  1.73k|            if self.validate {
  103|      0|                match cid.hash().code() {
  104|       |                    0x0 => {
  105|      0|                        if cid.hash().digest() != data {
  106|      0|                            return Err(Error::InvalidFile(
  107|      0|                                "CAR has an identity CID that doesn't match the corresponding data"
  108|      0|                                    .into(),
  109|      0|                            ));
  110|      0|                        }
  111|       |                    }
  112|      0|                    code => {
  113|      0|                        let code = multihash::Code::try_from(code)?;
  114|      0|                        let actual = Cid::new_v1(cid.codec(), code.digest(&data));
  115|      0|                        if actual != cid {
  116|      0|                            return Err(Error::InvalidFile(format!(
  117|      0|                                "CAR has an incorrect CID: expected {}, found {}",
  118|      0|                                cid, actual,
  119|      0|                            )));
  120|      0|                        }
  121|       |                    }
  122|       |                }
  123|  1.73k|            }
  124|  1.73k|            Ok(Some(Block { cid, data }))
  125|       |        } else {
  126|    102|            Ok(None)
  127|       |        }
  128|  1.83k|    }
_RNCINvCsFqKNUWW8VZ_12fvm_ipld_car18load_car_uncheckedRShNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreE0CsitTtQF8ArIt_8fvm_fuzz:
  153|    102|    load_car_inner(s, reader, false).await
  154|    102|}
_RINvCsFqKNUWW8VZ_12fvm_ipld_car14load_car_innerRShNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreECsitTtQF8ArIt_8fvm_fuzz:
  156|    102|async fn load_car_inner<R, B>(s: &B, reader: R, verify: bool) -> Result<Vec<Cid>, Error>
  157|    102|where
  158|    102|    B: Blockstore,
  159|    102|    R: AsyncRead + Send + Unpin,
  160|    102|{
_RNvMs0_CsFqKNUWW8VZ_12fvm_ipld_carINtB5_9CarReaderRShE13new_uncheckedCsitTtQF8ArIt_8fvm_fuzz:
   91|    102|    pub async fn new_unchecked(reader: R) -> Result<Self, Error> {
_RNCNvMs0_CsFqKNUWW8VZ_12fvm_ipld_carINtB7_9CarReaderRShE3new0CsitTtQF8ArIt_8fvm_fuzz:
   73|    102|        let buf = ld_read(&mut reader)
   74|      0|            .await?
   75|    102|            .ok_or_else(|| Error::ParsingError("failed to parse uvarint for header".to_string()))?;
   76|    102|        let header: CarHeader = from_slice(&buf).map_err(|e| Error::ParsingError(e.to_string()))?;
   77|    102|        if header.roots.is_empty() {
   78|      0|            return Err(Error::ParsingError("empty CAR file".to_owned()));
   79|    102|        }
   80|    102|        if header.version != 1 {
   81|      0|            return Err(Error::InvalidFile("CAR file version must be 1".to_owned()));
   82|    102|        }
   83|    102|        Ok(CarReader {
   84|    102|            reader,
   85|    102|            header,
   86|    102|            validate: true,
   87|    102|        })
   88|    102|    }
_RNCINvCsFqKNUWW8VZ_12fvm_ipld_car14load_car_innerRShNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreE0CsitTtQF8ArIt_8fvm_fuzz:
  161|    102|    let mut car_reader = if verify {
  162|      0|        CarReader::new(reader).await
  163|       |    } else {
  164|    102|        CarReader::new_unchecked(reader).await
  165|      0|    }?;
  166|       |
  167|       |    // Batch write key value pairs from car file
  168|       |    // TODO: Stream the data once some of the stream APIs stabilize.
  169|    102|    let mut buf = Vec::with_capacity(100);
  170|  1.83k|    while let Some(block) = car_reader.next_block().await? {
  171|  1.73k|        buf.push((block.cid, block.data));
  172|  1.73k|        if buf.len() > 1000 {
  173|      0|            s.put_many_keyed(buf.iter().map(|(k, v)| (*k, v)))
  174|      0|                .map_err(|e| Error::Other(e.to_string()))?;
  175|      0|            buf.clear();
  176|  1.73k|        }
  177|       |    }
  178|    102|    s.put_many_keyed(buf.iter().map(|(k, v)| (*k, v)))
  179|    102|        .map_err(|e| Error::Other(e.to_string()))?;
  180|    102|    Ok(car_reader.header.roots)
  181|    102|}
_RINvXs0_NvXNvCsFqKNUWW8VZ_12fvm_ipld_cars_1__NtBb_9CarHeaderNtNtCslVZeVZySzLE_5serde2de11Deserialize11deserializeNtB6_9___VisitorNtBY_7Visitor9visit_mapINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de8AccessorNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
   19|    306|#[derive(Debug, Default, Serialize, Deserialize, PartialEq, Eq)]

_RINvNtCsFqKNUWW8VZ_12fvm_ipld_car4util9read_nodeRShECsitTtQF8ArIt_8fvm_fuzz:
   53|  1.83k|pub(crate) async fn read_node<R>(buf_reader: &mut R) -> Result<Option<(Cid, Vec<u8>)>, Error>
   54|  1.83k|where
   55|  1.83k|    R: AsyncRead + Send + Unpin,
   56|  1.83k|{
_RNCINvNtCsFqKNUWW8VZ_12fvm_ipld_car4util9read_nodeRShE0CsitTtQF8ArIt_8fvm_fuzz:
   57|  1.83k|    match ld_read(buf_reader).await? {
   58|  1.73k|        Some(buf) => {
   59|  1.73k|            let mut cursor = std::io::Cursor::new(&buf);
   60|  1.73k|            let cid = Cid::read_bytes(&mut cursor)?;
   61|  1.73k|            Ok(Some((cid, buf[cursor.position() as usize..].to_vec())))
   62|       |        }
   63|    102|        None => Ok(None),
   64|       |    }
   65|  1.83k|}
_RINvNtCsFqKNUWW8VZ_12fvm_ipld_car4util7ld_readRShECsitTtQF8ArIt_8fvm_fuzz:
   11|  1.93k|pub(crate) async fn ld_read<R>(mut reader: &mut R) -> Result<Option<Vec<u8>>, Error>
   12|  1.93k|where
   13|  1.93k|    R: AsyncRead + Send + Unpin,
   14|  1.93k|{
_RNCINvNtCsFqKNUWW8VZ_12fvm_ipld_car4util7ld_readRShE0CsitTtQF8ArIt_8fvm_fuzz:
   16|  1.93k|    let l: usize = match VarIntAsyncReader::read_varint_async(&mut reader).await {
   17|  1.83k|        Ok(len) => len,
   18|    102|        Err(e) => {
   19|    102|            if e.kind() == std::io::ErrorKind::UnexpectedEof {
   20|    102|                return Ok(None);
   21|      0|            }
   22|      0|            return Err(Error::Other(e.to_string()));
   23|       |        }
   24|       |    };
   25|  1.83k|    let mut buf = Vec::with_capacity(std::cmp::min(l as usize, MAX_ALLOC));
   26|  1.83k|    let bytes_read = reader
   27|  1.83k|        .take(l as u64)
   28|  1.83k|        .read_to_end(&mut buf)
   29|      0|        .await
   30|  1.83k|        .map_err(|e| Error::Other(e.to_string()))?;
   31|  1.83k|    if bytes_read != l {
   32|      0|        return Err(Error::Io(std::io::Error::new(
   33|      0|            std::io::ErrorKind::UnexpectedEof,
   34|      0|            format!(
   35|      0|                "expected to read at least {} bytes, but read {}",
   36|      0|                l, bytes_read
   37|      0|            ),
   38|      0|        )));
   39|  1.83k|    }
   40|  1.83k|    Ok(Some(buf))
   41|  1.93k|}

_RINvXs0_NtNtCsbsA1N0ivJJv_17fvm_ipld_encoding5bytes12strict_bytesINtNtCsjYc3JqMxxfa_5alloc6borrow3CowShENtB6_11Deserialize11deserializeNtNtCsalhrieD8kwf_12libipld_core4ipld4IpldECsitTtQF8ArIt_8fvm_fuzz:
   76|    306|        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
   77|    306|        where
   78|    306|            D: Deserializer<'de>,
   79|    306|        {
   80|    306|            struct CowVisitor;
   81|    306|
   82|    306|            impl<'de> Visitor<'de> for CowVisitor {
   83|    306|                type Value = Cow<'de, [u8]>;
   84|    306|
   85|    306|                fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
   86|    306|                    formatter.write_str("a byte array")
   87|    306|                }
   88|    306|
   89|    306|                fn visit_borrowed_bytes<E>(self, v: &'de [u8]) -> Result<Self::Value, E>
   90|    306|                where
   91|    306|                    E: Error,
   92|    306|                {
   93|    306|                    Ok(Cow::Borrowed(v))
   94|    306|                }
   95|    306|
   96|    306|                fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>
   97|    306|                where
   98|    306|                    E: Error,
   99|    306|                {
  100|    306|                    Ok(Cow::Owned(v.to_vec()))
  101|    306|                }
  102|    306|
  103|    306|                fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<Self::Value, E>
  104|    306|                where
  105|    306|                    E: Error,
  106|    306|                {
  107|    306|                    Ok(Cow::Owned(v))
  108|    306|                }
  109|    306|            }
  110|    306|            deserializer.deserialize_bytes(CowVisitor)
  111|    306|        }
_RINvXNvXs0_NtNtCsbsA1N0ivJJv_17fvm_ipld_encoding5bytes12strict_bytesINtNtCsjYc3JqMxxfa_5alloc6borrow3CowShENtB9_11Deserialize11deserializeNtB3_10CowVisitorNtNtCslVZeVZySzLE_5serde2de7Visitor11visit_bytesNtNtCsalhrieD8kwf_12libipld_core5error10SerdeErrorECsitTtQF8ArIt_8fvm_fuzz:
   96|    306|                fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>
   97|    306|                where
   98|    306|                    E: Error,
   99|    306|                {
  100|    306|                    Ok(Cow::Owned(v.to_vec()))
  101|    306|                }
_RINvXNtNtCsbsA1N0ivJJv_17fvm_ipld_encoding5bytes12strict_bytesShNtB3_9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
   35|    204|        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   36|    204|        where
   37|    204|            S: Serializer,
   38|    204|        {
   39|    204|            serializer.serialize_bytes(self.as_ref())
   40|    204|        }
_RINvXNtNtCsbsA1N0ivJJv_17fvm_ipld_encoding5bytes12strict_bytesINtNtCsjYc3JqMxxfa_5alloc3vec3VechENtB3_9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
   35|    306|        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   36|    306|        where
   37|    306|            S: Serializer,
   38|    306|        {
   39|    306|            serializer.serialize_bytes(self.as_ref())
   40|    306|        }
_RINvXNvXs_NtNtCsbsA1N0ivJJv_17fvm_ipld_encoding5bytes12strict_bytesINtNtCsjYc3JqMxxfa_5alloc3vec3VechENtB8_11Deserialize11deserializeNtB3_10VecVisitorNtNtCslVZeVZySzLE_5serde2de7Visitor11visit_bytesINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor5error11DecodeErrorNtNtCshM4Il2Z0i4R_4core7convert10InfallibleEECsitTtQF8ArIt_8fvm_fuzz:
   57|    102|                fn visit_bytes<E>(self, v: &[u8]) -> Result<Vec<u8>, E>
   58|    102|                where
   59|    102|                    E: Error,
   60|    102|                {
   61|    102|                    Ok(v.into())
   62|    102|                }
_RINvXNvNtNtCsbsA1N0ivJJv_17fvm_ipld_encoding5bytes12strict_bytes1__NtB5_7ByteBufNtNtCslVZeVZySzLE_5serde2de11Deserialize11deserializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
  144|    102|    #[derive(serde::Deserialize, serde::Serialize, Debug, Eq, PartialEq, Clone)]
_RINvNtNtCsbsA1N0ivJJv_17fvm_ipld_encoding5bytes12strict_bytes11deserializeINtNtCsjYc3JqMxxfa_5alloc3vec3VechEQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
  162|    102|    pub fn deserialize<'de, T, D>(deserializer: D) -> Result<T, D::Error>
  163|    102|    where
  164|    102|        T: Deserialize<'de>,
  165|    102|        D: Deserializer<'de>,
  166|    102|    {
  167|    102|        Deserialize::deserialize(deserializer)
  168|    102|    }
_RNCINvXNvNtNtCsbsA1N0ivJJv_17fvm_ipld_encoding5bytes12strict_bytes1__NtB7_7ByteBufNtNtCslVZeVZySzLE_5serde2de11Deserialize11deserializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEE0CsitTtQF8ArIt_8fvm_fuzz:
  144|    102|    #[derive(serde::Deserialize, serde::Serialize, Debug, Eq, PartialEq, Clone)]
_RINvXs_NtNtCsbsA1N0ivJJv_17fvm_ipld_encoding5bytes12strict_bytesINtNtCsjYc3JqMxxfa_5alloc3vec3VechENtB5_11Deserialize11deserializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
   44|    102|        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
   45|    102|        where
   46|    102|            D: Deserializer<'de>,
   47|    102|        {
   48|    102|            struct VecVisitor;
   49|    102|
   50|    102|            impl<'de> Visitor<'de> for VecVisitor {
   51|    102|                type Value = Vec<u8>;
   52|    102|
   53|    102|                fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
   54|    102|                    formatter.write_str("byte array")
   55|    102|                }
   56|    102|
   57|    102|                fn visit_bytes<E>(self, v: &[u8]) -> Result<Vec<u8>, E>
   58|    102|                where
   59|    102|                    E: Error,
   60|    102|                {
   61|    102|                    Ok(v.into())
   62|    102|                }
   63|    102|
   64|    102|                fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<Vec<u8>, E>
   65|    102|                where
   66|    102|                    E: Error,
   67|    102|                {
   68|    102|                    Ok(v)
   69|    102|                }
   70|    102|            }
   71|    102|            deserializer.deserialize_byte_buf(VecVisitor)
   72|    102|        }
_RNvMs2_NtNtCsbsA1N0ivJJv_17fvm_ipld_encoding5bytes12strict_bytesNtB5_7ByteBuf8into_vec:
  149|    102|        pub fn into_vec(self) -> Vec<u8> {
  150|    102|            self.0
  151|    102|        }

_RINvYINtNtNtCs7Ei498kZF3p_3fvm10blockstore8buffered18BufferedBlockstoreNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreENtNtCsbsA1N0ivJJv_17fvm_ipld_encoding10cbor_store9CborStore8get_cborINtNtCshRBVfIqfJKm_13fvm_ipld_hamt4node4NodeNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtBa_10state_tree10ActorStateNtNtB3l_14hash_algorithm6Sha256EECsitTtQF8ArIt_8fvm_fuzz:
   16|    102|        match self.get(cid)? {
   17|    102|            Some(bz) => {
   18|    102|                let res = crate::from_slice(&bz)?;
   19|    102|                Ok(Some(res))
   20|       |            }
   21|      0|            None => Ok(None),
   22|       |        }
   23|    102|    }
_RINvYNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsbsA1N0ivJJv_17fvm_ipld_encoding10cbor_store9CborStore8put_cborINtNtCshRBVfIqfJKm_13fvm_ipld_hamt4node4NodeNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtB2g_14hash_algorithm6Sha256EECsitTtQF8ArIt_8fvm_fuzz:
   26|    102|    fn put_cbor<S>(&self, obj: &S, code: multihash::Code) -> anyhow::Result<Cid>
   27|    102|    where
   28|    102|        S: ser::Serialize,
   29|    102|    {
   30|    102|        let bytes = crate::to_vec(obj)?;
   31|    102|        self.put(
   32|    102|            code,
   33|    102|            &Block {
   34|    102|                codec: DAG_CBOR,
   35|    102|                data: &bytes,
   36|    102|            },
   37|    102|        )
   38|    102|    }
_RINvYNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsbsA1N0ivJJv_17fvm_ipld_encoding10cbor_store9CborStore8put_cborNtNtCs7Ei498kZF3p_3fvm12system_actor5StateECsitTtQF8ArIt_8fvm_fuzz:
   26|    102|    fn put_cbor<S>(&self, obj: &S, code: multihash::Code) -> anyhow::Result<Cid>
   27|    102|    where
   28|    102|        S: ser::Serialize,
   29|    102|    {
   30|    102|        let bytes = crate::to_vec(obj)?;
   31|    102|        self.put(
   32|    102|            code,
   33|    102|            &Block {
   34|    102|                codec: DAG_CBOR,
   35|    102|                data: &bytes,
   36|    102|            },
   37|    102|        )
   38|    102|    }
_RINvYNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsbsA1N0ivJJv_17fvm_ipld_encoding10cbor_store9CborStore8get_cborINtNtCsjYc3JqMxxfa_5alloc3vec3VecTNtNtB2g_6string6StringINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EEEECsitTtQF8ArIt_8fvm_fuzz:
   16|    102|        match self.get(cid)? {
   17|    102|            Some(bz) => {
   18|    102|                let res = crate::from_slice(&bz)?;
   19|    102|                Ok(Some(res))
   20|       |            }
   21|      0|            None => Ok(None),
   22|       |        }
   23|    102|    }
_RINvYNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsbsA1N0ivJJv_17fvm_ipld_encoding10cbor_store9CborStore8put_cborNtNtCs7Ei498kZF3p_3fvm10init_actor5StateECsitTtQF8ArIt_8fvm_fuzz:
   26|    102|    fn put_cbor<S>(&self, obj: &S, code: multihash::Code) -> anyhow::Result<Cid>
   27|    102|    where
   28|    102|        S: ser::Serialize,
   29|    102|    {
   30|    102|        let bytes = crate::to_vec(obj)?;
   31|    102|        self.put(
   32|    102|            code,
   33|    102|            &Block {
   34|    102|                codec: DAG_CBOR,
   35|    102|                data: &bytes,
   36|    102|            },
   37|    102|        )
   38|    102|    }
_RINvYNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsbsA1N0ivJJv_17fvm_ipld_encoding10cbor_store9CborStore8put_cborNtNtCs4pVfV2XJudO_10fvm_shared5state10StateInfo0ECsitTtQF8ArIt_8fvm_fuzz:
   26|    102|    fn put_cbor<S>(&self, obj: &S, code: multihash::Code) -> anyhow::Result<Cid>
   27|    102|    where
   28|    102|        S: ser::Serialize,
   29|    102|    {
   30|    102|        let bytes = crate::to_vec(obj)?;
   31|    102|        self.put(
   32|    102|            code,
   33|    102|            &Block {
   34|    102|                codec: DAG_CBOR,
   35|    102|                data: &bytes,
   36|    102|            },
   37|    102|        )
   38|    102|    }
_RINvYNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsbsA1N0ivJJv_17fvm_ipld_encoding10cbor_store9CborStore8put_cborNtNtCs4pVfV2XJudO_10fvm_shared5state9StateRootECsitTtQF8ArIt_8fvm_fuzz:
   26|    102|    fn put_cbor<S>(&self, obj: &S, code: multihash::Code) -> anyhow::Result<Cid>
   27|    102|    where
   28|    102|        S: ser::Serialize,
   29|    102|    {
   30|    102|        let bytes = crate::to_vec(obj)?;
   31|    102|        self.put(
   32|    102|            code,
   33|    102|            &Block {
   34|    102|                codec: DAG_CBOR,
   35|    102|                data: &bytes,
   36|    102|            },
   37|    102|        )
   38|    102|    }
_RINvYNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsbsA1N0ivJJv_17fvm_ipld_encoding10cbor_store9CborStore8get_cborTmINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EEECsitTtQF8ArIt_8fvm_fuzz:
   16|    102|        match self.get(cid)? {
   17|    102|            Some(bz) => {
   18|    102|                let res = crate::from_slice(&bz)?;
   19|    102|                Ok(Some(res))
   20|       |            }
   21|      0|            None => Ok(None),
   22|       |        }
   23|    102|    }
_RINvYINtNtNtCs7Ei498kZF3p_3fvm10blockstore8buffered18BufferedBlockstoreNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreENtNtCsbsA1N0ivJJv_17fvm_ipld_encoding10cbor_store9CborStore8get_cborINtNtCsjYc3JqMxxfa_5alloc3vec3VecTNtNtB3l_6string6StringINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EEEECsitTtQF8ArIt_8fvm_fuzz:
   16|    102|        match self.get(cid)? {
   17|    102|            Some(bz) => {
   18|    102|                let res = crate::from_slice(&bz)?;
   19|    102|                Ok(Some(res))
   20|       |            }
   21|      0|            None => Ok(None),
   22|       |        }
   23|    102|    }
_RINvYNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsbsA1N0ivJJv_17fvm_ipld_encoding10cbor_store9CborStore8put_cborAuj0_ECsitTtQF8ArIt_8fvm_fuzz:
   26|    102|    fn put_cbor<S>(&self, obj: &S, code: multihash::Code) -> anyhow::Result<Cid>
   27|    102|    where
   28|    102|        S: ser::Serialize,
   29|    102|    {
   30|    102|        let bytes = crate::to_vec(obj)?;
   31|    102|        self.put(
   32|    102|            code,
   33|    102|            &Block {
   34|    102|                codec: DAG_CBOR,
   35|    102|                data: &bytes,
   36|    102|            },
   37|    102|        )
   38|    102|    }
_RINvYRRNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsbsA1N0ivJJv_17fvm_ipld_encoding10cbor_store9CborStore8put_cborINtNtCshRBVfIqfJKm_13fvm_ipld_hamt4node4NodeNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCsjYc3JqMxxfa_5alloc6string6StringNtNtB2i_14hash_algorithm6Sha256EECsitTtQF8ArIt_8fvm_fuzz:
   26|    102|    fn put_cbor<S>(&self, obj: &S, code: multihash::Code) -> anyhow::Result<Cid>
   27|    102|    where
   28|    102|        S: ser::Serialize,
   29|    102|    {
   30|    102|        let bytes = crate::to_vec(obj)?;
   31|    102|        self.put(
   32|    102|            code,
   33|    102|            &Block {
   34|    102|                codec: DAG_CBOR,
   35|    102|                data: &bytes,
   36|    102|            },
   37|    102|        )
   38|    102|    }
_RINvYINtNtNtCs7Ei498kZF3p_3fvm10blockstore8buffered18BufferedBlockstoreNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreENtNtCsbsA1N0ivJJv_17fvm_ipld_encoding10cbor_store9CborStore8get_cborNtNtCs4pVfV2XJudO_10fvm_shared5state9StateRootECsitTtQF8ArIt_8fvm_fuzz:
   16|    102|        match self.get(cid)? {
   17|    102|            Some(bz) => {
   18|    102|                let res = crate::from_slice(&bz)?;
   19|    102|                Ok(Some(res))
   20|       |            }
   21|      0|            None => Ok(None),
   22|       |        }
   23|    102|    }
_RINvYINtNtNtCs7Ei498kZF3p_3fvm10blockstore8buffered18BufferedBlockstoreNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreENtNtCsbsA1N0ivJJv_17fvm_ipld_encoding10cbor_store9CborStore8get_cborTmINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EEECsitTtQF8ArIt_8fvm_fuzz:
   16|    102|        match self.get(cid)? {
   17|    102|            Some(bz) => {
   18|    102|                let res = crate::from_slice(&bz)?;
   19|    102|                Ok(Some(res))
   20|       |            }
   21|      0|            None => Ok(None),
   22|       |        }
   23|    102|    }

_RNvXNtCsbsA1N0ivJJv_17fvm_ipld_encoding6errorsNtB2_5ErrorINtNtCshM4Il2Z0i4R_4core7convert4FromINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor5error11DecodeErrorNtBW_10InfallibleEE4fromCsitTtQF8ArIt_8fvm_fuzz:
   23|  31.7k|    fn from(err: DecodeError<T>) -> Self {
   24|  31.7k|        Self {
   25|  31.7k|            description: err.to_string(),
   26|  31.7k|            protocol: CodecProtocol::Cbor,
   27|  31.7k|        }
   28|  31.7k|    }
_RNvXs2_NtCsbsA1N0ivJJv_17fvm_ipld_encoding6errorsNtB5_13CodecProtocolNtNtCshM4Il2Z0i4R_4core3fmt7Display3fmt:
   65|  31.7k|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
   66|  31.7k|        match *self {
   67|  31.7k|            CodecProtocol::Cbor => write!(f, "Cbor"),
   68|  31.7k|        }
   69|  31.7k|    }
_RNvXs9_NtCsbsA1N0ivJJv_17fvm_ipld_encoding6errorsNtB5_5ErrorNtNtCshM4Il2Z0i4R_4core3fmt7Display3fmt:
   15|  31.7k|#[derive(Debug, PartialEq, Eq, Error)]

_RINvCsbsA1N0ivJJv_17fvm_ipld_encoding10from_sliceNtCsFqKNUWW8VZ_12fvm_ipld_car9CarHeaderECsitTtQF8ArIt_8fvm_fuzz:
   50|    102|pub fn from_slice<'a, T>(slice: &'a [u8]) -> Result<T, Error>
   51|    102|where
   52|    102|    T: de::Deserialize<'a>,
   53|    102|{
   54|    102|    serde_ipld_dagcbor::from_slice(slice).map_err(Into::into)
   55|    102|}
_RINvCsbsA1N0ivJJv_17fvm_ipld_encoding6to_vecINtNtCshRBVfIqfJKm_13fvm_ipld_hamt4node4NodeNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCsjYc3JqMxxfa_5alloc6string6StringNtNtBL_14hash_algorithm6Sha256EECsitTtQF8ArIt_8fvm_fuzz:
   33|    102|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, Error>
   34|    102|where
   35|    102|    T: ser::Serialize + ?Sized,
   36|    102|{
   37|    102|    serde_ipld_dagcbor::to_vec(value).map_err(Into::into)
   38|    102|}
_RINvCsbsA1N0ivJJv_17fvm_ipld_encoding10from_sliceTmINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EEECsitTtQF8ArIt_8fvm_fuzz:
   50|    204|pub fn from_slice<'a, T>(slice: &'a [u8]) -> Result<T, Error>
   51|    204|where
   52|    204|    T: de::Deserialize<'a>,
   53|    204|{
   54|    204|    serde_ipld_dagcbor::from_slice(slice).map_err(Into::into)
   55|    204|}
_RINvCsbsA1N0ivJJv_17fvm_ipld_encoding10from_sliceINtNtCsjYc3JqMxxfa_5alloc3vec3VecNtNtCs4pVfV2XJudO_10fvm_shared5piece9PieceInfoEECsitTtQF8ArIt_8fvm_fuzz:
   50|  31.7k|pub fn from_slice<'a, T>(slice: &'a [u8]) -> Result<T, Error>
   51|  31.7k|where
   52|  31.7k|    T: de::Deserialize<'a>,
   53|  31.7k|{
   54|  31.7k|    serde_ipld_dagcbor::from_slice(slice).map_err(Into::into)
   55|  31.7k|}
_RINvCsbsA1N0ivJJv_17fvm_ipld_encoding6to_vecNtNtCs7Ei498kZF3p_3fvm12system_actor5StateECsitTtQF8ArIt_8fvm_fuzz:
   33|    102|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, Error>
   34|    102|where
   35|    102|    T: ser::Serialize + ?Sized,
   36|    102|{
   37|    102|    serde_ipld_dagcbor::to_vec(value).map_err(Into::into)
   38|    102|}
_RINvCsbsA1N0ivJJv_17fvm_ipld_encoding6to_vecINtNtCshRBVfIqfJKm_13fvm_ipld_hamt4node4NodeNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtBL_14hash_algorithm6Sha256EECsitTtQF8ArIt_8fvm_fuzz:
   33|    102|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, Error>
   34|    102|where
   35|    102|    T: ser::Serialize + ?Sized,
   36|    102|{
   37|    102|    serde_ipld_dagcbor::to_vec(value).map_err(Into::into)
   38|    102|}
_RINvCsbsA1N0ivJJv_17fvm_ipld_encoding6to_vecNtNtCs7Ei498kZF3p_3fvm10init_actor5StateECsitTtQF8ArIt_8fvm_fuzz:
   33|    102|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, Error>
   34|    102|where
   35|    102|    T: ser::Serialize + ?Sized,
   36|    102|{
   37|    102|    serde_ipld_dagcbor::to_vec(value).map_err(Into::into)
   38|    102|}
_RINvCsbsA1N0ivJJv_17fvm_ipld_encoding10from_sliceINtNtCsjYc3JqMxxfa_5alloc3vec3VecTNtNtBQ_6string6StringINtNtCs1slUOa8tBso_3cid3cid3CidKj40_EEEECsitTtQF8ArIt_8fvm_fuzz:
   50|    204|pub fn from_slice<'a, T>(slice: &'a [u8]) -> Result<T, Error>
   51|    204|where
   52|    204|    T: de::Deserialize<'a>,
   53|    204|{
   54|    204|    serde_ipld_dagcbor::from_slice(slice).map_err(Into::into)
   55|    204|}
_RINvCsbsA1N0ivJJv_17fvm_ipld_encoding10from_sliceNtNtCs4pVfV2XJudO_10fvm_shared5state9StateRootECsitTtQF8ArIt_8fvm_fuzz:
   50|    102|pub fn from_slice<'a, T>(slice: &'a [u8]) -> Result<T, Error>
   51|    102|where
   52|    102|    T: de::Deserialize<'a>,
   53|    102|{
   54|    102|    serde_ipld_dagcbor::from_slice(slice).map_err(Into::into)
   55|    102|}
_RINvCsbsA1N0ivJJv_17fvm_ipld_encoding6to_vecNtNtCs4pVfV2XJudO_10fvm_shared5state9StateRootECsitTtQF8ArIt_8fvm_fuzz:
   33|    102|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, Error>
   34|    102|where
   35|    102|    T: ser::Serialize + ?Sized,
   36|    102|{
   37|    102|    serde_ipld_dagcbor::to_vec(value).map_err(Into::into)
   38|    102|}
_RINvCsbsA1N0ivJJv_17fvm_ipld_encoding6to_vecAuj0_ECsitTtQF8ArIt_8fvm_fuzz:
   33|    102|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, Error>
   34|    102|where
   35|    102|    T: ser::Serialize + ?Sized,
   36|    102|{
   37|    102|    serde_ipld_dagcbor::to_vec(value).map_err(Into::into)
   38|    102|}
_RINvCsbsA1N0ivJJv_17fvm_ipld_encoding10from_sliceINtNtCshRBVfIqfJKm_13fvm_ipld_hamt4node4NodeNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtBQ_14hash_algorithm6Sha256EECsitTtQF8ArIt_8fvm_fuzz:
   50|    102|pub fn from_slice<'a, T>(slice: &'a [u8]) -> Result<T, Error>
   51|    102|where
   52|    102|    T: de::Deserialize<'a>,
   53|    102|{
   54|    102|    serde_ipld_dagcbor::from_slice(slice).map_err(Into::into)
   55|    102|}
_RINvCsbsA1N0ivJJv_17fvm_ipld_encoding6to_vecNtNtCs4pVfV2XJudO_10fvm_shared5state10StateInfo0ECsitTtQF8ArIt_8fvm_fuzz:
   33|    102|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, Error>
   34|    102|where
   35|    102|    T: ser::Serialize + ?Sized,
   36|    102|{
   37|    102|    serde_ipld_dagcbor::to_vec(value).map_err(Into::into)
   38|    102|}

_RINvXNtCshRBVfIqfJKm_13fvm_ipld_hamt8bitfieldNtB3_8BitfieldNtNtCslVZeVZySzLE_5serde3ser9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
   16|    204|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   17|    204|    where
   18|    204|        S: Serializer,
   19|    204|    {
   20|    204|        let mut v = [0u8; 4 * 8];
   21|    204|        // Big endian ordering, to match go
   22|    204|        BigEndian::write_u64(&mut v[..8], self.0[3]);
   23|    204|        BigEndian::write_u64(&mut v[8..16], self.0[2]);
   24|    204|        BigEndian::write_u64(&mut v[16..24], self.0[1]);
   25|    204|        BigEndian::write_u64(&mut v[24..], self.0[0]);
   26|       |
   27|  6.32k|        for i in 0..v.len() {
   28|  6.32k|            if v[i] != 0 {
   29|    102|                return strict_bytes::Serialize::serialize(&v[i..], serializer);
   30|  6.22k|            }
   31|       |        }
   32|       |
   33|    102|        <[u8] as strict_bytes::Serialize>::serialize(&[], serializer)
   34|    204|    }
_RINvXs_NtCshRBVfIqfJKm_13fvm_ipld_hamt8bitfieldNtB5_8BitfieldNtNtCslVZeVZySzLE_5serde2de11Deserialize11deserializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
   38|    102|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
   39|    102|    where
   40|    102|        D: Deserializer<'de>,
   41|    102|    {
   42|    102|        let mut res = Bitfield::zero();
   43|    102|        let bytes = strict_bytes::ByteBuf::deserialize(deserializer)?.into_vec();
   44|    102|
   45|    102|        let mut arr = [0u8; 4 * 8];
   46|    102|        let len = bytes.len();
   47|    306|        for (old, new) in bytes.iter().zip(arr[(32 - len)..].iter_mut()) {
   48|    306|            *new = *old;
   49|    306|        }
   50|    102|        res.0[3] = BigEndian::read_u64(&arr[..8]);
   51|    102|        res.0[2] = BigEndian::read_u64(&arr[8..16]);
   52|    102|        res.0[1] = BigEndian::read_u64(&arr[16..24]);
   53|    102|        res.0[0] = BigEndian::read_u64(&arr[24..]);
   54|    102|
   55|    102|        Ok(res)
   56|    102|    }
_RNvNtCshRBVfIqfJKm_13fvm_ipld_hamt8bitfield12set_bits_leq:
  132|    306|fn set_bits_leq(v: u64, bit: u32) -> u64 {
  133|    306|    (v as u128 | ((1u128 << (1 + bit)) - 1)) as u64
  134|    306|}
_RNCNvMs1_NtCshRBVfIqfJKm_13fvm_ipld_hamt8bitfieldNtB7_8Bitfield10count_ones0B9_:
   87|  2.44k|        self.0.iter().map(|a| a.count_ones() as usize).sum()
_RNvMs1_NtCshRBVfIqfJKm_13fvm_ipld_hamt8bitfieldNtB5_8Bitfield7set_bit:
   79|    306|    pub fn set_bit(&mut self, idx: u32) {
   80|    306|        let ai = idx / 64;
   81|    306|        let bi = idx % 64;
   82|    306|
   83|    306|        self.0[ai as usize] |= 1 << bi as u32;
   84|    306|    }
_RNvMs1_NtCshRBVfIqfJKm_13fvm_ipld_hamt8bitfieldNtB5_8Bitfield10count_ones:
   86|    612|    pub fn count_ones(&self) -> usize {
   87|    612|        self.0.iter().map(|a| a.count_ones() as usize).sum()
   88|    612|    }
_RNvMs1_NtCshRBVfIqfJKm_13fvm_ipld_hamt8bitfieldNtB5_8Bitfield4zero:
   99|    612|    pub fn zero() -> Self {
  100|    612|        Bitfield([0, 0, 0, 0])
  101|    612|    }
_RNvMs1_NtCshRBVfIqfJKm_13fvm_ipld_hamt8bitfieldNtB5_8Bitfield11set_bits_le:
  103|    306|    pub fn set_bits_le(self, bit: u32) -> Self {
  104|    306|        if bit == 0 {
  105|      0|            return self;
  106|    306|        }
  107|    306|        self.set_bits_leq(bit - 1)
  108|    306|    }
_RNvMs1_NtCshRBVfIqfJKm_13fvm_ipld_hamt8bitfieldNtB5_8Bitfield8test_bit:
   72|    306|    pub fn test_bit(&self, idx: u32) -> bool {
   73|    306|        let ai = idx / 64;
   74|    306|        let bi = idx % 64;
   75|    306|
   76|    306|        self.0[ai as usize] & (1 << bi as u32) != 0
   77|    306|    }
_RNvMs1_NtCshRBVfIqfJKm_13fvm_ipld_hamt8bitfieldNtB5_8Bitfield3and:
   90|    306|    pub fn and(self, other: &Self) -> Self {
   91|    306|        Bitfield([
   92|    306|            self.0[0] & other.0[0],
   93|    306|            self.0[1] & other.0[1],
   94|    306|            self.0[2] & other.0[2],
   95|    306|            self.0[3] & other.0[3],
   96|    306|        ])
   97|    306|    }
_RNvMs1_NtCshRBVfIqfJKm_13fvm_ipld_hamt8bitfieldNtB5_8Bitfield12set_bits_leq:
  110|    306|    pub fn set_bits_leq(mut self, bit: u32) -> Self {
  111|    306|        if bit < 64 {
  112|    306|            self.0[0] = set_bits_leq(self.0[0], bit);
  113|    306|        } else if bit < 128 {
  114|      0|            self.0[0] = std::u64::MAX;
  115|      0|            self.0[1] = set_bits_leq(self.0[1], bit - 64);
  116|      0|        } else if bit < 192 {
  117|      0|            self.0[0] = std::u64::MAX;
  118|      0|            self.0[1] = std::u64::MAX;
  119|      0|            self.0[2] = set_bits_leq(self.0[2], bit - 128);
  120|      0|        } else {
  121|      0|            self.0[0] = std::u64::MAX;
  122|      0|            self.0[1] = std::u64::MAX;
  123|      0|            self.0[2] = std::u64::MAX;
  124|      0|            self.0[3] = set_bits_leq(self.0[3], bit - 192);
  125|      0|        }
  126|       |
  127|    306|        self
  128|    306|    }

_RNvMs0_NtCshRBVfIqfJKm_13fvm_ipld_hamt4hamtINtB5_4HamtINtNtNtCs7Ei498kZF3p_3fvm10blockstore8buffered18BufferedBlockstoreNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreENtNtBX_10state_tree10ActorStateE5storeCsitTtQF8ArIt_8fvm_fuzz:
  141|    204|    pub fn store(&self) -> &BS {
  142|    204|        &self.store
  143|    204|    }
_RNvMs0_NtCshRBVfIqfJKm_13fvm_ipld_hamt4hamtINtB5_4HamtRRNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsjYc3JqMxxfa_5alloc6string6StringE18new_with_bit_widthCsitTtQF8ArIt_8fvm_fuzz:
   87|    102|    pub fn new_with_bit_width(store: BS, bit_width: u32) -> Self {
   88|    102|        Self::new_with_config(
   89|    102|            store,
   90|    102|            Config {
   91|    102|                bit_width,
   92|    102|                ..Default::default()
   93|    102|            },
   94|    102|        )
   95|    102|    }
_RNvMs0_NtCshRBVfIqfJKm_13fvm_ipld_hamt4hamtINtB5_4HamtNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateE15new_with_configCsitTtQF8ArIt_8fvm_fuzz:
   76|    102|    pub fn new_with_config(store: BS, conf: Config) -> Self {
   77|    102|        Self {
   78|    102|            root: Node::default(),
   79|    102|            store,
   80|    102|            conf,
   81|    102|            hash: Default::default(),
   82|    102|            flushed_cid: None,
   83|    102|        }
   84|    102|    }
_RNvMs0_NtCshRBVfIqfJKm_13fvm_ipld_hamt4hamtINtB5_4HamtNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateE5flushCsitTtQF8ArIt_8fvm_fuzz:
  320|    102|        if let Some(cid) = self.flushed_cid {
  321|      0|            return Ok(cid);
  322|    102|        }
  323|    102|        self.root.flush(self.store.borrow())?;
  324|    102|        let cid = self.store.put_cbor(&self.root, Code::Blake2b256)?;
  325|    102|        self.flushed_cid = Some(cid);
  326|    102|        Ok(cid)
  327|    102|    }
_RNvMs0_NtCshRBVfIqfJKm_13fvm_ipld_hamt4hamtINtB5_4HamtINtNtNtCs7Ei498kZF3p_3fvm10blockstore8buffered18BufferedBlockstoreNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreENtNtBX_10state_tree10ActorStateE16load_with_configCsitTtQF8ArIt_8fvm_fuzz:
  104|    102|        match store.get_cbor(cid)? {
  105|    102|            Some(root) => Ok(Self {
  106|    102|                root,
  107|    102|                store,
  108|    102|                conf,
  109|    102|                hash: Default::default(),
  110|    102|                flushed_cid: Some(*cid),
  111|    102|            }),
  112|      0|            None => Err(Error::CidNotFound(cid.to_string())),
  113|       |        }
  114|    102|    }
_RNvMs0_NtCshRBVfIqfJKm_13fvm_ipld_hamt4hamtINtB5_4HamtNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateE18new_with_bit_widthCsitTtQF8ArIt_8fvm_fuzz:
   87|    102|    pub fn new_with_bit_width(store: BS, bit_width: u32) -> Self {
   88|    102|        Self::new_with_config(
   89|    102|            store,
   90|    102|            Config {
   91|    102|                bit_width,
   92|    102|                ..Default::default()
   93|    102|            },
   94|    102|        )
   95|    102|    }
_RNvMs0_NtCshRBVfIqfJKm_13fvm_ipld_hamt4hamtINtB5_4HamtNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateE10into_storeCsitTtQF8ArIt_8fvm_fuzz:
  366|    102|    pub fn into_store(self) -> BS {
  367|    102|        self.store
  368|    102|    }
_RNvMs0_NtCshRBVfIqfJKm_13fvm_ipld_hamt4hamtINtB5_4HamtINtNtNtCs7Ei498kZF3p_3fvm10blockstore8buffered18BufferedBlockstoreNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreENtNtBX_10state_tree10ActorStateE19load_with_bit_widthCsitTtQF8ArIt_8fvm_fuzz:
  116|    102|    pub fn load_with_bit_width(cid: &Cid, store: BS, bit_width: u32) -> Result<Self, Error> {
  117|    102|        Self::load_with_config(
  118|    102|            cid,
  119|    102|            store,
  120|    102|            Config {
  121|    102|                bit_width,
  122|    102|                ..Default::default()
  123|    102|            },
  124|    102|        )
  125|    102|    }
_RNvMs0_NtCshRBVfIqfJKm_13fvm_ipld_hamt4hamtINtB5_4HamtRRNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsjYc3JqMxxfa_5alloc6string6StringE15new_with_configCsitTtQF8ArIt_8fvm_fuzz:
   76|    102|    pub fn new_with_config(store: BS, conf: Config) -> Self {
   77|    102|        Self {
   78|    102|            root: Node::default(),
   79|    102|            store,
   80|    102|            conf,
   81|    102|            hash: Default::default(),
   82|    102|            flushed_cid: None,
   83|    102|        }
   84|    102|    }
_RNvMs0_NtCshRBVfIqfJKm_13fvm_ipld_hamt4hamtINtB5_4HamtNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateE3setCsitTtQF8ArIt_8fvm_fuzz:
  167|    306|    pub fn set(&mut self, key: K, value: V) -> Result<Option<V>, Error>
  168|    306|    where
  169|    306|        V: PartialEq,
  170|    306|    {
  171|    306|        let (old, modified) = self
  172|    306|            .root
  173|    306|            .set(key, value, self.store.borrow(), &self.conf, true)?;
  174|       |
  175|    306|        if modified {
  176|    306|            self.flushed_cid = None;
  177|    306|        }
  178|       |
  179|    306|        Ok(old)
  180|    306|    }
_RNvMs0_NtCshRBVfIqfJKm_13fvm_ipld_hamt4hamtINtB5_4HamtNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateE5storeCsitTtQF8ArIt_8fvm_fuzz:
  141|    408|    pub fn store(&self) -> &BS {
  142|    408|        &self.store
  143|    408|    }
_RNvMs0_NtCshRBVfIqfJKm_13fvm_ipld_hamt4hamtINtB5_4HamtRRNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsjYc3JqMxxfa_5alloc6string6StringE5flushCsitTtQF8ArIt_8fvm_fuzz:
  320|    102|        if let Some(cid) = self.flushed_cid {
  321|      0|            return Ok(cid);
  322|    102|        }
  323|    102|        self.root.flush(self.store.borrow())?;
  324|    102|        let cid = self.store.put_cbor(&self.root, Code::Blake2b256)?;
  325|    102|        self.flushed_cid = Some(cid);
  326|    102|        Ok(cid)
  327|    102|    }

_RINvXs_NtCshRBVfIqfJKm_13fvm_ipld_hamt14hash_algorithmNtB5_6Sha256NtB5_13HashAlgorithm4hashNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyECsitTtQF8ArIt_8fvm_fuzz:
   38|    306|    fn hash<X: ?Sized>(key: &X) -> HashedKey
   39|    306|    where
   40|    306|        X: Hash,
   41|    306|    {
   42|    306|        let mut hasher = Sha2HasherWrapper::default();
   43|    306|        key.hash(&mut hasher);
   44|    306|        hasher.0.finalize().into()
   45|    306|    }
_RNvXs0_NtCshRBVfIqfJKm_13fvm_ipld_hamt14hash_algorithmNtB5_17Sha2HasherWrapperNtNtCshM4Il2Z0i4R_4core7default7Default7default:
   19|    306|#[derive(Default)]
_RNvXNtCshRBVfIqfJKm_13fvm_ipld_hamt14hash_algorithmNtB2_17Sha2HasherWrapperNtNtCshM4Il2Z0i4R_4core4hash6Hasher5write:
   28|    306|    fn write(&mut self, bytes: &[u8]) {
   29|    306|        self.0.update(bytes);
   30|    306|    }

_RNvMNtCshRBVfIqfJKm_13fvm_ipld_hamt9hash_bitsNtB2_8HashBits3new:
   25|    306|    pub fn new(hash_buffer: &'a HashedKey) -> HashBits<'a> {
   26|    306|        Self::new_at_index(hash_buffer, 0)
   27|    306|    }
_RNvMNtCshRBVfIqfJKm_13fvm_ipld_hamt9hash_bitsNtB2_8HashBits9next_bits:
   52|    306|    fn next_bits(&mut self, i: u32) -> u32 {
   53|    306|        let curbi = self.consumed / 8;
   54|    306|        let leftb = 8 - (self.consumed % 8);
   55|    306|
   56|    306|        let curb = self.b[curbi as usize] as u32;
   57|    306|        match i.cmp(&leftb) {
   58|       |            Ordering::Equal => {
   59|       |                // bits to consume is equal to the bits remaining in the currently indexed byte
   60|      0|                let out = mkmask(i) & curb;
   61|      0|                self.consumed += i;
   62|      0|                out
   63|       |            }
   64|       |            Ordering::Less => {
   65|       |                // Consuming less than the remaining bits in the current byte
   66|    306|                let a = curb & mkmask(leftb);
   67|    306|                let b = a & !mkmask(leftb - i);
   68|    306|                let c = b >> (leftb - i);
   69|    306|                self.consumed += i;
   70|    306|                c
   71|       |            }
   72|       |            Ordering::Greater => {
   73|       |                // Consumes remaining bits and remaining bits from a recursive call
   74|      0|                let mut out = (mkmask(leftb) & curb) as u64;
   75|      0|                out <<= i - leftb;
   76|      0|                self.consumed += leftb;
   77|      0|                out += self.next_bits(i - leftb) as u64;
   78|      0|                out as u32
   79|       |            }
   80|       |        }
   81|    306|    }
_RNvMNtCshRBVfIqfJKm_13fvm_ipld_hamt9hash_bitsNtB2_8HashBits4next:
   39|    306|    pub fn next(&mut self, i: u32) -> Result<u32, Error> {
   40|    306|        if i > 8 || i == 0 {
   41|      0|            return Err(Error::InvalidHashBitLen);
   42|    306|        }
   43|    306|        let maxi = (self.b.len() as u32) * 8 - self.consumed;
   44|    306|        if maxi == 0 {
   45|      0|            return Err(Error::MaxDepth);
   46|    306|        }
   47|    306|        // Only take what's left. If we consume 5 bits at a time from a 256 bit key,
   48|    306|        // there will be 1 bit left at the bottom.
   49|    306|        Ok(self.next_bits(std::cmp::min(i, maxi)))
   50|    306|    }
_RNvMNtCshRBVfIqfJKm_13fvm_ipld_hamt9hash_bitsNtB2_8HashBits12new_at_index:
   30|    306|    pub fn new_at_index(hash_buffer: &'a HashedKey, consumed: u32) -> HashBits<'a> {
   31|    306|        Self {
   32|    306|            b: hash_buffer,
   33|    306|            consumed,
   34|    306|        }
   35|    306|    }
_RNvNtCshRBVfIqfJKm_13fvm_ipld_hamt9hash_bits6mkmask:
   20|    612|pub(crate) fn mkmask(n: u32) -> u32 {
   21|    612|    ((1u64 << n) - 1) as u32
   22|    612|}

_RINvXNvXNvCshRBVfIqfJKm_13fvm_ipld_hamts_1__INtB8_12KeyValuePairppENtNtCslVZeVZySzLE_5serde2de11Deserialize11deserializeINtB3_9___VisitorNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateENtB15_7Visitor9visit_seqQNtNtNtCsalhrieD8kwf_12libipld_core5serde2de15SeqDeserializerECsitTtQF8ArIt_8fvm_fuzz:
   75|    306|#[derive(Debug, Serialize, Deserialize, PartialEq)]
_RINvXNvCshRBVfIqfJKm_13fvm_ipld_hamt1__INtB5_12KeyValuePairNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateENtNtCslVZeVZySzLE_5serde3ser9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
   75|    306|#[derive(Debug, Serialize, Deserialize, PartialEq)]
_RNvMs0_CshRBVfIqfJKm_13fvm_ipld_hamtINtB5_12KeyValuePairNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateE3newCsitTtQF8ArIt_8fvm_fuzz:
   88|    306|    pub fn new(key: K, value: V) -> Self {
   89|    306|        KeyValuePair(key, value)
   90|    306|    }
_RINvXNvCshRBVfIqfJKm_13fvm_ipld_hamts_1__INtB5_12KeyValuePairNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateENtNtCslVZeVZySzLE_5serde2de11Deserialize11deserializeNtNtCsalhrieD8kwf_12libipld_core4ipld4IpldECsitTtQF8ArIt_8fvm_fuzz:
   75|    306|#[derive(Debug, Serialize, Deserialize, PartialEq)]
_RNvXCshRBVfIqfJKm_13fvm_ipld_hamtNtB2_6ConfigNtNtCshM4Il2Z0i4R_4core7default7Default7default:
   64|    306|    fn default() -> Self {
   65|    306|        Self {
   66|    306|            bit_width: DEFAULT_BIT_WIDTH,
   67|    306|            min_data_depth: 0,
   68|    306|            max_array_width: 3,
   69|    306|        }
   70|    306|    }

_RINvXs_NtCshRBVfIqfJKm_13fvm_ipld_hamt4nodeINtB5_4NodeNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCsjYc3JqMxxfa_5alloc6string6StringNtNtB7_14hash_algorithm6Sha256ENtNtCslVZeVZySzLE_5serde3ser9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
   41|    102|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   42|    102|    where
   43|    102|        S: Serializer,
   44|    102|    {
   45|    102|        (&self.bitfield, &self.pointers).serialize(serializer)
   46|    102|    }
_RINvXs0_NtCshRBVfIqfJKm_13fvm_ipld_hamt4nodeINtB6_4NodeNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtB8_14hash_algorithm6Sha256ENtNtCslVZeVZySzLE_5serde2de11Deserialize11deserializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
   54|    102|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
   55|    102|    where
   56|    102|        D: Deserializer<'de>,
   57|    102|    {
   58|    102|        let (bitfield, pointers) = Deserialize::deserialize(deserializer)?;
   59|    102|        Ok(Node {
   60|    102|            bitfield,
   61|    102|            pointers,
   62|    102|            hash: Default::default(),
   63|    102|        })
   64|    102|    }
_RNvXs1_NtCshRBVfIqfJKm_13fvm_ipld_hamt4nodeINtB5_4NodeNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCsjYc3JqMxxfa_5alloc6string6StringNtNtB7_14hash_algorithm6Sha256ENtNtCshM4Il2Z0i4R_4core7default7Default7defaultCsitTtQF8ArIt_8fvm_fuzz:
   68|    102|    fn default() -> Self {
   69|    102|        Node {
   70|    102|            bitfield: Bitfield::zero(),
   71|    102|            pointers: Vec::new(),
   72|    102|            hash: Default::default(),
   73|    102|        }
   74|    102|    }
_RNvMs2_NtCshRBVfIqfJKm_13fvm_ipld_hamt4nodeINtB5_4NodeNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtB7_14hash_algorithm6Sha256E12insert_childCsitTtQF8ArIt_8fvm_fuzz:
  473|    306|    fn insert_child(&mut self, idx: u32, key: K, value: V) {
  474|    306|        let i = self.index_for_bit_pos(idx);
  475|    306|        self.bitfield.set_bit(idx);
  476|    306|        self.pointers.insert(i, Pointer::from_key_value(key, value))
  477|    306|    }
_RNvXs1_NtCshRBVfIqfJKm_13fvm_ipld_hamt4nodeINtB5_4NodeNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtB7_14hash_algorithm6Sha256ENtNtCshM4Il2Z0i4R_4core7default7Default7defaultCsitTtQF8ArIt_8fvm_fuzz:
   68|    102|    fn default() -> Self {
   69|    102|        Node {
   70|    102|            bitfield: Bitfield::zero(),
   71|    102|            pointers: Vec::new(),
   72|    102|            hash: Default::default(),
   73|    102|        }
   74|    102|    }
_RINvMs2_NtCshRBVfIqfJKm_13fvm_ipld_hamt4nodeINtB6_4NodeNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtB8_14hash_algorithm6Sha256E12modify_valueNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreECsitTtQF8ArIt_8fvm_fuzz:
  246|    306|    fn modify_value<S: Blockstore>(
  247|    306|        &mut self,
  248|    306|        hashed_key: &mut HashBits,
  249|    306|        conf: &Config,
  250|    306|        depth: u32,
  251|    306|        key: K,
  252|    306|        value: V,
  253|    306|        store: &S,
  254|    306|        overwrite: bool,
  255|    306|    ) -> Result<(Option<V>, bool), Error>
  256|    306|    where
  257|    306|        V: PartialEq,
  258|    306|    {
  259|    306|        let idx = hashed_key.next(conf.bit_width)?;
  260|       |
  261|       |        // No existing values at this point.
  262|    306|        if !self.bitfield.test_bit(idx) {
  263|    306|            if depth >= conf.min_data_depth {
  264|    306|                self.insert_child(idx, key, value);
  265|    306|            } else {
  266|       |                // Need to insert some empty nodes reserved for links.
  267|      0|                let mut sub = Node::<K, V, H>::default();
  268|      0|                sub.modify_value(hashed_key, conf, depth + 1, key, value, store, overwrite)?;
  269|      0|                self.insert_child_dirty(idx, Box::new(sub));
  270|       |            }
  271|    306|            return Ok((None, true));
  272|      0|        }
  273|      0|
  274|      0|        let cindex = self.index_for_bit_pos(idx);
  275|      0|        let child = self.get_child_mut(cindex);
  276|      0|
  277|      0|        match child {
  278|      0|            Pointer::Link { cid, cache } => {
  279|      0|                cache.get_or_try_init(|| {
  280|       |                    store
  281|       |                        .get_cbor(cid)?
  282|       |                        .ok_or_else(|| Error::CidNotFound(cid.to_string()))
  283|      0|                })?;
  284|      0|                let child_node = cache.get_mut().expect("filled line above");
  285|       |
  286|      0|                let (old, modified) = child_node.modify_value(
  287|      0|                    hashed_key,
  288|      0|                    conf,
  289|      0|                    depth + 1,
  290|      0|                    key,
  291|      0|                    value,
  292|      0|                    store,
  293|      0|                    overwrite,
  294|      0|                )?;
  295|      0|                if modified {
  296|      0|                    *child = Pointer::Dirty(std::mem::take(child_node));
  297|      0|                }
  298|      0|                Ok((old, modified))
  299|       |            }
  300|      0|            Pointer::Dirty(node) => {
  301|      0|                node.modify_value(hashed_key, conf, depth + 1, key, value, store, overwrite)
  302|       |            }
  303|      0|            Pointer::Values(vals) => {
  304|       |                // Update, if the key already exists.
  305|      0|                if let Some(i) = vals.iter().position(|p| p.key() == &key) {
  306|      0|                    if overwrite {
  307|       |                        // If value changed, the parent nodes need to be marked as dirty.
  308|       |                        // ! The assumption here is that `PartialEq` is implemented correctly,
  309|       |                        // ! and that if that is true, the serialized bytes are equal.
  310|       |                        // ! To be absolutely sure, can serialize each value and compare or
  311|       |                        // ! refactor the Hamt to not be type safe and serialize on entry and
  312|       |                        // ! exit. These both come at costs, and this isn't a concern.
  313|      0|                        let value_changed = vals[i].value() != &value;
  314|      0|                        return Ok((
  315|      0|                            Some(std::mem::replace(&mut vals[i].1, value)),
  316|      0|                            value_changed,
  317|      0|                        ));
  318|       |                    } else {
  319|       |                        // Can't overwrite, return None and false that the Node was not modified.
  320|      0|                        return Ok((None, false));
  321|       |                    }
  322|      0|                }
  323|      0|
  324|      0|                // If the array is full, create a subshard and insert everything
  325|      0|                if vals.len() >= conf.max_array_width {
  326|      0|                    let kvs = std::mem::take(vals);
  327|      0|                    let hashed_kvs = kvs.into_iter().map(|KeyValuePair(k, v)| {
  328|       |                        let hash = H::hash(&k);
  329|       |                        (k, v, hash)
  330|      0|                    });
  331|      0|
  332|      0|                    let consumed = hashed_key.consumed;
  333|      0|                    let mut sub = Node::<K, V, H>::default();
  334|      0|                    let modified = sub.modify_value(
  335|      0|                        hashed_key,
  336|      0|                        conf,
  337|      0|                        depth + 1,
  338|      0|                        key,
  339|      0|                        value,
  340|      0|                        store,
  341|      0|                        overwrite,
  342|      0|                    )?;
  343|       |
  344|      0|                    for (k, v, hash) in hashed_kvs {
  345|      0|                        sub.modify_value(
  346|      0|                            &mut HashBits::new_at_index(&hash, consumed),
  347|      0|                            conf,
  348|      0|                            depth + 1,
  349|      0|                            k,
  350|      0|                            v,
  351|      0|                            store,
  352|      0|                            overwrite,
  353|      0|                        )?;
  354|       |                    }
  355|       |
  356|      0|                    *child = Pointer::Dirty(Box::new(sub));
  357|      0|
  358|      0|                    return Ok(modified);
  359|      0|                }
  360|      0|
  361|      0|                // Otherwise insert the element into the array in order.
  362|      0|                let max = vals.len();
  363|      0|                let idx = vals.iter().position(|c| c.key() > &key).unwrap_or(max);
  364|      0|
  365|      0|                let np = KeyValuePair::new(key, value);
  366|      0|                vals.insert(idx, np);
  367|      0|
  368|      0|                Ok((None, true))
  369|       |            }
  370|       |        }
  371|    306|    }
_RNvMs2_NtCshRBVfIqfJKm_13fvm_ipld_hamt4nodeINtB5_4NodeNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtB7_14hash_algorithm6Sha256E17index_for_bit_posCsitTtQF8ArIt_8fvm_fuzz:
  485|    306|    fn index_for_bit_pos(&self, bp: u32) -> usize {
  486|    306|        let mask = Bitfield::zero().set_bits_le(bp);
  487|    306|        assert_eq!(mask.count_ones(), bp as usize);
  488|    306|        mask.and(&self.bitfield).count_ones()
  489|    306|    }
_RINvMs2_NtCshRBVfIqfJKm_13fvm_ipld_hamt4nodeINtB6_4NodeNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtB8_14hash_algorithm6Sha256E3setNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreECsitTtQF8ArIt_8fvm_fuzz:
   83|    306|    pub fn set<S: Blockstore>(
   84|    306|        &mut self,
   85|    306|        key: K,
   86|    306|        value: V,
   87|    306|        store: &S,
   88|    306|        conf: &Config,
   89|    306|        overwrite: bool,
   90|    306|    ) -> Result<(Option<V>, bool), Error>
   91|    306|    where
   92|    306|        V: PartialEq,
   93|    306|    {
   94|    306|        let hash = H::hash(&key);
   95|    306|        self.modify_value(
   96|    306|            &mut HashBits::new(&hash),
   97|    306|            conf,
   98|    306|            0,
   99|    306|            key,
  100|    306|            value,
  101|    306|            store,
  102|    306|            overwrite,
  103|    306|        )
  104|    306|    }
_RINvMs2_NtCshRBVfIqfJKm_13fvm_ipld_hamt4nodeINtB6_4NodeNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCsjYc3JqMxxfa_5alloc6string6StringNtNtB8_14hash_algorithm6Sha256E5flushRRNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreECsitTtQF8ArIt_8fvm_fuzz:
  448|    102|    pub fn flush<S: Blockstore>(&mut self, store: &S) -> Result<(), Error> {
  449|    102|        for pointer in &mut self.pointers {
  450|      0|            if let Pointer::Dirty(node) = pointer {
  451|       |                // Flush cached sub node to clear it's cache
  452|      0|                node.flush(store)?;
  453|       |
  454|       |                // Put node in blockstore and retrieve Cid
  455|      0|                let cid = store.put_cbor(node, Code::Blake2b256)?;
  456|       |
  457|       |                // Can keep the flushed node in link cache
  458|      0|                let cache = OnceCell::from(std::mem::take(node));
  459|      0|
  460|      0|                // Replace cached node with Cid link
  461|      0|                *pointer = Pointer::Link { cid, cache };
  462|      0|            }
  463|       |        }
  464|       |
  465|    102|        Ok(())
  466|    102|    }
_RINvXs_NtCshRBVfIqfJKm_13fvm_ipld_hamt4nodeINtB5_4NodeNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtB7_14hash_algorithm6Sha256ENtNtCslVZeVZySzLE_5serde3ser9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
   41|    102|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   42|    102|    where
   43|    102|        S: Serializer,
   44|    102|    {
   45|    102|        (&self.bitfield, &self.pointers).serialize(serializer)
   46|    102|    }
_RINvMs2_NtCshRBVfIqfJKm_13fvm_ipld_hamt4nodeINtB6_4NodeNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtB8_14hash_algorithm6Sha256E5flushNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreECsitTtQF8ArIt_8fvm_fuzz:
  448|    102|    pub fn flush<S: Blockstore>(&mut self, store: &S) -> Result<(), Error> {
  449|    408|        for pointer in &mut self.pointers {
  450|    306|            if let Pointer::Dirty(node) = pointer {
  451|       |                // Flush cached sub node to clear it's cache
  452|      0|                node.flush(store)?;
  453|       |
  454|       |                // Put node in blockstore and retrieve Cid
  455|      0|                let cid = store.put_cbor(node, Code::Blake2b256)?;
  456|       |
  457|       |                // Can keep the flushed node in link cache
  458|      0|                let cache = OnceCell::from(std::mem::take(node));
  459|      0|
  460|      0|                // Replace cached node with Cid link
  461|      0|                *pointer = Pointer::Link { cid, cache };
  462|    306|            }
  463|       |        }
  464|       |
  465|    102|        Ok(())
  466|    102|    }

_RNvMs3_NtCshRBVfIqfJKm_13fvm_ipld_hamt7pointerINtB5_7PointerNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtB7_14hash_algorithm6Sha256E14from_key_valueCsitTtQF8ArIt_8fvm_fuzz:
  109|    306|    pub(crate) fn from_key_value(key: K, value: V) -> Self {
  110|    306|        Pointer::Values(vec![KeyValuePair::new(key, value)])
  111|    306|    }
_RNvXs0_NtCshRBVfIqfJKm_13fvm_ipld_hamt7pointerINtB5_7PointerNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtB7_14hash_algorithm6Sha256EINtNtCshM4Il2Z0i4R_4core7convert7TryFromNtNtCsalhrieD8kwf_12libipld_core4ipld4IpldE8try_fromCsitTtQF8ArIt_8fvm_fuzz:
   65|    306|    fn try_from(ipld: Ipld) -> Result<Self, Self::Error> {
   66|    306|        match ipld {
   67|    306|            ipld_list @ Ipld::List(_) => {
   68|    306|                let values: Vec<KeyValuePair<K, V>> = from_ipld(ipld_list)?;
   69|    306|                Ok(Self::Values(values))
   70|       |            }
   71|      0|            Ipld::Link(cid) => Ok(Self::Link {
   72|      0|                cid,
   73|      0|                cache: Default::default(),
   74|      0|            }),
   75|      0|            other => Err(format!(
   76|      0|                "Expected `Ipld::List` or `Ipld::Link`, got {:#?}",
   77|      0|                other
   78|      0|            )),
   79|       |        }
   80|    306|    }
_RINvNtCshRBVfIqfJKm_13fvm_ipld_hamt7pointer9from_ipldINtNtCsjYc3JqMxxfa_5alloc3vec3VecINtB4_12KeyValuePairNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateEEECsitTtQF8ArIt_8fvm_fuzz:
  181|    306|fn from_ipld<T: DeserializeOwned>(ipld: Ipld) -> Result<T, String> {
  182|    306|    Deserialize::deserialize(ipld).map_err(|error| error.to_string())
  183|    306|}
_RINvXs1_NtCshRBVfIqfJKm_13fvm_ipld_hamt7pointerINtB6_7PointerNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtB8_14hash_algorithm6Sha256ENtNtCslVZeVZySzLE_5serde2de11Deserialize11deserializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
   89|    306|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
   90|    306|    where
   91|    306|        D: Deserializer<'de>,
   92|    306|    {
   93|    306|        Ipld::deserialize(deserializer).and_then(|ipld| ipld.try_into().map_err(de::Error::custom))
   94|    306|    }
_RINvXs_NtCshRBVfIqfJKm_13fvm_ipld_hamt7pointerINtB5_7PointerNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtB7_14hash_algorithm6Sha256ENtNtCslVZeVZySzLE_5serde3ser9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
   46|    306|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   47|    306|    where
   48|    306|        S: Serializer,
   49|    306|    {
   50|    306|        match self {
   51|    306|            Pointer::Values(vals) => vals.serialize(serializer),
   52|      0|            Pointer::Link { cid, .. } => cid.serialize(serializer),
   53|      0|            Pointer::Dirty(_) => Err(ser::Error::custom("Cannot serialize cached values")),
   54|       |        }
   55|    306|    }
_RNCINvXs1_NtCshRBVfIqfJKm_13fvm_ipld_hamt7pointerINtB8_7PointerNtNtCslriq3Zp8obK_17forest_hash_utils3key8BytesKeyNtNtCs7Ei498kZF3p_3fvm10state_tree10ActorStateNtNtBa_14hash_algorithm6Sha256ENtNtCslVZeVZySzLE_5serde2de11Deserialize11deserializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEE0CsitTtQF8ArIt_8fvm_fuzz:
   93|    306|        Ipld::deserialize(deserializer).and_then(|ipld| ipld.try_into().map_err(de::Error::custom))

_RNvMs_NtCs4pVfV2XJudO_10fvm_shared7addressNtB4_7Address8to_bytes:
  170|    306|    pub fn to_bytes(self) -> Vec<u8> {
  171|    306|        self.payload.to_bytes()
  172|    306|    }
_RNvNtCs4pVfV2XJudO_10fvm_shared7address12to_leb_bytes:
  371|    306|pub(crate) fn to_leb_bytes(id: u64) -> Vec<u8> {
  372|    306|    // write id to buffer in leb128 format
  373|    306|    unsigned_varint::encode::u64(id, &mut unsigned_varint::encode::u64_buffer()).into()
  374|    306|}
_RNvMs_NtCs4pVfV2XJudO_10fvm_shared7addressNtB4_7Address6new_id:
   98|    408|    pub const fn new_id(id: u64) -> Self {
   99|    408|        Self {
  100|    408|            payload: Payload::ID(id),
  101|    408|        }
  102|    408|    }

_RNvMs_NtNtCs4pVfV2XJudO_10fvm_shared7address7payloadNtB4_7Payload12to_raw_bytes:
  107|    306|    pub fn to_raw_bytes(self) -> Vec<u8> {
  108|    306|        use Payload::*;
  109|    306|        match self {
  110|    306|            ID(i) => to_leb_bytes(i),
  111|      0|            Secp256k1(arr) => arr.to_vec(),
  112|      0|            Actor(arr) => arr.to_vec(),
  113|      0|            BLS(arr) => arr.to_vec(),
  114|      0|            Delegated(addr) => {
  115|      0|                let mut buf = to_leb_bytes(addr.namespace());
  116|      0|                buf.extend(addr.subaddress());
  117|      0|                buf
  118|       |            }
  119|       |        }
  120|    306|    }
_RNvXs0_NtNtCs4pVfV2XJudO_10fvm_shared7address7payloadNtNtB7_8protocol8ProtocolINtNtCshM4Il2Z0i4R_4core7convert4FromNtB5_7PayloadE4from:
  158|    306|    fn from(pl: Payload) -> Self {
  159|    306|        match pl {
  160|    306|            Payload::ID(_) => Self::ID,
  161|      0|            Payload::Secp256k1(_) => Self::Secp256k1,
  162|      0|            Payload::Actor(_) => Self::Actor,
  163|      0|            Payload::BLS(_) => Self::BLS,
  164|      0|            Payload::Delegated { .. } => Self::Delegated,
  165|       |        }
  166|    306|    }
_RNvMs_NtNtCs4pVfV2XJudO_10fvm_shared7address7payloadNtB4_7Payload8to_bytes:
  123|    306|    pub fn to_bytes(self) -> Vec<u8> {
  124|    306|        let mut bz = self.to_raw_bytes();
  125|    306|        bz.insert(0, Protocol::from(self) as u8);
  126|    306|        bz
  127|    306|    }

_RINvNtNtCs4pVfV2XJudO_10fvm_shared6bigint10bigint_ser11deserializeNtNtCsalhrieD8kwf_12libipld_core4ipld4IpldECsitTtQF8ArIt_8fvm_fuzz:
   46|    306|pub fn deserialize<'de, D>(deserializer: D) -> Result<BigInt, D::Error>
   47|    306|where
   48|    306|    D: serde::Deserializer<'de>,
   49|    306|{
   50|    306|    let bz: Cow<'de, [u8]> = strict_bytes::Deserialize::deserialize(deserializer)?;
   51|    306|    if bz.is_empty() {
   52|    306|        return Ok(BigInt::default());
   53|      0|    }
   54|      0|    let sign_byte = bz[0];
   55|      0|    let sign: Sign = match sign_byte {
   56|      0|        1 => Sign::Minus,
   57|      0|        0 => Sign::Plus,
   58|       |        _ => {
   59|      0|            return Err(serde::de::Error::custom(
   60|      0|                "First byte must be valid sign (0, 1)",
   61|      0|            ));
   62|       |        }
   63|       |    };
   64|       |
   65|      0|    if bz.len() > MAX_BIGINT_SIZE {
   66|      0|        return Err(<D::Error as serde::de::Error>::custom("BigInt too large"));
   67|      0|    }
   68|      0|
   69|      0|    Ok(BigInt::from_bytes_be(sign, &bz[1..]))
   70|    306|}
_RINvNtNtCs4pVfV2XJudO_10fvm_shared6bigint10bigint_ser9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
   24|    306|pub fn serialize<S>(int: &BigInt, serializer: S) -> Result<S::Ok, S::Error>
   25|    306|where
   26|    306|    S: serde::Serializer,
   27|    306|{
   28|    306|    let (sign, mut bz) = int.to_bytes_be();
   29|    306|
   30|    306|    // Insert sign byte at start of encoded bytes
   31|    306|    match sign {
   32|      0|        Sign::Minus => bz.insert(0, 1),
   33|      0|        Sign::Plus => bz.insert(0, 0),
   34|    306|        Sign::NoSign => bz = Vec::new(),
   35|       |    }
   36|       |
   37|    306|    if bz.len() > MAX_BIGINT_SIZE {
   38|      0|        return Err(<S::Error as serde::ser::Error>::custom("BigInt too large"));
   39|    306|    }
   40|    306|
   41|    306|    // Serialize as bytes
   42|    306|    strict_bytes::Serialize::serialize(&bz, serializer)
   43|    306|}

_RNvXs0_NtCs4pVfV2XJudO_10fvm_shared7chainidNtB5_7ChainIDNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
    4|    306|#[derive(Clone, Copy, Debug, Eq, PartialEq)]
_RNvXNtCs4pVfV2XJudO_10fvm_shared7chainidNtB2_7ChainIDINtNtCshM4Il2Z0i4R_4core7convert4FromyE4from:
    8|    204|    fn from(src: u64) -> Self {
    9|    204|        Self(src)
   10|    204|    }

_RINvXsh_NtCs4pVfV2XJudO_10fvm_shared4econNtB6_11TokenAmountNtNtCslVZeVZySzLE_5serde3ser9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
  353|    306|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  354|    306|    where
  355|    306|        S: Serializer,
  356|    306|    {
  357|    306|        bigint_ser::serialize(&self.atto, serializer)
  358|    306|    }
_RNvXsj_NtCs4pVfV2XJudO_10fvm_shared4econNtB5_11TokenAmountNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
   20|    612|#[derive(Clone, PartialEq, Eq, Hash)]
_RNCINvXsi_NtCs4pVfV2XJudO_10fvm_shared4econNtB8_11TokenAmountNtNtCslVZeVZySzLE_5serde2de11Deserialize11deserializeNtNtCsalhrieD8kwf_12libipld_core4ipld4IpldE0CsitTtQF8ArIt_8fvm_fuzz:
  366|    306|        bigint_ser::deserialize(deserializer).map(|v| TokenAmount { atto: v })
_RINvXsi_NtCs4pVfV2XJudO_10fvm_shared4econNtB6_11TokenAmountNtNtCslVZeVZySzLE_5serde2de11Deserialize11deserializeNtNtCsalhrieD8kwf_12libipld_core4ipld4IpldECsitTtQF8ArIt_8fvm_fuzz:
  362|    306|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  363|    306|    where
  364|    306|        D: serde::Deserializer<'de>,
  365|    306|    {
  366|    306|        bigint_ser::deserialize(deserializer).map(|v| TokenAmount { atto: v })
  367|    306|    }
_RNvXs_NtCs4pVfV2XJudO_10fvm_shared4econNtB4_11TokenAmountNtNtCs4qz2OQMshGu_10num_traits10identities4Zero4zero:
   72|    408|    fn zero() -> Self {
   73|    408|        Self {
   74|    408|            atto: BigInt::zero(),
   75|    408|        }
   76|    408|    }
_RNvXs2_NtCs4pVfV2XJudO_10fvm_shared4econNtB5_11TokenAmountNtNtCshM4Il2Z0i4R_4core7default7Default7default:
  100|    306|    fn default() -> TokenAmount {
  101|    306|        TokenAmount::zero()
  102|    306|    }
_RINvMNtCs4pVfV2XJudO_10fvm_shared4econNtB3_11TokenAmount9from_attoyECsitTtQF8ArIt_8fvm_fuzz:
   35|    102|    pub fn from_atto(atto: impl Into<BigInt>) -> Self {
   36|    102|        Self { atto: atto.into() }
   37|    102|    }
_RINvMNtCs4pVfV2XJudO_10fvm_shared4econNtB3_11TokenAmount9from_attoNtNtCs2fUfrN5zbVj_10num_bigint6bigint6BigIntECsitTtQF8ArIt_8fvm_fuzz:
   35|    204|    pub fn from_atto(atto: impl Into<BigInt>) -> Self {
   36|    204|        Self { atto: atto.into() }
   37|    204|    }
_RNvMNtCs4pVfV2XJudO_10fvm_shared4econNtB2_11TokenAmount4atto:
   53|    102|    pub fn atto(&self) -> &BigInt {
   54|    102|        &self.atto
   55|    102|    }
_RNvXs4_NtCs4pVfV2XJudO_10fvm_shared4econNtB5_11TokenAmountNtNtCshM4Il2Z0i4R_4core3fmt7Display3fmt:
  122|    102|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  123|    102|        // Implementation based on the bigdecimal library.
  124|    102|        let (q, r) = self.atto.div_rem(&BigInt::from(Self::PRECISION));
  125|    102|        let before_decimal = q.abs().to_str_radix(10);
  126|    102|        let after_decimal = if r.is_zero() {
  127|      0|            "0".to_string()
  128|       |        } else {
  129|    102|            let fraction_str = r.abs().to_str_radix(10);
  130|    102|            let render = "0".repeat(Self::DECIMALS - fraction_str.len()) + fraction_str.as_str();
  131|    102|            render.trim_end_matches('0').to_string()
  132|       |        };
  133|       |
  134|       |        // Alter precision after the decimal point
  135|    102|        let after_decimal = if let Some(precision) = f.precision() {
  136|      0|            let len = after_decimal.len();
  137|      0|            if len < precision {
  138|      0|                after_decimal + "0".repeat(precision - len).as_str()
  139|       |            } else {
  140|      0|                after_decimal[0..precision].to_string()
  141|       |            }
  142|       |        } else {
  143|    102|            after_decimal
  144|       |        };
  145|       |
  146|       |        // Always show the decimal point, even with ".0".
  147|    102|        let complete_without_sign = before_decimal + "." + after_decimal.as_str();
  148|    102|        // Padding works even though we have a decimal point.
  149|    102|        f.pad_integral(!self.atto().is_negative(), "", &complete_without_sign)
  150|    102|    }
_RINvMNtCs4pVfV2XJudO_10fvm_shared4econNtB3_11TokenAmount10from_wholexEB5_:
   48|      1|    pub fn from_whole(tokens: impl Into<BigInt>) -> Self {
   49|      1|        Self::from_atto(tokens.into() * Self::PRECISION)
   50|      1|    }
_RINvMNtCs4pVfV2XJudO_10fvm_shared4econNtB3_11TokenAmount9from_attoNtNtCs2fUfrN5zbVj_10num_bigint6bigint6BigIntEB5_:
   35|      1|    pub fn from_atto(atto: impl Into<BigInt>) -> Self {
   36|      1|        Self { atto: atto.into() }
   37|      1|    }

_RNvXse_NtCs4pVfV2XJudO_10fvm_shared5errorNtB5_11ErrorNumberNtNtCshM4Il2Z0i4R_4core3fmt5Debug3fmt:
  123|  33.0k|#[derive(Copy, Clone, Eq, Debug, PartialEq, Error, FromPrimitive)]

_RNvXsj_NtNtCs4pVfV2XJudO_10fvm_shared6sector16registered_proofNtB5_19RegisteredSealProofNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
   15|      2|#[derive(PartialEq, Eq, Copy, Clone, Debug, Hash)]
_RINvXst_NtNtCs4pVfV2XJudO_10fvm_shared6sector16registered_proofNtB6_19RegisteredPoStProofNtNtCshM4Il2Z0i4R_4core4hash4Hash4hashNtNtNtNtCsxnqwkJeFav_3std11collections4hash3map13DefaultHasherECs7Ei498kZF3p_3fvm:
   98|      3|#[derive(PartialEq, Eq, Copy, Clone, Debug, Hash)]
_RINvXsl_NtNtCs4pVfV2XJudO_10fvm_shared6sector16registered_proofNtB6_19RegisteredSealProofNtNtCshM4Il2Z0i4R_4core4hash4Hash4hashNtNtNtNtCsxnqwkJeFav_3std11collections4hash3map13DefaultHasherECs7Ei498kZF3p_3fvm:
   15|      4|#[derive(PartialEq, Eq, Copy, Clone, Debug, Hash)]
_RNvXsM_NtNtCs4pVfV2XJudO_10fvm_shared6sector16registered_proofNtB5_19RegisteredSealProofINtNtCshM4Il2Z0i4R_4core7convert4FromxE4from:
  287|  31.7k|            fn from(value: i64) -> Self {
  288|  31.7k|                match value {
  289|      0|                    $( $val => $ty::$var, )*
  290|      0|                    other => $ty::Invalid(other),
  291|       |                }
  292|  31.7k|            }

_RINvXNvNvXs9_NtCs4pVfV2XJudO_10fvm_shared5stateNtBb_9StateRootNtNtCslVZeVZySzLE_5serde2de11Deserialize11deserialize1__NtB5_5InnerBY_11deserializeINtCs872nzRHi4k9_11serde_tuple12DeserializerQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEEECsitTtQF8ArIt_8fvm_fuzz:
   31|    102|#[derive(Deserialize_tuple, Serialize_tuple)]
_RINvXNvNtCs4pVfV2XJudO_10fvm_shared5states_1__NtB5_10StateInfo0NtNtCslVZeVZySzLE_5serde3ser9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
   46|    102|#[derive(Default, Deserialize, Serialize)]
_RINvXs7_NtCs4pVfV2XJudO_10fvm_shared5stateNtB6_16StateTreeVersionNtNtCslVZeVZySzLE_5serde3ser9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
   12|    102|#[derive(Debug, PartialEq, Eq, Clone, Copy, PartialOrd, Serialize_repr, Deserialize_repr)]
_RNvXsb_NtCs4pVfV2XJudO_10fvm_shared5stateNtB5_10StateInfo0NtNtCshM4Il2Z0i4R_4core7default7Default7default:
   46|    102|#[derive(Default, Deserialize, Serialize)]
_RINvXs9_NtCs4pVfV2XJudO_10fvm_shared5stateNtB6_9StateRootNtNtCslVZeVZySzLE_5serde2de11Deserialize11deserializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
   31|    102|#[derive(Deserialize_tuple, Serialize_tuple)]
_RINvXsa_NtCs4pVfV2XJudO_10fvm_shared5stateNtB6_9StateRootNtNtCslVZeVZySzLE_5serde3ser9Serialize9serializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEECsitTtQF8ArIt_8fvm_fuzz:
   31|    102|#[derive(Deserialize_tuple, Serialize_tuple)]
_RINvXNvNvXsa_NtCs4pVfV2XJudO_10fvm_shared5stateNtBb_9StateRootNtNtCslVZeVZySzLE_5serde3ser9Serialize9serialize1__NtB5_5InnerBY_9serializeINtCs872nzRHi4k9_11serde_tuple10SerializerQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor3ser10SerializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils9BufWriterEEECsitTtQF8ArIt_8fvm_fuzz:
   31|    102|#[derive(Deserialize_tuple, Serialize_tuple)]
_RINvXNvXNvNvXs9_NtCs4pVfV2XJudO_10fvm_shared5stateNtBe_9StateRootNtNtCslVZeVZySzLE_5serde2de11Deserialize11deserialize1__NtB8_5InnerB11_11deserializeNtB3_9___VisitorNtB13_7Visitor9visit_seqINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de8AccessorNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
   31|    102|#[derive(Deserialize_tuple, Serialize_tuple)]
_RINvXs8_NtCs4pVfV2XJudO_10fvm_shared5stateNtB6_16StateTreeVersionNtNtCslVZeVZySzLE_5serde2de11Deserialize11deserializeQINtNtCs8loA9e5gPGU_18serde_ipld_dagcbor2de12DeserializerNtNtNtCsda7B5SchGu_7cbor4ii4core5utils11SliceReaderEECsitTtQF8ArIt_8fvm_fuzz:
   12|    102|#[derive(Debug, PartialEq, Eq, Clone, Copy, PartialOrd, Serialize_repr, Deserialize_repr)]

_RNvXs5_NtCs4pVfV2XJudO_10fvm_shared7versionNtB5_14NetworkVersionNtNtCshM4Il2Z0i4R_4core5clone5Clone5clone:
   10|    306|#[derive(Debug, Eq, PartialEq, Clone, Copy, Ord, PartialOrd, Serialize_repr)]
_RNvXs8_NtCs4pVfV2XJudO_10fvm_shared7versionNtB5_14NetworkVersionNtNtCshM4Il2Z0i4R_4core3cmp10PartialOrd11partial_cmp:
   10|    204|#[derive(Debug, Eq, PartialEq, Clone, Copy, Ord, PartialOrd, Serialize_repr)]
_RNvXs0_NtCs4pVfV2XJudO_10fvm_shared7versionNtB5_14NetworkVersionNtNtCshM4Il2Z0i4R_4core3fmt5Debug3fmt:
   10|    102|#[derive(Debug, Eq, PartialEq, Clone, Copy, Ord, PartialOrd, Serialize_repr)]

_RINvNtCs6UoH8pR2orC_21fvm_integration_tests7builtin14set_init_actorNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreECsitTtQF8ArIt_8fvm_fuzz:
   54|    102|pub fn set_init_actor(
   55|    102|    state_tree: &mut StateTree<impl Blockstore>,
   56|    102|    init_code_cid: Cid,
   57|    102|    init_state: init_actor::State,
   58|    102|) -> Result<()> {
   59|    102|    let init_state_cid = state_tree
   60|    102|        .store()
   61|    102|        .put_cbor(&init_state, Code::Blake2b256)
   62|    102|        .context(FailedToSetState("init actor".to_owned()))?;
   63|       |
   64|    102|    let init_actor_state = ActorState {
   65|    102|        code: init_code_cid,
   66|    102|        state: init_state_cid,
   67|    102|        sequence: 0,
   68|    102|        balance: Default::default(),
   69|    102|        address: None,
   70|    102|    };
   71|    102|
   72|    102|    state_tree
   73|    102|        .set_actor(init_actor::INIT_ACTOR_ID, init_actor_state)
   74|    102|        .map_err(anyhow::Error::from)
   75|    102|        .context(FailedToSetActor("init actor".to_owned()))
   76|    102|}
_RINvNtCs6UoH8pR2orC_21fvm_integration_tests7builtin13set_sys_actorNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreECsitTtQF8ArIt_8fvm_fuzz:
   31|    102|pub fn set_sys_actor(
   32|    102|    state_tree: &mut StateTree<impl Blockstore>,
   33|    102|    sys_state: system_actor::State,
   34|    102|    sys_code_cid: Cid,
   35|    102|) -> Result<()> {
   36|    102|    let sys_state_cid = state_tree
   37|    102|        .store()
   38|    102|        .put_cbor(&sys_state, Code::Blake2b256)
   39|    102|        .context(FailedToSetState("system actor".to_owned()))?;
   40|       |
   41|    102|    let sys_actor_state = ActorState {
   42|    102|        code: sys_code_cid,
   43|    102|        state: sys_state_cid,
   44|    102|        sequence: 0,
   45|    102|        balance: Default::default(),
   46|    102|        address: None,
   47|    102|    };
   48|    102|    state_tree
   49|    102|        .set_actor(system_actor::SYSTEM_ACTOR_ID, sys_actor_state)
   50|    102|        .map_err(anyhow::Error::from)
   51|    102|        .context(FailedToSetActor("system actor".to_owned()))
   52|    102|}
_RINvNtCs6UoH8pR2orC_21fvm_integration_tests7builtin13set_eam_actorNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreECsitTtQF8ArIt_8fvm_fuzz:
   78|    102|pub fn set_eam_actor(state_tree: &mut StateTree<impl Blockstore>, eam_code_cid: Cid) -> Result<()> {
   79|       |    const EAM_ACTOR_ID: ActorID = 10;
   80|       |
   81|    102|    let eam_state_cid = state_tree
   82|    102|        .store()
   83|    102|        .put_cbor(&[(); 0], Code::Blake2b256)
   84|    102|        .context(FailedToSetState("eam actor".to_owned()))?;
   85|       |
   86|    102|    let eam_actor_state = ActorState {
   87|    102|        code: eam_code_cid,
   88|    102|        state: eam_state_cid,
   89|    102|        sequence: 0,
   90|    102|        balance: Default::default(),
   91|    102|        address: None,
   92|    102|    };
   93|    102|
   94|    102|    state_tree
   95|    102|        .set_actor(EAM_ACTOR_ID, eam_actor_state)
   96|    102|        .map_err(anyhow::Error::from)
   97|    102|        .context(FailedToSetActor("eam actor".to_owned()))
   98|    102|}
_RINvNtCs6UoH8pR2orC_21fvm_integration_tests7builtin22fetch_builtin_code_cidNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreECsitTtQF8ArIt_8fvm_fuzz:
   16|    102|pub fn fetch_builtin_code_cid(
   17|    102|    blockstore: &impl Blockstore,
   18|    102|    builtin_actors: &Cid,
   19|    102|    ver: u32,
   20|    102|) -> Result<(Cid, Cid, Cid, Cid, Cid)> {
   21|    102|    let manifest = Manifest::load(blockstore, builtin_actors, ver).context(FailedToLoadManifest)?;
   22|    102|    Ok((
   23|    102|        *manifest.get_system_code(),
   24|    102|        *manifest.get_init_code(),
   25|    102|        *manifest.get_account_code(),
   26|    102|        *manifest.get_embryo_code(),
   27|    102|        *manifest.get_eam_code(),
   28|    102|    ))
   29|    102|}

_RNCINvNtCs6UoH8pR2orC_21fvm_integration_tests6bundle13import_bundleNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreE0CsitTtQF8ArIt_8fvm_fuzz:
   11|    102|    match &*block_on(async { load_car_unchecked(blockstore, bundle).await })? {
_RINvNtCs6UoH8pR2orC_21fvm_integration_tests6bundle13import_bundleNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreECsitTtQF8ArIt_8fvm_fuzz:
   10|    102|pub fn import_bundle(blockstore: &impl Blockstore, bundle: &[u8]) -> anyhow::Result<Cid> {
   11|    102|    match &*block_on(async { load_car_unchecked(blockstore, bundle).await })? {
   12|    102|        [root] => Ok(*root),
   13|      0|        _ => Err(anyhow!("multiple root CIDs in bundle")),
   14|       |    }
   15|    102|}

_RNCNvMNtCs6UoH8pR2orC_21fvm_integration_tests6testerINtB4_6TesterNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtB6_5dummy12DummyExternsE19instantiate_machines_0CsitTtQF8ArIt_8fvm_fuzz:
  221|    102|        self.instantiate_machine_with_config(externs, |_| (), |_| ())
_RINvMNtCs6UoH8pR2orC_21fvm_integration_tests6testerINtB3_6TesterNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtB5_5dummy12DummyExternsE31instantiate_machine_with_configNCNvB2_19instantiate_machine0NCB33_s_0ECsitTtQF8ArIt_8fvm_fuzz:
  229|    102|    pub fn instantiate_machine_with_config<F, G>(
  230|    102|        &mut self,
  231|    102|        externs: E,
  232|    102|        configure_nc: F,
  233|    102|        configure_mc: G,
  234|    102|    ) -> Result<()>
  235|    102|    where
  236|    102|        F: FnOnce(&mut NetworkConfig),
  237|    102|        G: FnOnce(&mut MachineContext),
  238|    102|    {
  239|    102|        // Take the state tree and leave None behind.
  240|    102|        let mut state_tree = self.state_tree.take().unwrap();
  241|       |
  242|       |        // Calculate the state root.
  243|    102|        let state_root = state_tree
  244|    102|            .flush()
  245|    102|            .map_err(anyhow::Error::from)
  246|    102|            .context(FailedToFlushTree)?;
  247|       |
  248|       |        // Consume the state tree and take the blockstore.
  249|    102|        let blockstore = state_tree.into_store();
  250|    102|
  251|    102|        let mut nc = NetworkConfig::new(self.nv);
  252|    102|        nc.override_actors(self.builtin_actors);
  253|    102|        nc.enable_actor_debugging();
  254|    102|
  255|    102|        // Custom configuration.
  256|    102|        configure_nc(&mut nc);
  257|    102|
  258|    102|        let mut mc = nc.for_epoch(0, 0, state_root);
  259|    102|        mc.set_base_fee(TokenAmount::from_atto(DEFAULT_BASE_FEE))
  260|    102|            .enable_tracing();
  261|    102|
  262|    102|        // Custom configuration.
  263|    102|        configure_mc(&mut mc);
  264|       |
  265|    102|        let engine = EnginePool::new_default((&mc.network.clone()).into())?;
  266|    102|        engine.acquire().preload(&blockstore, &self.code_cids)?;
  267|       |
  268|    102|        let machine = DefaultMachine::new(&mc, blockstore, externs)?;
  269|       |
  270|    102|        let executor =
  271|    102|            DefaultExecutor::<DefaultKernel<DefaultCallManager<DefaultMachine<B, E>>>>::new(
  272|    102|                engine, machine,
  273|    102|            )?;
  274|       |
  275|    102|        self.executor = Some(executor);
  276|    102|
  277|    102|        Ok(())
  278|    102|    }
_RNCNvMNtCs6UoH8pR2orC_21fvm_integration_tests6testerINtB4_6TesterNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtB6_5dummy12DummyExternsE19instantiate_machine0CsitTtQF8ArIt_8fvm_fuzz:
  221|    102|        self.instantiate_machine_with_config(externs, |_| (), |_| ())
_RNvMNtCs6UoH8pR2orC_21fvm_integration_tests6testerINtB2_6TesterNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtB4_5dummy12DummyExternsE3newCsitTtQF8ArIt_8fvm_fuzz:
   61|    102|    pub fn new(
   62|    102|        nv: NetworkVersion,
   63|    102|        stv: StateTreeVersion,
   64|    102|        builtin_actors: Cid,
   65|    102|        blockstore: B,
   66|    102|    ) -> Result<Self> {
   67|    102|        let (manifest_version, manifest_data_cid): (u32, Cid) =
   68|    102|            match blockstore.get_cbor(&builtin_actors)? {
   69|    102|                Some((manifest_version, manifest_data)) => (manifest_version, manifest_data),
   70|      0|                None => return Err(NoManifestInformation(builtin_actors).into()),
   71|       |            };
   72|       |
   73|       |        // Get sys and init actors code cid
   74|    102|        let (sys_code_cid, init_code_cid, accounts_code_cid, embryo_code_cid, eam_code_cid) =
   75|    102|            fetch_builtin_code_cid(&blockstore, &manifest_data_cid, manifest_version)?;
   76|       |
   77|       |        // Initialize state tree
   78|    102|        let init_state = init_actor::State::new_test(&blockstore);
   79|    102|        let mut state_tree = StateTree::new(blockstore, stv).map_err(anyhow::Error::from)?;
   80|       |
   81|       |        // Deploy init, sys, and eam actors
   82|    102|        let sys_state = system_actor::State { builtin_actors };
   83|    102|        set_sys_actor(&mut state_tree, sys_state, sys_code_cid)?;
   84|    102|        set_init_actor(&mut state_tree, init_code_cid, init_state)?;
   85|    102|        set_eam_actor(&mut state_tree, eam_code_cid)?;
   86|       |
   87|    102|        Ok(Tester {
   88|    102|            nv,
   89|    102|            builtin_actors,
   90|    102|            executor: None,
   91|    102|            code_cids: vec![],
   92|    102|            state_tree: Some(state_tree),
   93|    102|            accounts_code_cid,
   94|    102|            embryo_code_cid,
   95|    102|        })
   96|    102|    }
_RNvMNtCs6UoH8pR2orC_21fvm_integration_tests6testerINtB2_6TesterNtNtCs6SqvG5Yde5c_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtB4_5dummy12DummyExternsE19instantiate_machineCsitTtQF8ArIt_8fvm_fuzz:
  220|    102|    pub fn instantiate_machine(&mut self, externs: E) -> Result<()> {
  221|    102|        self.instantiate_machine_with_config(externs, |_| (), |_| ())
  222|    102|    }

