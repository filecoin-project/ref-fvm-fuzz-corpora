_RINvXNtCsbqblzDQlyxB_6anyhow7contextINtNtCsiloedr2K6v7_4core6result6ResultINtNtCslH3pn9Bu6yX_13fvm_ipld_hamt4hamt4HamtINtNtNtCskJihg1y13m7_3fvm10blockstore8buffered18BufferedBlockstoreNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreENtNtB1Z_10state_tree10ActorStateENtNtB1f_5error5ErrorEINtB5_7ContextB1a_B4w_E7contextReECsboUdcTbF1FS_15direct_syscalls:
   46|    318|    fn context<C>(self, context: C) -> Result<T, Error>
   47|    318|    where
   48|    318|        C: Display + Send + Sync + 'static,
   49|    318|    {
   50|    318|        // Not using map_err to save 2 useless frames off the captured backtrace
   51|    318|        // in ext_context.
   52|    318|        match self {
   53|    318|            Ok(ok) => Ok(ok),
   54|      0|            Err(error) => Err(error.ext_context(context)),
   55|       |        }
   56|    318|    }
_RINvXNtCsbqblzDQlyxB_6anyhow7contextINtNtCsiloedr2K6v7_4core6result6ResultbNtB5_5ErrorEINtB5_7ContextbB1b_E7contextReECsboUdcTbF1FS_15direct_syscalls:
   46|    318|    fn context<C>(self, context: C) -> Result<T, Error>
   47|    318|    where
   48|    318|        C: Display + Send + Sync + 'static,
   49|    318|    {
   50|    318|        // Not using map_err to save 2 useless frames off the captured backtrace
   51|    318|        // in ext_context.
   52|    318|        match self {
   53|    318|            Ok(ok) => Ok(ok),
   54|      0|            Err(error) => Err(error.ext_context(context)),
   55|       |        }
   56|    318|    }
_RINvXs_NtCsbqblzDQlyxB_6anyhow7contextINtNtCsiloedr2K6v7_4core6option6OptionTmINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEEINtB7_7ContextB1c_NtNtBF_7convert10InfallibleE7contextReECsboUdcTbF1FS_15direct_syscalls:
   91|    318|    fn context<C>(self, context: C) -> Result<T, Error>
   92|    318|    where
   93|    318|        C: Display + Send + Sync + 'static,
   94|    318|    {
   95|    318|        self.ok_or_else(|| Error::from_display(context, backtrace!()))
   96|    318|    }
_RINvXNtCsbqblzDQlyxB_6anyhow7contextINtNtCsiloedr2K6v7_4core6result6ResultINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_ENtB5_5ErrorEINtB5_7ContextB1a_B1L_E7contextNtNtCsh74LAqVwWKW_21fvm_integration_tests5error5ErrorECsboUdcTbF1FS_15direct_syscalls:
   46|    318|    fn context<C>(self, context: C) -> Result<T, Error>
   47|    318|    where
   48|    318|        C: Display + Send + Sync + 'static,
   49|    318|    {
   50|    318|        // Not using map_err to save 2 useless frames off the captured backtrace
   51|    318|        // in ext_context.
   52|    318|        match self {
   53|    318|            Ok(ok) => Ok(ok),
   54|      0|            Err(error) => Err(error.ext_context(context)),
   55|       |        }
   56|    318|    }
_RINvXs_NtCsbqblzDQlyxB_6anyhow7contextINtNtCsiloedr2K6v7_4core6option6OptionRINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEINtB7_7ContextB1c_NtNtBF_7convert10InfallibleE7contextReECsboUdcTbF1FS_15direct_syscalls:
   91|  1.90k|    fn context<C>(self, context: C) -> Result<T, Error>
   92|  1.90k|    where
   93|  1.90k|        C: Display + Send + Sync + 'static,
   94|  1.90k|    {
   95|  1.90k|        self.ok_or_else(|| Error::from_display(context, backtrace!()))
   96|  1.90k|    }
_RINvXNtCsbqblzDQlyxB_6anyhow7contextINtNtCsiloedr2K6v7_4core6result6ResultINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_ENtB5_5ErrorEINtB5_7ContextB1a_B1L_E7contextReECs7AwuCMXPzRZ_8fvm_fuzz:
   46|    318|    fn context<C>(self, context: C) -> Result<T, Error>
   47|    318|    where
   48|    318|        C: Display + Send + Sync + 'static,
   49|    318|    {
   50|    318|        // Not using map_err to save 2 useless frames off the captured backtrace
   51|    318|        // in ext_context.
   52|    318|        match self {
   53|    318|            Ok(ok) => Ok(ok),
   54|      0|            Err(error) => Err(error.ext_context(context)),
   55|       |        }
   56|    318|    }
_RINvXs_NtCsbqblzDQlyxB_6anyhow7contextINtNtCsiloedr2K6v7_4core6option6OptionRINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEINtB7_7ContextB1c_NtNtBF_7convert10InfallibleE7contextReECs7AwuCMXPzRZ_8fvm_fuzz:
   91|  1.90k|    fn context<C>(self, context: C) -> Result<T, Error>
   92|  1.90k|    where
   93|  1.90k|        C: Display + Send + Sync + 'static,
   94|  1.90k|    {
   95|  1.90k|        self.ok_or_else(|| Error::from_display(context, backtrace!()))
   96|  1.90k|    }
_RINvXNtCsbqblzDQlyxB_6anyhow7contextINtNtCsiloedr2K6v7_4core6result6ResultINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_ENtB5_5ErrorEINtB5_7ContextB1a_B1L_E7contextNtNtCsh74LAqVwWKW_21fvm_integration_tests5error5ErrorECs7AwuCMXPzRZ_8fvm_fuzz:
   46|    954|    fn context<C>(self, context: C) -> Result<T, Error>
   47|    954|    where
   48|    954|        C: Display + Send + Sync + 'static,
   49|    954|    {
   50|    954|        // Not using map_err to save 2 useless frames off the captured backtrace
   51|    954|        // in ext_context.
   52|    954|        match self {
   53|    954|            Ok(ok) => Ok(ok),
   54|      0|            Err(error) => Err(error.ext_context(context)),
   55|       |        }
   56|    954|    }
_RINvXNtCsbqblzDQlyxB_6anyhow7contextINtNtCsiloedr2K6v7_4core6result6ResultNtNtNtCskJihg1y13m7_3fvm7machine8manifest8ManifestNtB5_5ErrorEINtB5_7ContextB1a_B1Y_E7contextNtNtCsh74LAqVwWKW_21fvm_integration_tests5error5ErrorECs7AwuCMXPzRZ_8fvm_fuzz:
   46|    318|    fn context<C>(self, context: C) -> Result<T, Error>
   47|    318|    where
   48|    318|        C: Display + Send + Sync + 'static,
   49|    318|    {
   50|    318|        // Not using map_err to save 2 useless frames off the captured backtrace
   51|    318|        // in ext_context.
   52|    318|        match self {
   53|    318|            Ok(ok) => Ok(ok),
   54|      0|            Err(error) => Err(error.ext_context(context)),
   55|       |        }
   56|    318|    }
_RINvXNtCsbqblzDQlyxB_6anyhow7contextINtNtCsiloedr2K6v7_4core6result6ResultuNtB5_5ErrorEINtB5_7ContextuB1b_E7contextNtNtCsh74LAqVwWKW_21fvm_integration_tests5error5ErrorECs7AwuCMXPzRZ_8fvm_fuzz:
   46|    954|    fn context<C>(self, context: C) -> Result<T, Error>
   47|    954|    where
   48|    954|        C: Display + Send + Sync + 'static,
   49|    954|    {
   50|    954|        // Not using map_err to save 2 useless frames off the captured backtrace
   51|    954|        // in ext_context.
   52|    954|        match self {
   53|    954|            Ok(ok) => Ok(ok),
   54|      0|            Err(error) => Err(error.ext_context(context)),
   55|       |        }
   56|    954|    }
_RINvXs_NtCsbqblzDQlyxB_6anyhow7contextINtNtCsiloedr2K6v7_4core6option6OptionRNtNtCskJihg1y13m7_3fvm10state_tree14StateSnapLayerEINtB7_7ContextB1c_NtNtBF_7convert10InfallibleE7contextReEB1h_:
   91|    954|    fn context<C>(self, context: C) -> Result<T, Error>
   92|    954|    where
   93|    954|        C: Display + Send + Sync + 'static,
   94|    954|    {
   95|    954|        self.ok_or_else(|| Error::from_display(context, backtrace!()))
   96|    954|    }
_RINvXNtCsbqblzDQlyxB_6anyhow7contextINtNtCsiloedr2K6v7_4core6result6ResultNtNtCslvZ9xuS3Qdd_16wasmtime_runtime4mmap4MmapNtB5_5ErrorEINtB5_7ContextB1a_B1U_E7contextReEB1e_:
   46|  1.90k|    fn context<C>(self, context: C) -> Result<T, Error>
   47|  1.90k|    where
   48|  1.90k|        C: Display + Send + Sync + 'static,
   49|  1.90k|    {
   50|  1.90k|        // Not using map_err to save 2 useless frames off the captured backtrace
   51|  1.90k|        // in ext_context.
   52|  1.90k|        match self {
   53|  1.90k|            Ok(ok) => Ok(ok),
   54|      0|            Err(error) => Err(error.ext_context(context)),
   55|       |        }
   56|  1.90k|    }
_RINvXNtCsbqblzDQlyxB_6anyhow7contextINtNtCsiloedr2K6v7_4core6result6ResultONtNtBD_3ffi6c_voidNtNtNtNtCs8bE1srDPHCS_6rustix7backend2io5errno5ErrnoEINtB5_7ContextB1a_B1t_E7contextNtNtCs9pDt8l5wGDA_5alloc6string6StringECslvZ9xuS3Qdd_16wasmtime_runtime:
   46|  2.54k|    fn context<C>(self, context: C) -> Result<T, Error>
   47|  2.54k|    where
   48|  2.54k|        C: Display + Send + Sync + 'static,
   49|  2.54k|    {
   50|  2.54k|        // Not using map_err to save 2 useless frames off the captured backtrace
   51|  2.54k|        // in ext_context.
   52|  2.54k|        match self {
   53|  2.54k|            Ok(ok) => Ok(ok),
   54|      0|            Err(error) => Err(error.ext_context(context)),
   55|       |        }
   56|  2.54k|    }

_RNCNvXs8_CsjfqZscuWrMJ_9arbitraryAhj186a0_NtB7_9Arbitrary9arbitrary0CsboUdcTbF1FS_15direct_syscalls:
  641|  31.8M|        try_create_array(|_| <T as Arbitrary<'a>>::arbitrary(u))
_RNCNvXs8_CsjfqZscuWrMJ_9arbitraryAmja_NtB7_9Arbitrary9arbitrary0CsboUdcTbF1FS_15direct_syscalls:
  641|  3.18k|        try_create_array(|_| <T as Arbitrary<'a>>::arbitrary(u))
_RNvXs8_CsjfqZscuWrMJ_9arbitraryAhj186a0_NtB5_9Arbitrary9arbitraryCsboUdcTbF1FS_15direct_syscalls:
  640|    318|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  641|    318|        try_create_array(|_| <T as Arbitrary<'a>>::arbitrary(u))
  642|    318|    }
_RNvXs8_CsjfqZscuWrMJ_9arbitraryAmja_NtB5_9Arbitrary9arbitraryCsboUdcTbF1FS_15direct_syscalls:
  640|    318|    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  641|    318|        try_create_array(|_| <T as Arbitrary<'a>>::arbitrary(u))
  642|    318|    }
_RINvCsjfqZscuWrMJ_9arbitrary16try_create_arrayNCNvXs8_B2_Ahj186a0_NtB2_9Arbitrary9arbitrary0hKBV_ECsboUdcTbF1FS_15direct_syscalls:
  614|    318|fn try_create_array<F, T, const N: usize>(mut cb: F) -> Result<[T; N]>
  615|    318|where
  616|    318|    F: FnMut(usize) -> Result<T>,
  617|    318|{
  618|    318|    let mut array: mem::MaybeUninit<[T; N]> = mem::MaybeUninit::uninit();
  619|    318|    let array_ptr = array.as_mut_ptr();
  620|    318|    let dst = array_ptr as _;
  621|    318|    let mut guard: ArrayGuard<T, N> = ArrayGuard {
  622|    318|        dst,
  623|    318|        initialized: 0,
  624|    318|    };
  625|       |    unsafe {
  626|  31.8M|        for (idx, value_ptr) in (*array.as_mut_ptr()).iter_mut().enumerate() {
  627|  31.8M|            core::ptr::write(value_ptr, cb(idx)?);
  628|  31.8M|            guard.initialized += 1;
  629|       |        }
  630|    318|        mem::forget(guard);
  631|    318|        Ok(array.assume_init())
  632|       |    }
  633|    318|}
_RINvCsjfqZscuWrMJ_9arbitrary16try_create_arrayNCNvXs8_B2_Amja_NtB2_9Arbitrary9arbitrary0mKBV_ECsboUdcTbF1FS_15direct_syscalls:
  614|    318|fn try_create_array<F, T, const N: usize>(mut cb: F) -> Result<[T; N]>
  615|    318|where
  616|    318|    F: FnMut(usize) -> Result<T>,
  617|    318|{
  618|    318|    let mut array: mem::MaybeUninit<[T; N]> = mem::MaybeUninit::uninit();
  619|    318|    let array_ptr = array.as_mut_ptr();
  620|    318|    let dst = array_ptr as _;
  621|    318|    let mut guard: ArrayGuard<T, N> = ArrayGuard {
  622|    318|        dst,
  623|    318|        initialized: 0,
  624|    318|    };
  625|       |    unsafe {
  626|  3.18k|        for (idx, value_ptr) in (*array.as_mut_ptr()).iter_mut().enumerate() {
  627|  3.18k|            core::ptr::write(value_ptr, cb(idx)?);
  628|  3.18k|            guard.initialized += 1;
  629|       |        }
  630|    318|        mem::forget(guard);
  631|    318|        Ok(array.assume_init())
  632|       |    }
  633|    318|}
_RNvXsJ_CsjfqZscuWrMJ_9arbitraryoNtB5_9Arbitrary9arbitrary:
  309|    318|                fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  310|    318|                    let mut buf = [0; mem::size_of::<$ty>()];
  311|    318|                    u.fill_buffer(&mut buf)?;
  312|    318|                    let mut x: $unsigned = 0;
  313|  5.08k|                    for i in 0..mem::size_of::<$ty>() {
  314|  5.08k|                        x |= buf[i] as $unsigned << (i * 8);
  315|  5.08k|                    }
  316|    318|                    Ok(x as $ty)
  317|    318|                }
_RNvXsH_CsjfqZscuWrMJ_9arbitrarymNtB5_9Arbitrary9arbitrary:
  309|  3.81k|                fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  310|  3.81k|                    let mut buf = [0; mem::size_of::<$ty>()];
  311|  3.81k|                    u.fill_buffer(&mut buf)?;
  312|  3.81k|                    let mut x: $unsigned = 0;
  313|  15.2k|                    for i in 0..mem::size_of::<$ty>() {
  314|  15.2k|                        x |= buf[i] as $unsigned << (i * 8);
  315|  15.2k|                    }
  316|  3.81k|                    Ok(x as $ty)
  317|  3.81k|                }
_RNvXsF_CsjfqZscuWrMJ_9arbitraryhNtB5_9Arbitrary9arbitrary:
  309|  31.8M|                fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  310|  31.8M|                    let mut buf = [0; mem::size_of::<$ty>()];
  311|  31.8M|                    u.fill_buffer(&mut buf)?;
  312|  31.8M|                    let mut x: $unsigned = 0;
  313|  31.8M|                    for i in 0..mem::size_of::<$ty>() {
  314|  31.8M|                        x |= buf[i] as $unsigned << (i * 8);
  315|  31.8M|                    }
  316|  31.8M|                    Ok(x as $ty)
  317|  31.8M|                }
_RNvXsI_CsjfqZscuWrMJ_9arbitraryyNtB5_9Arbitrary9arbitrary:
  309|  2.22k|                fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  310|  2.22k|                    let mut buf = [0; mem::size_of::<$ty>()];
  311|  2.22k|                    u.fill_buffer(&mut buf)?;
  312|  2.22k|                    let mut x: $unsigned = 0;
  313|  17.8k|                    for i in 0..mem::size_of::<$ty>() {
  314|  17.8k|                        x |= buf[i] as $unsigned << (i * 8);
  315|  17.8k|                    }
  316|  2.22k|                    Ok(x as $ty)
  317|  2.22k|                }
_RNvXsO_CsjfqZscuWrMJ_9arbitraryxNtB5_9Arbitrary9arbitrary:
  309|    318|                fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
  310|    318|                    let mut buf = [0; mem::size_of::<$ty>()];
  311|    318|                    u.fill_buffer(&mut buf)?;
  312|    318|                    let mut x: $unsigned = 0;
  313|  2.54k|                    for i in 0..mem::size_of::<$ty>() {
  314|  2.54k|                        x |= buf[i] as $unsigned << (i * 8);
  315|  2.54k|                    }
  316|    318|                    Ok(x as $ty)
  317|    318|                }

_RINvMNtCsjfqZscuWrMJ_9arbitrary12unstructuredNtB3_12Unstructured9arbitraryoECsboUdcTbF1FS_15direct_syscalls:
  167|    318|    pub fn arbitrary<A>(&mut self) -> Result<A>
  168|    318|    where
  169|    318|        A: Arbitrary<'a>,
  170|    318|    {
  171|    318|        <A as Arbitrary<'a>>::arbitrary(self)
  172|    318|    }
_RINvMNtCsjfqZscuWrMJ_9arbitrary12unstructuredNtB3_12Unstructured9arbitraryAmja_ECsboUdcTbF1FS_15direct_syscalls:
  167|    318|    pub fn arbitrary<A>(&mut self) -> Result<A>
  168|    318|    where
  169|    318|        A: Arbitrary<'a>,
  170|    318|    {
  171|    318|        <A as Arbitrary<'a>>::arbitrary(self)
  172|    318|    }
_RINvMNtCsjfqZscuWrMJ_9arbitrary12unstructuredNtB3_12Unstructured9arbitraryxECsboUdcTbF1FS_15direct_syscalls:
  167|    318|    pub fn arbitrary<A>(&mut self) -> Result<A>
  168|    318|    where
  169|    318|        A: Arbitrary<'a>,
  170|    318|    {
  171|    318|        <A as Arbitrary<'a>>::arbitrary(self)
  172|    318|    }
_RINvMNtCsjfqZscuWrMJ_9arbitrary12unstructuredNtB3_12Unstructured9arbitraryAhj186a0_ECsboUdcTbF1FS_15direct_syscalls:
  167|    318|    pub fn arbitrary<A>(&mut self) -> Result<A>
  168|    318|    where
  169|    318|        A: Arbitrary<'a>,
  170|    318|    {
  171|    318|        <A as Arbitrary<'a>>::arbitrary(self)
  172|    318|    }
_RINvMNtCsjfqZscuWrMJ_9arbitrary12unstructuredNtB3_12Unstructured9arbitrarymECsboUdcTbF1FS_15direct_syscalls:
  167|    636|    pub fn arbitrary<A>(&mut self) -> Result<A>
  168|    636|    where
  169|    636|        A: Arbitrary<'a>,
  170|    636|    {
  171|    636|        <A as Arbitrary<'a>>::arbitrary(self)
  172|    636|    }
_RINvMNtCsjfqZscuWrMJ_9arbitrary12unstructuredNtB3_12Unstructured9arbitraryyECsboUdcTbF1FS_15direct_syscalls:
  167|  2.22k|    pub fn arbitrary<A>(&mut self) -> Result<A>
  168|  2.22k|    where
  169|  2.22k|        A: Arbitrary<'a>,
  170|  2.22k|    {
  171|  2.22k|        <A as Arbitrary<'a>>::arbitrary(self)
  172|  2.22k|    }
_RNvMNtCsjfqZscuWrMJ_9arbitrary12unstructuredNtB2_12Unstructured3new:
   85|    318|    pub fn new(data: &'a [u8]) -> Self {
   86|    318|        Unstructured { data }
   87|    318|    }
_RNvMNtCsjfqZscuWrMJ_9arbitrary12unstructuredNtB2_12Unstructured11fill_buffer:
  521|  31.8M|    pub fn fill_buffer(&mut self, buffer: &mut [u8]) -> Result<()> {
  522|  31.8M|        let n = std::cmp::min(buffer.len(), self.data.len());
  523|  31.8M|        buffer[..n].copy_from_slice(&self.data[..n]);
  524|  31.8M|        for byte in buffer[n..].iter_mut() {
  525|  31.8M|            *byte = 0;
  526|  31.8M|        }
  527|  31.8M|        self.data = &self.data[n..];
  528|  31.8M|        Ok(())
  529|  31.8M|    }

_RINvNvNtCseOUJsTo2fy1_12blake2b_simd4avx214compress_block9as_arraysyEB6_:
  240|  2.86k|            unsafe fn as_arrays<T>(a: &mut [T; $( $len + )* 0 ]) -> ( $( &mut [T; $len], )* ) {
  241|  2.86k|                let mut p = a.as_mut_ptr();
  242|  2.86k|                ( $( {
  243|  2.86k|                    let aref = &mut *(p as *mut [T; $len]);
  244|  2.86k|                    p = p.offset($len as isize);
  245|  2.86k|                    aref
  246|  2.86k|                } ),* )
  247|  2.86k|            }
_RINvNvNtCseOUJsTo2fy1_12blake2b_simd4avx214compress_blocks_9as_arraysyEB6_:
  143|  2.86k|            unsafe fn as_arrays<T>(a: &[T; $( $len + )* 0 ]) -> ( $( &[T; $len], )* ) {
  144|  2.86k|                let mut p = a.as_ptr();
  145|  2.86k|                ( $( {
  146|  2.86k|                    let aref = &*(p as *const [T; $len]);
  147|  2.86k|                    p = p.offset($len as isize);
  148|  2.86k|                    aref
  149|  2.86k|                } ),* )
  150|  2.86k|            }
_RINvNvNtCseOUJsTo2fy1_12blake2b_simd4avx214compress_blocks0_9as_arrayshEB6_:
  143|  2.86k|            unsafe fn as_arrays<T>(a: &[T; $( $len + )* 0 ]) -> ( $( &[T; $len], )* ) {
  144|  2.86k|                let mut p = a.as_ptr();
  145|  2.86k|                ( $( {
  146|  2.86k|                    let aref = &*(p as *const [T; $len]);
  147|  2.86k|                    p = p.offset($len as isize);
  148|  2.86k|                    aref
  149|  2.86k|                } ),* )
  150|  2.86k|            }
_RINvNvCseOUJsTo2fy1_12blake2b_simd20state_words_to_bytes9as_arrayshEB4_:
  240|  2.22k|            unsafe fn as_arrays<T>(a: &mut [T; $( $len + )* 0 ]) -> ( $( &mut [T; $len], )* ) {
  241|  2.22k|                let mut p = a.as_mut_ptr();
  242|  2.22k|                ( $( {
  243|  2.22k|                    let aref = &mut *(p as *mut [T; $len]);
  244|  2.22k|                    p = p.offset($len as isize);
  245|  2.22k|                    aref
  246|  2.22k|                } ),* )
  247|  2.22k|            }
_RINvNvNtCseOUJsTo2fy1_12blake2b_simd4guts11final_block8as_arrayhEB6_:
   61|    318|            unsafe fn as_array<T>(slice: &[T]) -> &[T; $len] {
   62|    318|                &*(slice.as_ptr() as *const [_; $len])
   63|    318|            }
_RINvNvMCseOUJsTo2fy1_12blake2b_simdNtB5_6Params8to_words9as_arrayshEB5_:
  143|  2.22k|            unsafe fn as_arrays<T>(a: &[T; $( $len + )* 0 ]) -> ( $( &[T; $len], )* ) {
  144|  2.22k|                let mut p = a.as_ptr();
  145|  2.22k|                ( $( {
  146|  2.22k|                    let aref = &*(p as *const [T; $len]);
  147|  2.22k|                    p = p.offset($len as isize);
  148|  2.22k|                    aref
  149|  2.22k|                } ),* )
  150|  2.22k|            }
_RINvNvMCseOUJsTo2fy1_12blake2b_simdNtB5_6Params8to_wordss_9as_arrayshEB5_:
  143|  2.22k|            unsafe fn as_arrays<T>(a: &[T; $( $len + )* 0 ]) -> ( $( &[T; $len], )* ) {
  144|  2.22k|                let mut p = a.as_ptr();
  145|  2.22k|                ( $( {
  146|  2.22k|                    let aref = &*(p as *const [T; $len]);
  147|  2.22k|                    p = p.offset($len as isize);
  148|  2.22k|                    aref
  149|  2.22k|                } ),* )
  150|  2.22k|            }

_RNvCsfaGt87LuTPA_4atty2is:
   40|    318|pub fn is(stream: Stream) -> bool {
   41|       |    extern crate libc;
   42|       |
   43|    318|    let fd = match stream {
   44|      0|        Stream::Stdout => libc::STDOUT_FILENO,
   45|    318|        Stream::Stderr => libc::STDERR_FILENO,
   46|      0|        Stream::Stdin => libc::STDIN_FILENO,
   47|       |    };
   48|    318|    unsafe { libc::isatty(fd) != 0 }
   49|    318|}

_RNvMsd_NtNtNtCs8bE1srDPHCS_6rustix7backend2mm5typesNtB5_9ProtFlags5empty:
  526|  1.27k|            pub const fn empty() -> Self {
  527|  1.27k|                Self { bits: 0 }
  528|  1.27k|            }
_RNvXse_NtNtNtCs8bE1srDPHCS_6rustix7backend2mm5typesNtB5_9ProtFlagsNtNtNtCsiloedr2K6v7_4core3ops3bit5BitOr5bitor:
  731|  1.27k|            fn bitor(self, other: $BitFlags) -> Self {
  732|  1.27k|                Self { bits: self.bits | other.bits }
  733|  1.27k|            }
_RNvMs13_NtNtNtCs8bE1srDPHCS_6rustix7backend2mm5typesNtB6_8MapFlags4bits:
  545|  2.54k|            pub const fn bits(&self) -> $T {
  546|  2.54k|                self.bits
  547|  2.54k|            }
_RNvMsd_NtNtNtCs8bE1srDPHCS_6rustix7backend2mm5typesNtB5_9ProtFlags4bits:
  545|  2.54k|            pub const fn bits(&self) -> $T {
  546|  2.54k|                self.bits
  547|  2.54k|            }

_RNvNtCseOUJsTo2fy1_12blake2b_simd4avx25loadu:
   18|  11.4k|unsafe fn loadu(src: *const [Word; DEGREE]) -> __m256i {
   19|  11.4k|    // This is an unaligned load, so the pointer cast is allowed.
   20|  11.4k|    _mm256_loadu_si256(src as *const __m256i)
   21|  11.4k|}
_RNvNtCseOUJsTo2fy1_12blake2b_simd4avx25rot24:
   92|  68.6k|unsafe fn rot24(x: __m256i) -> __m256i {
   93|  68.6k|    _mm256_or_si256(_mm256_srli_epi64(x, 24), _mm256_slli_epi64(x, 64 - 24))
   94|  68.6k|}
_RNvNtCseOUJsTo2fy1_12blake2b_simd4avx23xor:
   56|   289k|unsafe fn xor(a: __m256i, b: __m256i) -> __m256i {
   57|   289k|    _mm256_xor_si256(a, b)
   58|   289k|}
_RNvNtCseOUJsTo2fy1_12blake2b_simd4avx24set4:
   66|  2.86k|unsafe fn set4(a: u64, b: u64, c: u64, d: u64) -> __m256i {
   67|  2.86k|    _mm256_setr_epi64x(a as i64, b as i64, c as i64, d as i64)
   68|  2.86k|}
_RNvNtCseOUJsTo2fy1_12blake2b_simd4avx29loadu_128:
   30|  22.8k|unsafe fn loadu_128(mem_addr: &[u8; 16]) -> __m128i {
   31|  22.8k|    _mm_loadu_si128(mem_addr.as_ptr() as *const __m128i)
   32|  22.8k|}
_RNvNtCseOUJsTo2fy1_12blake2b_simd4avx23add:
   35|   412k|unsafe fn add(a: __m256i, b: __m256i) -> __m256i {
   36|   412k|    _mm256_add_epi64(a, b)
   37|   412k|}
_RNvNtCseOUJsTo2fy1_12blake2b_simd4avx26storeu:
   24|  5.72k|unsafe fn storeu(src: __m256i, dest: *mut [Word; DEGREE]) {
   25|  5.72k|    // This is an unaligned store, so the pointer cast is allowed.
   26|  5.72k|    _mm256_storeu_si256(dest as *mut __m256i, src)
   27|  5.72k|}
_RNvNtCseOUJsTo2fy1_12blake2b_simd4avx25rot16:
   97|  68.6k|unsafe fn rot16(x: __m256i) -> __m256i {
   98|  68.6k|    _mm256_or_si256(_mm256_srli_epi64(x, 16), _mm256_slli_epi64(x, 64 - 16))
   99|  68.6k|}
_RNvNtCseOUJsTo2fy1_12blake2b_simd4avx25rot32:
   87|  68.6k|unsafe fn rot32(x: __m256i) -> __m256i {
   88|  68.6k|    _mm256_or_si256(_mm256_srli_epi64(x, 32), _mm256_slli_epi64(x, 64 - 32))
   89|  68.6k|}
_RNvNtCseOUJsTo2fy1_12blake2b_simd4avx25rot63:
  102|  68.6k|unsafe fn rot63(x: __m256i) -> __m256i {
  103|  68.6k|    _mm256_or_si256(_mm256_srli_epi64(x, 63), _mm256_slli_epi64(x, 64 - 63))
  104|  68.6k|}
_RNvNtCseOUJsTo2fy1_12blake2b_simd4avx214compress1_loop:
  427|  2.54k|pub unsafe fn compress1_loop(
  428|  2.54k|    input: &[u8],
  429|  2.54k|    words: &mut [Word; 8],
  430|  2.54k|    mut count: Count,
  431|  2.54k|    last_node: LastNode,
  432|  2.54k|    finalize: Finalize,
  433|  2.54k|    stride: Stride,
  434|  2.54k|) {
  435|  2.54k|    input_debug_asserts(input, finalize);
  436|  2.54k|
  437|  2.54k|    let mut local_words = *words;
  438|  2.54k|
  439|  2.54k|    let mut fin_offset = input.len().saturating_sub(1);
  440|  2.54k|    fin_offset -= fin_offset % stride.padded_blockbytes();
  441|  2.54k|    let mut buf = [0; BLOCKBYTES];
  442|  2.54k|    let (fin_block, fin_len, _) = final_block(input, fin_offset, &mut buf, stride);
  443|  2.54k|    let fin_last_block = flag_word(finalize.yes());
  444|  2.54k|    let fin_last_node = flag_word(finalize.yes() && last_node.yes());
  445|       |
  446|  2.54k|    let mut offset = 0;
  447|       |    loop {
  448|       |        let block;
  449|       |        let count_delta;
  450|       |        let last_block;
  451|       |        let last_node;
  452|  2.86k|        if offset == fin_offset {
  453|  2.54k|            block = fin_block;
  454|  2.54k|            count_delta = fin_len;
  455|  2.54k|            last_block = fin_last_block;
  456|  2.54k|            last_node = fin_last_node;
  457|  2.54k|        } else {
  458|    318|            // This unsafe cast avoids bounds checks. There's guaranteed to be
  459|    318|            // enough input because `offset < fin_offset`.
  460|    318|            block = &*(input.as_ptr().add(offset) as *const [u8; BLOCKBYTES]);
  461|    318|            count_delta = BLOCKBYTES;
  462|    318|            last_block = flag_word(false);
  463|    318|            last_node = flag_word(false);
  464|    318|        };
  465|       |
  466|  2.86k|        count = count.wrapping_add(count_delta as Count);
  467|  2.86k|        compress_block(block, &mut local_words, count, last_block, last_node);
  468|  2.86k|
  469|  2.86k|        // Check for termination before bumping the offset, to avoid overflow.
  470|  2.86k|        if offset == fin_offset {
  471|  2.54k|            break;
  472|    318|        }
  473|    318|
  474|    318|        offset += stride.padded_blockbytes();
  475|       |    }
  476|       |
  477|  2.54k|    *words = local_words;
  478|  2.54k|}
_RNvNtCseOUJsTo2fy1_12blake2b_simd4avx211diagonalize:
  132|  34.3k|unsafe fn diagonalize(a: &mut __m256i, _b: &mut __m256i, c: &mut __m256i, d: &mut __m256i) {
  133|  34.3k|    *a = _mm256_permute4x64_epi64(*a, _MM_SHUFFLE!(2, 1, 0, 3));
  134|  34.3k|    *d = _mm256_permute4x64_epi64(*d, _MM_SHUFFLE!(1, 0, 3, 2));
  135|  34.3k|    *c = _mm256_permute4x64_epi64(*c, _MM_SHUFFLE!(0, 3, 2, 1));
  136|  34.3k|}
_RNvNtCseOUJsTo2fy1_12blake2b_simd4avx22g2:
  118|  68.6k|unsafe fn g2(a: &mut __m256i, b: &mut __m256i, c: &mut __m256i, d: &mut __m256i, m: &mut __m256i) {
  119|  68.6k|    *a = add(*a, *m);
  120|  68.6k|    *a = add(*a, *b);
  121|  68.6k|    *d = xor(*d, *a);
  122|  68.6k|    *d = rot16(*d);
  123|  68.6k|    *c = add(*c, *d);
  124|  68.6k|    *b = xor(*b, *c);
  125|  68.6k|    *b = rot63(*b);
  126|  68.6k|}
_RNvNtCseOUJsTo2fy1_12blake2b_simd4avx22g1:
  107|  68.6k|unsafe fn g1(a: &mut __m256i, b: &mut __m256i, c: &mut __m256i, d: &mut __m256i, m: &mut __m256i) {
  108|  68.6k|    *a = add(*a, *m);
  109|  68.6k|    *a = add(*a, *b);
  110|  68.6k|    *d = xor(*d, *a);
  111|  68.6k|    *d = rot32(*d);
  112|  68.6k|    *c = add(*c, *d);
  113|  68.6k|    *b = xor(*b, *c);
  114|  68.6k|    *b = rot24(*b);
  115|  68.6k|}
_RNvNtCseOUJsTo2fy1_12blake2b_simd4avx214compress_block:
  146|  2.86k|unsafe fn compress_block(
  147|  2.86k|    block: &[u8; BLOCKBYTES],
  148|  2.86k|    words: &mut [Word; 8],
  149|  2.86k|    count: Count,
  150|  2.86k|    last_block: Word,
  151|  2.86k|    last_node: Word,
  152|  2.86k|) {
  153|  2.86k|    let (words_low, words_high) = mut_array_refs!(words, DEGREE, DEGREE);
  154|  2.86k|    let (iv_low, iv_high) = array_refs!(&IV, DEGREE, DEGREE);
  155|  2.86k|    let mut a = loadu(words_low);
  156|  2.86k|    let mut b = loadu(words_high);
  157|  2.86k|    let mut c = loadu(iv_low);
  158|  2.86k|    let flags = set4(count_low(count), count_high(count), last_block, last_node);
  159|  2.86k|    let mut d = xor(loadu(iv_high), flags);
  160|  2.86k|
  161|  2.86k|    let msg_chunks = array_refs!(block, 16, 16, 16, 16, 16, 16, 16, 16);
  162|  2.86k|    let m0 = _mm256_broadcastsi128_si256(loadu_128(msg_chunks.0));
  163|  2.86k|    let m1 = _mm256_broadcastsi128_si256(loadu_128(msg_chunks.1));
  164|  2.86k|    let m2 = _mm256_broadcastsi128_si256(loadu_128(msg_chunks.2));
  165|  2.86k|    let m3 = _mm256_broadcastsi128_si256(loadu_128(msg_chunks.3));
  166|  2.86k|    let m4 = _mm256_broadcastsi128_si256(loadu_128(msg_chunks.4));
  167|  2.86k|    let m5 = _mm256_broadcastsi128_si256(loadu_128(msg_chunks.5));
  168|  2.86k|    let m6 = _mm256_broadcastsi128_si256(loadu_128(msg_chunks.6));
  169|  2.86k|    let m7 = _mm256_broadcastsi128_si256(loadu_128(msg_chunks.7));
  170|  2.86k|
  171|  2.86k|    let iv0 = a;
  172|  2.86k|    let iv1 = b;
  173|  2.86k|    let mut t0;
  174|  2.86k|    let mut t1;
  175|  2.86k|    let mut b0;
  176|  2.86k|
  177|  2.86k|    // round 1
  178|  2.86k|    t0 = _mm256_unpacklo_epi64(m0, m1);
  179|  2.86k|    t1 = _mm256_unpacklo_epi64(m2, m3);
  180|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  181|  2.86k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  182|  2.86k|    t0 = _mm256_unpackhi_epi64(m0, m1);
  183|  2.86k|    t1 = _mm256_unpackhi_epi64(m2, m3);
  184|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  185|  2.86k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  186|  2.86k|    diagonalize(&mut a, &mut b, &mut c, &mut d);
  187|  2.86k|    t0 = _mm256_unpacklo_epi64(m7, m4);
  188|  2.86k|    t1 = _mm256_unpacklo_epi64(m5, m6);
  189|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  190|  2.86k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  191|  2.86k|    t0 = _mm256_unpackhi_epi64(m7, m4);
  192|  2.86k|    t1 = _mm256_unpackhi_epi64(m5, m6);
  193|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  194|  2.86k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  195|  2.86k|    undiagonalize(&mut a, &mut b, &mut c, &mut d);
  196|  2.86k|
  197|  2.86k|    // round 2
  198|  2.86k|    t0 = _mm256_unpacklo_epi64(m7, m2);
  199|  2.86k|    t1 = _mm256_unpackhi_epi64(m4, m6);
  200|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  201|  2.86k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  202|  2.86k|    t0 = _mm256_unpacklo_epi64(m5, m4);
  203|  2.86k|    t1 = _mm256_alignr_epi8(m3, m7, 8);
  204|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  205|  2.86k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  206|  2.86k|    diagonalize(&mut a, &mut b, &mut c, &mut d);
  207|  2.86k|    t0 = _mm256_unpackhi_epi64(m2, m0);
  208|  2.86k|    t1 = _mm256_blend_epi32(m5, m0, 0x33);
  209|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  210|  2.86k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  211|  2.86k|    t0 = _mm256_alignr_epi8(m6, m1, 8);
  212|  2.86k|    t1 = _mm256_blend_epi32(m3, m1, 0x33);
  213|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  214|  2.86k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  215|  2.86k|    undiagonalize(&mut a, &mut b, &mut c, &mut d);
  216|  2.86k|
  217|  2.86k|    // round 3
  218|  2.86k|    t0 = _mm256_alignr_epi8(m6, m5, 8);
  219|  2.86k|    t1 = _mm256_unpackhi_epi64(m2, m7);
  220|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  221|  2.86k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  222|  2.86k|    t0 = _mm256_unpacklo_epi64(m4, m0);
  223|  2.86k|    t1 = _mm256_blend_epi32(m6, m1, 0x33);
  224|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  225|  2.86k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  226|  2.86k|    diagonalize(&mut a, &mut b, &mut c, &mut d);
  227|  2.86k|    t0 = _mm256_alignr_epi8(m5, m4, 8);
  228|  2.86k|    t1 = _mm256_unpackhi_epi64(m1, m3);
  229|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  230|  2.86k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  231|  2.86k|    t0 = _mm256_unpacklo_epi64(m2, m7);
  232|  2.86k|    t1 = _mm256_blend_epi32(m0, m3, 0x33);
  233|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  234|  2.86k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  235|  2.86k|    undiagonalize(&mut a, &mut b, &mut c, &mut d);
  236|  2.86k|
  237|  2.86k|    // round 4
  238|  2.86k|    t0 = _mm256_unpackhi_epi64(m3, m1);
  239|  2.86k|    t1 = _mm256_unpackhi_epi64(m6, m5);
  240|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  241|  2.86k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  242|  2.86k|    t0 = _mm256_unpackhi_epi64(m4, m0);
  243|  2.86k|    t1 = _mm256_unpacklo_epi64(m6, m7);
  244|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  245|  2.86k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  246|  2.86k|    diagonalize(&mut a, &mut b, &mut c, &mut d);
  247|  2.86k|    t0 = _mm256_alignr_epi8(m1, m7, 8);
  248|  2.86k|    t1 = _mm256_shuffle_epi32(m2, _MM_SHUFFLE!(1, 0, 3, 2));
  249|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  250|  2.86k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  251|  2.86k|    t0 = _mm256_unpacklo_epi64(m4, m3);
  252|  2.86k|    t1 = _mm256_unpacklo_epi64(m5, m0);
  253|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  254|  2.86k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  255|  2.86k|    undiagonalize(&mut a, &mut b, &mut c, &mut d);
  256|  2.86k|
  257|  2.86k|    // round 5
  258|  2.86k|    t0 = _mm256_unpackhi_epi64(m4, m2);
  259|  2.86k|    t1 = _mm256_unpacklo_epi64(m1, m5);
  260|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  261|  2.86k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  262|  2.86k|    t0 = _mm256_blend_epi32(m3, m0, 0x33);
  263|  2.86k|    t1 = _mm256_blend_epi32(m7, m2, 0x33);
  264|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  265|  2.86k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  266|  2.86k|    diagonalize(&mut a, &mut b, &mut c, &mut d);
  267|  2.86k|    t0 = _mm256_alignr_epi8(m7, m1, 8);
  268|  2.86k|    t1 = _mm256_alignr_epi8(m3, m5, 8);
  269|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  270|  2.86k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  271|  2.86k|    t0 = _mm256_unpackhi_epi64(m6, m0);
  272|  2.86k|    t1 = _mm256_unpacklo_epi64(m6, m4);
  273|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  274|  2.86k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  275|  2.86k|    undiagonalize(&mut a, &mut b, &mut c, &mut d);
  276|  2.86k|
  277|  2.86k|    // round 6
  278|  2.86k|    t0 = _mm256_unpacklo_epi64(m1, m3);
  279|  2.86k|    t1 = _mm256_unpacklo_epi64(m0, m4);
  280|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  281|  2.86k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  282|  2.86k|    t0 = _mm256_unpacklo_epi64(m6, m5);
  283|  2.86k|    t1 = _mm256_unpackhi_epi64(m5, m1);
  284|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  285|  2.86k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  286|  2.86k|    diagonalize(&mut a, &mut b, &mut c, &mut d);
  287|  2.86k|    t0 = _mm256_alignr_epi8(m2, m0, 8);
  288|  2.86k|    t1 = _mm256_unpackhi_epi64(m3, m7);
  289|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  290|  2.86k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  291|  2.86k|    t0 = _mm256_unpackhi_epi64(m4, m6);
  292|  2.86k|    t1 = _mm256_alignr_epi8(m7, m2, 8);
  293|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  294|  2.86k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  295|  2.86k|    undiagonalize(&mut a, &mut b, &mut c, &mut d);
  296|  2.86k|
  297|  2.86k|    // round 7
  298|  2.86k|    t0 = _mm256_blend_epi32(m0, m6, 0x33);
  299|  2.86k|    t1 = _mm256_unpacklo_epi64(m7, m2);
  300|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  301|  2.86k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  302|  2.86k|    t0 = _mm256_unpackhi_epi64(m2, m7);
  303|  2.86k|    t1 = _mm256_alignr_epi8(m5, m6, 8);
  304|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  305|  2.86k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  306|  2.86k|    diagonalize(&mut a, &mut b, &mut c, &mut d);
  307|  2.86k|    t0 = _mm256_unpacklo_epi64(m4, m0);
  308|  2.86k|    t1 = _mm256_blend_epi32(m4, m3, 0x33);
  309|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  310|  2.86k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  311|  2.86k|    t0 = _mm256_unpackhi_epi64(m5, m3);
  312|  2.86k|    t1 = _mm256_shuffle_epi32(m1, _MM_SHUFFLE!(1, 0, 3, 2));
  313|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  314|  2.86k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  315|  2.86k|    undiagonalize(&mut a, &mut b, &mut c, &mut d);
  316|  2.86k|
  317|  2.86k|    // round 8
  318|  2.86k|    t0 = _mm256_unpackhi_epi64(m6, m3);
  319|  2.86k|    t1 = _mm256_blend_epi32(m1, m6, 0x33);
  320|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  321|  2.86k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  322|  2.86k|    t0 = _mm256_alignr_epi8(m7, m5, 8);
  323|  2.86k|    t1 = _mm256_unpackhi_epi64(m0, m4);
  324|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  325|  2.86k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  326|  2.86k|    diagonalize(&mut a, &mut b, &mut c, &mut d);
  327|  2.86k|    t0 = _mm256_blend_epi32(m2, m1, 0x33);
  328|  2.86k|    t1 = _mm256_alignr_epi8(m4, m7, 8);
  329|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  330|  2.86k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  331|  2.86k|    t0 = _mm256_unpacklo_epi64(m5, m0);
  332|  2.86k|    t1 = _mm256_unpacklo_epi64(m2, m3);
  333|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  334|  2.86k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  335|  2.86k|    undiagonalize(&mut a, &mut b, &mut c, &mut d);
  336|  2.86k|
  337|  2.86k|    // round 9
  338|  2.86k|    t0 = _mm256_unpacklo_epi64(m3, m7);
  339|  2.86k|    t1 = _mm256_alignr_epi8(m0, m5, 8);
  340|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  341|  2.86k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  342|  2.86k|    t0 = _mm256_unpackhi_epi64(m7, m4);
  343|  2.86k|    t1 = _mm256_alignr_epi8(m4, m1, 8);
  344|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  345|  2.86k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  346|  2.86k|    diagonalize(&mut a, &mut b, &mut c, &mut d);
  347|  2.86k|    t0 = _mm256_unpacklo_epi64(m5, m6);
  348|  2.86k|    t1 = _mm256_unpackhi_epi64(m6, m0);
  349|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  350|  2.86k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  351|  2.86k|    t0 = _mm256_alignr_epi8(m1, m2, 8);
  352|  2.86k|    t1 = _mm256_alignr_epi8(m2, m3, 8);
  353|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  354|  2.86k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  355|  2.86k|    undiagonalize(&mut a, &mut b, &mut c, &mut d);
  356|  2.86k|
  357|  2.86k|    // round 10
  358|  2.86k|    t0 = _mm256_unpacklo_epi64(m5, m4);
  359|  2.86k|    t1 = _mm256_unpackhi_epi64(m3, m0);
  360|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  361|  2.86k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  362|  2.86k|    t0 = _mm256_unpacklo_epi64(m1, m2);
  363|  2.86k|    t1 = _mm256_blend_epi32(m2, m3, 0x33);
  364|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  365|  2.86k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  366|  2.86k|    diagonalize(&mut a, &mut b, &mut c, &mut d);
  367|  2.86k|    t0 = _mm256_unpackhi_epi64(m6, m7);
  368|  2.86k|    t1 = _mm256_unpackhi_epi64(m4, m1);
  369|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  370|  2.86k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  371|  2.86k|    t0 = _mm256_blend_epi32(m5, m0, 0x33);
  372|  2.86k|    t1 = _mm256_unpacklo_epi64(m7, m6);
  373|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  374|  2.86k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  375|  2.86k|    undiagonalize(&mut a, &mut b, &mut c, &mut d);
  376|  2.86k|
  377|  2.86k|    // round 11
  378|  2.86k|    t0 = _mm256_unpacklo_epi64(m0, m1);
  379|  2.86k|    t1 = _mm256_unpacklo_epi64(m2, m3);
  380|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  381|  2.86k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  382|  2.86k|    t0 = _mm256_unpackhi_epi64(m0, m1);
  383|  2.86k|    t1 = _mm256_unpackhi_epi64(m2, m3);
  384|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  385|  2.86k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  386|  2.86k|    diagonalize(&mut a, &mut b, &mut c, &mut d);
  387|  2.86k|    t0 = _mm256_unpacklo_epi64(m7, m4);
  388|  2.86k|    t1 = _mm256_unpacklo_epi64(m5, m6);
  389|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  390|  2.86k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  391|  2.86k|    t0 = _mm256_unpackhi_epi64(m7, m4);
  392|  2.86k|    t1 = _mm256_unpackhi_epi64(m5, m6);
  393|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  394|  2.86k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  395|  2.86k|    undiagonalize(&mut a, &mut b, &mut c, &mut d);
  396|  2.86k|
  397|  2.86k|    // round 12
  398|  2.86k|    t0 = _mm256_unpacklo_epi64(m7, m2);
  399|  2.86k|    t1 = _mm256_unpackhi_epi64(m4, m6);
  400|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  401|  2.86k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  402|  2.86k|    t0 = _mm256_unpacklo_epi64(m5, m4);
  403|  2.86k|    t1 = _mm256_alignr_epi8(m3, m7, 8);
  404|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  405|  2.86k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  406|  2.86k|    diagonalize(&mut a, &mut b, &mut c, &mut d);
  407|  2.86k|    t0 = _mm256_unpackhi_epi64(m2, m0);
  408|  2.86k|    t1 = _mm256_blend_epi32(m5, m0, 0x33);
  409|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  410|  2.86k|    g1(&mut a, &mut b, &mut c, &mut d, &mut b0);
  411|  2.86k|    t0 = _mm256_alignr_epi8(m6, m1, 8);
  412|  2.86k|    t1 = _mm256_blend_epi32(m3, m1, 0x33);
  413|  2.86k|    b0 = _mm256_blend_epi32(t0, t1, 0xF0);
  414|  2.86k|    g2(&mut a, &mut b, &mut c, &mut d, &mut b0);
  415|  2.86k|    undiagonalize(&mut a, &mut b, &mut c, &mut d);
  416|  2.86k|
  417|  2.86k|    a = xor(a, c);
  418|  2.86k|    b = xor(b, d);
  419|  2.86k|    a = xor(a, iv0);
  420|  2.86k|    b = xor(b, iv1);
  421|  2.86k|
  422|  2.86k|    storeu(a, words_low);
  423|  2.86k|    storeu(b, words_high);
  424|  2.86k|}
_RNvNtCseOUJsTo2fy1_12blake2b_simd4avx213undiagonalize:
  139|  34.3k|unsafe fn undiagonalize(a: &mut __m256i, _b: &mut __m256i, c: &mut __m256i, d: &mut __m256i) {
  140|  34.3k|    *a = _mm256_permute4x64_epi64(*a, _MM_SHUFFLE!(0, 3, 2, 1));
  141|  34.3k|    *d = _mm256_permute4x64_epi64(*d, _MM_SHUFFLE!(1, 0, 3, 2));
  142|  34.3k|    *c = _mm256_permute4x64_epi64(*c, _MM_SHUFFLE!(2, 1, 0, 3));
  143|  34.3k|}

_RNvNtCseOUJsTo2fy1_12blake2b_simd4guts9flag_word:
  217|  5.72k|pub(crate) fn flag_word(flag: bool) -> Word {
  218|  5.72k|    if flag {
  219|  2.22k|        !0
  220|       |    } else {
  221|  3.49k|        0
  222|       |    }
  223|  5.72k|}
_RNvNtCseOUJsTo2fy1_12blake2b_simd4guts10count_high:
  208|  2.86k|pub(crate) fn count_high(count: Count) -> Word {
  209|  2.86k|    (count >> 8 * size_of::<Word>()) as Word
  210|  2.86k|}
_RNvNtCseOUJsTo2fy1_12blake2b_simd4guts9count_low:
  204|  2.86k|pub(crate) fn count_low(count: Count) -> Word {
  205|  2.86k|    count as Word
  206|  2.86k|}
_RNvMs1_NtCseOUJsTo2fy1_12blake2b_simd4gutsNtB5_8LastNode3yes:
  181|  2.22k|    pub fn yes(&self) -> bool {
  182|  2.22k|        match self {
  183|      0|            LastNode::Yes => true,
  184|  2.22k|            LastNode::No => false,
  185|       |        }
  186|  2.22k|    }
_RNvNtCseOUJsTo2fy1_12blake2b_simd4guts11final_block:
  232|  2.54k|pub fn final_block<'a>(
  233|  2.54k|    input: &'a [u8],
  234|  2.54k|    offset: usize,
  235|  2.54k|    buffer: &'a mut [u8; BLOCKBYTES],
  236|  2.54k|    stride: Stride,
  237|  2.54k|) -> (&'a [u8; BLOCKBYTES], usize, bool) {
  238|  2.54k|    let capped_offset = cmp::min(offset, input.len());
  239|  2.54k|    let offset_slice = &input[capped_offset..];
  240|  2.54k|    if offset_slice.len() >= BLOCKBYTES {
  241|    318|        let block = array_ref!(offset_slice, 0, BLOCKBYTES);
  242|    318|        let should_finalize = offset_slice.len() <= stride.padded_blockbytes();
  243|    318|        (block, BLOCKBYTES, should_finalize)
  244|       |    } else {
  245|       |        // Copy the final block to the front of the block buffer. The rest of
  246|       |        // the buffer is assumed to be initialized to zero.
  247|  2.22k|        buffer[..offset_slice.len()].copy_from_slice(offset_slice);
  248|  2.22k|        (buffer, offset_slice.len(), true)
  249|       |    }
  250|  2.54k|}
_RNvNtCseOUJsTo2fy1_12blake2b_simd4guts19input_debug_asserts:
  252|  2.54k|pub fn input_debug_asserts(input: &[u8], finalize: Finalize) {
  253|  2.54k|    // If we're not finalizing, the input must not be empty, and it must be an
  254|  2.54k|    // even multiple of the block size.
  255|  2.54k|    if !finalize.yes() {
  256|    318|        debug_assert!(!input.is_empty());
  257|    318|        debug_assert_eq!(0, input.len() % BLOCKBYTES);
  258|  2.22k|    }
  259|  2.54k|}
_RNvMs2_NtCseOUJsTo2fy1_12blake2b_simd4gutsNtB5_6Stride17padded_blockbytes:
  196|  3.18k|    pub fn padded_blockbytes(&self) -> usize {
  197|  3.18k|        match self {
  198|  3.18k|            Stride::Serial => BLOCKBYTES,
  199|      0|            Stride::Parallel => blake2bp::DEGREE * BLOCKBYTES,
  200|       |        }
  201|  3.18k|    }
_RNvMNtCseOUJsTo2fy1_12blake2b_simd4gutsNtB2_14Implementation6detect:
   33|  2.22k|            if let Some(avx2_impl) = Self::avx2_if_supported() {
   34|  2.22k|                return avx2_impl;
   35|      0|            }
   36|       |        }
   37|       |        #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
   38|       |        {
   39|      0|            if let Some(sse41_impl) = Self::sse41_if_supported() {
   40|      0|                return sse41_impl;
   41|      0|            }
   42|      0|        }
   43|      0|        Self::portable()
   44|  2.22k|    }
_RNvMNtCseOUJsTo2fy1_12blake2b_simd4gutsNtB2_14Implementation17avx2_if_supported:
   70|  2.22k|    pub fn avx2_if_supported() -> Option<Self> {
   71|       |        // Check whether AVX2 support is assumed by the build.
   72|       |        #[cfg(target_feature = "avx2")]
   73|       |        {
   74|       |            return Some(Implementation(Platform::AVX2));
   75|       |        }
   76|       |        // Otherwise dynamically check for support if we can.
   77|       |        #[cfg(feature = "std")]
   78|       |        {
   79|      0|            if is_x86_feature_detected!("avx2") {
   80|  2.22k|                return Some(Implementation(Platform::AVX2));
   81|      0|            }
   82|      0|        }
   83|      0|        None
   84|  2.22k|    }
_RNvMNtCseOUJsTo2fy1_12blake2b_simd4gutsNtB2_14Implementation14compress1_loop:
   96|  2.54k|    pub fn compress1_loop(
   97|  2.54k|        &self,
   98|  2.54k|        input: &[u8],
   99|  2.54k|        words: &mut [Word; 8],
  100|  2.54k|        count: Count,
  101|  2.54k|        last_node: LastNode,
  102|  2.54k|        finalize: Finalize,
  103|  2.54k|        stride: Stride,
  104|  2.54k|    ) {
  105|  2.54k|        match self.0 {
  106|       |            #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
  107|  2.54k|            Platform::AVX2 => unsafe {
  108|  2.54k|                avx2::compress1_loop(input, words, count, last_node, finalize, stride);
  109|  2.54k|            },
  110|       |            // Note that there's an SSE version of compress1 in the official C
  111|       |            // implementation, but I haven't ported it yet.
  112|      0|            _ => {
  113|      0|                portable::compress1_loop(input, words, count, last_node, finalize, stride);
  114|      0|            }
  115|       |        }
  116|  2.54k|    }
_RNvMs0_NtCseOUJsTo2fy1_12blake2b_simd4gutsNtB5_8Finalize3yes:
  165|  7.63k|    pub fn yes(&self) -> bool {
  166|  7.63k|        match self {
  167|  6.67k|            Finalize::Yes => true,
  168|    954|            Finalize::No => false,
  169|       |        }
  170|  7.63k|    }

_RNvMCseOUJsTo2fy1_12blake2b_simdNtB2_6Params11hash_length:
  238|  2.22k|    pub fn hash_length(&mut self, length: usize) -> &mut Self {
  239|  2.22k|        assert!(
  240|  2.22k|            1 <= length && length <= OUTBYTES,
  241|      0|            "Bad hash length: {}",
  242|       |            length
  243|       |        );
  244|  2.22k|        self.hash_length = length as u8;
  245|  2.22k|        self
  246|  2.22k|    }
_RNvMCseOUJsTo2fy1_12blake2b_simdNtB2_6Params3new:
  165|  2.22k|    pub fn new() -> Self {
  166|  2.22k|        Self {
  167|  2.22k|            hash_length: OUTBYTES as u8,
  168|  2.22k|            key_length: 0,
  169|  2.22k|            key_block: [0; BLOCKBYTES],
  170|  2.22k|            salt: [0; SALTBYTES],
  171|  2.22k|            personal: [0; PERSONALBYTES],
  172|  2.22k|            // NOTE: fanout and max_depth don't default to zero!
  173|  2.22k|            fanout: 1,
  174|  2.22k|            max_depth: 1,
  175|  2.22k|            max_leaf_length: 0,
  176|  2.22k|            node_offset: 0,
  177|  2.22k|            node_depth: 0,
  178|  2.22k|            inner_hash_length: 0,
  179|  2.22k|            last_node: guts::LastNode::No,
  180|  2.22k|            implementation: guts::Implementation::detect(),
  181|  2.22k|        }
  182|  2.22k|    }
_RNvMs1_CseOUJsTo2fy1_12blake2b_simdNtB5_5State8fill_buf:
  424|  2.22k|    fn fill_buf(&mut self, input: &mut &[u8]) {
  425|  2.22k|        let take = cmp::min(BLOCKBYTES - self.buflen as usize, input.len());
  426|  2.22k|        self.buf[self.buflen as usize..self.buflen as usize + take].copy_from_slice(&input[..take]);
  427|  2.22k|        self.buflen += take as u8;
  428|  2.22k|        *input = &input[take..];
  429|  2.22k|    }
_RNvMCseOUJsTo2fy1_12blake2b_simdNtB2_6Params8to_words:
  185|  2.22k|    fn to_words(&self) -> [Word; 8] {
  186|  2.22k|        let (salt_left, salt_right) = array_refs!(&self.salt, SALTBYTES / 2, SALTBYTES / 2);
  187|  2.22k|        let (personal_left, personal_right) =
  188|  2.22k|            array_refs!(&self.personal, PERSONALBYTES / 2, PERSONALBYTES / 2);
  189|  2.22k|        [
  190|  2.22k|            IV[0]
  191|  2.22k|                ^ self.hash_length as u64
  192|  2.22k|                ^ (self.key_length as u64) << 8
  193|  2.22k|                ^ (self.fanout as u64) << 16
  194|  2.22k|                ^ (self.max_depth as u64) << 24
  195|  2.22k|                ^ (self.max_leaf_length as u64) << 32,
  196|  2.22k|            IV[1] ^ self.node_offset,
  197|  2.22k|            IV[2] ^ self.node_depth as u64 ^ (self.inner_hash_length as u64) << 8,
  198|  2.22k|            IV[3],
  199|  2.22k|            IV[4] ^ Word::from_le_bytes(*salt_left),
  200|  2.22k|            IV[5] ^ Word::from_le_bytes(*salt_right),
  201|  2.22k|            IV[6] ^ Word::from_le_bytes(*personal_left),
  202|  2.22k|            IV[7] ^ Word::from_le_bytes(*personal_right),
  203|  2.22k|        ]
  204|  2.22k|    }
_RNvMs1_CseOUJsTo2fy1_12blake2b_simdNtB5_5State8finalize:
  482|  2.22k|    pub fn finalize(&self) -> Hash {
  483|  2.22k|        let mut words_copy = self.words;
  484|  2.22k|        self.implementation.compress1_loop(
  485|  2.22k|            &self.buf[..self.buflen as usize],
  486|  2.22k|            &mut words_copy,
  487|  2.22k|            self.count,
  488|  2.22k|            self.last_node,
  489|  2.22k|            guts::Finalize::Yes,
  490|  2.22k|            guts::Stride::Serial,
  491|  2.22k|        );
  492|  2.22k|        Hash {
  493|  2.22k|            bytes: state_words_to_bytes(&words_copy),
  494|  2.22k|            len: self.hash_length,
  495|  2.22k|        }
  496|  2.22k|    }
_RNvMCseOUJsTo2fy1_12blake2b_simdNtB2_6Params8to_state:
  230|  2.22k|    pub fn to_state(&self) -> State {
  231|  2.22k|        State::with_params(self)
  232|  2.22k|    }
_RNvMs5_CseOUJsTo2fy1_12blake2b_simdNtB5_4Hash8as_bytes:
  589|  2.22k|    pub fn as_bytes(&self) -> &[u8] {
  590|  2.22k|        &self.bytes[..self.len as usize]
  591|  2.22k|    }
_RNvCseOUJsTo2fy1_12blake2b_simd20state_words_to_bytes:
  529|  2.22k|fn state_words_to_bytes(state_words: &[Word; 8]) -> [u8; OUTBYTES] {
  530|  2.22k|    let mut bytes = [0; OUTBYTES];
  531|  2.22k|    {
  532|  2.22k|        const W: usize = size_of::<Word>();
  533|  2.22k|        let refs = mut_array_refs!(&mut bytes, W, W, W, W, W, W, W, W);
  534|  2.22k|        *refs.0 = state_words[0].to_le_bytes();
  535|  2.22k|        *refs.1 = state_words[1].to_le_bytes();
  536|  2.22k|        *refs.2 = state_words[2].to_le_bytes();
  537|  2.22k|        *refs.3 = state_words[3].to_le_bytes();
  538|  2.22k|        *refs.4 = state_words[4].to_le_bytes();
  539|  2.22k|        *refs.5 = state_words[5].to_le_bytes();
  540|  2.22k|        *refs.6 = state_words[6].to_le_bytes();
  541|  2.22k|        *refs.7 = state_words[7].to_le_bytes();
  542|  2.22k|    }
  543|  2.22k|    bytes
  544|  2.22k|}
_RNvMs1_CseOUJsTo2fy1_12blake2b_simdNtB5_5State11with_params:
  406|  2.22k|    fn with_params(params: &Params) -> Self {
  407|  2.22k|        let mut state = Self {
  408|  2.22k|            words: params.to_words(),
  409|  2.22k|            count: 0,
  410|  2.22k|            buf: [0; BLOCKBYTES],
  411|  2.22k|            buflen: 0,
  412|  2.22k|            last_node: params.last_node,
  413|  2.22k|            hash_length: params.hash_length,
  414|  2.22k|            implementation: params.implementation,
  415|  2.22k|            is_keyed: params.key_length > 0,
  416|  2.22k|        };
  417|  2.22k|        if state.is_keyed {
  418|      0|            state.buf = params.key_block;
  419|      0|            state.buflen = state.buf.len() as u8;
  420|  2.22k|        }
  421|  2.22k|        state
  422|  2.22k|    }
_RNvMs1_CseOUJsTo2fy1_12blake2b_simdNtB5_5State6update:
  453|  2.22k|    pub fn update(&mut self, mut input: &[u8]) -> &mut Self {
  454|  2.22k|        // If we have a partial buffer, try to complete it.
  455|  2.22k|        self.compress_buffer_if_possible(&mut input);
  456|  2.22k|        // While there's more than a block of input left (which also means we cleared the buffer
  457|  2.22k|        // above), compress blocks directly without copying.
  458|  2.22k|        let mut end = input.len().saturating_sub(1);
  459|  2.22k|        end -= end % BLOCKBYTES;
  460|  2.22k|        if end > 0 {
  461|    318|            self.implementation.compress1_loop(
  462|    318|                &input[..end],
  463|    318|                &mut self.words,
  464|    318|                self.count,
  465|    318|                self.last_node,
  466|    318|                guts::Finalize::No,
  467|    318|                guts::Stride::Serial,
  468|    318|            );
  469|    318|            self.count = self.count.wrapping_add(end as Count);
  470|    318|            input = &input[end..];
  471|  1.90k|        }
  472|       |        // Buffer any remaining input, to be either compressed or finalized in a subsequent call.
  473|       |        // Note that this represents some copying overhead, which in theory we could avoid in
  474|       |        // all-at-once setting. A function hardcoded for exactly BLOCKSIZE input bytes is about 10%
  475|       |        // faster than using this implementation for the same input.
  476|  2.22k|        self.fill_buf(&mut input);
  477|  2.22k|        self
  478|  2.22k|    }
_RNvMs1_CseOUJsTo2fy1_12blake2b_simdNtB5_5State27compress_buffer_if_possible:
  434|  2.22k|    fn compress_buffer_if_possible(&mut self, input: &mut &[u8]) {
  435|  2.22k|        if self.buflen > 0 {
  436|      0|            self.fill_buf(input);
  437|      0|            if !input.is_empty() {
  438|      0|                self.implementation.compress1_loop(
  439|      0|                    &self.buf,
  440|      0|                    &mut self.words,
  441|      0|                    self.count,
  442|      0|                    self.last_node,
  443|      0|                    guts::Finalize::No,
  444|      0|                    guts::Stride::Serial,
  445|      0|                );
  446|      0|                self.count = self.count.wrapping_add(BLOCKBYTES as Count);
  447|      0|                self.buflen = 0;
  448|      0|            }
  449|  2.22k|        }
  450|  2.22k|    }

_RNvMs3_CshW4z5Uv978K_12block_bufferINtB5_11BlockBufferINtNtCs6DngFm1hXV4_7typenum4uint4UIntIBR_IBR_IBR_IBR_IBR_IBR_NtBT_5UTermNtNtBV_3bit2B1ENtB22_2B0EB2f_EB2f_EB2f_EB2f_EB2f_ENtB5_5EagerE17set_pos_uncheckedCsboUdcTbF1FS_15direct_syscalls:
  231|    954|    fn set_pos_unchecked(&mut self, pos: usize) {
  232|    954|        debug_assert!(Kind::invariant(pos, BlockSize::USIZE));
  233|    954|        self.pos = pos as u8;
  234|    954|    }
_RNvMs3_CshW4z5Uv978K_12block_bufferINtB5_11BlockBufferINtNtCs6DngFm1hXV4_7typenum4uint4UIntIBR_IBR_IBR_IBR_IBR_IBR_NtBT_5UTermNtNtBV_3bit2B1ENtB22_2B0EB2f_EB2f_EB2f_EB2f_EB2f_ENtB5_5EagerE7get_posCsboUdcTbF1FS_15direct_syscalls:
  189|  1.90k|    pub fn get_pos(&self) -> usize {
  190|  1.90k|        let pos = self.pos as usize;
  191|  1.90k|        if !Kind::invariant(pos, BlockSize::USIZE) {
  192|      0|            debug_assert!(false);
  193|       |            // SAFETY: `pos` never breaks the invariant
  194|       |            unsafe {
  195|      0|                core::hint::unreachable_unchecked();
  196|       |            }
  197|  1.90k|        }
  198|  1.90k|        pos
  199|  1.90k|    }
_RNvMs3_CshW4z5Uv978K_12block_bufferINtB5_11BlockBufferINtNtCs6DngFm1hXV4_7typenum4uint4UIntIBR_IBR_IBR_IBR_IBR_IBR_NtBT_5UTermNtNtBV_3bit2B1ENtB22_2B0EB2f_EB2f_EB2f_EB2f_EB2f_ENtB5_5EagerE4sizeCsboUdcTbF1FS_15direct_syscalls:
  220|  1.90k|    pub fn size(&self) -> usize {
  221|  1.90k|        BlockSize::USIZE
  222|  1.90k|    }
_RINvMs4_CshW4z5Uv978K_12block_bufferINtB6_11BlockBufferINtNtCs6DngFm1hXV4_7typenum4uint4UIntIBS_IBS_IBS_IBS_IBS_IBS_NtBU_5UTermNtNtBW_3bit2B1ENtB23_2B0EB2g_EB2g_EB2g_EB2g_EB2g_ENtB6_5EagerE10digest_padNCNvXs3_NtCs6hBXtUubyyi_4sha28core_apiNtB3l_13Sha256VarCoreNtNtCs9RD1cWfVxpd_6digest8core_api18VariableOutputCore22finalize_variable_core0ECsboUdcTbF1FS_15direct_syscalls:
  284|    954|    pub fn digest_pad(
  285|    954|        &mut self,
  286|    954|        delim: u8,
  287|    954|        suffix: &[u8],
  288|    954|        mut compress: impl FnMut(&Block<BlockSize>),
  289|    954|    ) {
  290|    954|        if suffix.len() > BlockSize::USIZE {
  291|      0|            panic!("suffix is too long");
  292|    954|        }
  293|    954|        let pos = self.get_pos();
  294|    954|        self.buffer[pos] = delim;
  295|  58.1k|        for b in &mut self.buffer[pos + 1..] {
  296|  58.1k|            *b = 0;
  297|  58.1k|        }
  298|       |
  299|    954|        let n = self.size() - suffix.len();
  300|    954|        if self.size() - pos - 1 < suffix.len() {
  301|      0|            compress(&self.buffer);
  302|      0|            let mut block = Block::<BlockSize>::default();
  303|      0|            block[n..].copy_from_slice(suffix);
  304|      0|            compress(&block);
  305|    954|        } else {
  306|    954|            self.buffer[n..].copy_from_slice(suffix);
  307|    954|            compress(&self.buffer);
  308|    954|        }
  309|    954|        self.set_pos_unchecked(0)
  310|    954|    }
_RNvXs1_CshW4z5Uv978K_12block_bufferINtB5_11BlockBufferINtNtCs6DngFm1hXV4_7typenum4uint4UIntIBR_IBR_IBR_IBR_IBR_IBR_NtBT_5UTermNtNtBV_3bit2B1ENtB22_2B0EB2f_EB2f_EB2f_EB2f_EB2f_ENtB5_5EagerENtNtCsiloedr2K6v7_4core7default7Default7defaultCsboUdcTbF1FS_15direct_syscalls:
   72|    954|    fn default() -> Self {
   73|    954|        Self {
   74|    954|            buffer: Default::default(),
   75|    954|            pos: 0,
   76|    954|            _pd: PhantomData,
   77|    954|        }
   78|    954|    }
_RINvMs4_CshW4z5Uv978K_12block_bufferINtB6_11BlockBufferINtNtCs6DngFm1hXV4_7typenum4uint4UIntIBS_IBS_IBS_IBS_IBS_IBS_NtBU_5UTermNtNtBW_3bit2B1ENtB23_2B0EB2g_EB2g_EB2g_EB2g_EB2g_ENtB6_5EagerE16len64_padding_beNCNvXs3_NtCs6hBXtUubyyi_4sha28core_apiNtB3r_13Sha256VarCoreNtNtCs9RD1cWfVxpd_6digest8core_api18VariableOutputCore22finalize_variable_core0ECsboUdcTbF1FS_15direct_syscalls:
  315|    954|    pub fn len64_padding_be(&mut self, data_len: u64, compress: impl FnMut(&Block<BlockSize>)) {
  316|    954|        self.digest_pad(0x80, &data_len.to_be_bytes(), compress);
  317|    954|    }
_RNvMs3_CshW4z5Uv978K_12block_bufferINtB5_11BlockBufferINtNtCs6DngFm1hXV4_7typenum4uint4UIntIBR_IBR_IBR_IBR_IBR_IBR_NtBT_5UTermNtNtBV_3bit2B1ENtB22_2B0EB2f_EB2f_EB2f_EB2f_EB2f_ENtB5_5EagerE17set_pos_uncheckedCslH3pn9Bu6yX_13fvm_ipld_hamt:
  231|    954|    fn set_pos_unchecked(&mut self, pos: usize) {
  232|    954|        debug_assert!(Kind::invariant(pos, BlockSize::USIZE));
  233|    954|        self.pos = pos as u8;
  234|    954|    }
_RINvMs3_CshW4z5Uv978K_12block_bufferINtB6_11BlockBufferINtNtCs6DngFm1hXV4_7typenum4uint4UIntIBS_IBS_IBS_IBS_IBS_IBS_NtBU_5UTermNtNtBW_3bit2B1ENtB23_2B0EB2g_EB2g_EB2g_EB2g_EB2g_ENtB6_5EagerE13digest_blocksNCNvXs6_NtNtCs9RD1cWfVxpd_6digest8core_api7wrapperINtB3o_11CoreWrapperINtNtB3q_11ct_variable21CtVariableCoreWrapperNtNtCs6hBXtUubyyi_4sha28core_api13Sha256VarCoreB1s_NtB5b_9OidSha256EENtB3s_6Update6update0ECslH3pn9Bu6yX_13fvm_ipld_hamt:
  132|    954|    pub fn digest_blocks(
  133|    954|        &mut self,
  134|    954|        mut input: &[u8],
  135|    954|        mut compress: impl FnMut(&[Block<BlockSize>]),
  136|    954|    ) {
  137|    954|        let pos = self.get_pos();
  138|    954|        // using `self.remaining()` for some reason
  139|    954|        // prevents panic elimination
  140|    954|        let rem = self.size() - pos;
  141|    954|        let n = input.len();
  142|    954|        // Note that checking condition `pos + n < BlockSize` is
  143|    954|        // equivalent to checking `n < rem`, where `rem` is equal
  144|    954|        // to `BlockSize - pos`. Using the latter allows us to work
  145|    954|        // around compiler accounting for possible overflow of
  146|    954|        // `pos + n` which results in it inserting unreachable
  147|    954|        // panic branches. Using `unreachable_unchecked` in `get_pos`
  148|    954|        // we convince compiler that `BlockSize - pos` never underflows.
  149|    954|        if Kind::invariant(n, rem) {
  150|       |            // double slicing allows to remove panic branches
  151|    954|            self.buffer[pos..][..n].copy_from_slice(input);
  152|    954|            self.set_pos_unchecked(pos + n);
  153|    954|            return;
  154|      0|        }
  155|      0|        if pos != 0 {
  156|      0|            let (left, right) = input.split_at(rem);
  157|      0|            input = right;
  158|      0|            self.buffer[pos..].copy_from_slice(left);
  159|      0|            compress(slice::from_ref(&self.buffer));
  160|      0|        }
  161|       |
  162|      0|        let (blocks, leftover) = Kind::split_blocks(input);
  163|      0|        if !blocks.is_empty() {
  164|      0|            compress(blocks);
  165|      0|        }
  166|       |
  167|      0|        let n = leftover.len();
  168|      0|        self.buffer[..n].copy_from_slice(leftover);
  169|      0|        self.set_pos_unchecked(n);
  170|    954|    }
_RNvMs3_CshW4z5Uv978K_12block_bufferINtB5_11BlockBufferINtNtCs6DngFm1hXV4_7typenum4uint4UIntIBR_IBR_IBR_IBR_IBR_IBR_NtBT_5UTermNtNtBV_3bit2B1ENtB22_2B0EB2f_EB2f_EB2f_EB2f_EB2f_ENtB5_5EagerE4sizeCslH3pn9Bu6yX_13fvm_ipld_hamt:
  220|    954|    pub fn size(&self) -> usize {
  221|    954|        BlockSize::USIZE
  222|    954|    }
_RNvMs3_CshW4z5Uv978K_12block_bufferINtB5_11BlockBufferINtNtCs6DngFm1hXV4_7typenum4uint4UIntIBR_IBR_IBR_IBR_IBR_IBR_NtBT_5UTermNtNtBV_3bit2B1ENtB22_2B0EB2f_EB2f_EB2f_EB2f_EB2f_ENtB5_5EagerE7get_posCslH3pn9Bu6yX_13fvm_ipld_hamt:
  189|    954|    pub fn get_pos(&self) -> usize {
  190|    954|        let pos = self.pos as usize;
  191|    954|        if !Kind::invariant(pos, BlockSize::USIZE) {
  192|      0|            debug_assert!(false);
  193|       |            // SAFETY: `pos` never breaks the invariant
  194|       |            unsafe {
  195|      0|                core::hint::unreachable_unchecked();
  196|       |            }
  197|    954|        }
  198|    954|        pos
  199|    954|    }

_RNvXNtCshW4z5Uv978K_12block_buffer6sealedNtB4_5EagerNtB2_6Sealed9invariant:
   16|  5.72k|    fn invariant(pos: usize, block_size: usize) -> bool {
   17|  5.72k|        pos < block_size
   18|  5.72k|    }

_RNvXs0_Csd6dETW1SGAI_9byteorderNtB5_9BigEndianNtB5_9ByteOrder8read_u64:
 1982|  1.27k|    fn read_u64(buf: &[u8]) -> u64 {
 1983|  1.27k|        u64::from_be_bytes(buf[..8].try_into().unwrap())
 1984|  1.27k|    }
_RNvXs0_Csd6dETW1SGAI_9byteorderNtB5_9BigEndianNtB5_9ByteOrder9write_u64:
 2032|  2.54k|    fn write_u64(buf: &mut [u8], n: u64) {
 2033|  2.54k|        unsafe_write_num_bytes!(u64, 8, n, buf, to_be);
 2034|  2.54k|    }

_RINvYmNtNtNtCs7tbBVnmGocF_7cbor4ii4core3dec6Decode6decodeNtNtB8_5utils11SliceReaderECsboUdcTbF1FS_15direct_syscalls:
   73|    318|    fn decode<R: Read<'a>>(reader: &mut R) -> Result<Self, Error<R::Error>> {
   74|    318|        let byte = pull_one(reader)?;
   75|    318|        Self::decode_with(byte, reader)
   76|    318|    }
_RINvXsg_NtNtCs7tbBVnmGocF_7cbor4ii4core3decNtB6_8TagStartNtB6_6Decode11decode_withNtNtB8_5utils11SliceReaderECsboUdcTbF1FS_15direct_syscalls:
  703|  7.63k|    fn decode_with<R: Read<'a>>(byte: u8, reader: &mut R) -> Result<Self, Error<R::Error>> {
  704|  7.63k|        TypeNum::new(!(major::TAG << 5), byte).decode_u64(reader).map(TagStart)
  705|  7.63k|    }
_RINvNtNtCs7tbBVnmGocF_7cbor4ii4core3dec10decode_bufNtNtB4_5utils11SliceReaderECsboUdcTbF1FS_15direct_syscalls:
  427|  14.6k|fn decode_buf<'a, R: Read<'a>>(major: u8, byte: u8, reader: &mut R, buf: &mut Vec<u8>)
  428|  14.6k|    -> Result<Option<&'a [u8]>, Error<R::Error>>
  429|  14.6k|{
  430|       |    const CAP_LIMIT: usize = 16 * 1024;
  431|       |
  432|  14.6k|    if let Some(mut len) = decode_len(major, byte, reader)? {
  433|       |        // try long lifetime buffer
  434|  14.6k|        if let Reference::Long(buf) = reader.fill(len)? {
  435|  14.6k|            if buf.len() >= len {
  436|  14.6k|                reader.advance(len);
  437|  14.6k|                return Ok(Some(&buf[..len]));
  438|      0|            }
  439|      0|        }
  440|       |
  441|      0|        buf.reserve(core::cmp::min(len, CAP_LIMIT)); // TODO try_reserve ?
  442|       |
  443|      0|        while len != 0 {
  444|      0|            let readbuf = reader.fill(len)?;
  445|      0|            let readbuf = readbuf.as_ref();
  446|      0|
  447|      0|            if readbuf.is_empty() {
  448|      0|                return Err(Error::Eof);
  449|      0|            }
  450|      0|
  451|      0|            let readlen = core::cmp::min(readbuf.len(), len);
  452|      0|
  453|      0|            buf.extend_from_slice(&readbuf[..readlen]);
  454|      0|            reader.advance(readlen);
  455|      0|            len -= readlen;
  456|       |        }
  457|       |
  458|      0|        Ok(None)
  459|       |    } else {
  460|       |        // bytes sequence
  461|       |        loop {
  462|      0|            let byte = pull_one(reader)?;
  463|       |
  464|      0|            if byte == marker::BREAK {
  465|      0|                break
  466|      0|            }
  467|      0|
  468|      0|            if !reader.step_in() {
  469|      0|                return Err(Error::DepthLimit);
  470|      0|            }
  471|      0|            let mut reader = ScopeGuard(reader, |reader| reader.step_out());
  472|      0|            let reader = &mut *reader;
  473|       |
  474|      0|            if let Some(longbuf) = decode_buf(major, byte, reader, buf)? {
  475|      0|                buf.extend_from_slice(longbuf);
  476|      0|            }
  477|       |        }
  478|       |
  479|      0|        Ok(None)
  480|       |    }
  481|  14.6k|}
_RNvMs0_NtNtCs7tbBVnmGocF_7cbor4ii4core3decNtB5_7TypeNum3new:
  175|  55.9k|    pub(crate) const fn new(major_limit: u8, byte: u8) -> TypeNum {
  176|  55.9k|        TypeNum { major_limit, byte }
  177|  55.9k|    }
_RINvXsr_NtNtCs7tbBVnmGocF_7cbor4ii4core3decmNtB6_6Decode11decode_withNtNtB8_5utils11SliceReaderECsboUdcTbF1FS_15direct_syscalls:
  252|    318|                fn decode_with<R: Read<'a>>(byte: u8, reader: &mut R) -> Result<Self, Error<R::Error>> {
  253|    318|                    TypeNum::new(!(major::UNSIGNED << 5), byte).$decode_fn(reader)
  254|    318|                }
_RINvNtNtCs7tbBVnmGocF_7cbor4ii4core3dec10decode_lenNtNtB4_5utils11SliceReaderECsboUdcTbF1FS_15direct_syscalls:
  595|  23.8k|fn decode_len<'a, R: Read<'a>>(major: u8, byte: u8, reader: &mut R)
  596|  23.8k|    -> Result<Option<usize>, Error<R::Error>>
  597|  23.8k|{
  598|  23.8k|    if byte != (marker::START | (major << 5)) {
  599|  23.8k|        let len = TypeNum::new(!(major << 5), byte).decode_u64(reader)?;
  600|  23.8k|        let len = usize::try_from(len).map_err(Error::CastOverflow)?;
  601|  23.8k|        Ok(Some(len))
  602|       |    } else {
  603|      0|        Ok(None)
  604|       |    }
  605|  23.8k|}
_RINvNtNtCs7tbBVnmGocF_7cbor4ii4core3dec8pull_oneNtNtB4_5utils11SliceReaderECsboUdcTbF1FS_15direct_syscalls:
  125|  48.3k|pub(crate) fn pull_one<'a, R: Read<'a>>(reader: &mut R) -> Result<u8, Error<R::Error>> {
  126|  48.3k|    let b = reader.fill(1)?
  127|  48.3k|        .as_ref()
  128|  48.3k|        .get(0)
  129|  48.3k|        .copied()
  130|  48.3k|        .ok_or(Error::Eof)?;
  131|  48.3k|    reader.advance(1);
  132|  48.3k|    Ok(b)
  133|  48.3k|}
_RINvYINtNtCs9pDt8l5wGDA_5alloc6borrow3CoweENtNtNtCs7tbBVnmGocF_7cbor4ii4core3dec6Decode6decodeNtNtBJ_5utils11SliceReaderECsboUdcTbF1FS_15direct_syscalls:
   73|  4.77k|    fn decode<R: Read<'a>>(reader: &mut R) -> Result<Self, Error<R::Error>> {
   74|  4.77k|        let byte = pull_one(reader)?;
   75|  4.77k|        Self::decode_with(byte, reader)
   76|  4.77k|    }
_RINvYNtNtNtCs7tbBVnmGocF_7cbor4ii4core3dec8TagStartNtB5_6Decode6decodeNtNtB7_5utils11SliceReaderECsboUdcTbF1FS_15direct_syscalls:
   73|  7.63k|    fn decode<R: Read<'a>>(reader: &mut R) -> Result<Self, Error<R::Error>> {
   74|  7.63k|        let byte = pull_one(reader)?;
   75|  7.63k|        Self::decode_with(byte, reader)
   76|  7.63k|    }
_RINvYNtNtNtCs7tbBVnmGocF_7cbor4ii4core3dec10ArrayStartNtB5_6Decode6decodeNtNtB7_5utils11SliceReaderECsboUdcTbF1FS_15direct_syscalls:
   73|  9.22k|    fn decode<R: Read<'a>>(reader: &mut R) -> Result<Self, Error<R::Error>> {
   74|  9.22k|        let byte = pull_one(reader)?;
   75|  9.22k|        Self::decode_with(byte, reader)
   76|  9.22k|    }
_RNvNtNtCs7tbBVnmGocF_7cbor4ii4core3dec8if_major:
  890|  21.6k|pub fn if_major(byte: u8) -> u8 {
  891|  21.6k|    byte >> 5
  892|  21.6k|}
_RINvYINtNtNtCs7tbBVnmGocF_7cbor4ii4core5types5BytesINtNtCs9pDt8l5wGDA_5alloc6borrow3CowShEENtNtB8_3dec6Decode6decodeNtNtB8_5utils11SliceReaderECsboUdcTbF1FS_15direct_syscalls:
   73|  9.85k|    fn decode<R: Read<'a>>(reader: &mut R) -> Result<Self, Error<R::Error>> {
   74|  9.85k|        let byte = pull_one(reader)?;
   75|  9.85k|        Self::decode_with(byte, reader)
   76|  9.85k|    }
_RINvYyNtNtNtCs7tbBVnmGocF_7cbor4ii4core3dec6Decode6decodeNtNtB8_5utils11SliceReaderECsboUdcTbF1FS_15direct_syscalls:
   73|  1.27k|    fn decode<R: Read<'a>>(reader: &mut R) -> Result<Self, Error<R::Error>> {
   74|  1.27k|        let byte = pull_one(reader)?;
   75|  1.27k|        Self::decode_with(byte, reader)
   76|  1.27k|    }
_RINvMs0_NtNtCs7tbBVnmGocF_7cbor4ii4core3decNtB6_7TypeNum10decode_u64NtNtB8_5utils11SliceReaderECsboUdcTbF1FS_15direct_syscalls:
  223|  32.7k|    pub(crate) fn decode_u64<'a, R: Read<'a>>(self, reader: &mut R) -> Result<u64, Error<R::Error>> {
  224|  32.7k|        match self.byte & self.major_limit {
  225|  32.7k|            x @ 0 ..= 0x17 => Ok(x.into()),
  226|  15.2k|            0x18 => pull_one(reader).map(Into::into),
  227|       |            0x19 => {
  228|      0|                let mut buf = [0; 2];
  229|      0|                pull_exact(reader, &mut buf)?;
  230|      0|                Ok(u16::from_be_bytes(buf).into())
  231|       |            },
  232|       |            0x1a => {
  233|      0|                let mut buf = [0; 4];
  234|      0|                pull_exact(reader, &mut buf)?;
  235|      0|                Ok(u32::from_be_bytes(buf).into())
  236|       |            },
  237|       |            0x1b => {
  238|      0|                let mut buf = [0; 8];
  239|      0|                pull_exact(reader, &mut buf)?;
  240|      0|                Ok(u64::from_be_bytes(buf))
  241|       |            },
  242|      0|            _ => Err(Error::mismatch(self.major_limit, self.byte))
  243|       |        }
  244|  32.7k|    }
_RINvXss_NtNtCs7tbBVnmGocF_7cbor4ii4core3decyNtB6_6Decode11decode_withNtNtB8_5utils11SliceReaderECsboUdcTbF1FS_15direct_syscalls:
  252|  1.27k|                fn decode_with<R: Read<'a>>(byte: u8, reader: &mut R) -> Result<Self, Error<R::Error>> {
  253|  1.27k|                    TypeNum::new(!(major::UNSIGNED << 5), byte).$decode_fn(reader)
  254|  1.27k|                }
_RINvXs5_NtNtCs7tbBVnmGocF_7cbor4ii4core3decINtNtB8_5types5BytesINtNtCs9pDt8l5wGDA_5alloc6borrow3CowShEENtB6_6Decode11decode_withNtNtB8_5utils11SliceReaderECsboUdcTbF1FS_15direct_syscalls:
  506|  9.85k|    fn decode_with<R: Read<'a>>(byte: u8, reader: &mut R) -> Result<Self, Error<R::Error>> {
  507|  9.85k|        use crate::alloc::borrow::Cow;
  508|  9.85k|
  509|  9.85k|        let mut buf = Vec::new();
  510|  9.85k|        Ok(types::Bytes(if let Some(longbuf) = decode_buf(major::BYTES, byte, reader, &mut buf)? {
  511|  9.85k|            Cow::Borrowed(longbuf)
  512|       |        } else {
  513|      0|            Cow::Owned(buf)
  514|       |        }))
  515|  9.85k|    }
_RINvMs0_NtNtCs7tbBVnmGocF_7cbor4ii4core3decNtB6_7TypeNum10decode_u32NtNtB8_5utils11SliceReaderECsboUdcTbF1FS_15direct_syscalls:
  204|    318|    fn decode_u32<'a, R: Read<'a>>(self, reader: &mut R) -> Result<u32, Error<R::Error>> {
  205|    318|        match self.byte & self.major_limit {
  206|    318|            x @ 0 ..= 0x17 => Ok(x.into()),
  207|      0|            0x18 => pull_one(reader).map(Into::into),
  208|       |            0x19 => {
  209|      0|                let mut buf = [0; 2];
  210|      0|                pull_exact(reader, &mut buf)?;
  211|      0|                Ok(u16::from_be_bytes(buf).into())
  212|       |            },
  213|       |            0x1a => {
  214|      0|                let mut buf = [0; 4];
  215|      0|                pull_exact(reader, &mut buf)?;
  216|      0|                Ok(u32::from_be_bytes(buf))
  217|       |            }
  218|      0|            _ => Err(Error::mismatch(self.major_limit, self.byte))
  219|       |        }
  220|    318|    }
_RINvXsc_NtNtCs7tbBVnmGocF_7cbor4ii4core3decNtB6_10ArrayStartNtB6_6Decode11decode_withNtNtB8_5utils11SliceReaderECsboUdcTbF1FS_15direct_syscalls:
  611|  9.22k|    fn decode_with<R: Read<'a>>(byte: u8, reader: &mut R) -> Result<Self, Error<R::Error>> {
  612|  9.22k|        decode_len(major::ARRAY, byte, reader).map(ArrayStart)
  613|  9.22k|    }
_RINvXs8_NtNtCs7tbBVnmGocF_7cbor4ii4core3decINtNtCs9pDt8l5wGDA_5alloc6borrow3CoweENtB6_6Decode11decode_withNtNtB8_5utils11SliceReaderECsboUdcTbF1FS_15direct_syscalls:
  545|  4.77k|    fn decode_with<R: Read<'a>>(byte: u8, reader: &mut R) -> Result<Self, Error<R::Error>> {
  546|  4.77k|        use crate::alloc::borrow::Cow;
  547|  4.77k|
  548|  4.77k|        let mut buf = Vec::new();
  549|  4.77k|        Ok(if let Some(longbuf) = decode_buf(major::STRING, byte, reader, &mut buf)? {
  550|  4.77k|            Cow::Borrowed(core::str::from_utf8(longbuf).map_err(Error::InvalidUtf8)?)
  551|       |        } else {
  552|      0|            let buf = String::from_utf8(buf)
  553|      0|                .map_err(|err| Error::InvalidUtf8(err.utf8_error()))?;
  554|      0|            Cow::Owned(buf)
  555|       |        })
  556|  4.77k|    }
_RNvMNtNtCs7tbBVnmGocF_7cbor4ii4core3decNtB2_9Reference6as_ref:
   81|  82.0k|    pub(crate) const fn as_ref(&self) -> &[u8] {
   82|  82.0k|        match self {
   83|  82.0k|            Reference::Long(buf) => buf,
   84|      0|            Reference::Short(buf) => buf
   85|       |        }
   86|  82.0k|    }
_RINvXsr_NtNtCs7tbBVnmGocF_7cbor4ii4core3decmNtB6_6Decode11decode_withNtNtB8_5utils11SliceReaderECs7AwuCMXPzRZ_8fvm_fuzz:
  252|    318|                fn decode_with<R: Read<'a>>(byte: u8, reader: &mut R) -> Result<Self, Error<R::Error>> {
  253|    318|                    TypeNum::new(!(major::UNSIGNED << 5), byte).$decode_fn(reader)
  254|    318|                }
_RINvXss_NtNtCs7tbBVnmGocF_7cbor4ii4core3decyNtB6_6Decode11decode_withNtNtB8_5utils11SliceReaderECs7AwuCMXPzRZ_8fvm_fuzz:
  252|    318|                fn decode_with<R: Read<'a>>(byte: u8, reader: &mut R) -> Result<Self, Error<R::Error>> {
  253|    318|                    TypeNum::new(!(major::UNSIGNED << 5), byte).$decode_fn(reader)
  254|    318|                }
_RINvYNtNtNtCs7tbBVnmGocF_7cbor4ii4core3dec10ArrayStartNtB5_6Decode6decodeNtNtB7_5utils11SliceReaderECs7AwuCMXPzRZ_8fvm_fuzz:
   73|  5.72k|    fn decode<R: Read<'a>>(reader: &mut R) -> Result<Self, Error<R::Error>> {
   74|  5.72k|        let byte = pull_one(reader)?;
   75|  5.72k|        Self::decode_with(byte, reader)
   76|  5.72k|    }
_RINvYINtNtCs9pDt8l5wGDA_5alloc6borrow3CoweENtNtNtCs7tbBVnmGocF_7cbor4ii4core3dec6Decode6decodeNtNtBJ_5utils11SliceReaderECs7AwuCMXPzRZ_8fvm_fuzz:
   73|  5.40k|    fn decode<R: Read<'a>>(reader: &mut R) -> Result<Self, Error<R::Error>> {
   74|  5.40k|        let byte = pull_one(reader)?;
   75|  5.40k|        Self::decode_with(byte, reader)
   76|  5.40k|    }
_RINvXs8_NtNtCs7tbBVnmGocF_7cbor4ii4core3decINtNtCs9pDt8l5wGDA_5alloc6borrow3CoweENtB6_6Decode11decode_withNtNtB8_5utils11SliceReaderECs7AwuCMXPzRZ_8fvm_fuzz:
  545|  5.40k|    fn decode_with<R: Read<'a>>(byte: u8, reader: &mut R) -> Result<Self, Error<R::Error>> {
  546|  5.40k|        use crate::alloc::borrow::Cow;
  547|  5.40k|
  548|  5.40k|        let mut buf = Vec::new();
  549|  5.40k|        Ok(if let Some(longbuf) = decode_buf(major::STRING, byte, reader, &mut buf)? {
  550|  5.40k|            Cow::Borrowed(core::str::from_utf8(longbuf).map_err(Error::InvalidUtf8)?)
  551|       |        } else {
  552|      0|            let buf = String::from_utf8(buf)
  553|      0|                .map_err(|err| Error::InvalidUtf8(err.utf8_error()))?;
  554|      0|            Cow::Owned(buf)
  555|       |        })
  556|  5.40k|    }
_RINvMs0_NtNtCs7tbBVnmGocF_7cbor4ii4core3decNtB6_7TypeNum10decode_u64NtNtB8_5utils11SliceReaderECs7AwuCMXPzRZ_8fvm_fuzz:
  223|  22.5k|    pub(crate) fn decode_u64<'a, R: Read<'a>>(self, reader: &mut R) -> Result<u64, Error<R::Error>> {
  224|  22.5k|        match self.byte & self.major_limit {
  225|  22.5k|            x @ 0 ..= 0x17 => Ok(x.into()),
  226|  10.8k|            0x18 => pull_one(reader).map(Into::into),
  227|       |            0x19 => {
  228|      0|                let mut buf = [0; 2];
  229|      0|                pull_exact(reader, &mut buf)?;
  230|      0|                Ok(u16::from_be_bytes(buf).into())
  231|       |            },
  232|       |            0x1a => {
  233|      0|                let mut buf = [0; 4];
  234|      0|                pull_exact(reader, &mut buf)?;
  235|      0|                Ok(u32::from_be_bytes(buf).into())
  236|       |            },
  237|       |            0x1b => {
  238|      0|                let mut buf = [0; 8];
  239|      0|                pull_exact(reader, &mut buf)?;
  240|      0|                Ok(u64::from_be_bytes(buf))
  241|       |            },
  242|      0|            _ => Err(Error::mismatch(self.major_limit, self.byte))
  243|       |        }
  244|  22.5k|    }
_RINvNtNtCs7tbBVnmGocF_7cbor4ii4core3dec8pull_oneNtNtB4_5utils11SliceReaderECs7AwuCMXPzRZ_8fvm_fuzz:
  125|  33.7k|pub(crate) fn pull_one<'a, R: Read<'a>>(reader: &mut R) -> Result<u8, Error<R::Error>> {
  126|  33.7k|    let b = reader.fill(1)?
  127|  33.7k|        .as_ref()
  128|  33.7k|        .get(0)
  129|  33.7k|        .copied()
  130|  33.7k|        .ok_or(Error::Eof)?;
  131|  33.7k|    reader.advance(1);
  132|  33.7k|    Ok(b)
  133|  33.7k|}
_RINvYNtNtNtCs7tbBVnmGocF_7cbor4ii4core3dec8MapStartNtB5_6Decode6decodeNtNtB7_5utils11SliceReaderECs7AwuCMXPzRZ_8fvm_fuzz:
   73|    318|    fn decode<R: Read<'a>>(reader: &mut R) -> Result<Self, Error<R::Error>> {
   74|    318|        let byte = pull_one(reader)?;
   75|    318|        Self::decode_with(byte, reader)
   76|    318|    }
_RINvXsc_NtNtCs7tbBVnmGocF_7cbor4ii4core3decNtB6_10ArrayStartNtB6_6Decode11decode_withNtNtB8_5utils11SliceReaderECs7AwuCMXPzRZ_8fvm_fuzz:
  611|  5.72k|    fn decode_with<R: Read<'a>>(byte: u8, reader: &mut R) -> Result<Self, Error<R::Error>> {
  612|  5.72k|        decode_len(major::ARRAY, byte, reader).map(ArrayStart)
  613|  5.72k|    }
_RINvXsg_NtNtCs7tbBVnmGocF_7cbor4ii4core3decNtB6_8TagStartNtB6_6Decode11decode_withNtNtB8_5utils11SliceReaderECs7AwuCMXPzRZ_8fvm_fuzz:
  703|  5.40k|    fn decode_with<R: Read<'a>>(byte: u8, reader: &mut R) -> Result<Self, Error<R::Error>> {
  704|  5.40k|        TypeNum::new(!(major::TAG << 5), byte).decode_u64(reader).map(TagStart)
  705|  5.40k|    }
_RINvYmNtNtNtCs7tbBVnmGocF_7cbor4ii4core3dec6Decode6decodeNtNtB8_5utils11SliceReaderECs7AwuCMXPzRZ_8fvm_fuzz:
   73|    318|    fn decode<R: Read<'a>>(reader: &mut R) -> Result<Self, Error<R::Error>> {
   74|    318|        let byte = pull_one(reader)?;
   75|    318|        Self::decode_with(byte, reader)
   76|    318|    }
_RINvYyNtNtNtCs7tbBVnmGocF_7cbor4ii4core3dec6Decode6decodeNtNtB8_5utils11SliceReaderECs7AwuCMXPzRZ_8fvm_fuzz:
   73|    318|    fn decode<R: Read<'a>>(reader: &mut R) -> Result<Self, Error<R::Error>> {
   74|    318|        let byte = pull_one(reader)?;
   75|    318|        Self::decode_with(byte, reader)
   76|    318|    }
_RINvNtNtCs7tbBVnmGocF_7cbor4ii4core3dec10decode_lenNtNtB4_5utils11SliceReaderECs7AwuCMXPzRZ_8fvm_fuzz:
  595|  16.8k|fn decode_len<'a, R: Read<'a>>(major: u8, byte: u8, reader: &mut R)
  596|  16.8k|    -> Result<Option<usize>, Error<R::Error>>
  597|  16.8k|{
  598|  16.8k|    if byte != (marker::START | (major << 5)) {
  599|  16.8k|        let len = TypeNum::new(!(major << 5), byte).decode_u64(reader)?;
  600|  16.8k|        let len = usize::try_from(len).map_err(Error::CastOverflow)?;
  601|  16.8k|        Ok(Some(len))
  602|       |    } else {
  603|      0|        Ok(None)
  604|       |    }
  605|  16.8k|}
_RINvYNtNtNtCs7tbBVnmGocF_7cbor4ii4core3dec8TagStartNtB5_6Decode6decodeNtNtB7_5utils11SliceReaderECs7AwuCMXPzRZ_8fvm_fuzz:
   73|  5.40k|    fn decode<R: Read<'a>>(reader: &mut R) -> Result<Self, Error<R::Error>> {
   74|  5.40k|        let byte = pull_one(reader)?;
   75|  5.40k|        Self::decode_with(byte, reader)
   76|  5.40k|    }
_RINvXs5_NtNtCs7tbBVnmGocF_7cbor4ii4core3decINtNtB8_5types5BytesINtNtCs9pDt8l5wGDA_5alloc6borrow3CowShEENtB6_6Decode11decode_withNtNtB8_5utils11SliceReaderECs7AwuCMXPzRZ_8fvm_fuzz:
  506|  5.40k|    fn decode_with<R: Read<'a>>(byte: u8, reader: &mut R) -> Result<Self, Error<R::Error>> {
  507|  5.40k|        use crate::alloc::borrow::Cow;
  508|  5.40k|
  509|  5.40k|        let mut buf = Vec::new();
  510|  5.40k|        Ok(types::Bytes(if let Some(longbuf) = decode_buf(major::BYTES, byte, reader, &mut buf)? {
  511|  5.40k|            Cow::Borrowed(longbuf)
  512|       |        } else {
  513|      0|            Cow::Owned(buf)
  514|       |        }))
  515|  5.40k|    }
_RINvYINtNtNtCs7tbBVnmGocF_7cbor4ii4core5types5BytesINtNtCs9pDt8l5wGDA_5alloc6borrow3CowShEENtNtB8_3dec6Decode6decodeNtNtB8_5utils11SliceReaderECs7AwuCMXPzRZ_8fvm_fuzz:
   73|  5.40k|    fn decode<R: Read<'a>>(reader: &mut R) -> Result<Self, Error<R::Error>> {
   74|  5.40k|        let byte = pull_one(reader)?;
   75|  5.40k|        Self::decode_with(byte, reader)
   76|  5.40k|    }
_RINvXse_NtNtCs7tbBVnmGocF_7cbor4ii4core3decNtB6_8MapStartNtB6_6Decode11decode_withNtNtB8_5utils11SliceReaderECs7AwuCMXPzRZ_8fvm_fuzz:
  656|    318|    fn decode_with<R: Read<'a>>(byte: u8, reader: &mut R) -> Result<Self, Error<R::Error>> {
  657|    318|        decode_len(major::MAP, byte, reader).map(MapStart)
  658|    318|    }
_RINvMs0_NtNtCs7tbBVnmGocF_7cbor4ii4core3decNtB6_7TypeNum10decode_u32NtNtB8_5utils11SliceReaderECs7AwuCMXPzRZ_8fvm_fuzz:
  204|    318|    fn decode_u32<'a, R: Read<'a>>(self, reader: &mut R) -> Result<u32, Error<R::Error>> {
  205|    318|        match self.byte & self.major_limit {
  206|    318|            x @ 0 ..= 0x17 => Ok(x.into()),
  207|      0|            0x18 => pull_one(reader).map(Into::into),
  208|       |            0x19 => {
  209|      0|                let mut buf = [0; 2];
  210|      0|                pull_exact(reader, &mut buf)?;
  211|      0|                Ok(u16::from_be_bytes(buf).into())
  212|       |            },
  213|       |            0x1a => {
  214|      0|                let mut buf = [0; 4];
  215|      0|                pull_exact(reader, &mut buf)?;
  216|      0|                Ok(u32::from_be_bytes(buf))
  217|       |            }
  218|      0|            _ => Err(Error::mismatch(self.major_limit, self.byte))
  219|       |        }
  220|    318|    }
_RINvNtNtCs7tbBVnmGocF_7cbor4ii4core3dec10decode_bufNtNtB4_5utils11SliceReaderECs7AwuCMXPzRZ_8fvm_fuzz:
  427|  10.8k|fn decode_buf<'a, R: Read<'a>>(major: u8, byte: u8, reader: &mut R, buf: &mut Vec<u8>)
  428|  10.8k|    -> Result<Option<&'a [u8]>, Error<R::Error>>
  429|  10.8k|{
  430|       |    const CAP_LIMIT: usize = 16 * 1024;
  431|       |
  432|  10.8k|    if let Some(mut len) = decode_len(major, byte, reader)? {
  433|       |        // try long lifetime buffer
  434|  10.8k|        if let Reference::Long(buf) = reader.fill(len)? {
  435|  10.8k|            if buf.len() >= len {
  436|  10.8k|                reader.advance(len);
  437|  10.8k|                return Ok(Some(&buf[..len]));
  438|      0|            }
  439|      0|        }
  440|       |
  441|      0|        buf.reserve(core::cmp::min(len, CAP_LIMIT)); // TODO try_reserve ?
  442|       |
  443|      0|        while len != 0 {
  444|      0|            let readbuf = reader.fill(len)?;
  445|      0|            let readbuf = readbuf.as_ref();
  446|      0|
  447|      0|            if readbuf.is_empty() {
  448|      0|                return Err(Error::Eof);
  449|      0|            }
  450|      0|
  451|      0|            let readlen = core::cmp::min(readbuf.len(), len);
  452|      0|
  453|      0|            buf.extend_from_slice(&readbuf[..readlen]);
  454|      0|            reader.advance(readlen);
  455|      0|            len -= readlen;
  456|       |        }
  457|       |
  458|      0|        Ok(None)
  459|       |    } else {
  460|       |        // bytes sequence
  461|       |        loop {
  462|      0|            let byte = pull_one(reader)?;
  463|       |
  464|      0|            if byte == marker::BREAK {
  465|      0|                break
  466|      0|            }
  467|      0|
  468|      0|            if !reader.step_in() {
  469|      0|                return Err(Error::DepthLimit);
  470|      0|            }
  471|      0|            let mut reader = ScopeGuard(reader, |reader| reader.step_out());
  472|      0|            let reader = &mut *reader;
  473|       |
  474|      0|            if let Some(longbuf) = decode_buf(major, byte, reader, buf)? {
  475|      0|                buf.extend_from_slice(longbuf);
  476|      0|            }
  477|       |        }
  478|       |
  479|      0|        Ok(None)
  480|       |    }
  481|  10.8k|}

_RINvXs4_NtNtCs7tbBVnmGocF_7cbor4ii4core3encINtB6_7TypeNumyENtB6_6Encode6encodeNtNtB8_5utils9BufWriterECsboUdcTbF1FS_15direct_syscalls:
   98|  12.4k|    fn encode<W: Write>(&self, writer: &mut W) -> Result<(), Error<W::Error>> {
   99|  12.4k|        match u32::try_from(self.value) {
  100|  12.4k|            Ok(x) => TypeNum::new(self.type_, x).encode(writer)?,
  101|       |            Err(_) => {
  102|      0|                let [x0, x1, x2, x3, x4, x5, x6, x7] = self.value.to_be_bytes();
  103|      0|                writer.push(&[self.type_ | 0x1b, x0, x1, x2, x3, x4, x5, x6, x7])?;
  104|       |            }
  105|       |        }
  106|  12.4k|        Ok(())
  107|  12.4k|    }
_RINvXsl_NtNtCs7tbBVnmGocF_7cbor4ii4core3encNtNtB8_5types4NullNtB6_6Encode6encodeNtNtB8_5utils9BufWriterECsboUdcTbF1FS_15direct_syscalls:
  343|    954|        writer.push(&[marker::NULL])?;
  344|    954|        Ok(())
  345|    954|    }
_RINvXs3_NtNtCs7tbBVnmGocF_7cbor4ii4core3encINtB6_7TypeNummENtB6_6Encode6encodeNtNtB8_5utils9BufWriterECsboUdcTbF1FS_15direct_syscalls:
   84|  12.4k|    fn encode<W: Write>(&self, writer: &mut W) -> Result<(), Error<W::Error>> {
   85|  12.4k|        match u16::try_from(self.value) {
   86|  12.4k|            Ok(x) => TypeNum::new(self.type_, x).encode(writer)?,
   87|       |            Err(_) =>{
   88|      0|                let [x0, x1, x2, x3] = self.value.to_be_bytes();
   89|      0|                writer.push(&[self.type_ | 0x1a, x0, x1, x2, x3])?;
   90|       |            }
   91|       |        }
   92|  12.4k|        Ok(())
   93|  12.4k|    }
_RINvXsu_NtNtCs7tbBVnmGocF_7cbor4ii4core3encyNtB6_6Encode6encodeNtNtB8_5utils9BufWriterECsboUdcTbF1FS_15direct_syscalls:
  159|  1.27k|                fn encode<W: Write>(&self, writer: &mut W) -> Result<(), Error<W::Error>> {
  160|  1.27k|                    TypeNum::new(major::UNSIGNED << 5, *self).encode(writer)
  161|  1.27k|                }
_RNvMs0_NtNtCs7tbBVnmGocF_7cbor4ii4core3encINtB5_7TypeNumhE3newCsboUdcTbF1FS_15direct_syscalls:
   52|  12.4k|    const fn new(type_: u8, value: V) -> TypeNum<V> {
   53|  12.4k|        TypeNum { type_, value }
   54|  12.4k|    }
_RNvMs0_NtNtCs7tbBVnmGocF_7cbor4ii4core3encINtB5_7TypeNumyE3newCsboUdcTbF1FS_15direct_syscalls:
   52|  12.4k|    const fn new(type_: u8, value: V) -> TypeNum<V> {
   53|  12.4k|        TypeNum { type_, value }
   54|  12.4k|    }
_RINvXsd_NtNtCs7tbBVnmGocF_7cbor4ii4core3encNtB6_17ArrayStartBoundedNtB6_6Encode6encodeNtNtB8_5utils9BufWriterECsboUdcTbF1FS_15direct_syscalls:
  270|  3.81k|        TypeNum::new(major::ARRAY << 5, self.0 as u64).encode(writer)?;
  271|  3.81k|        Ok(())
  272|  3.81k|    }
_RNvMs0_NtNtCs7tbBVnmGocF_7cbor4ii4core3encINtB5_7TypeNumtE3newCsboUdcTbF1FS_15direct_syscalls:
   52|  12.4k|    const fn new(type_: u8, value: V) -> TypeNum<V> {
   53|  12.4k|        TypeNum { type_, value }
   54|  12.4k|    }
_RINvXs1_NtNtCs7tbBVnmGocF_7cbor4ii4core3encINtB6_7TypeNumhENtB6_6Encode6encodeNtNtB8_5utils9BufWriterECsboUdcTbF1FS_15direct_syscalls:
   59|  12.4k|    fn encode<W: Write>(&self, writer: &mut W) -> Result<(), Error<W::Error>> {
   60|  12.4k|        match self.value {
   61|  12.4k|            x @ 0x00 ..= 0x17 => writer.push(&[self.type_ | x])?,
   62|  5.08k|            x => writer.push(&[self.type_ | 0x18, x])?
   63|       |        }
   64|  12.4k|        Ok(())
   65|  12.4k|    }
_RINvXs7_NtNtCs7tbBVnmGocF_7cbor4ii4core3encINtNtB8_5types5BytesRShENtB6_6Encode6encodeNtNtB8_5utils9BufWriterECsboUdcTbF1FS_15direct_syscalls:
  209|  4.77k|        TypeNum::new(major::BYTES << 5, self.0.len() as u64).encode(writer)?;
  210|  4.77k|        writer.push(self.0)?;
  211|  4.77k|        Ok(())
  212|  4.77k|    }
_RNvMs0_NtNtCs7tbBVnmGocF_7cbor4ii4core3encINtB5_7TypeNummE3newCsboUdcTbF1FS_15direct_syscalls:
   52|  12.4k|    const fn new(type_: u8, value: V) -> TypeNum<V> {
   53|  12.4k|        TypeNum { type_, value }
   54|  12.4k|    }
_RINvXsi_NtNtCs7tbBVnmGocF_7cbor4ii4core3encINtNtB8_5types3TagINtBI_5BytesRShEENtB6_6Encode6encodeNtNtB8_5utils9BufWriterECsboUdcTbF1FS_15direct_syscalls:
  317|  2.54k|        TypeNum::new(major::TAG << 5, self.0).encode(writer)?;
  318|  2.54k|        self.1.encode(writer)
  319|  2.54k|    }
_RINvXs2_NtNtCs7tbBVnmGocF_7cbor4ii4core3encINtB6_7TypeNumtENtB6_6Encode6encodeNtNtB8_5utils9BufWriterECsboUdcTbF1FS_15direct_syscalls:
   70|  12.4k|    fn encode<W: Write>(&self, writer: &mut W) -> Result<(), Error<W::Error>> {
   71|  12.4k|        match u8::try_from(self.value) {
   72|  12.4k|            Ok(x) => TypeNum::new(self.type_, x).encode(writer)?,
   73|       |            Err(_) => {
   74|      0|                let [x0, x1] = self.value.to_be_bytes();
   75|      0|                writer.push(&[self.type_ | 0x19, x0, x1])?
   76|       |            }
   77|       |        }
   78|  12.4k|        Ok(())
   79|  12.4k|    }
_RINvXs1_NtNtCs7tbBVnmGocF_7cbor4ii4core3encINtB6_7TypeNumhENtB6_6Encode6encodeNtNtB8_5utils9BufWriterECs7AwuCMXPzRZ_8fvm_fuzz:
   59|  4.13k|    fn encode<W: Write>(&self, writer: &mut W) -> Result<(), Error<W::Error>> {
   60|  4.13k|        match self.value {
   61|  4.13k|            x @ 0x00 ..= 0x17 => writer.push(&[self.type_ | x])?,
   62|  1.59k|            x => writer.push(&[self.type_ | 0x18, x])?
   63|       |        }
   64|  4.13k|        Ok(())
   65|  4.13k|    }
_RINvXs9_NtNtCs7tbBVnmGocF_7cbor4ii4core3encReNtB6_6Encode6encodeNtNtB8_5utils9BufWriterECs7AwuCMXPzRZ_8fvm_fuzz:
  228|    318|        TypeNum::new(major::STRING << 5, self.len() as u64).encode(writer)?;
  229|    318|        writer.push(self.as_bytes())?;
  230|    318|        Ok(())
  231|    318|    }
_RINvXsd_NtNtCs7tbBVnmGocF_7cbor4ii4core3encNtB6_17ArrayStartBoundedNtB6_6Encode6encodeNtNtB8_5utils9BufWriterECs7AwuCMXPzRZ_8fvm_fuzz:
  270|  1.90k|        TypeNum::new(major::ARRAY << 5, self.0 as u64).encode(writer)?;
  271|  1.90k|        Ok(())
  272|  1.90k|    }
_RNvMs0_NtNtCs7tbBVnmGocF_7cbor4ii4core3encINtB5_7TypeNumyE3newCs7AwuCMXPzRZ_8fvm_fuzz:
   52|  4.13k|    const fn new(type_: u8, value: V) -> TypeNum<V> {
   53|  4.13k|        TypeNum { type_, value }
   54|  4.13k|    }
_RINvXs3_NtNtCs7tbBVnmGocF_7cbor4ii4core3encINtB6_7TypeNummENtB6_6Encode6encodeNtNtB8_5utils9BufWriterECs7AwuCMXPzRZ_8fvm_fuzz:
   84|  4.13k|    fn encode<W: Write>(&self, writer: &mut W) -> Result<(), Error<W::Error>> {
   85|  4.13k|        match u16::try_from(self.value) {
   86|  4.13k|            Ok(x) => TypeNum::new(self.type_, x).encode(writer)?,
   87|       |            Err(_) =>{
   88|      0|                let [x0, x1, x2, x3] = self.value.to_be_bytes();
   89|      0|                writer.push(&[self.type_ | 0x1a, x0, x1, x2, x3])?;
   90|       |            }
   91|       |        }
   92|  4.13k|        Ok(())
   93|  4.13k|    }
_RINvXs7_NtNtCs7tbBVnmGocF_7cbor4ii4core3encINtNtB8_5types5BytesRShENtB6_6Encode6encodeNtNtB8_5utils9BufWriterECs7AwuCMXPzRZ_8fvm_fuzz:
  209|    954|        TypeNum::new(major::BYTES << 5, self.0.len() as u64).encode(writer)?;
  210|    954|        writer.push(self.0)?;
  211|    954|        Ok(())
  212|    954|    }
_RNvMs0_NtNtCs7tbBVnmGocF_7cbor4ii4core3encINtB5_7TypeNumtE3newCs7AwuCMXPzRZ_8fvm_fuzz:
   52|  4.13k|    const fn new(type_: u8, value: V) -> TypeNum<V> {
   53|  4.13k|        TypeNum { type_, value }
   54|  4.13k|    }
_RNvMs0_NtNtCs7tbBVnmGocF_7cbor4ii4core3encINtB5_7TypeNummE3newCs7AwuCMXPzRZ_8fvm_fuzz:
   52|  4.13k|    const fn new(type_: u8, value: V) -> TypeNum<V> {
   53|  4.13k|        TypeNum { type_, value }
   54|  4.13k|    }
_RINvXs4_NtNtCs7tbBVnmGocF_7cbor4ii4core3encINtB6_7TypeNumyENtB6_6Encode6encodeNtNtB8_5utils9BufWriterECs7AwuCMXPzRZ_8fvm_fuzz:
   98|  4.13k|    fn encode<W: Write>(&self, writer: &mut W) -> Result<(), Error<W::Error>> {
   99|  4.13k|        match u32::try_from(self.value) {
  100|  4.13k|            Ok(x) => TypeNum::new(self.type_, x).encode(writer)?,
  101|       |            Err(_) => {
  102|      0|                let [x0, x1, x2, x3, x4, x5, x6, x7] = self.value.to_be_bytes();
  103|      0|                writer.push(&[self.type_ | 0x1b, x0, x1, x2, x3, x4, x5, x6, x7])?;
  104|       |            }
  105|       |        }
  106|  4.13k|        Ok(())
  107|  4.13k|    }
_RINvXsu_NtNtCs7tbBVnmGocF_7cbor4ii4core3encyNtB6_6Encode6encodeNtNtB8_5utils9BufWriterECs7AwuCMXPzRZ_8fvm_fuzz:
  159|    318|                fn encode<W: Write>(&self, writer: &mut W) -> Result<(), Error<W::Error>> {
  160|    318|                    TypeNum::new(major::UNSIGNED << 5, *self).encode(writer)
  161|    318|                }
_RINvXsi_NtNtCs7tbBVnmGocF_7cbor4ii4core3encINtNtB8_5types3TagINtBI_5BytesRShEENtB6_6Encode6encodeNtNtB8_5utils9BufWriterECs7AwuCMXPzRZ_8fvm_fuzz:
  317|    636|        TypeNum::new(major::TAG << 5, self.0).encode(writer)?;
  318|    636|        self.1.encode(writer)
  319|    636|    }
_RINvXs2_NtNtCs7tbBVnmGocF_7cbor4ii4core3encINtB6_7TypeNumtENtB6_6Encode6encodeNtNtB8_5utils9BufWriterECs7AwuCMXPzRZ_8fvm_fuzz:
   70|  4.13k|    fn encode<W: Write>(&self, writer: &mut W) -> Result<(), Error<W::Error>> {
   71|  4.13k|        match u8::try_from(self.value) {
   72|  4.13k|            Ok(x) => TypeNum::new(self.type_, x).encode(writer)?,
   73|       |            Err(_) => {
   74|      0|                let [x0, x1] = self.value.to_be_bytes();
   75|      0|                writer.push(&[self.type_ | 0x19, x0, x1])?
   76|       |            }
   77|       |        }
   78|  4.13k|        Ok(())
   79|  4.13k|    }
_RNvMs0_NtNtCs7tbBVnmGocF_7cbor4ii4core3encINtB5_7TypeNumhE3newCs7AwuCMXPzRZ_8fvm_fuzz:
   52|  4.13k|    const fn new(type_: u8, value: V) -> TypeNum<V> {
   53|  4.13k|        TypeNum { type_, value }
   54|  4.13k|    }

_RNvXs1_NtNtCs7tbBVnmGocF_7cbor4ii4core5utilsNtB5_11SliceReaderNtNtB7_3dec4Read8step_out:
   84|  23.8k|    fn step_out(&mut self) {
   85|  23.8k|        self.limit += 1;
   86|  23.8k|    }
_RNvXs1_NtNtCs7tbBVnmGocF_7cbor4ii4core5utilsNtB5_11SliceReaderNtNtB7_3dec4Read7step_in:
   75|  23.8k|        if let Some(limit) = self.limit.checked_sub(1) {
   76|  23.8k|            self.limit = limit;
   77|  23.8k|            true
   78|       |        } else {
   79|      0|            false
   80|       |        }
   81|  23.8k|    }
_RNvXs1_NtNtCs7tbBVnmGocF_7cbor4ii4core5utilsNtB5_11SliceReaderNtNtB7_3dec4Read7advance:
   68|   108k|    fn advance(&mut self, n: usize) {
   69|   108k|        let len = core::cmp::min(self.buf.len(), n);
   70|   108k|        self.buf = &self.buf[len..];
   71|   108k|    }
_RNvXs1_NtNtCs7tbBVnmGocF_7cbor4ii4core5utilsNtB5_11SliceReaderNtNtB7_3dec4Read4fill:
   62|   131k|    fn fill<'b>(&'b mut self, want: usize) -> Result<dec::Reference<'de, 'b>, Self::Error> {
   63|   131k|        let len = core::cmp::min(self.buf.len(), want);
   64|   131k|        Ok(dec::Reference::Long(&self.buf[..len]))
   65|   131k|    }
_RNvXs_NtNtCs7tbBVnmGocF_7cbor4ii4core5utilsNtB4_9BufWriterNtNtB6_3enc5Write4push:
   40|  23.5k|        self.0.try_reserve(input.len())?;
   41|  23.5k|        self.0.extend_from_slice(input);
   42|  23.5k|        Ok(())
   43|  23.5k|    }
_RNvMNtNtCs7tbBVnmGocF_7cbor4ii4core5utilsNtB2_9BufWriter3new:
   14|  2.22k|    pub fn new(buf: Vec<u8>) -> Self {
   15|  2.22k|       BufWriter(buf)
   16|  2.22k|    }
_RNvMNtNtCs7tbBVnmGocF_7cbor4ii4core5utilsNtB2_9BufWriter10into_inner:
   24|  2.22k|    pub fn into_inner(self) -> Vec<u8> {
   25|  2.22k|        self.0
   26|  2.22k|    }
_RNvMs0_NtNtCs7tbBVnmGocF_7cbor4ii4core5utilsNtB5_11SliceReader3new:
   53|  2.22k|    pub fn new(buf: &[u8]) -> SliceReader<'_> {
   54|  2.22k|        SliceReader { buf, limit: 256 }
   55|  2.22k|    }

_RNvXse_NtCsl4cFeht4Yol_3cid3cidINtB5_3CidKj40_ENtNtCsiloedr2K6v7_4core3cmp9PartialEq2eqCsboUdcTbF1FS_15direct_syscalls:
   64|    367|#[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]
_RINvMNtCsl4cFeht4Yol_3cid3cidINtB3_3CidKj40_E11write_bytesQINtNtCs9pDt8l5wGDA_5alloc3vec3VechEECsboUdcTbF1FS_15direct_syscalls:
  176|  4.77k|    pub fn write_bytes<W: io::Write>(&self, w: W) -> Result<()> {
  177|  4.77k|        match self.version {
  178|      0|            Version::V0 => self.hash.write(w)?,
  179|  4.77k|            Version::V1 => self.write_bytes_v1(w)?,
  180|       |        }
  181|  4.77k|        Ok(())
  182|  4.77k|    }
_RINvMNtCsl4cFeht4Yol_3cid3cidINtB3_3CidKj40_E10read_bytesQRShECsboUdcTbF1FS_15direct_syscalls:
  140|  9.54k|    pub fn read_bytes<R: io::Read>(mut r: R) -> Result<Self> {
  141|  9.54k|        let version = varint_read_u64(&mut r)?;
  142|  9.54k|        let codec = varint_read_u64(&mut r)?;
  143|       |
  144|       |        // CIDv0 has the fixed `0x12 0x20` prefix
  145|  9.54k|        if [version, codec] == [0x12, 0x20] {
  146|      0|            let mut digest = [0u8; 32];
  147|      0|            r.read_exact(&mut digest)?;
  148|      0|            let mh = Multihash::wrap(version, &digest).expect("Digest is always 32 bytes.");
  149|      0|            return Self::new_v0(mh);
  150|  9.54k|        }
  151|       |
  152|  9.54k|        let version = Version::try_from(version)?;
  153|  9.54k|        match version {
  154|      0|            Version::V0 => Err(Error::InvalidExplicitCidV0),
  155|       |            Version::V1 => {
  156|  9.54k|                let mh = Multihash::read(r)?;
  157|  9.54k|                Self::new(version, codec, mh)
  158|       |            }
  159|       |        }
  160|  9.54k|    }
_RNvXs6_NtCsl4cFeht4Yol_3cid3cidINtB5_3CidKj40_EINtNtCsiloedr2K6v7_4core7convert7TryFromRShE8try_fromCsboUdcTbF1FS_15direct_syscalls:
  333|  9.54k|    fn try_from(mut bytes: &[u8]) -> Result<Self> {
  334|  9.54k|        Self::read_bytes(&mut bytes)
  335|  9.54k|    }
_RNvMNtCsl4cFeht4Yol_3cid3cidINtB2_3CidKj40_E12to_string_v1CsboUdcTbF1FS_15direct_syscalls:
  200|    318|    fn to_string_v1(&self) -> String {
  201|    318|        multibase::encode(Base::Base32Lower, self.to_bytes().as_slice())
  202|    318|    }
_RINvXsk_NtCsl4cFeht4Yol_3cid3cidINtB6_3CidKj40_ENtNtCsiloedr2K6v7_4core4hash4Hash4hashNtNtNtNtCsdyNNmftaNAQ_3std11collections4hash3map13DefaultHasherECsboUdcTbF1FS_15direct_syscalls:
   64|  18.1k|#[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]
_RNvXs0_NtCsl4cFeht4Yol_3cid3cidINtB5_3CidKj40_ENtNtCsiloedr2K6v7_4core3fmt7Display3fmtCsboUdcTbF1FS_15direct_syscalls:
  248|    318|    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
  249|    318|        let output = match self.version {
  250|      0|            Version::V0 => self.to_string_v0(),
  251|    318|            Version::V1 => self.to_string_v1(),
  252|       |        };
  253|    318|        write!(f, "{}", output)
  254|    318|    }
_RNvMNtCsl4cFeht4Yol_3cid3cidINtB2_3CidKj40_E6new_v1CsboUdcTbF1FS_15direct_syscalls:
   90|  10.1k|    pub const fn new_v1(codec: u64, hash: Multihash<S>) -> Self {
   91|  10.1k|        Self {
   92|  10.1k|            version: Version::V1,
   93|  10.1k|            codec,
   94|  10.1k|            hash,
   95|  10.1k|        }
   96|  10.1k|    }
_RINvMNtCsl4cFeht4Yol_3cid3cidINtB3_3CidKj40_E14write_bytes_v1QINtNtCs9pDt8l5wGDA_5alloc3vec3VechEECsboUdcTbF1FS_15direct_syscalls:
  162|  4.77k|    fn write_bytes_v1<W: io::Write>(&self, mut w: W) -> Result<()> {
  163|  4.77k|        let mut version_buf = varint_encode::u64_buffer();
  164|  4.77k|        let version = varint_encode::u64(self.version.into(), &mut version_buf);
  165|  4.77k|
  166|  4.77k|        let mut codec_buf = varint_encode::u64_buffer();
  167|  4.77k|        let codec = varint_encode::u64(self.codec, &mut codec_buf);
  168|  4.77k|
  169|  4.77k|        w.write_all(version)?;
  170|  4.77k|        w.write_all(codec)?;
  171|  4.77k|        self.hash.write(&mut w)?;
  172|  4.77k|        Ok(())
  173|  4.77k|    }
_RNvMNtCsl4cFeht4Yol_3cid3cidINtB2_3CidKj40_E8to_bytesCsboUdcTbF1FS_15direct_syscalls:
  186|  4.77k|    pub fn to_bytes(&self) -> Vec<u8> {
  187|  4.77k|        let mut bytes = Vec::new();
  188|  4.77k|        self.write_bytes(&mut bytes).unwrap();
  189|  4.77k|        bytes
  190|  4.77k|    }
_RNvXsh_NtCsl4cFeht4Yol_3cid3cidINtB5_3CidKj40_ENtNtCsiloedr2K6v7_4core5clone5Clone5cloneCsboUdcTbF1FS_15direct_syscalls:
   64|  2.86k|#[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]
_RNvMNtCsl4cFeht4Yol_3cid3cidINtB2_3CidKj40_E3newCsboUdcTbF1FS_15direct_syscalls:
   99|  9.54k|    pub const fn new(version: Version, codec: u64, hash: Multihash<S>) -> Result<Self> {
  100|  9.54k|        match version {
  101|       |            Version::V0 => {
  102|      0|                if codec != DAG_PB {
  103|      0|                    return Err(Error::InvalidCidV0Codec);
  104|      0|                }
  105|      0|                Self::new_v0(hash)
  106|       |            }
  107|  9.54k|            Version::V1 => Ok(Self::new_v1(codec, hash)),
  108|       |        }
  109|  9.54k|    }
_RNvXs6_NtCsl4cFeht4Yol_3cid3cidINtB5_3CidKj40_EINtNtCsiloedr2K6v7_4core7convert7TryFromRShE8try_fromCs7AwuCMXPzRZ_8fvm_fuzz:
  333|  5.40k|    fn try_from(mut bytes: &[u8]) -> Result<Self> {
  334|  5.40k|        Self::read_bytes(&mut bytes)
  335|  5.40k|    }
_RINvXsk_NtCsl4cFeht4Yol_3cid3cidINtB6_3CidKj40_ENtNtCsiloedr2K6v7_4core4hash4Hash4hashNtNtNtNtCsdyNNmftaNAQ_3std11collections4hash3map13DefaultHasherECs7AwuCMXPzRZ_8fvm_fuzz:
   64|  18.1k|#[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]
_RINvMNtCsl4cFeht4Yol_3cid3cidINtB3_3CidKj40_E10read_bytesQINtNtNtCsdyNNmftaNAQ_3std2io6cursor6CursorRINtNtCs9pDt8l5wGDA_5alloc3vec3VechEEECs7AwuCMXPzRZ_8fvm_fuzz:
  140|  5.40k|    pub fn read_bytes<R: io::Read>(mut r: R) -> Result<Self> {
  141|  5.40k|        let version = varint_read_u64(&mut r)?;
  142|  5.40k|        let codec = varint_read_u64(&mut r)?;
  143|       |
  144|       |        // CIDv0 has the fixed `0x12 0x20` prefix
  145|  5.40k|        if [version, codec] == [0x12, 0x20] {
  146|      0|            let mut digest = [0u8; 32];
  147|      0|            r.read_exact(&mut digest)?;
  148|      0|            let mh = Multihash::wrap(version, &digest).expect("Digest is always 32 bytes.");
  149|      0|            return Self::new_v0(mh);
  150|  5.40k|        }
  151|       |
  152|  5.40k|        let version = Version::try_from(version)?;
  153|  5.40k|        match version {
  154|      0|            Version::V0 => Err(Error::InvalidExplicitCidV0),
  155|       |            Version::V1 => {
  156|  5.40k|                let mh = Multihash::read(r)?;
  157|  5.40k|                Self::new(version, codec, mh)
  158|       |            }
  159|       |        }
  160|  5.40k|    }
_RINvMNtCsl4cFeht4Yol_3cid3cidINtB3_3CidKj40_E11write_bytesQINtNtCs9pDt8l5wGDA_5alloc3vec3VechEECs7AwuCMXPzRZ_8fvm_fuzz:
  176|    636|    pub fn write_bytes<W: io::Write>(&self, w: W) -> Result<()> {
  177|    636|        match self.version {
  178|      0|            Version::V0 => self.hash.write(w)?,
  179|    636|            Version::V1 => self.write_bytes_v1(w)?,
  180|       |        }
  181|    636|        Ok(())
  182|    636|    }
_RNvXse_NtCsl4cFeht4Yol_3cid3cidINtB5_3CidKj40_ENtNtCsiloedr2K6v7_4core3cmp9PartialEq2eqCs7AwuCMXPzRZ_8fvm_fuzz:
   64|    310|#[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]
_RNvMNtCsl4cFeht4Yol_3cid3cidINtB2_3CidKj40_E8to_bytesCs7AwuCMXPzRZ_8fvm_fuzz:
  186|    636|    pub fn to_bytes(&self) -> Vec<u8> {
  187|    636|        let mut bytes = Vec::new();
  188|    636|        self.write_bytes(&mut bytes).unwrap();
  189|    636|        bytes
  190|    636|    }
_RINvMNtCsl4cFeht4Yol_3cid3cidINtB3_3CidKj40_E10read_bytesQRShECs7AwuCMXPzRZ_8fvm_fuzz:
  140|  5.40k|    pub fn read_bytes<R: io::Read>(mut r: R) -> Result<Self> {
  141|  5.40k|        let version = varint_read_u64(&mut r)?;
  142|  5.40k|        let codec = varint_read_u64(&mut r)?;
  143|       |
  144|       |        // CIDv0 has the fixed `0x12 0x20` prefix
  145|  5.40k|        if [version, codec] == [0x12, 0x20] {
  146|      0|            let mut digest = [0u8; 32];
  147|      0|            r.read_exact(&mut digest)?;
  148|      0|            let mh = Multihash::wrap(version, &digest).expect("Digest is always 32 bytes.");
  149|      0|            return Self::new_v0(mh);
  150|  5.40k|        }
  151|       |
  152|  5.40k|        let version = Version::try_from(version)?;
  153|  5.40k|        match version {
  154|      0|            Version::V0 => Err(Error::InvalidExplicitCidV0),
  155|       |            Version::V1 => {
  156|  5.40k|                let mh = Multihash::read(r)?;
  157|  5.40k|                Self::new(version, codec, mh)
  158|       |            }
  159|       |        }
  160|  5.40k|    }
_RNvMNtCsl4cFeht4Yol_3cid3cidINtB2_3CidKj40_E6new_v1Cs7AwuCMXPzRZ_8fvm_fuzz:
   90|  12.4k|    pub const fn new_v1(codec: u64, hash: Multihash<S>) -> Self {
   91|  12.4k|        Self {
   92|  12.4k|            version: Version::V1,
   93|  12.4k|            codec,
   94|  12.4k|            hash,
   95|  12.4k|        }
   96|  12.4k|    }
_RNvMNtCsl4cFeht4Yol_3cid3cidINtB2_3CidKj40_E3newCs7AwuCMXPzRZ_8fvm_fuzz:
   99|  10.8k|    pub const fn new(version: Version, codec: u64, hash: Multihash<S>) -> Result<Self> {
  100|  10.8k|        match version {
  101|       |            Version::V0 => {
  102|      0|                if codec != DAG_PB {
  103|      0|                    return Err(Error::InvalidCidV0Codec);
  104|      0|                }
  105|      0|                Self::new_v0(hash)
  106|       |            }
  107|  10.8k|            Version::V1 => Ok(Self::new_v1(codec, hash)),
  108|       |        }
  109|  10.8k|    }
_RINvMNtCsl4cFeht4Yol_3cid3cidINtB3_3CidKj40_E14write_bytes_v1QINtNtCs9pDt8l5wGDA_5alloc3vec3VechEECs7AwuCMXPzRZ_8fvm_fuzz:
  162|    636|    fn write_bytes_v1<W: io::Write>(&self, mut w: W) -> Result<()> {
  163|    636|        let mut version_buf = varint_encode::u64_buffer();
  164|    636|        let version = varint_encode::u64(self.version.into(), &mut version_buf);
  165|    636|
  166|    636|        let mut codec_buf = varint_encode::u64_buffer();
  167|    636|        let codec = varint_encode::u64(self.codec, &mut codec_buf);
  168|    636|
  169|    636|        w.write_all(version)?;
  170|    636|        w.write_all(codec)?;
  171|    636|        self.hash.write(&mut w)?;
  172|    636|        Ok(())
  173|    636|    }
_RNvXsh_NtCsl4cFeht4Yol_3cid3cidINtB5_3CidKj40_ENtNtCsiloedr2K6v7_4core5clone5Clone5cloneCskJihg1y13m7_3fvm:
   64|    318|#[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]
_RINvXsk_NtCsl4cFeht4Yol_3cid3cidINtB6_3CidKj40_ENtNtCsiloedr2K6v7_4core4hash4Hash4hashNtNtNtNtCsdyNNmftaNAQ_3std11collections4hash3map13DefaultHasherECs23Y5vRLZE35_19fvm_ipld_blockstore:
   64|  17.4k|#[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]
_RNvXse_NtCsl4cFeht4Yol_3cid3cidINtB5_3CidKj40_ENtNtCsiloedr2K6v7_4core3cmp9PartialEq2eqCs23Y5vRLZE35_19fvm_ipld_blockstore:
   64|  3.01k|#[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]

_RINvXNvXs0_NtCsl4cFeht4Yol_3cid5serdeINtNtBb_3cid3CidKpENtNtCssVaLrL3Upj_5serde2de11Deserialize11deserializeINtB3_16MainEntryVisitorKj40_ENtBU_7Visitor20visit_newtype_structQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de15CidDeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECsboUdcTbF1FS_15direct_syscalls:
   97|  5.72k|            fn visit_newtype_struct<D>(self, deserializer: D) -> Result<Self::Value, D::Error>
   98|  5.72k|            where
   99|  5.72k|                D: de::Deserializer<'de>,
  100|  5.72k|            {
  101|  5.72k|                deserializer.deserialize_bytes(BytesToCidVisitor)
  102|  5.72k|            }
_RINvXs_NtCsl4cFeht4Yol_3cid5serdeNtB5_17BytesToCidVisitorNtNtCssVaLrL3Upj_5serde2de7Visitor11visit_bytesNtNtCs3TS9n28v4Rl_12libipld_core5error10SerdeErrorECsboUdcTbF1FS_15direct_syscalls:
   48|  1.90k|    fn visit_bytes<E>(self, value: &[u8]) -> Result<Self::Value, E>
   49|  1.90k|    where
   50|  1.90k|        E: de::Error,
   51|  1.90k|    {
   52|  1.90k|        CidGeneric::<SIZE>::try_from(value)
   53|  1.90k|            .map_err(|err| de::Error::custom(format!("Failed to deserialize CID: {}", err)))
   54|  1.90k|    }
_RINvXNvXs0_NtCsl4cFeht4Yol_3cid5serdeINtNtBb_3cid3CidKpENtNtCssVaLrL3Upj_5serde2de11Deserialize11deserializeINtB3_16MainEntryVisitorKj40_ENtBU_7Visitor20visit_newtype_structNtNtNtCs3TS9n28v4Rl_12libipld_core5serde2de15CidDeserializerECsboUdcTbF1FS_15direct_syscalls:
   97|  1.90k|            fn visit_newtype_struct<D>(self, deserializer: D) -> Result<Self::Value, D::Error>
   98|  1.90k|            where
   99|  1.90k|                D: de::Deserializer<'de>,
  100|  1.90k|            {
  101|  1.90k|                deserializer.deserialize_bytes(BytesToCidVisitor)
  102|  1.90k|            }
_RINvXs_NtCsl4cFeht4Yol_3cid5serdeNtB5_17BytesToCidVisitorNtNtCssVaLrL3Upj_5serde2de7Visitor11visit_bytesINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsiloedr2K6v7_4core7convert10InfallibleEECsboUdcTbF1FS_15direct_syscalls:
   48|  7.63k|    fn visit_bytes<E>(self, value: &[u8]) -> Result<Self::Value, E>
   49|  7.63k|    where
   50|  7.63k|        E: de::Error,
   51|  7.63k|    {
   52|  7.63k|        CidGeneric::<SIZE>::try_from(value)
   53|  7.63k|            .map_err(|err| de::Error::custom(format!("Failed to deserialize CID: {}", err)))
   54|  7.63k|    }
_RINvXs0_NtCsl4cFeht4Yol_3cid5serdeINtNtB8_3cid3CidKj40_ENtNtCssVaLrL3Upj_5serde2de11Deserialize11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECsboUdcTbF1FS_15direct_syscalls:
   79|  5.72k|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
   80|  5.72k|    where
   81|  5.72k|        D: de::Deserializer<'de>,
   82|  5.72k|    {
   83|  5.72k|        /// Main visitor to deserialize a CID.
   84|  5.72k|        ///
   85|  5.72k|        /// This visitor has only a single entry point to deserialize CIDs, it's
   86|  5.72k|        /// `visit_new_type_struct()`. This ensures that it isn't accidentally used to decode CIDs
   87|  5.72k|        /// to bytes.
   88|  5.72k|        struct MainEntryVisitor<const SIZE: usize>;
   89|  5.72k|
   90|  5.72k|        impl<'de, const SIZE: usize> de::Visitor<'de> for MainEntryVisitor<SIZE> {
   91|  5.72k|            type Value = CidGeneric<SIZE>;
   92|  5.72k|
   93|  5.72k|            fn expecting(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
   94|  5.72k|                write!(fmt, "a valid CID in bytes, wrapped in an newtype struct")
   95|  5.72k|            }
   96|  5.72k|
   97|  5.72k|            fn visit_newtype_struct<D>(self, deserializer: D) -> Result<Self::Value, D::Error>
   98|  5.72k|            where
   99|  5.72k|                D: de::Deserializer<'de>,
  100|  5.72k|            {
  101|  5.72k|                deserializer.deserialize_bytes(BytesToCidVisitor)
  102|  5.72k|            }
  103|  5.72k|        }
  104|  5.72k|
  105|  5.72k|        deserializer.deserialize_newtype_struct(CID_SERDE_PRIVATE_IDENTIFIER, MainEntryVisitor)
  106|  5.72k|    }
_RINvXNtCsl4cFeht4Yol_3cid5serdeINtNtB5_3cid3CidKj40_ENtNtCssVaLrL3Upj_5serde3ser9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECsboUdcTbF1FS_15direct_syscalls:
   29|  2.54k|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   30|  2.54k|    where
   31|  2.54k|        S: ser::Serializer,
   32|  2.54k|    {
   33|  2.54k|        let value = ByteBuf::from(self.to_bytes());
   34|  2.54k|        serializer.serialize_newtype_struct(CID_SERDE_PRIVATE_IDENTIFIER, &value)
   35|  2.54k|    }
_RINvXs0_NtCsl4cFeht4Yol_3cid5serdeINtNtB8_3cid3CidKj40_ENtNtCssVaLrL3Upj_5serde2de11Deserialize11deserializeNtNtCs3TS9n28v4Rl_12libipld_core4ipld4IpldECsboUdcTbF1FS_15direct_syscalls:
   79|  1.90k|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
   80|  1.90k|    where
   81|  1.90k|        D: de::Deserializer<'de>,
   82|  1.90k|    {
   83|  1.90k|        /// Main visitor to deserialize a CID.
   84|  1.90k|        ///
   85|  1.90k|        /// This visitor has only a single entry point to deserialize CIDs, it's
   86|  1.90k|        /// `visit_new_type_struct()`. This ensures that it isn't accidentally used to decode CIDs
   87|  1.90k|        /// to bytes.
   88|  1.90k|        struct MainEntryVisitor<const SIZE: usize>;
   89|  1.90k|
   90|  1.90k|        impl<'de, const SIZE: usize> de::Visitor<'de> for MainEntryVisitor<SIZE> {
   91|  1.90k|            type Value = CidGeneric<SIZE>;
   92|  1.90k|
   93|  1.90k|            fn expecting(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
   94|  1.90k|                write!(fmt, "a valid CID in bytes, wrapped in an newtype struct")
   95|  1.90k|            }
   96|  1.90k|
   97|  1.90k|            fn visit_newtype_struct<D>(self, deserializer: D) -> Result<Self::Value, D::Error>
   98|  1.90k|            where
   99|  1.90k|                D: de::Deserializer<'de>,
  100|  1.90k|            {
  101|  1.90k|                deserializer.deserialize_bytes(BytesToCidVisitor)
  102|  1.90k|            }
  103|  1.90k|        }
  104|  1.90k|
  105|  1.90k|        deserializer.deserialize_newtype_struct(CID_SERDE_PRIVATE_IDENTIFIER, MainEntryVisitor)
  106|  1.90k|    }
_RINvXNtCsl4cFeht4Yol_3cid5serdeINtNtB5_3cid3CidKj40_ENtNtCssVaLrL3Upj_5serde3ser9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECs7AwuCMXPzRZ_8fvm_fuzz:
   29|    636|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   30|    636|    where
   31|    636|        S: ser::Serializer,
   32|    636|    {
   33|    636|        let value = ByteBuf::from(self.to_bytes());
   34|    636|        serializer.serialize_newtype_struct(CID_SERDE_PRIVATE_IDENTIFIER, &value)
   35|    636|    }
_RINvXs_NtCsl4cFeht4Yol_3cid5serdeNtB5_17BytesToCidVisitorNtNtCssVaLrL3Upj_5serde2de7Visitor11visit_bytesINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsiloedr2K6v7_4core7convert10InfallibleEECs7AwuCMXPzRZ_8fvm_fuzz:
   48|  5.40k|    fn visit_bytes<E>(self, value: &[u8]) -> Result<Self::Value, E>
   49|  5.40k|    where
   50|  5.40k|        E: de::Error,
   51|  5.40k|    {
   52|  5.40k|        CidGeneric::<SIZE>::try_from(value)
   53|  5.40k|            .map_err(|err| de::Error::custom(format!("Failed to deserialize CID: {}", err)))
   54|  5.40k|    }
_RINvXs0_NtCsl4cFeht4Yol_3cid5serdeINtNtB8_3cid3CidKj40_ENtNtCssVaLrL3Upj_5serde2de11Deserialize11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECs7AwuCMXPzRZ_8fvm_fuzz:
   79|  5.40k|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
   80|  5.40k|    where
   81|  5.40k|        D: de::Deserializer<'de>,
   82|  5.40k|    {
   83|  5.40k|        /// Main visitor to deserialize a CID.
   84|  5.40k|        ///
   85|  5.40k|        /// This visitor has only a single entry point to deserialize CIDs, it's
   86|  5.40k|        /// `visit_new_type_struct()`. This ensures that it isn't accidentally used to decode CIDs
   87|  5.40k|        /// to bytes.
   88|  5.40k|        struct MainEntryVisitor<const SIZE: usize>;
   89|  5.40k|
   90|  5.40k|        impl<'de, const SIZE: usize> de::Visitor<'de> for MainEntryVisitor<SIZE> {
   91|  5.40k|            type Value = CidGeneric<SIZE>;
   92|  5.40k|
   93|  5.40k|            fn expecting(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
   94|  5.40k|                write!(fmt, "a valid CID in bytes, wrapped in an newtype struct")
   95|  5.40k|            }
   96|  5.40k|
   97|  5.40k|            fn visit_newtype_struct<D>(self, deserializer: D) -> Result<Self::Value, D::Error>
   98|  5.40k|            where
   99|  5.40k|                D: de::Deserializer<'de>,
  100|  5.40k|            {
  101|  5.40k|                deserializer.deserialize_bytes(BytesToCidVisitor)
  102|  5.40k|            }
  103|  5.40k|        }
  104|  5.40k|
  105|  5.40k|        deserializer.deserialize_newtype_struct(CID_SERDE_PRIVATE_IDENTIFIER, MainEntryVisitor)
  106|  5.40k|    }
_RINvXNvXs0_NtCsl4cFeht4Yol_3cid5serdeINtNtBb_3cid3CidKpENtNtCssVaLrL3Upj_5serde2de11Deserialize11deserializeINtB3_16MainEntryVisitorKj40_ENtBU_7Visitor20visit_newtype_structQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de15CidDeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECs7AwuCMXPzRZ_8fvm_fuzz:
   97|  5.40k|            fn visit_newtype_struct<D>(self, deserializer: D) -> Result<Self::Value, D::Error>
   98|  5.40k|            where
   99|  5.40k|                D: de::Deserializer<'de>,
  100|  5.40k|            {
  101|  5.40k|                deserializer.deserialize_bytes(BytesToCidVisitor)
  102|  5.40k|            }

_RNvXs2_NtCsl4cFeht4Yol_3cid7versionNtB5_7VersionNtNtCsiloedr2K6v7_4core3cmp9PartialEq2eq:
    6|  3.69k|#[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Debug, Hash)]
_RINvXsa_NtCsl4cFeht4Yol_3cid7versionNtB6_7VersionNtNtCsiloedr2K6v7_4core4hash4Hash4hashNtNtNtNtCsdyNNmftaNAQ_3std11collections4hash3map13DefaultHasherECsboUdcTbF1FS_15direct_syscalls:
    6|  18.1k|#[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Debug, Hash)]
_RINvXsa_NtCsl4cFeht4Yol_3cid7versionNtB6_7VersionNtNtCsiloedr2K6v7_4core4hash4Hash4hashNtNtNtNtCsdyNNmftaNAQ_3std11collections4hash3map13DefaultHasherECs7AwuCMXPzRZ_8fvm_fuzz:
    6|  18.1k|#[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Debug, Hash)]
_RINvXsa_NtCsl4cFeht4Yol_3cid7versionNtB6_7VersionNtNtCsiloedr2K6v7_4core4hash4Hash4hashNtNtNtNtCsdyNNmftaNAQ_3std11collections4hash3map13DefaultHasherECs23Y5vRLZE35_19fvm_ipld_blockstore:
    6|  17.4k|#[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Debug, Hash)]
_RNvXs_NtCsl4cFeht4Yol_3cid7versionNtB4_7VersionINtNtCsiloedr2K6v7_4core7convert7TryFromyE8try_from:
   34|  20.3k|    fn try_from(raw: u64) -> Result<Self> {
   35|  20.3k|        match raw {
   36|      0|            0 => Ok(Self::V0),
   37|  20.3k|            1 => Ok(Self::V1),
   38|      0|            _ => Err(Error::InvalidCidVersion),
   39|       |        }
   40|  20.3k|    }
_RNvXs0_NtCsl4cFeht4Yol_3cid7versionyINtNtCsiloedr2K6v7_4core7convert4FromNtB5_7VersionE4from:
   44|  5.40k|    fn from(ver: Version) -> u64 {
   45|  5.40k|        match ver {
   46|      0|            Version::V0 => 0,
   47|  5.40k|            Version::V1 => 1,
   48|       |        }
   49|  5.40k|    }

_RNvNtNtNtCs6hBXtUubyyi_4sha26sha2563x8611shani_cpuid8init_get:
  106|    954|            pub fn init_get() -> (InitToken, bool) {
  107|    954|                let res = $crate::__unless_target_features! {
  108|       |                    $($tf),+ => {
  109|       |                        // Relaxed ordering is fine, as we only have a single atomic variable.
  110|    954|                        let val = STORAGE.load(Relaxed);
  111|    954|
  112|    954|                        if val == UNINIT {
  113|      1|                            let res = $crate::__detect_target_features!($($tf),+);
  114|      1|                            STORAGE.store(res as u8, Relaxed);
  115|      1|                            res
  116|       |                        } else {
  117|    953|                            val == 1
  118|       |                        }
  119|       |                    }
  120|       |                };
  121|       |
  122|    954|                (InitToken(()), res)
  123|    954|            }
_RNvNtNtNtCs6hBXtUubyyi_4sha26sha2563x8611shani_cpuid3get:
  135|    954|            pub fn get() -> bool {
  136|    954|                init_get().1
  137|    954|            }

_RNvNvNtNtNtCs6hBXtUubyyi_4sha26sha2563x8611shani_cpuid8init_get11cpuid_count:
   51|      1|        unsafe fn cpuid_count(leaf: u32, sub_leaf: u32) -> CpuidResult {
   52|      1|            __cpuid_count(leaf, sub_leaf)
   53|      1|        }
_RNvNvNtNtNtCs6hBXtUubyyi_4sha26sha2563x8611shani_cpuid8init_get5cpuid:
   46|      1|        unsafe fn cpuid(leaf: u32) -> CpuidResult {
   47|      1|            __cpuid(leaf)
   48|      1|        }

_RINvNtCs1uaCP4zf1x7_17cranelift_codegen13constant_hash5probeReNtNtNtB4_8settings6detail8TemplateEB4_:
   33|  15.2k|pub fn probe<K: Copy + Eq, T: Table<K> + ?Sized>(
   34|  15.2k|    table: &T,
   35|  15.2k|    key: K,
   36|  15.2k|    hash: usize,
   37|  15.2k|) -> Result<usize, usize> {
   38|  15.2k|    debug_assert!(table.len().is_power_of_two());
   39|  15.2k|    let mask = table.len() - 1;
   40|  15.2k|
   41|  15.2k|    let mut idx = hash;
   42|  15.2k|    let mut step = 0;
   43|       |
   44|       |    loop {
   45|  17.1k|        idx &= mask;
   46|  17.1k|
   47|  17.1k|        match table.key(idx) {
   48|      0|            None => return Err(idx),
   49|  17.1k|            Some(k) if k == key => return Ok(idx),
   50|  1.90k|            _ => {}
   51|  1.90k|        }
   52|  1.90k|
   53|  1.90k|        // Quadratic probing.
   54|  1.90k|        step += 1;
   55|       |
   56|       |        // When `table.len()` is a power of two, it can be proven that `idx` will visit all
   57|       |        // entries. This means that this loop will always terminate if the hash table has even
   58|       |        // one unused entry.
   59|  1.90k|        debug_assert!(step < table.len());
   60|  1.90k|        idx += step;
   61|       |    }
   62|  15.2k|}

_RNvXsc_NtCs1uaCP4zf1x7_17cranelift_codegen3isaNtB5_7BuilderNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
  138|    636|#[derive(Clone)]
_RNvNtCs1uaCP4zf1x7_17cranelift_codegen3isa6lookup:
   93|    636|pub fn lookup(triple: Triple) -> Result<Builder, LookupError> {
   94|    636|    match triple.architecture {
   95|       |        Architecture::X86_64 => {
   96|    636|            isa_builder!(x64, (feature = "x86"), triple)
   97|       |        }
   98|      0|        Architecture::Aarch64 { .. } => isa_builder!(aarch64, (feature = "arm64"), triple),
   99|      0|        Architecture::S390x { .. } => isa_builder!(s390x, (feature = "s390x"), triple),
  100|      0|        _ => Err(LookupError::Unsupported),
  101|       |    }
  102|    636|}
_RNvXs1_NtCs1uaCP4zf1x7_17cranelift_codegen3isaNtB5_7BuilderNtNtB7_8settings12Configurable6enable:
  173|  8.90k|    fn enable(&mut self, name: &str) -> SetResult<()> {
  174|  8.90k|        self.setup.enable(name)
  175|  8.90k|    }
_RNvMs0_NtCs1uaCP4zf1x7_17cranelift_codegen3isaNtB5_7Builder6finish:
  163|    636|    pub fn finish(self, shared_flags: settings::Flags) -> CodegenResult<Box<dyn TargetIsa>> {
  164|    636|        (self.constructor)(self.triple, shared_flags, self.setup)
  165|    636|    }
_RNvXs1_NtCs1uaCP4zf1x7_17cranelift_codegen3isaNtB5_7BuilderNtNtB7_8settings12Configurable3set:
  169|  2.54k|    fn set(&mut self, name: &str, value: &str) -> SetResult<()> {
  170|  2.54k|        self.setup.set(name, value)
  171|  2.54k|    }

_RNvNtNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x644inst4regs3rbx:
   79|    636|pub(crate) fn rbx() -> Reg {
   80|    636|    gpr(ENC_RBX)
   81|    636|}
_RNvNtNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x644inst4regs5xmm11:
  143|    636|pub(crate) fn xmm11() -> Reg {
  144|    636|    fpr(11)
  145|    636|}
_RNvNtNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x644inst4regs4xmm7:
  131|    636|pub(crate) fn xmm7() -> Reg {
  132|    636|    fpr(7)
  133|    636|}
_RNvNtNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x644inst4regs3fpr:
  101|  10.1k|fn fpr(enc: u8) -> Reg {
  102|  10.1k|    let preg = fpr_preg(enc);
  103|  10.1k|    Reg::from(VReg::new(preg.index(), RegClass::Float))
  104|  10.1k|}
_RNvNtNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x644inst4regs8gpr_preg:
   39|  10.1k|pub(crate) const fn gpr_preg(enc: u8) -> PReg {
   40|  10.1k|    PReg::new(enc as usize, RegClass::Int)
   41|  10.1k|}
_RNvNtNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x644inst4regs3rcx:
   52|    636|pub(crate) fn rcx() -> Reg {
   53|    636|    gpr(ENC_RCX)
   54|    636|}
_RNvNtNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x644inst4regs4xmm6:
  128|    636|pub(crate) fn xmm6() -> Reg {
  129|    636|    fpr(6)
  130|    636|}
_RNvNtNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x644inst4regs4xmm0:
  110|    636|pub(crate) fn xmm0() -> Reg {
  111|    636|    fpr(0)
  112|    636|}
_RNvNtNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x644inst4regs8fpr_preg:
  106|  10.1k|pub(crate) const fn fpr_preg(enc: u8) -> PReg {
  107|  10.1k|    PReg::new(enc as usize, RegClass::Float)
  108|  10.1k|}
_RNvNvNtNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x644inst4regs22create_reg_env_systemv4preg:
  161|  19.0k|    fn preg(r: Reg) -> PReg {
  162|  19.0k|        r.to_real_reg().unwrap().into()
  163|  19.0k|    }
_RNvNtNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x644inst4regs3r11:
   67|    636|pub(crate) fn r11() -> Reg {
   68|    636|    gpr(ENC_R11)
   69|    636|}
_RNvNtNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x644inst4regs4xmm4:
  122|    636|pub(crate) fn xmm4() -> Reg {
  123|    636|    fpr(4)
  124|    636|}
_RNvNtNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x644inst4regs4xmm8:
  134|    636|pub(crate) fn xmm8() -> Reg {
  135|    636|    fpr(8)
  136|    636|}
_RNvNtNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x644inst4regs3rdx:
   55|    636|pub(crate) fn rdx() -> Reg {
   56|    636|    gpr(ENC_RDX)
   57|    636|}
_RNvNtNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x644inst4regs4xmm2:
  116|    636|pub(crate) fn xmm2() -> Reg {
  117|    636|    fpr(2)
  118|    636|}
_RNvNtNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x644inst4regs3r12:
   70|    636|pub(crate) fn r12() -> Reg {
   71|    636|    gpr(ENC_R12)
   72|    636|}
_RNvNtNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x644inst4regs3rsi:
   43|    636|pub(crate) fn rsi() -> Reg {
   44|    636|    gpr(ENC_RSI)
   45|    636|}
_RNvNtNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x644inst4regs3rax:
   49|    636|pub(crate) fn rax() -> Reg {
   50|    636|    gpr(ENC_RAX)
   51|    636|}
_RNvNtNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x644inst4regs4xmm1:
  113|    636|pub(crate) fn xmm1() -> Reg {
  114|    636|    fpr(1)
  115|    636|}
_RNvNtNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x644inst4regs3r10:
   64|    636|pub(crate) fn r10() -> Reg {
   65|    636|    gpr(ENC_R10)
   66|    636|}
_RNvNtNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x644inst4regs5xmm12:
  146|    636|pub(crate) fn xmm12() -> Reg {
  147|    636|    fpr(12)
  148|    636|}
_RNvNtNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x644inst4regs4xmm3:
  119|    636|pub(crate) fn xmm3() -> Reg {
  120|    636|    fpr(3)
  121|    636|}
_RNvNtNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x644inst4regs4xmm5:
  125|    636|pub(crate) fn xmm5() -> Reg {
  126|    636|    fpr(5)
  127|    636|}
_RNvNtNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x644inst4regs10pinned_reg:
   97|    636|pub(crate) fn pinned_reg() -> Reg {
   98|    636|    r15()
   99|    636|}
_RNvNtNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x644inst4regs2r9:
   61|    636|pub(crate) fn r9() -> Reg {
   62|    636|    gpr(ENC_R9)
   63|    636|}
_RNvNtNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x644inst4regs5xmm14:
  152|    636|pub(crate) fn xmm14() -> Reg {
  153|    636|    fpr(14)
  154|    636|}
_RNvNtNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x644inst4regs5xmm10:
  140|    636|pub(crate) fn xmm10() -> Reg {
  141|    636|    fpr(10)
  142|    636|}
_RNvNtNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x644inst4regs3rdi:
   46|    636|pub(crate) fn rdi() -> Reg {
   47|    636|    gpr(ENC_RDI)
   48|    636|}
_RNvNtNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x644inst4regs2r8:
   58|    636|pub(crate) fn r8() -> Reg {
   59|    636|    gpr(ENC_R8)
   60|    636|}
_RNvNtNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x644inst4regs4xmm9:
  137|    636|pub(crate) fn xmm9() -> Reg {
  138|    636|    fpr(9)
  139|    636|}
_RNvNtNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x644inst4regs3r13:
   73|    636|pub(crate) fn r13() -> Reg {
   74|    636|    gpr(ENC_R13)
   75|    636|}
_RNvNtNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x644inst4regs5xmm13:
  149|    636|pub(crate) fn xmm13() -> Reg {
  150|    636|    fpr(13)
  151|    636|}
_RNvNtNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x644inst4regs5xmm15:
  155|    636|pub(crate) fn xmm15() -> Reg {
  156|    636|    fpr(15)
  157|    636|}
_RNvNtNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x644inst4regs3gpr:
   35|  10.1k|fn gpr(enc: u8) -> Reg {
   36|  10.1k|    let preg = gpr_preg(enc);
   37|  10.1k|    Reg::from(VReg::new(preg.index(), RegClass::Int))
   38|  10.1k|}
_RNvNtNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x644inst4regs3r15:
   83|  1.90k|pub(crate) fn r15() -> Reg {
   84|  1.90k|    gpr(ENC_R15)
   85|  1.90k|}
_RNvNtNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x644inst4regs22create_reg_env_systemv:
  160|    636|pub(crate) fn create_reg_env_systemv(flags: &settings::Flags) -> MachineEnv {
  161|    636|    fn preg(r: Reg) -> PReg {
  162|    636|        r.to_real_reg().unwrap().into()
  163|    636|    }
  164|    636|
  165|    636|    let mut env = MachineEnv {
  166|    636|        preferred_regs_by_class: [
  167|    636|            // Preferred GPRs: caller-saved in the SysV ABI.
  168|    636|            vec![
  169|    636|                preg(rsi()),
  170|    636|                preg(rdi()),
  171|    636|                preg(rax()),
  172|    636|                preg(rcx()),
  173|    636|                preg(rdx()),
  174|    636|                preg(r8()),
  175|    636|                preg(r9()),
  176|    636|                preg(r10()),
  177|    636|                preg(r11()),
  178|    636|            ],
  179|    636|            // Preferred XMMs: all of them.
  180|    636|            vec![
  181|    636|                preg(xmm0()),
  182|    636|                preg(xmm1()),
  183|    636|                preg(xmm2()),
  184|    636|                preg(xmm3()),
  185|    636|                preg(xmm4()),
  186|    636|                preg(xmm5()),
  187|    636|                preg(xmm6()),
  188|    636|                preg(xmm7()),
  189|    636|                preg(xmm8()),
  190|    636|                preg(xmm9()),
  191|    636|                preg(xmm10()),
  192|    636|                preg(xmm11()),
  193|    636|                preg(xmm12()),
  194|    636|                preg(xmm13()),
  195|    636|                preg(xmm14()),
  196|    636|                preg(xmm15()),
  197|    636|            ],
  198|    636|        ],
  199|    636|        non_preferred_regs_by_class: [
  200|    636|            // Non-preferred GPRs: callee-saved in the SysV ABI.
  201|    636|            vec![preg(rbx()), preg(r12()), preg(r13()), preg(r14())],
  202|    636|            // Non-preferred XMMs: none.
  203|    636|            vec![],
  204|    636|        ],
  205|    636|        fixed_stack_slots: vec![],
  206|    636|    };
  207|       |
  208|    636|    debug_assert_eq!(r15(), pinned_reg());
  209|    636|    if !flags.enable_pinned_reg() {
  210|    636|        env.non_preferred_regs_by_class[0].push(preg(r15()));
  211|    636|    }
  212|       |
  213|    636|    env
  214|    636|}
_RNvNtNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x644inst4regs3r14:
   76|    636|pub(crate) fn r14() -> Reg {
   77|    636|    gpr(ENC_R14)
   78|    636|}

_RNvNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x6415isa_constructor:
  189|    636|fn isa_constructor(
  190|    636|    triple: Triple,
  191|    636|    shared_flags: Flags,
  192|    636|    builder: shared_settings::Builder,
  193|    636|) -> CodegenResult<Box<dyn TargetIsa>> {
  194|    636|    let isa_flags = x64_settings::Flags::new(&shared_flags, builder);
  195|    636|
  196|    636|    // Check for compatibility between flags and ISA level
  197|    636|    // requested. In particular, SIMD support requires SSE4.2.
  198|    636|    if shared_flags.enable_simd() {
  199|      0|        if !isa_flags.has_sse3()
  200|      0|            || !isa_flags.has_ssse3()
  201|      0|            || !isa_flags.has_sse41()
  202|      0|            || !isa_flags.has_sse42()
  203|       |        {
  204|      0|            return Err(CodegenError::Unsupported(
  205|      0|                "SIMD support requires SSE3, SSSE3, SSE4.1, and SSE4.2 on x86_64.".into(),
  206|      0|            ));
  207|      0|        }
  208|    636|    }
  209|       |
  210|    636|    let backend = X64Backend::new_with_flags(triple, shared_flags, isa_flags);
  211|    636|    Ok(Box::new(backend))
  212|    636|}
_RNvNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x6411isa_builder:
  181|    636|pub(crate) fn isa_builder(triple: Triple) -> IsaBuilder {
  182|    636|    IsaBuilder {
  183|    636|        triple,
  184|    636|        setup: x64_settings::builder(),
  185|    636|        constructor: isa_constructor,
  186|    636|    }
  187|    636|}
_RNvMNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x64NtB2_10X64Backend14new_with_flags:
   38|    636|    fn new_with_flags(triple: Triple, flags: Flags, x64_flags: x64_settings::Flags) -> Self {
   39|    636|        let reg_env = create_reg_env_systemv(&flags);
   40|    636|        Self {
   41|    636|            triple,
   42|    636|            flags,
   43|    636|            x64_flags,
   44|    636|            reg_env,
   45|    636|        }
   46|    636|    }

_RNvNtNtCs1uaCP4zf1x7_17cranelift_codegen8machinst3reg19pinned_vreg_to_preg:
   25|  19.0k|pub fn pinned_vreg_to_preg(vreg: VReg) -> Option<PReg> {
   26|  19.0k|    if vreg.vreg() < PINNED_VREGS {
   27|  19.0k|        Some(PReg::from_index(vreg.vreg()))
   28|       |    } else {
   29|      0|        None
   30|       |    }
   31|  19.0k|}
_RNvXsm_NtNtCs1uaCP4zf1x7_17cranelift_codegen8machinst3regNtB5_3RegNtNtCsiloedr2K6v7_4core3cmp9PartialEq2eq:
   48|    636|#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
_RNvXsb_NtNtCs1uaCP4zf1x7_17cranelift_codegen8machinst3regNtCsjDo9fZ7x0Pp_9regalloc24PRegINtNtCsiloedr2K6v7_4core7convert4FromNtB5_7RealRegE4from:
  236|  19.0k|    fn from(reg: RealReg) -> regalloc2::PReg {
  237|  19.0k|        PReg::from_index(reg.0.vreg())
  238|  19.0k|    }
_RNvXs5_NtNtCs1uaCP4zf1x7_17cranelift_codegen8machinst3regNtB5_3RegINtNtCsiloedr2K6v7_4core7convert4FromNtCsjDo9fZ7x0Pp_9regalloc24VRegE4from:
  195|  20.3k|    fn from(vreg: regalloc2::VReg) -> Reg {
  196|  20.3k|        Reg(vreg)
  197|  20.3k|    }
_RNvMNtNtCs1uaCP4zf1x7_17cranelift_codegen8machinst3regNtB2_3Reg11to_real_reg:
   55|  19.0k|    pub fn to_real_reg(self) -> Option<RealReg> {
   56|  19.0k|        if pinned_vreg_to_preg(self.0).is_some() {
   57|  19.0k|            Some(RealReg(self.0))
   58|       |        } else {
   59|      0|            None
   60|       |        }
   61|  19.0k|    }

_RNvXsh_NtCs1uaCP4zf1x7_17cranelift_codegen8settingsNtB5_7BuilderNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
  148|  1.27k|#[derive(Clone, Hash)]
_RNvNtCs1uaCP4zf1x7_17cranelift_codegen8settings16parse_enum_value:
  231|    636|fn parse_enum_value(value: &str, choices: &[&str]) -> SetResult<u8> {
  232|    636|    match choices.iter().position(|&tag| tag == value) {
  233|    636|        Some(idx) => Ok(idx as u8),
  234|       |        None => {
  235|       |            // TODO: Use `join` instead of this code, once
  236|       |            // https://github.com/rust-lang/rust/issues/27747 is resolved.
  237|      0|            let mut all_choices = String::new();
  238|      0|            let mut first = true;
  239|      0|            for choice in choices {
  240|      0|                if first {
  241|      0|                    first = false
  242|      0|                } else {
  243|      0|                    all_choices += ", ";
  244|      0|                }
  245|      0|                all_choices += choice;
  246|       |            }
  247|      0|            Err(SetError::BadValue(format!("any among {}", all_choices)))
  248|       |        }
  249|       |    }
  250|    636|}
_RNvXs1_NtCs1uaCP4zf1x7_17cranelift_codegen8settingsNtB5_7BuilderNtB5_12Configurable3set:
  269|  5.72k|    fn set(&mut self, name: &str, value: &str) -> SetResult<()> {
  270|       |        use self::detail::Detail;
  271|  5.72k|        let (offset, detail) = self.lookup(name)?;
  272|  5.72k|        match detail {
  273|  5.08k|            Detail::Bool { bit } => {
  274|  5.08k|                self.set_bit(offset, bit, parse_bool_value(value)?);
  275|       |            }
  276|      0|            Detail::Num => {
  277|      0|                self.bytes[offset] = value
  278|      0|                    .parse()
  279|      0|                    .map_err(|_| SetError::BadValue("number".to_string()))?;
  280|       |            }
  281|    636|            Detail::Enum { last, enumerators } => {
  282|    636|                self.bytes[offset] =
  283|    636|                    parse_enum_value(value, self.template.enums(last, enumerators))?;
  284|       |            }
  285|      0|            Detail::Preset => return Err(SetError::BadName(name.to_string())),
  286|       |        }
  287|  5.72k|        Ok(())
  288|  5.72k|    }
_RNvMNtNtCs1uaCP4zf1x7_17cranelift_codegen8settings6detailNtB2_8Template5enums:
  373|    636|        pub fn enums(&self, last: u8, enumerators: u16) -> &[&'static str] {
  374|    636|            let from = enumerators as usize;
  375|    636|            let len = usize::from(last) + 1;
  376|    636|            &self.enumerators[from..from + len]
  377|    636|        }
_RNvXs1_NtCs1uaCP4zf1x7_17cranelift_codegen8settingsNtB5_7BuilderNtB5_12Configurable6enable:
  253|  9.54k|    fn enable(&mut self, name: &str) -> SetResult<()> {
  254|       |        use self::detail::Detail;
  255|  9.54k|        let (offset, detail) = self.lookup(name)?;
  256|  9.54k|        match detail {
  257|  9.54k|            Detail::Bool { bit } => {
  258|  9.54k|                self.set_bit(offset, bit, true);
  259|  9.54k|                Ok(())
  260|       |            }
  261|       |            Detail::Preset => {
  262|      0|                self.apply_preset(&self.template.presets[offset..]);
  263|      0|                Ok(())
  264|       |            }
  265|      0|            _ => Err(SetError::BadType),
  266|       |        }
  267|  9.54k|    }
_RNvMs0_NtCs1uaCP4zf1x7_17cranelift_codegen8settingsNtB5_7Builder9state_for:
  164|  1.27k|    pub fn state_for(self, name: &str) -> Box<[u8]> {
  165|  1.27k|        assert_eq!(name, self.template.name);
  166|  1.27k|        self.bytes
  167|  1.27k|    }
_RNvNtCs1uaCP4zf1x7_17cranelift_codegen8settings16parse_bool_value:
  223|  5.08k|fn parse_bool_value(value: &str) -> SetResult<bool> {
  224|  5.08k|    match value {
  225|  5.08k|        "true" | "on" | "yes" | "1" => Ok(true),
  226|  3.81k|        "false" | "off" | "no" | "0" => Ok(false),
  227|      0|        _ => Err(SetError::BadValue("bool".to_string())),
  228|       |    }
  229|  5.08k|}
_RNvMs0_NtCs1uaCP4zf1x7_17cranelift_codegen8settingsNtB5_7Builder3new:
  156|  1.27k|    pub fn new(tmpl: &'static detail::Template) -> Self {
  157|  1.27k|        Self {
  158|  1.27k|            template: tmpl,
  159|  1.27k|            bytes: tmpl.defaults.into(),
  160|  1.27k|        }
  161|  1.27k|    }
_RNCNvNtCs1uaCP4zf1x7_17cranelift_codegen8settings16parse_enum_value0B5_:
  232|  1.27k|    match choices.iter().position(|&tag| tag == value) {
_RNvMs0_NtCs1uaCP4zf1x7_17cranelift_codegen8settingsNtB5_7Builder7set_bit:
  194|  14.6k|    fn set_bit(&mut self, offset: usize, bit: u8, value: bool) {
  195|  14.6k|        let byte = &mut self.bytes[offset];
  196|  14.6k|        let mask = 1 << bit;
  197|  14.6k|        if value {
  198|  10.8k|            *byte |= mask;
  199|  10.8k|        } else {
  200|  3.81k|            *byte &= !mask;
  201|  3.81k|        }
  202|  14.6k|    }
_RNvXs_NtNtCs1uaCP4zf1x7_17cranelift_codegen8settings6detailNtB4_8TemplateINtNtB8_13constant_hash5TableReE3len:
  406|  32.4k|        fn len(&self) -> usize {
  407|  32.4k|            self.hash_table.len()
  408|  32.4k|        }
_RNvMs0_NtCs1uaCP4zf1x7_17cranelift_codegen8settingsNtB5_7Builder6lookup:
  212|  15.2k|    fn lookup(&self, name: &str) -> SetResult<(usize, detail::Detail)> {
  213|  15.2k|        match probe(self.template, name, simple_hash(name)) {
  214|      0|            Err(_) => Err(SetError::BadName(name.to_string())),
  215|  15.2k|            Ok(entry) => {
  216|  15.2k|                let d = &self.template.descriptors[self.template.hash_table[entry] as usize];
  217|  15.2k|                Ok((d.offset as usize, d.detail))
  218|       |            }
  219|       |        }
  220|  15.2k|    }
_RNvXs_NtNtCs1uaCP4zf1x7_17cranelift_codegen8settings6detailNtB4_8TemplateINtNtB8_13constant_hash5TableReE3key:
  410|  17.1k|        fn key(&self, idx: usize) -> Option<&'a str> {
  411|  17.1k|            let e = self.hash_table[idx] as usize;
  412|  17.1k|            if e < self.descriptors.len() {
  413|  17.1k|                Some(self.descriptors[e].name)
  414|       |            } else {
  415|      0|                None
  416|       |            }
  417|  17.1k|        }

_RNvNtCshVFmqFimirM_24cranelift_codegen_shared13constant_hash11simple_hash:
    4|  15.2k|pub fn simple_hash(s: &str) -> usize {
    5|  15.2k|    let mut h: u32 = 5381;
    6|   170k|    for c in s.chars() {
    7|   170k|        h = (h ^ c as u32).wrapping_add(h.rotate_right(6));
    8|   170k|    }
    9|  15.2k|    h as usize
   10|  15.2k|}

_RNvMNtCs9iALTVfPkbw_16cranelift_entity4iterINtB2_4IterNtCs15iRE7yYizN_14wasmtime_types11GlobalIndexNtBS_6GlobalE3newCslvZ9xuS3Qdd_16wasmtime_runtime:
   21|  3.81k|    pub fn new(iter: slice::Iter<'a, V>) -> Self {
   22|  3.81k|        Self {
   23|  3.81k|            enumerate: iter.enumerate(),
   24|  3.81k|            unused: PhantomData,
   25|  3.81k|        }
   26|  3.81k|    }
_RNvMNtCs9iALTVfPkbw_16cranelift_entity4iterINtB2_4IterNtCs15iRE7yYizN_14wasmtime_types11MemoryIndexNtNtCs4vXvIybW1e9_16wasmtime_environ6module10MemoryPlanE3newCslvZ9xuS3Qdd_16wasmtime_runtime:
   21|  3.18k|    pub fn new(iter: slice::Iter<'a, V>) -> Self {
   22|  3.18k|        Self {
   23|  3.18k|            enumerate: iter.enumerate(),
   24|  3.18k|            unused: PhantomData,
   25|  3.18k|        }
   26|  3.18k|    }
_RNCNvXs_NtCs9iALTVfPkbw_16cranelift_entity4iterINtB6_4IterNtCs15iRE7yYizN_14wasmtime_types11GlobalIndexNtBW_6GlobalENtNtNtNtCsiloedr2K6v7_4core4iter6traits8iterator8Iterator4next0CslvZ9xuS3Qdd_16wasmtime_runtime:
   33|  1.27k|        self.enumerate.next().map(|(i, v)| (K::new(i), v))
_RNvMNtCs9iALTVfPkbw_16cranelift_entity4iterINtB2_4IterNtCs15iRE7yYizN_14wasmtime_types10TableIndexNtNtCs4vXvIybW1e9_16wasmtime_environ6module9TablePlanE3newCslvZ9xuS3Qdd_16wasmtime_runtime:
   21|  1.27k|    pub fn new(iter: slice::Iter<'a, V>) -> Self {
   22|  1.27k|        Self {
   23|  1.27k|            enumerate: iter.enumerate(),
   24|  1.27k|            unused: PhantomData,
   25|  1.27k|        }
   26|  1.27k|    }
_RNvXs_NtCs9iALTVfPkbw_16cranelift_entity4iterINtB4_4IterNtCs15iRE7yYizN_14wasmtime_types11GlobalIndexNtBU_6GlobalENtNtNtNtCsiloedr2K6v7_4core4iter6traits8iterator8Iterator4nextCslvZ9xuS3Qdd_16wasmtime_runtime:
   32|  5.08k|    fn next(&mut self) -> Option<Self::Item> {
   33|  5.08k|        self.enumerate.next().map(|(i, v)| (K::new(i), v))
   34|  5.08k|    }
_RNvXs_NtCs9iALTVfPkbw_16cranelift_entity4iterINtB4_4IterNtCs15iRE7yYizN_14wasmtime_types11MemoryIndexNtNtCs4vXvIybW1e9_16wasmtime_environ6module10MemoryPlanENtNtNtNtCsiloedr2K6v7_4core4iter6traits8iterator8Iterator4nextCslvZ9xuS3Qdd_16wasmtime_runtime:
   32|  3.81k|    fn next(&mut self) -> Option<Self::Item> {
   33|  3.81k|        self.enumerate.next().map(|(i, v)| (K::new(i), v))
   34|  3.81k|    }
_RNCNvXs_NtCs9iALTVfPkbw_16cranelift_entity4iterINtB6_4IterNtCs15iRE7yYizN_14wasmtime_types11MemoryIndexNtNtCs4vXvIybW1e9_16wasmtime_environ6module10MemoryPlanENtNtNtNtCsiloedr2K6v7_4core4iter6traits8iterator8Iterator4next0CslvZ9xuS3Qdd_16wasmtime_runtime:
   33|    636|        self.enumerate.next().map(|(i, v)| (K::new(i), v))
_RNvXs_NtCs9iALTVfPkbw_16cranelift_entity4iterINtB4_4IterNtCs15iRE7yYizN_14wasmtime_types10TableIndexNtNtCs4vXvIybW1e9_16wasmtime_environ6module9TablePlanENtNtNtNtCsiloedr2K6v7_4core4iter6traits8iterator8Iterator4nextCslvZ9xuS3Qdd_16wasmtime_runtime:
   32|  1.27k|    fn next(&mut self) -> Option<Self::Item> {
   33|  1.27k|        self.enumerate.next().map(|(i, v)| (K::new(i), v))
   34|  1.27k|    }

_RNvXs2g_Cs15iRE7yYizN_14wasmtime_typesNtB6_11MemoryIndexNtCs9iALTVfPkbw_16cranelift_entity9EntityRef3new:
   74|  1.90k|            fn new(index: usize) -> Self {
   75|  1.90k|                debug_assert!(index < ($crate::__core::u32::MAX as usize));
   76|  1.90k|                $entity(index as u32)
   77|  1.90k|            }
_RNvMs25_Cs15iRE7yYizN_14wasmtime_typesNtB6_11GlobalIndex8from_u32:
  101|    636|            pub fn from_u32(x: u32) -> Self {
  102|    636|                debug_assert!(x < $crate::__core::u32::MAX);
  103|    636|                $entity(x)
  104|    636|            }
_RNvMs2i_Cs15iRE7yYizN_14wasmtime_typesNtB6_11MemoryIndex6as_u32:
  109|    636|            pub fn as_u32(self) -> u32 {
  110|    636|                self.0
  111|    636|            }
_RNvXs23_Cs15iRE7yYizN_14wasmtime_typesNtB6_11GlobalIndexNtCs9iALTVfPkbw_16cranelift_entity9EntityRef3new:
   74|  1.90k|            fn new(index: usize) -> Self {
   75|  1.90k|                debug_assert!(index < ($crate::__core::u32::MAX as usize));
   76|  1.90k|                $entity(index as u32)
   77|  1.90k|            }
_RNvMs2i_Cs15iRE7yYizN_14wasmtime_typesNtB6_11MemoryIndex8from_u32:
  101|    636|            pub fn from_u32(x: u32) -> Self {
  102|    636|                debug_assert!(x < $crate::__core::u32::MAX);
  103|    636|                $entity(x)
  104|    636|            }
_RNvXs2g_Cs15iRE7yYizN_14wasmtime_typesNtB6_11MemoryIndexNtCs9iALTVfPkbw_16cranelift_entity9EntityRef5index:
   80|  2.54k|            fn index(self) -> usize {
   81|  2.54k|                self.0 as usize
   82|  2.54k|            }
_RNvXs1D_Cs15iRE7yYizN_14wasmtime_typesNtB6_18DefinedGlobalIndexNtCs9iALTVfPkbw_16cranelift_entity9EntityRef3new:
   74|  1.90k|            fn new(index: usize) -> Self {
   75|  1.90k|                debug_assert!(index < ($crate::__core::u32::MAX as usize));
   76|  1.90k|                $entity(index as u32)
   77|  1.90k|            }
_RNvXs1d_Cs15iRE7yYizN_14wasmtime_typesNtB6_18DefinedMemoryIndexNtCs9iALTVfPkbw_16cranelift_entity9EntityRef5index:
   80|  1.27k|            fn index(self) -> usize {
   81|  1.27k|                self.0 as usize
   82|  1.27k|            }
_RNvXs23_Cs15iRE7yYizN_14wasmtime_typesNtB6_11GlobalIndexNtCs9iALTVfPkbw_16cranelift_entity9EntityRef5index:
   80|  4.45k|            fn index(self) -> usize {
   81|  4.45k|                self.0 as usize
   82|  4.45k|            }
_RNvMs1F_Cs15iRE7yYizN_14wasmtime_typesNtB6_18DefinedGlobalIndex6as_u32:
  109|  2.54k|            pub fn as_u32(self) -> u32 {
  110|  2.54k|                self.0
  111|  2.54k|            }
_RNvXs1d_Cs15iRE7yYizN_14wasmtime_typesNtB6_18DefinedMemoryIndexNtCs9iALTVfPkbw_16cranelift_entity9EntityRef3new:
   74|  1.90k|            fn new(index: usize) -> Self {
   75|  1.90k|                debug_assert!(index < ($crate::__core::u32::MAX as usize));
   76|  1.90k|                $entity(index as u32)
   77|  1.90k|            }
_RNvMs1f_Cs15iRE7yYizN_14wasmtime_typesNtB6_18DefinedMemoryIndex6as_u32:
  109|  1.27k|            pub fn as_u32(self) -> u32 {
  110|  1.27k|                self.0
  111|  1.27k|            }

_RNvXs_NtCs9iALTVfPkbw_16cranelift_entity7primaryINtB4_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types10TableIndexNtNtCs4vXvIybW1e9_16wasmtime_environ6module9TablePlanENtNtCsiloedr2K6v7_4core7default7Default7defaultCskJihg1y13m7_3fvm:
  188|    636|    fn default() -> PrimaryMap<K, V> {
  189|    636|        PrimaryMap::new()
  190|    636|    }
_RNvXs_NtCs9iALTVfPkbw_16cranelift_entity7primaryINtB4_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types11MemoryIndexNtNtCs4vXvIybW1e9_16wasmtime_environ6module10MemoryPlanENtNtCsiloedr2K6v7_4core7default7Default7defaultCskJihg1y13m7_3fvm:
  188|    636|    fn default() -> PrimaryMap<K, V> {
  189|    636|        PrimaryMap::new()
  190|    636|    }
_RNvXs_NtCs9iALTVfPkbw_16cranelift_entity7primaryINtB4_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types9FuncIndexNtNtCs4vXvIybW1e9_16wasmtime_environ6module12FunctionTypeENtNtCsiloedr2K6v7_4core7default7Default7defaultCskJihg1y13m7_3fvm:
  188|    636|    fn default() -> PrimaryMap<K, V> {
  189|    636|        PrimaryMap::new()
  190|    636|    }
_RNvMNtCs9iALTVfPkbw_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types11MemoryIndexNtNtCs4vXvIybW1e9_16wasmtime_environ6module10MemoryPlanE3newCskJihg1y13m7_3fvm:
   45|    636|    pub fn new() -> Self {
   46|    636|        Self {
   47|    636|            elems: Vec::new(),
   48|    636|            unused: PhantomData,
   49|    636|        }
   50|    636|    }
_RNvMNtCs9iALTVfPkbw_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types9TypeIndexNtNtCs4vXvIybW1e9_16wasmtime_environ6module10ModuleTypeE3newCskJihg1y13m7_3fvm:
   45|    636|    pub fn new() -> Self {
   46|    636|        Self {
   47|    636|            elems: Vec::new(),
   48|    636|            unused: PhantomData,
   49|    636|        }
   50|    636|    }
_RNvMNtCs9iALTVfPkbw_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types11GlobalIndexNtB12_6GlobalE3newCskJihg1y13m7_3fvm:
   45|    636|    pub fn new() -> Self {
   46|    636|        Self {
   47|    636|            elems: Vec::new(),
   48|    636|            unused: PhantomData,
   49|    636|        }
   50|    636|    }
_RNvMNtCs9iALTVfPkbw_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types9FuncIndexNtNtCs4vXvIybW1e9_16wasmtime_environ6module12FunctionTypeE3newCskJihg1y13m7_3fvm:
   45|    636|    pub fn new() -> Self {
   46|    636|        Self {
   47|    636|            elems: Vec::new(),
   48|    636|            unused: PhantomData,
   49|    636|        }
   50|    636|    }
_RNvMNtCs9iALTVfPkbw_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types10TableIndexNtNtCs4vXvIybW1e9_16wasmtime_environ6module9TablePlanE3newCskJihg1y13m7_3fvm:
   45|    636|    pub fn new() -> Self {
   46|    636|        Self {
   47|    636|            elems: Vec::new(),
   48|    636|            unused: PhantomData,
   49|    636|        }
   50|    636|    }
_RNvXs_NtCs9iALTVfPkbw_16cranelift_entity7primaryINtB4_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types9TypeIndexNtNtCs4vXvIybW1e9_16wasmtime_environ6module10ModuleTypeENtNtCsiloedr2K6v7_4core7default7Default7defaultCskJihg1y13m7_3fvm:
  188|    636|    fn default() -> PrimaryMap<K, V> {
  189|    636|        PrimaryMap::new()
  190|    636|    }
_RNvXs_NtCs9iALTVfPkbw_16cranelift_entity7primaryINtB4_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types11GlobalIndexNtB14_6GlobalENtNtCsiloedr2K6v7_4core7default7Default7defaultCskJihg1y13m7_3fvm:
  188|    636|    fn default() -> PrimaryMap<K, V> {
  189|    636|        PrimaryMap::new()
  190|    636|    }
_RNvMNtCs9iALTVfPkbw_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types11MemoryIndexNtNtCs4vXvIybW1e9_16wasmtime_environ6module10MemoryPlanE4pushCsaCHOb31h0oq_8wasmtime:
  121|    636|    pub fn push(&mut self, v: V) -> K {
  122|    636|        let k = self.next_key();
  123|    636|        self.elems.push(v);
  124|    636|        k
  125|    636|    }
_RNvMNtCs9iALTVfPkbw_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types11MemoryIndexNtNtCs4vXvIybW1e9_16wasmtime_environ6module10MemoryPlanE8next_keyCsaCHOb31h0oq_8wasmtime:
  116|    636|    pub fn next_key(&self) -> K {
  117|    636|        K::new(self.elems.len())
  118|    636|    }
_RNvMNtCs9iALTVfPkbw_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types11GlobalIndexNtB12_6GlobalE8next_keyCsaCHOb31h0oq_8wasmtime:
  116|    636|    pub fn next_key(&self) -> K {
  117|    636|        K::new(self.elems.len())
  118|    636|    }
_RNvXs_NtCs9iALTVfPkbw_16cranelift_entity7primaryINtB4_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types16DefinedFuncIndexNtNtCs4vXvIybW1e9_16wasmtime_environ11compilation12FunctionInfoENtNtCsiloedr2K6v7_4core7default7Default7defaultCsaCHOb31h0oq_8wasmtime:
  188|  1.90k|    fn default() -> PrimaryMap<K, V> {
  189|  1.90k|        PrimaryMap::new()
  190|  1.90k|    }
_RNvMNtCs9iALTVfPkbw_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types16DefinedFuncIndexNtNtCs4vXvIybW1e9_16wasmtime_environ11compilation12FunctionInfoE3newCsaCHOb31h0oq_8wasmtime:
   45|  1.90k|    pub fn new() -> Self {
   46|  1.90k|        Self {
   47|  1.90k|            elems: Vec::new(),
   48|  1.90k|            unused: PhantomData,
   49|  1.90k|        }
   50|  1.90k|    }
_RNvMNtCs9iALTVfPkbw_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types11GlobalIndexNtB12_6GlobalE4pushCsaCHOb31h0oq_8wasmtime:
  121|    636|    pub fn push(&mut self, v: V) -> K {
  122|    636|        let k = self.next_key();
  123|    636|        self.elems.push(v);
  124|    636|        k
  125|    636|    }
_RNvMNtCs9iALTVfPkbw_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types18DefinedMemoryIndexNtNtCslvZ9xuS3Qdd_16wasmtime_runtime6memory6MemoryE4pushB1U_:
  121|    636|    pub fn push(&mut self, v: V) -> K {
  122|    636|        let k = self.next_key();
  123|    636|        self.elems.push(v);
  124|    636|        k
  125|    636|    }
_RNvXs0_NtCs9iALTVfPkbw_16cranelift_entity7primaryINtB5_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types11MemoryIndexNtNtCs4vXvIybW1e9_16wasmtime_environ6module10MemoryPlanEINtNtNtCsiloedr2K6v7_4core3ops5index5IndexB13_E5indexCslvZ9xuS3Qdd_16wasmtime_runtime:
  201|  1.27k|    fn index(&self, k: K) -> &V {
  202|  1.27k|        &self.elems[k.index()]
  203|  1.27k|    }
_RNvMNtCs9iALTVfPkbw_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types18DefinedMemoryIndexNtNtCslvZ9xuS3Qdd_16wasmtime_runtime6memory6MemoryE13with_capacityB1U_:
   53|  1.27k|    pub fn with_capacity(capacity: usize) -> Self {
   54|  1.27k|        Self {
   55|  1.27k|            elems: Vec::with_capacity(capacity),
   56|  1.27k|            unused: PhantomData,
   57|  1.27k|        }
   58|  1.27k|    }
_RNvMNtCs9iALTVfPkbw_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types11MemoryIndexNtNtCs4vXvIybW1e9_16wasmtime_environ6module10MemoryPlanE3lenCslvZ9xuS3Qdd_16wasmtime_runtime:
   81|  5.08k|    pub fn len(&self) -> usize {
   82|  5.08k|        self.elems.len()
   83|  5.08k|    }
_RNvMNtCs9iALTVfPkbw_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types18DefinedMemoryIndexNtNtCslvZ9xuS3Qdd_16wasmtime_runtime6memory6MemoryE8next_keyB1U_:
  116|    636|    pub fn next_key(&self) -> K {
  117|    636|        K::new(self.elems.len())
  118|    636|    }
_RNvMNtCs9iALTVfPkbw_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types18DefinedMemoryIndexNtNtCslvZ9xuS3Qdd_16wasmtime_runtime6memory6MemoryE3newB1U_:
   45|    636|    pub fn new() -> Self {
   46|    636|        Self {
   47|    636|            elems: Vec::new(),
   48|    636|            unused: PhantomData,
   49|    636|        }
   50|    636|    }
_RNvXs0_NtCs9iALTVfPkbw_16cranelift_entity7primaryINtB5_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types11GlobalIndexNtB15_6GlobalEINtNtNtCsiloedr2K6v7_4core3ops5index5IndexB13_E5indexCslvZ9xuS3Qdd_16wasmtime_runtime:
  201|    636|    fn index(&self, k: K) -> &V {
  202|    636|        &self.elems[k.index()]
  203|    636|    }
_RNvMNtCs9iALTVfPkbw_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types17DefinedTableIndexNtNtCslvZ9xuS3Qdd_16wasmtime_runtime5table5TableE13with_capacityB1T_:
   53|  1.27k|    pub fn with_capacity(capacity: usize) -> Self {
   54|  1.27k|        Self {
   55|  1.27k|            elems: Vec::with_capacity(capacity),
   56|  1.27k|            unused: PhantomData,
   57|  1.27k|        }
   58|  1.27k|    }
_RNvMNtCs9iALTVfPkbw_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types11MemoryIndexNtNtCs4vXvIybW1e9_16wasmtime_environ6module10MemoryPlanE4iterCslvZ9xuS3Qdd_16wasmtime_runtime:
  101|  3.18k|    pub fn iter(&self) -> Iter<K, V> {
  102|  3.18k|        Iter::new(self.elems.iter())
  103|  3.18k|    }
_RNvXs1_NtCs9iALTVfPkbw_16cranelift_entity7primaryINtB5_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types18DefinedMemoryIndexNtNtCslvZ9xuS3Qdd_16wasmtime_runtime6memory6MemoryEINtNtNtCsiloedr2K6v7_4core3ops5index8IndexMutB13_E9index_mutB1X_:
  211|    636|    fn index_mut(&mut self, k: K) -> &mut V {
  212|    636|        &mut self.elems[k.index()]
  213|    636|    }
_RNvMNtCs9iALTVfPkbw_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types11GlobalIndexNtB12_6GlobalE3lenCslvZ9xuS3Qdd_16wasmtime_runtime:
   81|  1.90k|    pub fn len(&self) -> usize {
   82|  1.90k|        self.elems.len()
   83|  1.90k|    }
_RNvXs_NtCs9iALTVfPkbw_16cranelift_entity7primaryINtB4_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types17DefinedTableIndexNtNtCslvZ9xuS3Qdd_16wasmtime_runtime5table5TableENtNtCsiloedr2K6v7_4core7default7Default7defaultB1V_:
  188|    636|    fn default() -> PrimaryMap<K, V> {
  189|    636|        PrimaryMap::new()
  190|    636|    }
_RNvMNtCs9iALTVfPkbw_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types10TableIndexNtNtCs4vXvIybW1e9_16wasmtime_environ6module9TablePlanE3lenCslvZ9xuS3Qdd_16wasmtime_runtime:
   81|  5.08k|    pub fn len(&self) -> usize {
   82|  5.08k|        self.elems.len()
   83|  5.08k|    }
_RNvMNtCs9iALTVfPkbw_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types17DefinedTableIndexNtNtCslvZ9xuS3Qdd_16wasmtime_runtime5table5TableE3newB1T_:
   45|    636|    pub fn new() -> Self {
   46|    636|        Self {
   47|    636|            elems: Vec::new(),
   48|    636|            unused: PhantomData,
   49|    636|        }
   50|    636|    }
_RNvMNtCs9iALTVfPkbw_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types10TableIndexNtNtCs4vXvIybW1e9_16wasmtime_environ6module9TablePlanE4iterCslvZ9xuS3Qdd_16wasmtime_runtime:
  101|  1.27k|    pub fn iter(&self) -> Iter<K, V> {
  102|  1.27k|        Iter::new(self.elems.iter())
  103|  1.27k|    }
_RNvXs_NtCs9iALTVfPkbw_16cranelift_entity7primaryINtB4_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types18DefinedMemoryIndexNtNtCslvZ9xuS3Qdd_16wasmtime_runtime6memory6MemoryENtNtCsiloedr2K6v7_4core7default7Default7defaultB1W_:
  188|    636|    fn default() -> PrimaryMap<K, V> {
  189|    636|        PrimaryMap::new()
  190|    636|    }
_RNvMNtCs9iALTVfPkbw_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types11GlobalIndexNtB12_6GlobalE4iterCslvZ9xuS3Qdd_16wasmtime_runtime:
  101|  3.81k|    pub fn iter(&self) -> Iter<K, V> {
  102|  3.81k|        Iter::new(self.elems.iter())
  103|  3.81k|    }
_RNvMNtCs9iALTVfPkbw_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types9TypeIndexNtNtCs4vXvIybW1e9_16wasmtime_environ6module10ModuleTypeE3newB1K_:
   45|  1.27k|    pub fn new() -> Self {
   46|  1.27k|        Self {
   47|  1.27k|            elems: Vec::new(),
   48|  1.27k|            unused: PhantomData,
   49|  1.27k|        }
   50|  1.27k|    }
_RNvMNtCs9iALTVfPkbw_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types11MemoryIndexNtNtCs4vXvIybW1e9_16wasmtime_environ6module10MemoryPlanE3newB1N_:
   45|  1.27k|    pub fn new() -> Self {
   46|  1.27k|        Self {
   47|  1.27k|            elems: Vec::new(),
   48|  1.27k|            unused: PhantomData,
   49|  1.27k|        }
   50|  1.27k|    }
_RNvMNtCs9iALTVfPkbw_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types9FuncIndexNtNtCs4vXvIybW1e9_16wasmtime_environ6module12FunctionTypeE3newB1K_:
   45|  1.27k|    pub fn new() -> Self {
   46|  1.27k|        Self {
   47|  1.27k|            elems: Vec::new(),
   48|  1.27k|            unused: PhantomData,
   49|  1.27k|        }
   50|  1.27k|    }
_RNvXs_NtCs9iALTVfPkbw_16cranelift_entity7primaryINtB4_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types11MemoryIndexNtNtCs4vXvIybW1e9_16wasmtime_environ6module10MemoryPlanENtNtCsiloedr2K6v7_4core7default7Default7defaultB1P_:
  188|  1.27k|    fn default() -> PrimaryMap<K, V> {
  189|  1.27k|        PrimaryMap::new()
  190|  1.27k|    }
_RNvXs_NtCs9iALTVfPkbw_16cranelift_entity7primaryINtB4_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types10TableIndexNtNtCs4vXvIybW1e9_16wasmtime_environ6module9TablePlanENtNtCsiloedr2K6v7_4core7default7Default7defaultB1O_:
  188|  1.27k|    fn default() -> PrimaryMap<K, V> {
  189|  1.27k|        PrimaryMap::new()
  190|  1.27k|    }
_RNvXs_NtCs9iALTVfPkbw_16cranelift_entity7primaryINtB4_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types11GlobalIndexNtB14_6GlobalENtNtCsiloedr2K6v7_4core7default7Default7defaultCs4vXvIybW1e9_16wasmtime_environ:
  188|  1.27k|    fn default() -> PrimaryMap<K, V> {
  189|  1.27k|        PrimaryMap::new()
  190|  1.27k|    }
_RNvMNtCs9iALTVfPkbw_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types11GlobalIndexNtB12_6GlobalE3newCs4vXvIybW1e9_16wasmtime_environ:
   45|  1.27k|    pub fn new() -> Self {
   46|  1.27k|        Self {
   47|  1.27k|            elems: Vec::new(),
   48|  1.27k|            unused: PhantomData,
   49|  1.27k|        }
   50|  1.27k|    }
_RNvXs_NtCs9iALTVfPkbw_16cranelift_entity7primaryINtB4_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types9FuncIndexNtNtCs4vXvIybW1e9_16wasmtime_environ6module12FunctionTypeENtNtCsiloedr2K6v7_4core7default7Default7defaultB1M_:
  188|  1.27k|    fn default() -> PrimaryMap<K, V> {
  189|  1.27k|        PrimaryMap::new()
  190|  1.27k|    }
_RNvMNtCs9iALTVfPkbw_16cranelift_entity7primaryINtB2_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types10TableIndexNtNtCs4vXvIybW1e9_16wasmtime_environ6module9TablePlanE3newB1M_:
   45|  1.27k|    pub fn new() -> Self {
   46|  1.27k|        Self {
   47|  1.27k|            elems: Vec::new(),
   48|  1.27k|            unused: PhantomData,
   49|  1.27k|        }
   50|  1.27k|    }
_RNvXs_NtCs9iALTVfPkbw_16cranelift_entity7primaryINtB4_10PrimaryMapNtCs15iRE7yYizN_14wasmtime_types9TypeIndexNtNtCs4vXvIybW1e9_16wasmtime_environ6module10ModuleTypeENtNtCsiloedr2K6v7_4core7default7Default7defaultB1M_:
  188|  1.27k|    fn default() -> PrimaryMap<K, V> {
  189|  1.27k|        PrimaryMap::new()
  190|  1.27k|    }

_RNvMNtCs9iALTVfPkbw_16cranelift_entity3setINtB2_9EntitySetNtCs15iRE7yYizN_14wasmtime_types9ElemIndexE13with_capacityCslvZ9xuS3Qdd_16wasmtime_runtime:
   37|  1.90k|    pub fn with_capacity(capacity: usize) -> Self {
   38|  1.90k|        Self {
   39|  1.90k|            elems: Vec::with_capacity((capacity + 7) / 8),
   40|  1.90k|            ..Self::new()
   41|  1.90k|        }
   42|  1.90k|    }
_RNvMNtCs9iALTVfPkbw_16cranelift_entity3setINtB2_9EntitySetNtCs15iRE7yYizN_14wasmtime_types9ElemIndexE3newCslvZ9xuS3Qdd_16wasmtime_runtime:
   28|  1.90k|    pub fn new() -> Self {
   29|  1.90k|        Self {
   30|  1.90k|            elems: Vec::new(),
   31|  1.90k|            len: 0,
   32|  1.90k|            unused: PhantomData,
   33|  1.90k|        }
   34|  1.90k|    }
_RNvMNtCs9iALTVfPkbw_16cranelift_entity3setINtB2_9EntitySetNtCs15iRE7yYizN_14wasmtime_types9DataIndexE13with_capacityCslvZ9xuS3Qdd_16wasmtime_runtime:
   37|  1.90k|    pub fn with_capacity(capacity: usize) -> Self {
   38|  1.90k|        Self {
   39|  1.90k|            elems: Vec::with_capacity((capacity + 7) / 8),
   40|  1.90k|            ..Self::new()
   41|  1.90k|        }
   42|  1.90k|    }
_RNvMNtCs9iALTVfPkbw_16cranelift_entity3setINtB2_9EntitySetNtCs15iRE7yYizN_14wasmtime_types9DataIndexE3newCslvZ9xuS3Qdd_16wasmtime_runtime:
   28|  1.90k|    pub fn new() -> Self {
   29|  1.90k|        Self {
   30|  1.90k|            elems: Vec::new(),
   31|  1.90k|            len: 0,
   32|  1.90k|            unused: PhantomData,
   33|  1.90k|        }
   34|  1.90k|    }

_RNvCs1eENd7P87r1_16cranelift_native7builder:
   32|    636|pub fn builder() -> Result<isa::Builder, &'static str> {
   33|    636|    builder_with_options(true)
   34|    636|}
_RNvCs1eENd7P87r1_16cranelift_native20builder_with_options:
   43|    636|pub fn builder_with_options(infer_native_flags: bool) -> Result<isa::Builder, &'static str> {
   44|    636|    let mut isa_builder = isa::lookup(Triple::host()).map_err(|err| match err {
   45|       |        isa::LookupError::SupportDisabled => "support for architecture disabled at compile time",
   46|       |        isa::LookupError::Unsupported => "unsupported architecture",
   47|    636|    })?;
   48|       |
   49|       |    #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
   50|       |    {
   51|       |        use cranelift_codegen::settings::Configurable;
   52|       |
   53|    636|        if !std::is_x86_feature_detected!("sse2") {
   54|      0|            return Err("x86 support requires SSE2");
   55|    636|        }
   56|    636|
   57|    636|        if !infer_native_flags {
   58|      0|            return Ok(isa_builder);
   59|    636|        }
   60|    636|
   61|    636|        // These are temporarily enabled by default (see #3810 for
   62|    636|        // more) so that a default-constructed `Flags` can work with
   63|    636|        // default Wasmtime features. Otherwise, the user must
   64|    636|        // explicitly use native flags or turn these on when on x86-64
   65|    636|        // platforms to avoid a configuration panic. In order for the
   66|    636|        // "enable if detected" logic below to work, we must turn them
   67|    636|        // *off* (differing from the default) and then re-enable below
   68|    636|        // if present.
   69|    636|        isa_builder.set("has_sse3", "false").unwrap();
   70|    636|        isa_builder.set("has_ssse3", "false").unwrap();
   71|    636|        isa_builder.set("has_sse41", "false").unwrap();
   72|    636|        isa_builder.set("has_sse42", "false").unwrap();
   73|       |
   74|    636|        if std::is_x86_feature_detected!("sse3") {
   75|    636|            isa_builder.enable("has_sse3").unwrap();
   76|    636|        }
   77|    636|        if std::is_x86_feature_detected!("ssse3") {
   78|    636|            isa_builder.enable("has_ssse3").unwrap();
   79|    636|        }
   80|    636|        if std::is_x86_feature_detected!("sse4.1") {
   81|    636|            isa_builder.enable("has_sse41").unwrap();
   82|    636|        }
   83|    636|        if std::is_x86_feature_detected!("sse4.2") {
   84|    636|            isa_builder.enable("has_sse42").unwrap();
   85|    636|        }
   86|    636|        if std::is_x86_feature_detected!("popcnt") {
   87|    636|            isa_builder.enable("has_popcnt").unwrap();
   88|    636|        }
   89|    636|        if std::is_x86_feature_detected!("avx") {
   90|    636|            isa_builder.enable("has_avx").unwrap();
   91|    636|        }
   92|    636|        if std::is_x86_feature_detected!("avx2") {
   93|    636|            isa_builder.enable("has_avx2").unwrap();
   94|    636|        }
   95|    636|        if std::is_x86_feature_detected!("fma") {
   96|    636|            isa_builder.enable("has_fma").unwrap();
   97|    636|        }
   98|    636|        if std::is_x86_feature_detected!("bmi1") {
   99|    636|            isa_builder.enable("has_bmi1").unwrap();
  100|    636|        }
  101|    636|        if std::is_x86_feature_detected!("bmi2") {
  102|    636|            isa_builder.enable("has_bmi2").unwrap();
  103|    636|        }
  104|      0|        if std::is_x86_feature_detected!("avx512bitalg") {
  105|      0|            isa_builder.enable("has_avx512bitalg").unwrap();
  106|    636|        }
  107|    636|        if std::is_x86_feature_detected!("avx512dq") {
  108|    636|            isa_builder.enable("has_avx512dq").unwrap();
  109|    636|        }
  110|    636|        if std::is_x86_feature_detected!("avx512f") {
  111|    636|            isa_builder.enable("has_avx512f").unwrap();
  112|    636|        }
  113|    636|        if std::is_x86_feature_detected!("avx512vl") {
  114|    636|            isa_builder.enable("has_avx512vl").unwrap();
  115|    636|        }
  116|      0|        if std::is_x86_feature_detected!("avx512vbmi") {
  117|      0|            isa_builder.enable("has_avx512vbmi").unwrap();
  118|    636|        }
  119|    636|        if std::is_x86_feature_detected!("lzcnt") {
  120|    636|            isa_builder.enable("has_lzcnt").unwrap();
  121|    636|        }
  122|       |    }
  123|       |
  124|       |    #[cfg(target_arch = "aarch64")]
  125|       |    {
  126|       |        use cranelift_codegen::settings::Configurable;
  127|       |
  128|       |        if !infer_native_flags {
  129|       |            return Ok(isa_builder);
  130|       |        }
  131|       |
  132|       |        if std::arch::is_aarch64_feature_detected!("lse") {
  133|       |            isa_builder.enable("has_lse").unwrap();
  134|       |        }
  135|       |
  136|       |        if std::arch::is_aarch64_feature_detected!("paca") {
  137|       |            isa_builder.enable("has_pauth").unwrap();
  138|       |        }
  139|       |
  140|       |        if cfg!(target_os = "macos") {
  141|       |            // Pointer authentication is always available on Apple Silicon.
  142|       |            isa_builder.enable("sign_return_address").unwrap();
  143|       |            // macOS enforces the use of the B key for return addresses.
  144|       |            isa_builder.enable("sign_return_address_with_bkey").unwrap();
  145|       |        }
  146|       |    }
  147|       |
  148|       |    // There is no is_s390x_feature_detected macro yet, so for now
  149|       |    // we use getauxval from the libc crate directly.
  150|       |    #[cfg(all(target_arch = "s390x", target_os = "linux"))]
  151|       |    {
  152|       |        use cranelift_codegen::settings::Configurable;
  153|       |
  154|       |        if !infer_native_flags {
  155|       |            return Ok(isa_builder);
  156|       |        }
  157|       |
  158|       |        let v = unsafe { libc::getauxval(libc::AT_HWCAP) };
  159|       |        const HWCAP_S390X_VXRS_EXT2: libc::c_ulong = 32768;
  160|       |        if (v & HWCAP_S390X_VXRS_EXT2) != 0 {
  161|       |            isa_builder.enable("has_vxrs_ext2").unwrap();
  162|       |            // There is no separate HWCAP bit for mie2, so assume
  163|       |            // that any machine with vxrs_ext2 also has mie2.
  164|       |            isa_builder.enable("has_mie2").unwrap();
  165|       |        }
  166|       |    }
  167|       |
  168|       |    // squelch warnings about unused mut/variables on some platforms.
  169|    636|    drop(&mut isa_builder);
  170|    636|    drop(infer_native_flags);
  171|    636|
  172|    636|    Ok(isa_builder)
  173|    636|}

_RINvXsd_NtCsf2Bn5hSrLpu_14cs_serde_bytes7bytebufNtB6_14ByteBufVisitorNtNtCssVaLrL3Upj_5serde2de7Visitor14visit_byte_bufNtNtCs3TS9n28v4Rl_12libipld_core5error10SerdeErrorECsboUdcTbF1FS_15direct_syscalls:
  208|    954|    fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<ByteBuf, E>
  209|    954|    where
  210|    954|        E: Error,
  211|    954|    {
  212|    954|        Ok(ByteBuf::from(v))
  213|    954|    }
_RINvXse_NtCsf2Bn5hSrLpu_14cs_serde_bytes7bytebufNtB6_7ByteBufNtNtCssVaLrL3Upj_5serde2de11Deserialize11deserializeNtNtCs3TS9n28v4Rl_12libipld_core4ipld4IpldECsboUdcTbF1FS_15direct_syscalls:
  217|    954|    fn deserialize<D>(deserializer: D) -> Result<ByteBuf, D::Error>
  218|    954|    where
  219|    954|        D: Deserializer<'de>,
  220|    954|    {
  221|    954|        deserializer.deserialize_byte_buf(ByteBufVisitor)
  222|    954|    }
_RINvMNtCsf2Bn5hSrLpu_14cs_serde_bytes7bytebufNtB3_7ByteBuf4fromINtNtCs9pDt8l5wGDA_5alloc3vec3VechEECsboUdcTbF1FS_15direct_syscalls:
   58|    954|    pub fn from<T: Into<Vec<u8>>>(bytes: T) -> Self {
   59|    954|        ByteBuf {
   60|    954|            bytes: bytes.into(),
   61|    954|        }
   62|    954|    }
_RNvMNtCsf2Bn5hSrLpu_14cs_serde_bytes7bytebufNtB2_7ByteBuf8into_vec:
   65|    954|    pub fn into_vec(self) -> Vec<u8> {
   66|    954|        self.bytes
   67|    954|    }

_RINvXs_NtCsf2Bn5hSrLpu_14cs_serde_bytes2deINtNtCs9pDt8l5wGDA_5alloc3vec3VechENtB5_11Deserialize11deserializeNtNtCs3TS9n28v4Rl_12libipld_core4ipld4IpldECsboUdcTbF1FS_15direct_syscalls:
   40|    954|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
   41|    954|    where
   42|    954|        D: Deserializer<'de>,
   43|    954|    {
   44|    954|        Deserialize::deserialize(deserializer).map(ByteBuf::into_vec)
   45|    954|    }
_RINvXs1_NtCsf2Bn5hSrLpu_14cs_serde_bytes2deNtNtB8_7bytebuf7ByteBufNtB6_11Deserialize11deserializeNtNtCs3TS9n28v4Rl_12libipld_core4ipld4IpldECsboUdcTbF1FS_15direct_syscalls:
   59|    954|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
   60|    954|    where
   61|    954|        D: Deserializer<'de>,
   62|    954|    {
   63|    954|        // Via the serde::Deserialize impl for ByteBuf.
   64|    954|        serde::Deserialize::deserialize(deserializer)
   65|    954|    }

_RINvCsf2Bn5hSrLpu_14cs_serde_bytes11deserializeINtNtCs9pDt8l5wGDA_5alloc3vec3VechENtNtCs3TS9n28v4Rl_12libipld_core4ipld4IpldECsboUdcTbF1FS_15direct_syscalls:
  102|    954|pub fn deserialize<'de, T, D>(deserializer: D) -> Result<T, D::Error>
  103|    954|where
  104|    954|    T: Deserialize<'de>,
  105|    954|    D: Deserializer<'de>,
  106|    954|{
  107|    954|    Deserialize::deserialize(deserializer)
  108|    954|}
_RINvCsf2Bn5hSrLpu_14cs_serde_bytes9serializeINtNtCs9pDt8l5wGDA_5alloc3vec3VechEQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECsboUdcTbF1FS_15direct_syscalls:
   76|    954|pub fn serialize<T, S>(bytes: &T, serializer: S) -> Result<S::Ok, S::Error>
   77|    954|where
   78|    954|    T: ?Sized + Serialize,
   79|    954|    S: Serializer,
   80|    954|{
   81|    954|    Serialize::serialize(bytes, serializer)
   82|    954|}

_RINvXs_NtCsf2Bn5hSrLpu_14cs_serde_bytes3serINtNtCs9pDt8l5wGDA_5alloc3vec3VechENtB5_9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECsboUdcTbF1FS_15direct_syscalls:
   37|    954|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   38|    954|    where
   39|    954|        S: Serializer,
   40|    954|    {
   41|    954|        serializer.serialize_bytes(self)
   42|    954|    }

_RINvCsa87WX2XYAZI_13data_encoding15encode_base_lenNtB2_2N5EB2_:
  481|  1.90k|fn encode_base_len<B: Static<usize>>(bit: B, len: usize) -> usize {
  482|  1.90k|    encode_len(bit, len)
  483|  1.90k|}
_RNvCsa87WX2XYAZI_13data_encoding15chunk_unchecked:
  241|  3.18k|unsafe fn chunk_unchecked(x: &[u8], n: usize, i: usize) -> &[u8] {
  242|  3.18k|    debug_assert!((i + 1) * n <= x.len());
  243|  3.18k|    let ptr = x.as_ptr().add(n * i);
  244|  3.18k|    core::slice::from_raw_parts(ptr, n)
  245|  3.18k|}
_RNvCsa87WX2XYAZI_13data_encoding5order:
  347|  44.8k|fn order(msb: bool, n: usize, i: usize) -> usize {
  348|  44.8k|    if msb {
  349|  44.8k|        n - 1 - i
  350|       |    } else {
  351|      0|        i
  352|       |    }
  353|  44.8k|}
_RINvCsa87WX2XYAZI_13data_encoding11encode_baseNtB2_2N5NtB2_2BtEB2_:
  485|    636|fn encode_base<B: Static<usize>, M: Static<bool>>(
  486|    636|    bit: B, msb: M, symbols: &[u8; 256], input: &[u8], output: &mut [u8],
  487|    636|) {
  488|    636|    debug_assert_eq!(output.len(), encode_base_len(bit, input.len()));
  489|    636|    encode_mut(bit, msb, symbols, input, output);
  490|    636|}
_RNvMs4_Csa87WX2XYAZI_13data_encodingNtB5_8Encoding3pad:
 1230|  1.90k|    fn pad(&self) -> Option<u8> {
 1231|  1.90k|        if self.0[512] < 128 {
 1232|      0|            Some(self.0[512])
 1233|       |        } else {
 1234|  1.90k|            None
 1235|       |        }
 1236|  1.90k|    }
_RNvCsa87WX2XYAZI_13data_encoding3dec:
  365|  28.3k|fn dec(bit: usize) -> usize {
  366|  28.3k|    enc(bit) * 8 / bit
  367|  28.3k|}
_RNCINvCsa87WX2XYAZI_13data_encoding10encode_mutNtB4_2N5NtB4_2BtE0B4_:
  402|  3.18k|    vectorize(n, bs, |i| {
  403|  3.18k|        let input = unsafe { chunk_unchecked(input, enc, i) };
  404|  3.18k|        let output = unsafe { chunk_mut_unchecked(output, dec, i) };
  405|  3.18k|        encode_block(bit, msb, symbols, input, output);
  406|  3.18k|    });
_RINvCsa87WX2XYAZI_13data_encoding10encode_lenNtB2_2N5EB2_:
  369|  6.36k|fn encode_len<B: Static<usize>>(bit: B, len: usize) -> usize {
  370|  6.36k|    div_ceil(8 * len, bit.val())
  371|  6.36k|}
_RNvXCsa87WX2XYAZI_13data_encodingNtB2_2OnINtB2_6StaticINtNtCsiloedr2K6v7_4core6option6OptionhEE3valB2_:
  199|  1.90k|    fn val(self) -> Option<T> {
  200|  1.90k|        None
  201|  1.90k|    }
_RINvCsa87WX2XYAZI_13data_encoding15encode_wrap_lenNtB2_2N5NtB2_2OnBU_EB2_:
  514|  1.27k|fn encode_wrap_len<
  515|  1.27k|    'a,
  516|  1.27k|    B: Static<usize>,
  517|  1.27k|    P: Static<Option<u8>>,
  518|  1.27k|    W: Static<Option<(usize, &'a [u8])>>,
  519|  1.27k|>(
  520|  1.27k|    bit: B, pad: P, wrap: W, ilen: usize,
  521|  1.27k|) -> usize {
  522|  1.27k|    let olen = encode_pad_len(bit, pad, ilen);
  523|  1.27k|    match wrap.val() {
  524|  1.27k|        None => olen,
  525|      0|        Some((col, end)) => olen + end.len() * div_ceil(olen, col),
  526|       |    }
  527|  1.27k|}
_RINvCsa87WX2XYAZI_13data_encoding15encode_wrap_mutNtB2_2N5NtB2_2BtNtB2_2OnB12_EB2_:
  529|    636|fn encode_wrap_mut<
  530|    636|    'a,
  531|    636|    B: Static<usize>,
  532|    636|    M: Static<bool>,
  533|    636|    P: Static<Option<u8>>,
  534|    636|    W: Static<Option<(usize, &'a [u8])>>,
  535|    636|>(
  536|    636|    bit: B, msb: M, symbols: &[u8; 256], pad: P, wrap: W, input: &[u8], output: &mut [u8],
  537|    636|) {
  538|    636|    let (col, end) = match wrap.val() {
  539|    636|        None => return encode_pad(bit, msb, symbols, pad, input, output),
  540|      0|        Some((col, end)) => (col, end),
  541|       |    };
  542|      0|    debug_assert_eq!(output.len(), encode_wrap_len(bit, pad, wrap, input.len()));
  543|      0|    debug_assert_eq!(col % dec(bit.val()), 0);
  544|      0|    let col = col / dec(bit.val());
  545|      0|    let enc = col * enc(bit.val());
  546|      0|    let dec = col * dec(bit.val()) + end.len();
  547|      0|    let olen = dec - end.len();
  548|      0|    let n = input.len() / enc;
  549|      0|    for i in 0 .. n {
  550|      0|        let input = unsafe { chunk_unchecked(input, enc, i) };
  551|      0|        let output = unsafe { chunk_mut_unchecked(output, dec, i) };
  552|      0|        encode_base(bit, msb, symbols, input, &mut output[.. olen]);
  553|      0|        output[olen ..].copy_from_slice(end);
  554|      0|    }
  555|      0|    if input.len() > enc * n {
  556|      0|        let olen = dec * n + encode_pad_len(bit, pad, input.len() - enc * n);
  557|      0|        encode_pad(bit, msb, symbols, pad, &input[enc * n ..], &mut output[dec * n .. olen]);
  558|      0|        output[olen ..].copy_from_slice(end);
  559|      0|    }
  560|    636|}
_RNvMs4_Csa87WX2XYAZI_13data_encodingNtB5_8Encoding3sym:
 1222|    636|    fn sym(&self) -> &[u8; 256] {
 1223|    636|        unsafe { as_array(&self.0[0 .. 256]) }
 1224|    636|    }
_RINvCsa87WX2XYAZI_13data_encoding10encode_mutNtB2_2N5NtB2_2BtEB2_:
  390|    636|fn encode_mut<B: Static<usize>, M: Static<bool>>(
  391|    636|    bit: B, msb: M, symbols: &[u8; 256], input: &[u8], output: &mut [u8],
  392|    636|) {
  393|    636|    debug_assert_eq!(output.len(), encode_len(bit, input.len()));
  394|    636|    let enc = enc(bit.val());
  395|    636|    let dec = dec(bit.val());
  396|    636|    let n = input.len() / enc;
  397|    636|    let bs = match bit.val() {
  398|    636|        5 => 2,
  399|      0|        6 => 4,
  400|      0|        _ => 1,
  401|       |    };
  402|    636|    vectorize(n, bs, |i| {
  403|       |        let input = unsafe { chunk_unchecked(input, enc, i) };
  404|       |        let output = unsafe { chunk_mut_unchecked(output, dec, i) };
  405|       |        encode_block(bit, msb, symbols, input, output);
  406|    636|    });
  407|    636|    encode_block(bit, msb, symbols, &input[enc * n ..], &mut output[dec * n ..]);
  408|    636|}
_RNvCsa87WX2XYAZI_13data_encoding5floor:
  262|    636|fn floor(x: usize, m: usize) -> usize {
  263|    636|    x / m * m
  264|    636|}
_RNvMs4_Csa87WX2XYAZI_13data_encodingNtB5_8Encoding10encode_mut:
 1295|    636|    pub fn encode_mut(&self, input: &[u8], output: &mut [u8]) {
 1296|    636|        assert_eq!(output.len(), self.encode_len(input.len()));
 1297|       |        dispatch! {
 1298|    636|            let bit: usize = self.bit();
 1299|    636|            let msb: bool = self.msb();
 1300|    636|            let pad: Option<u8> = self.pad();
 1301|    636|            let wrap: Option<(usize, &[u8])> = self.wrap();
 1302|    636|            encode_wrap_mut(bit, msb, self.sym(), pad, wrap, input, output)
 1303|       |        }
 1304|    636|    }
_RNvCsa87WX2XYAZI_13data_encoding19chunk_mut_unchecked:
  247|  3.18k|unsafe fn chunk_mut_unchecked(x: &mut [u8], n: usize, i: usize) -> &mut [u8] {
  248|  3.18k|    debug_assert!((i + 1) * n <= x.len());
  249|  3.18k|    let ptr = x.as_mut_ptr().add(n * i);
  250|  3.18k|    core::slice::from_raw_parts_mut(ptr, n)
  251|  3.18k|}
_RNvCsa87WX2XYAZI_13data_encoding3enc:
  355|  49.9k|fn enc(bit: usize) -> usize {
  356|  49.9k|    debug_assert!(1 <= bit && bit <= 6);
  357|  49.9k|    match bit {
  358|      0|        1 | 2 | 4 => 1,
  359|      0|        3 | 6 => 3,
  360|  49.9k|        5 => 5,
  361|      0|        _ => unreachable!(),
  362|       |    }
  363|  49.9k|}
_RNvXsb_Csa87WX2XYAZI_13data_encodingNtB5_2BtINtB5_6StaticbE3val:
  179|  3.81k|            fn val(self) -> $type {
  180|  3.81k|                $val
  181|  3.81k|            }
_RINvCsa87WX2XYAZI_13data_encoding9vectorizeNCINvB2_10encode_mutNtB2_2N5NtB2_2BtE0EB2_:
  266|    636|fn vectorize<F: FnMut(usize)>(n: usize, bs: usize, mut f: F) {
  267|  1.27k|    for k in 0 .. n / bs {
  268|  2.54k|        for i in k * bs .. (k + 1) * bs {
  269|  2.54k|            f(i);
  270|  2.54k|        }
  271|       |    }
  272|    636|    for i in floor(n, bs) .. n {
  273|    636|        f(i);
  274|    636|    }
  275|    636|}
_RNvMs4_Csa87WX2XYAZI_13data_encodingNtB5_8Encoding10encode_len:
 1266|  1.27k|    pub fn encode_len(&self, len: usize) -> usize {
 1267|  1.27k|        dispatch! {
 1268|  1.27k|            let bit: usize = self.bit();
 1269|  1.27k|            let pad: Option<u8> = self.pad();
 1270|  1.27k|            let wrap: Option<(usize, &[u8])> = self.wrap();
 1271|  1.27k|            encode_wrap_len(bit, pad, wrap, len)
 1272|       |        }
 1273|  1.27k|    }
_RINvCsa87WX2XYAZI_13data_encoding10encode_padNtB2_2N5NtB2_2BtNtB2_2OnEB2_:
  499|    636|fn encode_pad<B: Static<usize>, M: Static<bool>, P: Static<Option<u8>>>(
  500|    636|    bit: B, msb: M, symbols: &[u8; 256], spad: P, input: &[u8], output: &mut [u8],
  501|    636|) {
  502|    636|    let pad = match spad.val() {
  503|    636|        None => return encode_base(bit, msb, symbols, input, output),
  504|      0|        Some(pad) => pad,
  505|       |    };
  506|      0|    debug_assert_eq!(output.len(), encode_pad_len(bit, spad, input.len()));
  507|      0|    let olen = encode_base_len(bit, input.len());
  508|      0|    encode_base(bit, msb, symbols, input, &mut output[.. olen]);
  509|      0|    for output in output.iter_mut().skip(olen) {
  510|      0|        *output = pad;
  511|      0|    }
  512|    636|}
_RNvMs4_Csa87WX2XYAZI_13data_encodingNtB5_8Encoding3bit:
 1246|  1.90k|    fn bit(&self) -> usize {
 1247|  1.90k|        (self.0[513] & 0x7) as usize
 1248|  1.90k|    }
_RNvCsa87WX2XYAZI_13data_encoding8div_ceil:
  258|  6.36k|fn div_ceil(x: usize, m: usize) -> usize {
  259|  6.36k|    (x + m - 1) / m
  260|  6.36k|}
_RINvCsa87WX2XYAZI_13data_encoding14encode_pad_lenNtB2_2N5NtB2_2OnEB2_:
  492|  1.27k|fn encode_pad_len<B: Static<usize>, P: Static<Option<u8>>>(bit: B, pad: P, len: usize) -> usize {
  493|  1.27k|    match pad.val() {
  494|  1.27k|        None => encode_base_len(bit, len),
  495|      0|        Some(_) => div_ceil(len, enc(bit.val())) * dec(bit.val()),
  496|       |    }
  497|  1.27k|}
_RNvMs4_Csa87WX2XYAZI_13data_encodingNtB5_8Encoding3msb:
 1242|    636|    fn msb(&self) -> bool {
 1243|    636|        self.0[513] & 0x8 != 0
 1244|    636|    }
_RNvMs4_Csa87WX2XYAZI_13data_encodingNtB5_8Encoding6encode:
 1343|    636|    pub fn encode(&self, input: &[u8]) -> String {
 1344|    636|        let mut output = vec![0u8; self.encode_len(input.len())];
 1345|    636|        self.encode_mut(input, &mut output);
 1346|    636|        unsafe { String::from_utf8_unchecked(output) }
 1347|    636|    }
_RNvMs4_Csa87WX2XYAZI_13data_encodingNtB5_8Encoding4wrap:
 1250|  1.90k|    fn wrap(&self) -> Option<(usize, &[u8])> {
 1251|  1.90k|        if self.0.len() <= 515 {
 1252|  1.90k|            return None;
 1253|      0|        }
 1254|      0|        Some((self.0[514] as usize, &self.0[515 ..]))
 1255|  1.90k|    }
_RNvXCsa87WX2XYAZI_13data_encodingNtB2_2OnINtB2_6StaticINtNtCsiloedr2K6v7_4core6option6OptionTjRShEEE3valB2_:
  199|  1.90k|    fn val(self) -> Option<T> {
  200|  1.90k|        None
  201|  1.90k|    }
_RNvCsa87WX2XYAZI_13data_encoding8as_array:
  253|    636|unsafe fn as_array(x: &[u8]) -> &[u8; 256] {
  254|    636|    debug_assert_eq!(x.len(), 256);
  255|    636|    &*(x.as_ptr() as *const [u8; 256])
  256|    636|}
_RINvCsa87WX2XYAZI_13data_encoding12encode_blockNtB2_2N5NtB2_2BtEB2_:
  373|  3.81k|fn encode_block<B: Static<usize>, M: Static<bool>>(
  374|  3.81k|    bit: B, msb: M, symbols: &[u8; 256], input: &[u8], output: &mut [u8],
  375|  3.81k|) {
  376|  3.81k|    debug_assert!(input.len() <= enc(bit.val()));
  377|  3.81k|    debug_assert_eq!(output.len(), encode_len(bit, input.len()));
  378|  3.81k|    let bit = bit.val();
  379|  3.81k|    let msb = msb.val();
  380|  3.81k|    let mut x = 0u64;
  381|  17.1k|    for (i, input) in input.iter().enumerate() {
  382|  17.1k|        x |= u64::from(*input) << (8 * order(msb, enc(bit), i));
  383|  17.1k|    }
  384|  27.6k|    for (i, output) in output.iter_mut().enumerate() {
  385|  27.6k|        let y = x >> (bit * order(msb, dec(bit), i));
  386|  27.6k|        *output = symbols[y as usize % 256];
  387|  27.6k|    }
  388|  3.81k|}
_RNvXsq_Csa87WX2XYAZI_13data_encodingNtB5_2N5INtB5_6StaticjE3val:
  179|  15.9k|            fn val(self) -> $type {
  180|  15.9k|                $val
  181|  15.9k|            }

_RNvXs4_NtNtCs9RD1cWfVxpd_6digest8core_api11ct_variableINtB5_21CtVariableCoreWrapperNtNtCs6hBXtUubyyi_4sha28core_api13Sha256VarCoreINtNtCs6DngFm1hXV4_7typenum4uint4UIntIB25_IB25_IB25_IB25_IB25_NtB27_5UTermNtNtB29_3bit2B1ENtB3i_2B0EB3w_EB3w_EB3w_EB3w_ENtB1n_9OidSha256ENtB7_15FixedOutputCore19finalize_fixed_coreCsboUdcTbF1FS_15direct_syscalls:
  114|    954|    fn finalize_fixed_core(
  115|    954|        &mut self,
  116|    954|        buffer: &mut Buffer<Self>,
  117|    954|        out: &mut GenericArray<u8, Self::OutputSize>,
  118|    954|    ) {
  119|    954|        let mut full_res = Default::default();
  120|    954|        self.inner.finalize_variable_core(buffer, &mut full_res);
  121|    954|        let n = out.len();
  122|    954|        let m = full_res.len() - n;
  123|    954|        match T::TRUNC_SIDE {
  124|    954|            TruncSide::Left => out.copy_from_slice(&full_res[..n]),
  125|      0|            TruncSide::Right => out.copy_from_slice(&full_res[m..]),
  126|       |        }
  127|    954|    }
_RNvXs5_NtNtCs9RD1cWfVxpd_6digest8core_api11ct_variableINtB5_21CtVariableCoreWrapperNtNtCs6hBXtUubyyi_4sha28core_api13Sha256VarCoreINtNtCs6DngFm1hXV4_7typenum4uint4UIntIB25_IB25_IB25_IB25_IB25_NtB27_5UTermNtNtB29_3bit2B1ENtB3i_2B0EB3w_EB3w_EB3w_EB3w_ENtB1n_9OidSha256ENtNtCsiloedr2K6v7_4core7default7Default7defaultCsboUdcTbF1FS_15direct_syscalls:
  139|    954|    fn default() -> Self {
  140|    954|        Self {
  141|    954|            inner: T::new(OutSize::USIZE).unwrap(),
  142|    954|            _out: PhantomData,
  143|    954|        }
  144|    954|    }

_RNvXs8_NtNtCs9RD1cWfVxpd_6digest8core_api7wrapperINtB5_11CoreWrapperINtNtB7_11ct_variable21CtVariableCoreWrapperNtNtCs6hBXtUubyyi_4sha28core_api13Sha256VarCoreINtNtCs6DngFm1hXV4_7typenum4uint4UIntIB2y_IB2y_IB2y_IB2y_IB2y_NtB2A_5UTermNtNtB2C_3bit2B1ENtB3L_2B0EB3Z_EB3Z_EB3Z_EB3Z_ENtB1Q_9OidSha256EENtB9_11FixedOutput13finalize_intoCsboUdcTbF1FS_15direct_syscalls:
  170|    954|    fn finalize_into(mut self, out: &mut Output<Self>) {
  171|    954|        let Self { core, buffer } = &mut self;
  172|    954|        core.finalize_fixed_core(buffer, out);
  173|    954|    }
_RNvXsg_NtNtCs9RD1cWfVxpd_6digest8core_api7wrapperINtB5_11CoreWrapperINtNtB7_11ct_variable21CtVariableCoreWrapperNtNtCs6hBXtUubyyi_4sha28core_api13Sha256VarCoreINtNtCs6DngFm1hXV4_7typenum4uint4UIntIB2y_IB2y_IB2y_IB2y_IB2y_NtB2A_5UTermNtNtB2C_3bit2B1ENtB3L_2B0EB3Z_EB3Z_EB3Z_EB3Z_ENtB1Q_9OidSha256EENtNtCsiloedr2K6v7_4core7default7Default7defaultCsboUdcTbF1FS_15direct_syscalls:
   23|    954|#[derive(Clone, Default)]
_RNvXs6_NtNtCs9RD1cWfVxpd_6digest8core_api7wrapperINtB5_11CoreWrapperINtNtB7_11ct_variable21CtVariableCoreWrapperNtNtCs6hBXtUubyyi_4sha28core_api13Sha256VarCoreINtNtCs6DngFm1hXV4_7typenum4uint4UIntIB2y_IB2y_IB2y_IB2y_IB2y_NtB2A_5UTermNtNtB2C_3bit2B1ENtB3L_2B0EB3Z_EB3Z_EB3Z_EB3Z_ENtB1Q_9OidSha256EENtB9_6Update6updateCslH3pn9Bu6yX_13fvm_ipld_hamt:
  148|    954|    fn update(&mut self, input: &[u8]) {
  149|    954|        let Self { core, buffer } = self;
  150|    954|        buffer.digest_blocks(input, |blocks| core.update_blocks(blocks));
  151|    954|    }

_RNvXNtCs9RD1cWfVxpd_6digest6digestINtNtNtB4_8core_api7wrapper11CoreWrapperINtNtBB_11ct_variable21CtVariableCoreWrapperNtNtCs6hBXtUubyyi_4sha28core_api13Sha256VarCoreINtNtCs6DngFm1hXV4_7typenum4uint4UIntIB2E_IB2E_IB2E_IB2E_IB2E_NtB2G_5UTermNtNtB2I_3bit2B1ENtB3R_2B0EB45_EB45_EB45_EB45_ENtB1W_9OidSha256EENtB2_6Digest8finalizeCsboUdcTbF1FS_15direct_syscalls:
   85|    954|    fn finalize(self) -> Output<Self> {
   86|    954|        FixedOutput::finalize_fixed(self)
   87|    954|    }
_RINvXNtCs9RD1cWfVxpd_6digest6digestINtNtNtB5_8core_api7wrapper11CoreWrapperINtNtBC_11ct_variable21CtVariableCoreWrapperNtNtCs6hBXtUubyyi_4sha28core_api13Sha256VarCoreINtNtCs6DngFm1hXV4_7typenum4uint4UIntIB2F_IB2F_IB2F_IB2F_IB2F_NtB2H_5UTermNtNtB2J_3bit2B1ENtB3S_2B0EB46_EB46_EB46_EB46_ENtB1X_9OidSha256EENtB3_6Digest6updateRShECslH3pn9Bu6yX_13fvm_ipld_hamt:
   74|    954|    fn update(&mut self, data: impl AsRef<[u8]>) {
   75|    954|        Update::update(self, data.as_ref());
   76|    954|    }

_RNvYINtNtNtCs9RD1cWfVxpd_6digest8core_api7wrapper11CoreWrapperINtNtB7_11ct_variable21CtVariableCoreWrapperNtNtCs6hBXtUubyyi_4sha28core_api13Sha256VarCoreINtNtCs6DngFm1hXV4_7typenum4uint4UIntIB2s_IB2s_IB2s_IB2s_IB2s_NtB2u_5UTermNtNtB2w_3bit2B1ENtB3F_2B0EB3T_EB3T_EB3T_EB3T_ENtB1K_9OidSha256EENtB9_11FixedOutput14finalize_fixedCsboUdcTbF1FS_15direct_syscalls:
   99|    954|    fn finalize_fixed(self) -> Output<Self> {
  100|    954|        let mut out = Default::default();
  101|    954|        self.finalize_into(&mut out);
  102|    954|        out
  103|    954|    }

_RNCNvMNtCscSNP6bGsstK_10env_logger6filterNtB4_6Filter6filter0B6_:
  142|  1.27k|            .map(|d| d.level)
_RNvNtCscSNP6bGsstK_10env_logger6filter7enabled:
  362|    954|fn enabled(directives: &[Directive], level: Level, target: &str) -> bool {
  363|       |    // Search for the longest match, the vector is assumed to be pre-sorted.
  364|  3.81k|    for directive in directives.iter().rev() {
  365|  3.81k|        match directive.name {
  366|  3.81k|            Some(ref name) if !target.starts_with(&**name) => {}
  367|    636|            Some(..) | None => return level <= directive.level,
  368|       |        }
  369|       |    }
  370|    318|    false
  371|    954|}
_RNCNvMs_NtCscSNP6bGsstK_10env_logger6filterNtB6_7Builder5builds_0B8_:
  248|  1.59k|            directives.sort_by(|a, b| {
  249|  1.59k|                let alen = a.name.as_ref().map(|a| a.len()).unwrap_or(0);
  250|  1.59k|                let blen = b.name.as_ref().map(|b| b.len()).unwrap_or(0);
  251|  1.59k|                alen.cmp(&blen)
  252|  1.59k|            });
_RNvMNtCscSNP6bGsstK_10env_logger6filterNtB2_6Filter6filter:
  139|    318|    pub fn filter(&self) -> LevelFilter {
  140|    318|        self.directives
  141|    318|            .iter()
  142|    318|            .map(|d| d.level)
  143|    318|            .max()
  144|    318|            .unwrap_or(LevelFilter::Off)
  145|    318|    }
_RNCNvMs_NtCscSNP6bGsstK_10env_logger6filterNtB6_7Builder5build0B8_:
  244|  1.27k|                .map(|(name, level)| Directive { name, level })
_RNCNvNtCscSNP6bGsstK_10env_logger6filter10parse_specs_0B5_:
  313|    636|                match (parts.next(), parts.next().map(|s| s.trim()), parts.next()) {
_RNvMNtCscSNP6bGsstK_10env_logger6filterNtB2_6Filter7enabled:
  163|    954|    pub fn enabled(&self, metadata: &Metadata) -> bool {
  164|    954|        let level = metadata.level();
  165|    954|        let target = metadata.target();
  166|    954|
  167|    954|        enabled(&self.directives, level, target)
  168|    954|    }
_RNvMNtCscSNP6bGsstK_10env_logger6filterNtB2_6Filter7matches:
  148|    954|    pub fn matches(&self, record: &Record) -> bool {
  149|    954|        if !self.enabled(record.metadata()) {
  150|    318|            return false;
  151|    636|        }
  152|       |
  153|    636|        if let Some(filter) = self.filter.as_ref() {
  154|      0|            if !filter.is_match(&record.args().to_string()) {
  155|      0|                return false;
  156|      0|            }
  157|    636|        }
  158|       |
  159|    636|        true
  160|    954|    }
_RNvMs_NtCscSNP6bGsstK_10env_logger6filterNtB4_7Builder3new:
  173|    318|    pub fn new() -> Builder {
  174|    318|        Builder {
  175|    318|            directives: HashMap::new(),
  176|    318|            filter: None,
  177|    318|            built: false,
  178|    318|        }
  179|    318|    }
_RNCNCNvMs_NtCscSNP6bGsstK_10env_logger6filterNtB8_7Builder5builds_0s_0Ba_:
  250|  1.59k|                let blen = b.name.as_ref().map(|b| b.len()).unwrap_or(0);
_RNCNCNvMs_NtCscSNP6bGsstK_10env_logger6filterNtB8_7Builder5builds_00Ba_:
  249|  1.59k|                let alen = a.name.as_ref().map(|a| a.len()).unwrap_or(0);
_RNCNvNtCscSNP6bGsstK_10env_logger6filter10parse_spec0B5_:
  307|  1.27k|        for s in m.split(',').map(|ss| ss.trim()) {
_RNvXs0_NtCscSNP6bGsstK_10env_logger6filterNtB5_7BuilderNtNtCsiloedr2K6v7_4core7default7Default7default:
  263|    318|    fn default() -> Self {
  264|    318|        Builder::new()
  265|    318|    }
_RNvMs_NtCscSNP6bGsstK_10env_logger6filterNtB4_7Builder5build:
  228|    318|    pub fn build(&mut self) -> Filter {
  229|    318|        assert!(!self.built, "attempt to re-use consumed builder");
  230|    318|        self.built = true;
  231|    318|
  232|    318|        let mut directives = Vec::new();
  233|    318|        if self.directives.is_empty() {
  234|      0|            // Adds the default filter if none exist
  235|      0|            directives.push(Directive {
  236|      0|                name: None,
  237|      0|                level: LevelFilter::Error,
  238|      0|            });
  239|    318|        } else {
  240|    318|            // Consume map of directives.
  241|    318|            let directives_map = mem::take(&mut self.directives);
  242|    318|            directives = directives_map
  243|    318|                .into_iter()
  244|    318|                .map(|(name, level)| Directive { name, level })
  245|    318|                .collect();
  246|    318|            // Sort the directives by length of their name, this allows a
  247|    318|            // little more efficient lookup at runtime.
  248|    318|            directives.sort_by(|a, b| {
  249|       |                let alen = a.name.as_ref().map(|a| a.len()).unwrap_or(0);
  250|       |                let blen = b.name.as_ref().map(|b| b.len()).unwrap_or(0);
  251|       |                alen.cmp(&blen)
  252|    318|            });
  253|    318|        }
  254|       |
  255|    318|        Filter {
  256|    318|            directives: mem::take(&mut directives),
  257|    318|            filter: mem::replace(&mut self.filter, None),
  258|    318|        }
  259|    318|    }
_RNCNvNtCscSNP6bGsstK_10env_logger6filter10parse_specs0_0B5_:
  344|  1.27k|                name: name.map(|s| s.to_string()),
_RNvMs_NtCscSNP6bGsstK_10env_logger6filterNtB4_7Builder5parse:
  216|    318|    pub fn parse(&mut self, filters: &str) -> &mut Self {
  217|    318|        let (directives, filter) = parse_spec(filters);
  218|    318|
  219|    318|        self.filter = filter;
  220|       |
  221|  1.59k|        for directive in directives {
  222|  1.27k|            self.directives.insert(directive.name, directive.level);
  223|  1.27k|        }
  224|    318|        self
  225|    318|    }
_RNvNtCscSNP6bGsstK_10env_logger6filter10parse_spec:
  292|    318|fn parse_spec(spec: &str) -> (Vec<Directive>, Option<inner::Filter>) {
  293|    318|    let mut dirs = Vec::new();
  294|    318|
  295|    318|    let mut parts = spec.split('/');
  296|    318|    let mods = parts.next();
  297|    318|    let filter = parts.next();
  298|    318|    if parts.next().is_some() {
  299|      0|        eprintln!(
  300|      0|            "warning: invalid logging spec '{}', \
  301|      0|             ignoring it (too many '/'s)",
  302|      0|            spec
  303|      0|        );
  304|      0|        return (dirs, None);
  305|    318|    }
  306|    318|    if let Some(m) = mods {
  307|  1.27k|        for s in m.split(',').map(|ss| ss.trim()) {
  308|  1.27k|            if s.is_empty() {
  309|      0|                continue;
  310|  1.27k|            }
  311|  1.27k|            let mut parts = s.split('=');
  312|  1.27k|            let (log_level, name) =
  313|  1.27k|                match (parts.next(), parts.next().map(|s| s.trim()), parts.next()) {
  314|    636|                    (Some(part0), None, None) => {
  315|    636|                        // if the single argument is a log-level string or number,
  316|    636|                        // treat that as a global fallback
  317|    636|                        match part0.parse() {
  318|      0|                            Ok(num) => (num, None),
  319|    636|                            Err(_) => (LevelFilter::max(), Some(part0)),
  320|       |                        }
  321|       |                    }
  322|    636|                    (Some(part0), Some(""), None) => (LevelFilter::max(), Some(part0)),
  323|    636|                    (Some(part0), Some(part1), None) => match part1.parse() {
  324|    636|                        Ok(num) => (num, Some(part0)),
  325|       |                        _ => {
  326|      0|                            eprintln!(
  327|      0|                                "warning: invalid logging spec '{}', \
  328|      0|                                 ignoring it",
  329|      0|                                part1
  330|      0|                            );
  331|      0|                            continue;
  332|       |                        }
  333|       |                    },
  334|       |                    _ => {
  335|      0|                        eprintln!(
  336|      0|                            "warning: invalid logging spec '{}', \
  337|      0|                             ignoring it",
  338|      0|                            s
  339|      0|                        );
  340|      0|                        continue;
  341|       |                    }
  342|       |                };
  343|  1.27k|            dirs.push(Directive {
  344|  1.27k|                name: name.map(|s| s.to_string()),
  345|  1.27k|                level: log_level,
  346|  1.27k|            });
  347|       |        }
  348|      0|    }
  349|       |
  350|    318|    let filter = filter.and_then(|filter| match inner::Filter::new(filter) {
  351|       |        Ok(re) => Some(re),
  352|       |        Err(e) => {
  353|       |            eprintln!("warning: invalid regex filter - {}", e);
  354|       |            None
  355|       |        }
  356|    318|    });
  357|    318|
  358|    318|    (dirs, filter)
  359|    318|}

_RNvXs0_NtNtNtCscSNP6bGsstK_10env_logger3fmt9humantime3impNtB5_9TimestampNtNtCsiloedr2K6v7_4core3fmt7Display3fmt:
  108|    636|    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
  109|    636|        let formatter = match self.precision {
  110|    636|            TimestampPrecision::Seconds => format_rfc3339_seconds,
  111|      0|            TimestampPrecision::Millis => format_rfc3339_millis,
  112|      0|            TimestampPrecision::Micros => format_rfc3339_micros,
  113|      0|            TimestampPrecision::Nanos => format_rfc3339_nanos,
  114|       |        };
  115|       |
  116|    636|        formatter(self.time).fmt(f)
  117|    636|    }
_RNvMNtNtNtCscSNP6bGsstK_10env_logger3fmt9humantime3impNtB6_9Formatter17timestamp_seconds:
   43|    636|    pub fn timestamp_seconds(&self) -> Timestamp {
   44|    636|        Timestamp {
   45|    636|            time: SystemTime::now(),
   46|    636|            precision: TimestampPrecision::Seconds,
   47|    636|        }
   48|    636|    }

_RNvMs_NtCscSNP6bGsstK_10env_logger3fmtNtB4_9Formatter3new:
  103|      1|    pub(crate) fn new(writer: &Writer) -> Self {
  104|      1|        Formatter {
  105|      1|            buf: Rc::new(RefCell::new(writer.buffer())),
  106|      1|            write_style: writer.write_style(),
  107|      1|        }
  108|      1|    }
_RNvXNvMs4_NtCscSNP6bGsstK_10env_logger3fmtNtB8_13DefaultFormat10write_argsNtB2_13IndentWrapperNtNtCsdyNNmftaNAQ_3std2io5Write5write:
  353|  3.81k|                    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
  354|  3.81k|                        let mut first = true;
  355|  3.81k|                        for chunk in buf.split(|&x| x == b'\n') {
  356|  3.81k|                            if !first {
  357|      0|                                write!(
  358|      0|                                    self.fmt.buf,
  359|      0|                                    "{}{:width$}",
  360|      0|                                    self.fmt.suffix,
  361|      0|                                    "",
  362|      0|                                    width = self.indent_count
  363|      0|                                )?;
  364|  3.81k|                            }
  365|  3.81k|                            self.fmt.buf.write_all(chunk)?;
  366|  3.81k|                            first = false;
  367|       |                        }
  368|       |
  369|  3.81k|                        Ok(buf.len())
  370|  3.81k|                    }
_RNvMs4_NtCscSNP6bGsstK_10env_logger3fmtNtB5_13DefaultFormat5write:
  226|    636|        self.write_timestamp()?;
  227|    636|        self.write_level(record)?;
  228|    636|        self.write_module_path(record)?;
  229|    636|        self.write_target(record)?;
  230|    636|        self.finish_header()?;
  231|       |
  232|    636|        self.write_args(record)
  233|    636|    }
_RNvMs4_NtCscSNP6bGsstK_10env_logger3fmtNtB5_13DefaultFormat12write_target:
  319|    636|    fn write_target(&mut self, record: &Record) -> io::Result<()> {
  320|    636|        if !self.target {
  321|      0|            return Ok(());
  322|    636|        }
  323|    636|
  324|    636|        match record.target() {
  325|    636|            "" => Ok(()),
  326|    636|            target => self.write_header_value(target),
  327|       |        }
  328|    636|    }
_RNvMs3_NtCscSNP6bGsstK_10env_logger3fmtNtB5_7Builder5build:
  173|    318|    pub fn build(&mut self) -> FormatFn {
  174|    318|        assert!(!self.built, "attempt to re-use consumed builder");
  175|       |
  176|    318|        let built = mem::replace(
  177|    318|            self,
  178|    318|            Builder {
  179|    318|                built: true,
  180|    318|                ..Default::default()
  181|    318|            },
  182|    318|        );
  183|       |
  184|    318|        if let Some(fmt) = built.custom_format {
  185|      0|            fmt
  186|       |        } else {
  187|    318|            Box::new(move |buf, record| {
  188|       |                let fmt = DefaultFormat {
  189|       |                    timestamp: built.format_timestamp,
  190|       |                    module_path: built.format_module_path,
  191|       |                    target: built.format_target,
  192|       |                    level: built.format_level,
  193|       |                    written_header_value: false,
  194|       |                    indent: built.format_indent,
  195|       |                    suffix: built.format_suffix,
  196|       |                    buf,
  197|       |                };
  198|       |
  199|       |                fmt.write(record)
  200|    318|            })
  201|       |        }
  202|    318|    }
_RINvMs4_NtCscSNP6bGsstK_10env_logger3fmtNtB6_13DefaultFormat18write_header_valueNtNtCsiloedr2K6v7_4core3fmt9ArgumentsEB8_:
  251|    636|    fn write_header_value<T>(&mut self, value: T) -> io::Result<()>
  252|    636|    where
  253|    636|        T: Display,
  254|    636|    {
  255|    636|        if !self.written_header_value {
  256|      0|            self.written_header_value = true;
  257|      0|
  258|      0|            let open_brace = self.subtle_style("[");
  259|      0|            write!(self.buf, "{}{}", open_brace, value)
  260|       |        } else {
  261|    636|            write!(self.buf, " {}", value)
  262|       |        }
  263|    636|    }
_RNvMs4_NtCscSNP6bGsstK_10env_logger3fmtNtB5_13DefaultFormat12subtle_style:
  235|  1.27k|    fn subtle_style(&self, text: &'static str) -> SubtleStyle {
  236|  1.27k|        #[cfg(feature = "termcolor")]
  237|  1.27k|        {
  238|  1.27k|            self.buf
  239|  1.27k|                .style()
  240|  1.27k|                .set_color(Color::Black)
  241|  1.27k|                .set_intense(true)
  242|  1.27k|                .clone()
  243|  1.27k|                .into_value(text)
  244|  1.27k|        }
  245|  1.27k|        #[cfg(not(feature = "termcolor"))]
  246|  1.27k|        {
  247|  1.27k|            text
  248|  1.27k|        }
  249|  1.27k|    }
_RNvMs4_NtCscSNP6bGsstK_10env_logger3fmtNtB5_13DefaultFormat15write_timestamp:
  284|    636|    fn write_timestamp(&mut self) -> io::Result<()> {
  285|       |        #[cfg(feature = "humantime")]
  286|       |        {
  287|       |            use self::TimestampPrecision::*;
  288|    636|            let ts = match self.timestamp {
  289|      0|                None => return Ok(()),
  290|    636|                Some(Seconds) => self.buf.timestamp_seconds(),
  291|      0|                Some(Millis) => self.buf.timestamp_millis(),
  292|      0|                Some(Micros) => self.buf.timestamp_micros(),
  293|      0|                Some(Nanos) => self.buf.timestamp_nanos(),
  294|       |            };
  295|       |
  296|    636|            self.write_header_value(ts)
  297|       |        }
  298|       |        #[cfg(not(feature = "humantime"))]
  299|       |        {
  300|       |            // Trick the compiler to think we have used self.timestamp
  301|       |            // Workaround for "field is never used: `timestamp`" compiler nag.
  302|       |            let _ = self.timestamp;
  303|       |            Ok(())
  304|       |        }
  305|    636|    }
_RNvMs_NtCscSNP6bGsstK_10env_logger3fmtNtB4_9Formatter11write_style:
  110|    635|    pub(crate) fn write_style(&self) -> WriteStyle {
  111|    635|        self.write_style
  112|    635|    }
_RNvMs_NtCscSNP6bGsstK_10env_logger3fmtNtB4_9Formatter5clear:
  118|    636|    pub(crate) fn clear(&mut self) {
  119|    636|        self.buf.borrow_mut().clear()
  120|    636|    }
_RINvMs4_NtCscSNP6bGsstK_10env_logger3fmtNtB6_13DefaultFormat18write_header_valueNtNtNtB6_9humantime3imp9TimestampEB8_:
  251|    636|    fn write_header_value<T>(&mut self, value: T) -> io::Result<()>
  252|    636|    where
  253|    636|        T: Display,
  254|    636|    {
  255|    636|        if !self.written_header_value {
  256|    636|            self.written_header_value = true;
  257|    636|
  258|    636|            let open_brace = self.subtle_style("[");
  259|    636|            write!(self.buf, "{}{}", open_brace, value)
  260|       |        } else {
  261|      0|            write!(self.buf, " {}", value)
  262|       |        }
  263|    636|    }
_RINvMs4_NtCscSNP6bGsstK_10env_logger3fmtNtB6_13DefaultFormat18write_header_valueReEB8_:
  251|    636|    fn write_header_value<T>(&mut self, value: T) -> io::Result<()>
  252|    636|    where
  253|    636|        T: Display,
  254|    636|    {
  255|    636|        if !self.written_header_value {
  256|      0|            self.written_header_value = true;
  257|      0|
  258|      0|            let open_brace = self.subtle_style("[");
  259|      0|            write!(self.buf, "{}{}", open_brace, value)
  260|       |        } else {
  261|    636|            write!(self.buf, " {}", value)
  262|       |        }
  263|    636|    }
_RNvMs4_NtCscSNP6bGsstK_10env_logger3fmtNtB5_13DefaultFormat11write_level:
  265|    636|    fn write_level(&mut self, record: &Record) -> io::Result<()> {
  266|    636|        if !self.level {
  267|      0|            return Ok(());
  268|    636|        }
  269|    636|
  270|    636|        let level = {
  271|    636|            #[cfg(feature = "termcolor")]
  272|    636|            {
  273|    636|                self.buf.default_styled_level(record.level())
  274|    636|            }
  275|    636|            #[cfg(not(feature = "termcolor"))]
  276|    636|            {
  277|    636|                record.level()
  278|    636|            }
  279|    636|        };
  280|    636|
  281|    636|        self.write_header_value(format_args!("{:<5}", level))
  282|    636|    }
_RNCNvMs3_NtCscSNP6bGsstK_10env_logger3fmtNtB7_7Builder5build0B9_:
  187|    636|            Box::new(move |buf, record| {
  188|    636|                let fmt = DefaultFormat {
  189|    636|                    timestamp: built.format_timestamp,
  190|    636|                    module_path: built.format_module_path,
  191|    636|                    target: built.format_target,
  192|    636|                    level: built.format_level,
  193|    636|                    written_header_value: false,
  194|    636|                    indent: built.format_indent,
  195|    636|                    suffix: built.format_suffix,
  196|    636|                    buf,
  197|    636|                };
  198|    636|
  199|    636|                fmt.write(record)
  200|    636|            })
_RNCNvXNvMs4_NtCscSNP6bGsstK_10env_logger3fmtNtBa_13DefaultFormat10write_argsNtB4_13IndentWrapperNtNtCsdyNNmftaNAQ_3std2io5Write5write0Bc_:
  355|  54.0k|                        for chunk in buf.split(|&x| x == b'\n') {
_RNvXs2_NtCscSNP6bGsstK_10env_logger3fmtNtB5_7BuilderNtNtCsiloedr2K6v7_4core7default7Default7default:
  153|    636|    fn default() -> Self {
  154|    636|        Builder {
  155|    636|            format_timestamp: Some(Default::default()),
  156|    636|            format_module_path: false,
  157|    636|            format_target: true,
  158|    636|            format_level: true,
  159|    636|            format_indent: Some(4),
  160|    636|            custom_format: None,
  161|    636|            format_suffix: "\n",
  162|    636|            built: false,
  163|    636|        }
  164|    636|    }
_RNvMs4_NtCscSNP6bGsstK_10env_logger3fmtNtB5_13DefaultFormat13finish_header:
  330|    636|    fn finish_header(&mut self) -> io::Result<()> {
  331|    636|        if self.written_header_value {
  332|    636|            let close_brace = self.subtle_style("]");
  333|    636|            write!(self.buf, "{} ", close_brace)
  334|       |        } else {
  335|      0|            Ok(())
  336|       |        }
  337|    636|    }
_RNvXNtCscSNP6bGsstK_10env_logger3fmtNtB2_18TimestampPrecisionNtNtCsiloedr2K6v7_4core7default7Default7default:
   71|    636|    fn default() -> Self {
   72|    636|        TimestampPrecision::Seconds
   73|    636|    }
_RNvXs0_NtCscSNP6bGsstK_10env_logger3fmtNtB5_9FormatterNtNtCsdyNNmftaNAQ_3std2io5Write5write:
  124|  9.54k|    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
  125|  9.54k|        self.buf.borrow_mut().write(buf)
  126|  9.54k|    }
_RNvMs_NtCscSNP6bGsstK_10env_logger3fmtNtB4_9Formatter5print:
  114|    636|    pub(crate) fn print(&self, writer: &Writer) -> io::Result<()> {
  115|    636|        writer.print(&self.buf.borrow())
  116|    636|    }
_RNvMs4_NtCscSNP6bGsstK_10env_logger3fmtNtB5_13DefaultFormat10write_args:
  339|    636|    fn write_args(&mut self, record: &Record) -> io::Result<()> {
  340|    636|        match self.indent {
  341|       |            // Fast path for no indentation
  342|      0|            None => write!(self.buf, "{}{}", record.args(), self.suffix),
  343|       |
  344|    636|            Some(indent_count) => {
  345|    636|                // Create a wrapper around the buffer only if we have to actually indent the message
  346|    636|
  347|    636|                struct IndentWrapper<'a, 'b: 'a> {
  348|    636|                    fmt: &'a mut DefaultFormat<'b>,
  349|    636|                    indent_count: usize,
  350|    636|                }
  351|    636|
  352|    636|                impl<'a, 'b> Write for IndentWrapper<'a, 'b> {
  353|    636|                    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
  354|    636|                        let mut first = true;
  355|    636|                        for chunk in buf.split(|&x| x == b'\n') {
  356|    636|                            if !first {
  357|    636|                                write!(
  358|    636|                                    self.fmt.buf,
  359|    636|                                    "{}{:width$}",
  360|    636|                                    self.fmt.suffix,
  361|    636|                                    "",
  362|    636|                                    width = self.indent_count
  363|    636|                                )?;
  364|    636|                            }
  365|    636|                            self.fmt.buf.write_all(chunk)?;
  366|    636|                            first = false;
  367|    636|                        }
  368|    636|
  369|    636|                        Ok(buf.len())
  370|    636|                    }
  371|    636|
  372|    636|                    fn flush(&mut self) -> io::Result<()> {
  373|    636|                        self.fmt.buf.flush()
  374|    636|                    }
  375|    636|                }
  376|    636|
  377|    636|                // The explicit scope here is just to make older versions of Rust happy
  378|    636|                {
  379|    636|                    let mut wrapper = IndentWrapper {
  380|    636|                        fmt: self,
  381|    636|                        indent_count,
  382|    636|                    };
  383|    636|                    write!(wrapper, "{}", record.args())?;
  384|       |                }
  385|       |
  386|    636|                write!(self.buf, "{}", self.suffix)?;
  387|       |
  388|    636|                Ok(())
  389|       |            }
  390|       |        }
  391|    636|    }
_RNvMs4_NtCscSNP6bGsstK_10env_logger3fmtNtB5_13DefaultFormat17write_module_path:
  307|    636|    fn write_module_path(&mut self, record: &Record) -> io::Result<()> {
  308|    636|        if !self.module_path {
  309|    636|            return Ok(());
  310|      0|        }
  311|       |
  312|      0|        if let Some(module_path) = record.module_path() {
  313|      0|            self.write_header_value(module_path)
  314|       |        } else {
  315|      0|            Ok(())
  316|       |        }
  317|    636|    }

_RNvNtNtNtNtCscSNP6bGsstK_10env_logger3fmt6writer4atty3imp9is_stderr:
   16|    318|    pub(in crate::fmt) fn is_stderr() -> bool {
   17|    318|        atty::is(atty::Stream::Stderr)
   18|    318|    }

_RNvXsf_NtNtCscSNP6bGsstK_10env_logger3fmt6writerNtB5_10WriteStyleNtNtCsiloedr2K6v7_4core3cmp9PartialEq2eq:
   88|    635|#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
_RNvMs4_NtNtCscSNP6bGsstK_10env_logger3fmt6writerNtB5_6Writer6buffer:
  115|      1|    pub(super) fn buffer(&self) -> Buffer {
  116|      1|        self.inner.buffer()
  117|      1|    }
_RNvXs1_NtNtCscSNP6bGsstK_10env_logger3fmt6writerNtB5_14WritableTargetNtNtCsiloedr2K6v7_4core7default7Default7default:
   69|    636|    fn default() -> Self {
   70|    636|        Self::from(Target::default())
   71|    636|    }
_RNvMs5_NtNtCscSNP6bGsstK_10env_logger3fmt6writerNtB5_7Builder5build:
  174|    318|    pub(crate) fn build(&mut self) -> Writer {
  175|    318|        assert!(!self.built, "attempt to re-use consumed builder");
  176|    318|        self.built = true;
  177|       |
  178|    318|        let color_choice = match self.write_style {
  179|       |            WriteStyle::Auto => {
  180|    318|                if match &self.target {
  181|    318|                    WritableTarget::Stderr => is_stderr(),
  182|      0|                    WritableTarget::Stdout => is_stdout(),
  183|      0|                    WritableTarget::Pipe(_) => false,
  184|       |                } {
  185|      0|                    WriteStyle::Auto
  186|       |                } else {
  187|    318|                    WriteStyle::Never
  188|       |                }
  189|       |            }
  190|      0|            color_choice => color_choice,
  191|       |        };
  192|       |
  193|    318|        let writer = match mem::take(&mut self.target) {
  194|    318|            WritableTarget::Stderr => BufferWriter::stderr(self.is_test, color_choice),
  195|      0|            WritableTarget::Stdout => BufferWriter::stdout(self.is_test, color_choice),
  196|      0|            WritableTarget::Pipe(pipe) => BufferWriter::pipe(color_choice, pipe),
  197|       |        };
  198|       |
  199|    318|        Writer {
  200|    318|            inner: writer,
  201|    318|            write_style: self.write_style,
  202|    318|        }
  203|    318|    }
_RNvMs4_NtNtCscSNP6bGsstK_10env_logger3fmt6writerNtB5_6Writer11write_style:
  111|    636|    pub fn write_style(&self) -> WriteStyle {
  112|    636|        self.write_style
  113|    636|    }
_RNvXs3_NtNtCscSNP6bGsstK_10env_logger3fmt6writerNtB5_10WriteStyleNtNtCsiloedr2K6v7_4core7default7Default7default:
   99|    318|    fn default() -> Self {
  100|    318|        WriteStyle::Auto
  101|    318|    }
_RNvMs4_NtNtCscSNP6bGsstK_10env_logger3fmt6writerNtB5_6Writer5print:
  119|    636|    pub(super) fn print(&self, buf: &Buffer) -> io::Result<()> {
  120|    636|        self.inner.print(buf)
  121|    636|    }
_RNvXNtNtCscSNP6bGsstK_10env_logger3fmt6writerNtB2_6TargetNtNtCsiloedr2K6v7_4core7default7Default7default:
   27|    636|    fn default() -> Self {
   28|    636|        Target::Stderr
   29|    636|    }
_RNvMs5_NtNtCscSNP6bGsstK_10env_logger3fmt6writerNtB5_7Builder3new:
  137|    318|    pub(crate) fn new() -> Self {
  138|    318|        Builder {
  139|    318|            target: Default::default(),
  140|    318|            write_style: Default::default(),
  141|    318|            is_test: false,
  142|    318|            built: false,
  143|    318|        }
  144|    318|    }
_RNvXs6_NtNtCscSNP6bGsstK_10env_logger3fmt6writerNtB5_7BuilderNtNtCsiloedr2K6v7_4core7default7Default7default:
  207|    318|    fn default() -> Self {
  208|    318|        Builder::new()
  209|    318|    }
_RNvXs0_NtNtCscSNP6bGsstK_10env_logger3fmt6writerNtB5_14WritableTargetINtNtCsiloedr2K6v7_4core7convert4FromNtB5_6TargetE4from:
   59|    636|    fn from(target: Target) -> Self {
   60|    636|        match target {
   61|      0|            Target::Stdout => Self::Stdout,
   62|    636|            Target::Stderr => Self::Stderr,
   63|      0|            Target::Pipe(pipe) => Self::Pipe(Box::new(Mutex::new(pipe))),
   64|       |        }
   65|    636|    }

_RNvMs1_NtNtNtNtCscSNP6bGsstK_10env_logger3fmt6writer9termcolor3impNtB9_10WriteStyle17into_color_choice:
  180|    318|    fn into_color_choice(self) -> ColorChoice {
  181|    318|        match self {
  182|      0|            WriteStyle::Always => ColorChoice::Always,
  183|      0|            WriteStyle::Auto => ColorChoice::Auto,
  184|    318|            WriteStyle::Never => ColorChoice::Never,
  185|       |        }
  186|    318|    }
_RNvXs8_NtNtNtNtCscSNP6bGsstK_10env_logger3fmt6writer9termcolor3impINtB5_11StyledValueNtCsbIC4eNc6bgl_3log5LevelENtNtCsiloedr2K6v7_4core3fmt7Display3fmtBd_:
  458|    636|                fn fmt(&self, f: &mut fmt::Formatter)->fmt::Result {
  459|    636|                    self.write_fmt(|| T::fmt(&self.value, f))
  460|    636|                }
_RNvMs5_NtNtNtNtCscSNP6bGsstK_10env_logger3fmt6writer9termcolor3impNtB5_5Color14into_termcolor:
  518|  1.90k|    fn into_termcolor(self) -> termcolor::Color {
  519|  1.90k|        match self {
  520|  1.27k|            Color::Black => termcolor::Color::Black,
  521|    318|            Color::Blue => termcolor::Color::Blue,
  522|      0|            Color::Green => termcolor::Color::Green,
  523|      0|            Color::Red => termcolor::Color::Red,
  524|    318|            Color::Cyan => termcolor::Color::Cyan,
  525|      0|            Color::Magenta => termcolor::Color::Magenta,
  526|      0|            Color::Yellow => termcolor::Color::Yellow,
  527|      0|            Color::White => termcolor::Color::White,
  528|      0|            Color::Ansi256(value) => termcolor::Color::Ansi256(value),
  529|      0|            Color::Rgb(r, g, b) => termcolor::Color::Rgb(r, g, b),
  530|       |        }
  531|  1.90k|    }
_RNvXs6_NtNtNtNtCscSNP6bGsstK_10env_logger3fmt6writer9termcolor3impNtB5_5StyleNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
  241|  1.27k|#[derive(Clone)]
_RINvMs2_NtNtNtNtCscSNP6bGsstK_10env_logger3fmt6writer9termcolor3impNtB6_5Style10into_valueReEBe_:
  421|  1.27k|    pub(crate) fn into_value<T>(self, value: T) -> StyledValue<'static, T> {
  422|  1.27k|        StyledValue {
  423|  1.27k|            style: Cow::Owned(self),
  424|  1.27k|            value,
  425|  1.27k|        }
  426|  1.27k|    }
_RINvMs3_NtNtNtNtCscSNP6bGsstK_10env_logger3fmt6writer9termcolor3impINtB6_11StyledValueNtCsbIC4eNc6bgl_3log5LevelE9write_fmtNCNvXs8_B6_B13_NtNtCsiloedr2K6v7_4core3fmt7Display3fmt0EBe_:
  434|    636|        self.style
  435|    636|            .buf
  436|    636|            .borrow_mut()
  437|    636|            .set_color(&self.style.spec)
  438|    636|            .map_err(|_| fmt::Error)?;
  439|       |
  440|       |        // Always try to reset the terminal style, even if writing failed
  441|    636|        let write = f();
  442|    636|        let reset = self.style.buf.borrow_mut().reset().map_err(|_| fmt::Error);
  443|    636|
  444|    636|        write.and(reset)
  445|    636|    }
_RNvMs2_NtNtNtNtCscSNP6bGsstK_10env_logger3fmt6writer9termcolor3impNtB5_5Style11set_intense:
  332|  1.27k|    pub fn set_intense(&mut self, yes: bool) -> &mut Style {
  333|  1.27k|        self.spec.set_intense(yes);
  334|  1.27k|        self
  335|  1.27k|    }
_RNvXs8_NtNtNtNtCscSNP6bGsstK_10env_logger3fmt6writer9termcolor3impINtB5_11StyledValueReENtNtCsiloedr2K6v7_4core3fmt7Display3fmtBd_:
  458|  1.27k|                fn fmt(&self, f: &mut fmt::Formatter)->fmt::Result {
  459|  1.27k|                    self.write_fmt(|| T::fmt(&self.value, f))
  460|  1.27k|                }
_RNvMs_NtNtNtNtCscSNP6bGsstK_10env_logger3fmt6writer9termcolor3impNtB4_12BufferWriter5print:
  124|    636|        if let Some(target) = &self.uncolored_target {
  125|       |            // This impl uses the `eprint` and `print` macros
  126|       |            // instead of `termcolor`'s buffer.
  127|       |            // This is so their output can be captured by `cargo test`
  128|      0|            let log = String::from_utf8_lossy(buf.bytes());
  129|      0|
  130|      0|            match target {
  131|      0|                WritableTarget::Stderr => eprint!("{}", log),
  132|      0|                WritableTarget::Stdout => print!("{}", log),
  133|      0|                WritableTarget::Pipe(pipe) => write!(pipe.lock().unwrap(), "{}", log)?,
  134|       |            }
  135|       |
  136|      0|            Ok(())
  137|       |        } else {
  138|    636|            self.inner.print(&buf.inner)
  139|       |        }
  140|    636|    }
_RNvMs_NtNtNtNtCscSNP6bGsstK_10env_logger3fmt6writer9termcolor3impNtB4_12BufferWriter6stderr:
   83|    318|    pub(in crate::fmt::writer) fn stderr(is_test: bool, write_style: WriteStyle) -> Self {
   84|    318|        BufferWriter {
   85|    318|            inner: termcolor::BufferWriter::stderr(write_style.into_color_choice()),
   86|    318|            uncolored_target: if is_test {
   87|      0|                Some(WritableTarget::Stderr)
   88|       |            } else {
   89|    318|                None
   90|       |            },
   91|       |        }
   92|    318|    }
_RNvMNtNtNtNtCscSNP6bGsstK_10env_logger3fmt6writer9termcolor3impNtB8_9Formatter19default_level_style:
   52|    636|    pub fn default_level_style(&self, level: Level) -> Style {
   53|    636|        let mut level_style = self.style();
   54|    636|        match level {
   55|    318|            Level::Trace => level_style.set_color(Color::Cyan),
   56|    318|            Level::Debug => level_style.set_color(Color::Blue),
   57|      0|            Level::Info => level_style.set_color(Color::Green),
   58|      0|            Level::Warn => level_style.set_color(Color::Yellow),
   59|      0|            Level::Error => level_style.set_color(Color::Red).set_bold(true),
   60|       |        };
   61|    636|        level_style
   62|    636|    }
_RNvMs0_NtNtNtNtCscSNP6bGsstK_10env_logger3fmt6writer9termcolor3impNtB5_6Buffer5clear:
  144|    636|    pub(in crate::fmt) fn clear(&mut self) {
  145|    636|        self.inner.clear()
  146|    636|    }
_RNvMs_NtNtNtNtCscSNP6bGsstK_10env_logger3fmt6writer9termcolor3impNtB4_12BufferWriter6buffer:
  116|      1|    pub(in crate::fmt::writer) fn buffer(&self) -> Buffer {
  117|      1|        Buffer {
  118|      1|            inner: self.inner.buffer(),
  119|      1|            has_uncolored_target: self.uncolored_target.is_some(),
  120|      1|        }
  121|      1|    }
_RNvMs0_NtNtNtNtCscSNP6bGsstK_10env_logger3fmt6writer9termcolor3impNtB5_6Buffer5write:
  148|  9.54k|    pub(in crate::fmt) fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
  149|  9.54k|        self.inner.write(buf)
  150|  9.54k|    }
_RNvMNtNtNtNtCscSNP6bGsstK_10env_logger3fmt6writer9termcolor3impNtB8_9Formatter5style:
   42|  1.90k|    pub fn style(&self) -> Style {
   43|  1.90k|        Style {
   44|  1.90k|            buf: self.buf.clone(),
   45|  1.90k|            spec: ColorSpec::new(),
   46|  1.90k|        }
   47|  1.90k|    }
_RNCNvXs8_NtNtNtNtCscSNP6bGsstK_10env_logger3fmt6writer9termcolor3impINtB7_11StyledValueReENtNtCsiloedr2K6v7_4core3fmt7Display3fmt0Bf_:
  466|  1.27k|impl_styled_value_fmt!(
  467|  1.27k|    fmt::Debug,
  468|  1.27k|    fmt::Display,
  469|  1.27k|    fmt::Pointer,
  470|  1.27k|    fmt::Octal,
  471|  1.27k|    fmt::Binary,
  472|  1.27k|    fmt::UpperHex,
  473|  1.27k|    fmt::LowerHex,
  474|  1.27k|    fmt::UpperExp,
  475|  1.27k|    fmt::LowerExp
  476|  1.27k|);
_RNvMs0_NtNtNtNtCscSNP6bGsstK_10env_logger3fmt6writer9termcolor3impNtB5_6Buffer9set_color:
  160|  1.90k|    fn set_color(&mut self, spec: &ColorSpec) -> io::Result<()> {
  161|  1.90k|        // Ignore styles for test captured logs because they can't be printed
  162|  1.90k|        if !self.has_uncolored_target {
  163|  1.90k|            self.inner.set_color(spec)
  164|       |        } else {
  165|      0|            Ok(())
  166|       |        }
  167|  1.90k|    }
_RINvMs2_NtNtNtNtCscSNP6bGsstK_10env_logger3fmt6writer9termcolor3impNtB6_5Style10into_valueNtCsbIC4eNc6bgl_3log5LevelEBe_:
  421|    636|    pub(crate) fn into_value<T>(self, value: T) -> StyledValue<'static, T> {
  422|    636|        StyledValue {
  423|    636|            style: Cow::Owned(self),
  424|    636|            value,
  425|    636|        }
  426|    636|    }
_RINvMs3_NtNtNtNtCscSNP6bGsstK_10env_logger3fmt6writer9termcolor3impINtB6_11StyledValueReE9write_fmtNCNvXs8_B6_B13_NtNtCsiloedr2K6v7_4core3fmt7Display3fmt0EBe_:
  434|  1.27k|        self.style
  435|  1.27k|            .buf
  436|  1.27k|            .borrow_mut()
  437|  1.27k|            .set_color(&self.style.spec)
  438|  1.27k|            .map_err(|_| fmt::Error)?;
  439|       |
  440|       |        // Always try to reset the terminal style, even if writing failed
  441|  1.27k|        let write = f();
  442|  1.27k|        let reset = self.style.buf.borrow_mut().reset().map_err(|_| fmt::Error);
  443|  1.27k|
  444|  1.27k|        write.and(reset)
  445|  1.27k|    }
_RNvMNtNtNtNtCscSNP6bGsstK_10env_logger3fmt6writer9termcolor3impNtB8_9Formatter20default_styled_level:
   67|    636|    pub fn default_styled_level(&self, level: Level) -> StyledValue<'static, Level> {
   68|    636|        self.default_level_style(level).into_value(level)
   69|    636|    }
_RNCNvXs8_NtNtNtNtCscSNP6bGsstK_10env_logger3fmt6writer9termcolor3impINtB7_11StyledValueNtCsbIC4eNc6bgl_3log5LevelENtNtCsiloedr2K6v7_4core3fmt7Display3fmt0Bf_:
  466|    636|impl_styled_value_fmt!(
  467|    636|    fmt::Debug,
  468|    636|    fmt::Display,
  469|    636|    fmt::Pointer,
  470|    636|    fmt::Octal,
  471|    636|    fmt::Binary,
  472|    636|    fmt::UpperHex,
  473|    636|    fmt::LowerHex,
  474|    636|    fmt::UpperExp,
  475|    636|    fmt::LowerExp
  476|    636|);
_RNvMs2_NtNtNtNtCscSNP6bGsstK_10env_logger3fmt6writer9termcolor3impNtB5_5Style9set_color:
  278|  1.90k|    pub fn set_color(&mut self, color: Color) -> &mut Style {
  279|  1.90k|        self.spec.set_fg(Some(color.into_termcolor()));
  280|  1.90k|        self
  281|  1.90k|    }
_RNvMs0_NtNtNtNtCscSNP6bGsstK_10env_logger3fmt6writer9termcolor3impNtB5_6Buffer5reset:
  169|  1.90k|    fn reset(&mut self) -> io::Result<()> {
  170|  1.90k|        // Ignore styles for test captured logs because they can't be printed
  171|  1.90k|        if !self.has_uncolored_target {
  172|  1.90k|            self.inner.reset()
  173|       |        } else {
  174|      0|            Ok(())
  175|       |        }
  176|  1.90k|    }

_RINvMs2_CscSNP6bGsstK_10env_loggerNtB6_3Var3newReEB6_:
 1059|    636|    fn new<E>(name: E) -> Self
 1060|    636|    where
 1061|    636|        E: Into<Cow<'a, str>>,
 1062|    636|    {
 1063|    636|        Var {
 1064|    636|            name: name.into(),
 1065|    636|            default: None,
 1066|    636|        }
 1067|    636|    }
_RNvMs2_CscSNP6bGsstK_10env_loggerNtB5_3Var3get:
 1080|    636|    fn get(&self) -> Option<String> {
 1081|    636|        env::var(&*self.name)
 1082|    636|            .ok()
 1083|    636|            .or_else(|| self.default.to_owned().map(|v| v.into_owned()))
 1084|    636|    }
_RNvMs1_CscSNP6bGsstK_10env_loggerNtB5_3Env15get_write_style:
 1053|    318|    fn get_write_style(&self) -> Option<String> {
 1054|    318|        self.write_style.get()
 1055|    318|    }
_RNCNvXs0_CscSNP6bGsstK_10env_loggerNtB7_6LoggerNtCsbIC4eNc6bgl_3log3Log3logs_0B7_:
  931|    636|                .try_with(|tl_buf| {
  932|    636|                    match tl_buf.try_borrow_mut() {
  933|       |                        // There are no active borrows of the buffer
  934|    636|                        Ok(mut tl_buf) => match *tl_buf {
  935|       |                            // We have a previously set formatter
  936|    635|                            Some(ref mut formatter) => {
  937|    635|                                // Check the buffer style. If it's different from the logger's
  938|    635|                                // style then drop the buffer and recreate it.
  939|    635|                                if formatter.write_style() != self.writer.write_style() {
  940|      0|                                    *formatter = Formatter::new(&self.writer);
  941|    635|                                }
  942|       |
  943|    635|                                print(formatter, record);
  944|       |                            }
  945|       |                            // We don't have a previously set formatter
  946|      1|                            None => {
  947|      1|                                let mut formatter = Formatter::new(&self.writer);
  948|      1|                                print(&mut formatter, record);
  949|      1|
  950|      1|                                *tl_buf = Some(formatter);
  951|      1|                            }
  952|       |                        },
  953|       |                        // There's already an active borrow of the buffer (due to re-entrancy)
  954|      0|                        Err(_) => {
  955|      0|                            print(&mut Formatter::new(&self.writer), record);
  956|      0|                        }
  957|       |                    }
  958|    636|                })
_RNvMCscSNP6bGsstK_10env_loggerNtB2_7Builder3new:
  411|    318|    pub fn new() -> Builder {
  412|    318|        Default::default()
  413|    318|    }
_RINvCscSNP6bGsstK_10env_logger17try_init_from_envNtB2_3EnvEB2_:
 1185|    318|pub fn try_init_from_env<'a, E>(env: E) -> Result<(), SetLoggerError>
 1186|    318|where
 1187|    318|    E: Into<Env<'a>>,
 1188|    318|{
 1189|    318|    let mut builder = Builder::from_env(env);
 1190|    318|
 1191|    318|    builder.try_init()
 1192|    318|}
_RNCNCNvXs0_CscSNP6bGsstK_10env_loggerNtB9_6LoggerNtCsbIC4eNc6bgl_3log3Log3log00B9_:
  924|    636|                    (self.format)(formatter, record).and_then(|_| formatter.print(&self.writer));
_RNCNvXs0_CscSNP6bGsstK_10env_loggerNtB7_6LoggerNtCsbIC4eNc6bgl_3log3Log3log0B7_:
  922|    636|            let print = |formatter: &mut Formatter, record: &Record| {
  923|    636|                let _ =
  924|    636|                    (self.format)(formatter, record).and_then(|_| formatter.print(&self.writer));
  925|    636|
  926|    636|                // Always clear the buffer afterwards
  927|    636|                formatter.clear();
  928|    636|            };
_RNvMs_CscSNP6bGsstK_10env_loggerNtB4_6Logger6filter:
  892|    318|    pub fn filter(&self) -> LevelFilter {
  893|    318|        self.filter.filter()
  894|    318|    }
_RINvMCscSNP6bGsstK_10env_loggerNtB3_7Builder9parse_envNtB3_3EnvEB3_:
  488|    318|    pub fn parse_env<'a, E>(&mut self, env: E) -> &mut Self
  489|    318|    where
  490|    318|        E: Into<Env<'a>>,
  491|    318|    {
  492|    318|        let env = env.into();
  493|       |
  494|    318|        if let Some(s) = env.get_filter() {
  495|    318|            self.parse_filters(&s);
  496|    318|        }
  497|       |
  498|    318|        if let Some(s) = env.get_write_style() {
  499|      0|            self.parse_write_style(&s);
  500|    318|        }
  501|       |
  502|    318|        self
  503|    318|    }
_RNvXs0_CscSNP6bGsstK_10env_loggerNtB5_6LoggerNtCsbIC4eNc6bgl_3log3Log3log:
  907|    954|    fn log(&self, record: &Record) {
  908|    954|        if self.matches(record) {
  909|       |            // Log records are written to a thread-local buffer before being printed
  910|       |            // to the terminal. We clear these buffers afterwards, but they aren't shrinked
  911|       |            // so will always at least have capacity for the largest log record formatted
  912|       |            // on that thread.
  913|       |            //
  914|       |            // If multiple `Logger`s are used by the same threads then the thread-local
  915|       |            // formatter might have different color support. If this is the case the
  916|       |            // formatter and its buffer are discarded and recreated.
  917|       |
  918|       |            thread_local! {
  919|       |                static FORMATTER: RefCell<Option<Formatter>> = RefCell::new(None);
  920|       |            }
  921|       |
  922|    636|            let print = |formatter: &mut Formatter, record: &Record| {
  923|       |                let _ =
  924|       |                    (self.format)(formatter, record).and_then(|_| formatter.print(&self.writer));
  925|       |
  926|       |                // Always clear the buffer afterwards
  927|       |                formatter.clear();
  928|       |            };
  929|       |
  930|    636|            let printed = FORMATTER
  931|    636|                .try_with(|tl_buf| {
  932|       |                    match tl_buf.try_borrow_mut() {
  933|       |                        // There are no active borrows of the buffer
  934|       |                        Ok(mut tl_buf) => match *tl_buf {
  935|       |                            // We have a previously set formatter
  936|       |                            Some(ref mut formatter) => {
  937|       |                                // Check the buffer style. If it's different from the logger's
  938|       |                                // style then drop the buffer and recreate it.
  939|       |                                if formatter.write_style() != self.writer.write_style() {
  940|       |                                    *formatter = Formatter::new(&self.writer);
  941|       |                                }
  942|       |
  943|       |                                print(formatter, record);
  944|       |                            }
  945|       |                            // We don't have a previously set formatter
  946|       |                            None => {
  947|       |                                let mut formatter = Formatter::new(&self.writer);
  948|       |                                print(&mut formatter, record);
  949|       |
  950|       |                                *tl_buf = Some(formatter);
  951|       |                            }
  952|       |                        },
  953|       |                        // There's already an active borrow of the buffer (due to re-entrancy)
  954|       |                        Err(_) => {
  955|       |                            print(&mut Formatter::new(&self.writer), record);
  956|       |                        }
  957|       |                    }
  958|    636|                })
  959|    636|                .is_ok();
  960|    636|
  961|    636|            if !printed {
  962|      0|                // The thread-local storage was not available (because its
  963|      0|                // destructor has already run). Create a new single-use
  964|      0|                // Formatter on the stack for this call.
  965|      0|                print(&mut Formatter::new(&self.writer), record);
  966|    636|            }
  967|    318|        }
  968|    954|    }
_RNCNvNvNvXs0_CscSNP6bGsstK_10env_loggerNtBb_6LoggerNtCsbIC4eNc6bgl_3log3Log3log9FORMATTER7___getit0Bb_:
  918|      1|            thread_local! {
  919|      1|                static FORMATTER: RefCell<Option<Formatter>> = RefCell::new(None);
  920|      1|            }
_RNvMCscSNP6bGsstK_10env_loggerNtB2_7Builder13parse_filters:
  716|    318|    pub fn parse_filters(&mut self, filters: &str) -> &mut Self {
  717|    318|        self.filter.parse(filters);
  718|    318|        self
  719|    318|    }
_RNvMCscSNP6bGsstK_10env_loggerNtB2_7Builder5build:
  823|    318|    pub fn build(&mut self) -> Logger {
  824|    318|        assert!(!self.built, "attempt to re-use consumed builder");
  825|    318|        self.built = true;
  826|    318|
  827|    318|        Logger {
  828|    318|            writer: self.writer.build(),
  829|    318|            filter: self.filter.build(),
  830|    318|            format: self.format.build(),
  831|    318|        }
  832|    318|    }
_RNvXs4_CscSNP6bGsstK_10env_loggerNtB5_3EnvNtNtCsiloedr2K6v7_4core7default7Default7default:
 1097|    318|    fn default() -> Self {
 1098|    318|        Env {
 1099|    318|            filter: Var::new(DEFAULT_FILTER_ENV),
 1100|    318|            write_style: Var::new(DEFAULT_WRITE_STYLE_ENV),
 1101|    318|        }
 1102|    318|    }
_RNvMs1_CscSNP6bGsstK_10env_loggerNtB5_3Env10get_filter:
 1014|    318|    fn get_filter(&self) -> Option<String> {
 1015|    318|        self.filter.get()
 1016|    318|    }
_RNvMs_CscSNP6bGsstK_10env_loggerNtB4_6Logger7matches:
  897|    954|    pub fn matches(&self, record: &Record) -> bool {
  898|    954|        self.filter.matches(record)
  899|    954|    }
_RNvMCscSNP6bGsstK_10env_loggerNtB2_7Builder8try_init:
  792|    318|    pub fn try_init(&mut self) -> Result<(), SetLoggerError> {
  793|    318|        let logger = self.build();
  794|    318|
  795|    318|        let max_level = logger.filter();
  796|    318|        let r = log::set_boxed_logger(Box::new(logger));
  797|    318|
  798|    318|        if r.is_ok() {
  799|      1|            log::set_max_level(max_level);
  800|    317|        }
  801|       |
  802|    318|        r
  803|    318|    }
_RNCNvMs2_CscSNP6bGsstK_10env_loggerNtB7_3Var3get0B7_:
 1083|    318|            .or_else(|| self.default.to_owned().map(|v| v.into_owned()))
_RNvCscSNP6bGsstK_10env_logger8try_init:
 1140|    318|pub fn try_init() -> Result<(), SetLoggerError> {
 1141|    318|    try_init_from_env(Env::default())
 1142|    318|}
_RINvMCscSNP6bGsstK_10env_loggerNtB3_7Builder8from_envNtB3_3EnvEB3_:
  443|    318|    pub fn from_env<'a, E>(env: E) -> Self
  444|    318|    where
  445|    318|        E: Into<Env<'a>>,
  446|    318|    {
  447|    318|        let mut builder = Builder::new();
  448|    318|        builder.parse_env(env);
  449|    318|        builder
  450|    318|    }
_RNvXs7_CscSNP6bGsstK_10env_loggerNtB5_7BuilderNtNtCsiloedr2K6v7_4core7default7Default7default:
  376|    318|#[derive(Default)]

_RNCINvXNvNtCsMEM5GKmsj7_17forest_hash_utils3keys_1__NtB7_8BytesKeyNtNtCssVaLrL3Upj_5serde2de11Deserialize11deserializeNtNtCs3TS9n28v4Rl_12libipld_core4ipld4IpldE0CsboUdcTbF1FS_15direct_syscalls:
   10|    954|#[derive(Eq, PartialOrd, Clone, Debug, Serialize, Deserialize)]
_RINvXs_NtCsMEM5GKmsj7_17forest_hash_utils3keyNtB5_8BytesKeyNtB7_4Hash4hashNtNtCslH3pn9Bu6yX_13fvm_ipld_hamt14hash_algorithm17Sha2HasherWrapperECsboUdcTbF1FS_15direct_syscalls:
   21|    954|    fn hash<H: Hasher>(&self, state: &mut H) {
   22|    954|        state.write(&self.0);
   23|    954|    }
_RINvXNvNtCsMEM5GKmsj7_17forest_hash_utils3keys_1__NtB5_8BytesKeyNtNtCssVaLrL3Upj_5serde2de11Deserialize11deserializeNtNtCs3TS9n28v4Rl_12libipld_core4ipld4IpldECsboUdcTbF1FS_15direct_syscalls:
   10|    954|#[derive(Eq, PartialOrd, Clone, Debug, Serialize, Deserialize)]
_RINvXNvNtCsMEM5GKmsj7_17forest_hash_utils3key1__NtB5_8BytesKeyNtNtCssVaLrL3Upj_5serde3ser9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECsboUdcTbF1FS_15direct_syscalls:
   10|    954|#[derive(Eq, PartialOrd, Clone, Debug, Serialize, Deserialize)]
_RNvXs3_NtCsMEM5GKmsj7_17forest_hash_utils3keyNtB5_8BytesKeyINtNtCsiloedr2K6v7_4core7convert4FromINtNtCs9pDt8l5wGDA_5alloc3vec3VechEE4from:
   46|    954|    fn from(bz: Vec<u8>) -> Self {
   47|    954|        BytesKey(bz)
   48|    954|    }

_RNCNvNtCsiDsdoxUJBlR_16futures_executor5enter5enter0B5_:
   56|    318|    ENTERED.with(|c| {
   57|    318|        if c.get() {
   58|      0|            Err(EnterError { _priv: () })
   59|       |        } else {
   60|    318|            c.set(true);
   61|    318|
   62|    318|            Ok(Enter { _priv: () })
   63|       |        }
   64|    318|    })
_RNCNvNvNtCsiDsdoxUJBlR_16futures_executor5enter7ENTERED7___getit0B7_:
    4|      1|thread_local!(static ENTERED: Cell<bool> = Cell::new(false));
_RNvXs2_NtCsiDsdoxUJBlR_16futures_executor5enterNtB5_5EnterNtNtNtCsiloedr2K6v7_4core3ops4drop4Drop4drop:
   74|    318|    fn drop(&mut self) {
   75|    318|        ENTERED.with(|c| {
   76|       |            assert!(c.get());
   77|       |            c.set(false);
   78|    318|        });
   79|    318|    }
_RNvNtCsiDsdoxUJBlR_16futures_executor5enter5enter:
   55|    318|pub fn enter() -> Result<Enter, EnterError> {
   56|    318|    ENTERED.with(|c| {
   57|       |        if c.get() {
   58|       |            Err(EnterError { _priv: () })
   59|       |        } else {
   60|       |            c.set(true);
   61|       |
   62|       |            Ok(Enter { _priv: () })
   63|       |        }
   64|    318|    })
   65|    318|}
_RNCNvXs2_NtCsiDsdoxUJBlR_16futures_executor5enterNtB7_5EnterNtNtNtCsiloedr2K6v7_4core3ops4drop4Drop4drop0B9_:
   75|    318|        ENTERED.with(|c| {
   76|    318|            assert!(c.get());
   77|    318|            c.set(false);
   78|    318|        });

_RNCINvNtCsiDsdoxUJBlR_16futures_executor10local_pool12run_executorINtNtCsiloedr2K6v7_4core6result6ResultINtNtCs9pDt8l5wGDA_5alloc3vec3VecINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EENtNtCs7wiLZqa2F25_12fvm_ipld_car5error5ErrorENCINvB4_8block_onNCINvNtCsh74LAqVwWKW_21fvm_integration_tests6bundle13import_bundleNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreE0E0E0Cs7AwuCMXPzRZ_8fvm_fuzz:
   86|    318|    CURRENT_THREAD_NOTIFY.with(|thread_notify| {
   87|    318|        let waker = waker_ref(thread_notify);
   88|    318|        let mut cx = Context::from_waker(&waker);
   89|       |        loop {
   90|    318|            if let Poll::Ready(t) = f(&mut cx) {
   91|    318|                return t;
   92|      0|            }
   93|       |
   94|       |            // Wait for a wakeup.
   95|      0|            while !thread_notify.unparked.swap(false, Ordering::Acquire) {
   96|      0|                // No wakeup occurred. It may occur now, right before parking,
   97|      0|                // but in that case the token made available by `unpark()`
   98|      0|                // is guaranteed to still be available and `park()` is a no-op.
   99|      0|                thread::park();
  100|      0|            }
  101|       |        }
  102|    318|    })
_RINvNtCsiDsdoxUJBlR_16futures_executor10local_pool12run_executorINtNtCsiloedr2K6v7_4core6result6ResultINtNtCs9pDt8l5wGDA_5alloc3vec3VecINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EENtNtCs7wiLZqa2F25_12fvm_ipld_car5error5ErrorENCINvB2_8block_onNCINvNtCsh74LAqVwWKW_21fvm_integration_tests6bundle13import_bundleNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreE0E0ECs7AwuCMXPzRZ_8fvm_fuzz:
   80|    318|fn run_executor<T, F: FnMut(&mut Context<'_>) -> Poll<T>>(mut f: F) -> T {
   81|    318|    let _enter = enter().expect(
   82|    318|        "cannot execute `LocalPool` executor from within \
   83|    318|         another executor",
   84|    318|    );
   85|    318|
   86|    318|    CURRENT_THREAD_NOTIFY.with(|thread_notify| {
   87|       |        let waker = waker_ref(thread_notify);
   88|       |        let mut cx = Context::from_waker(&waker);
   89|       |        loop {
   90|       |            if let Poll::Ready(t) = f(&mut cx) {
   91|       |                return t;
   92|       |            }
   93|       |
   94|       |            // Wait for a wakeup.
   95|       |            while !thread_notify.unparked.swap(false, Ordering::Acquire) {
   96|       |                // No wakeup occurred. It may occur now, right before parking,
   97|       |                // but in that case the token made available by `unpark()`
   98|       |                // is guaranteed to still be available and `park()` is a no-op.
   99|       |                thread::park();
  100|       |            }
  101|       |        }
  102|    318|    })
  103|    318|}
_RINvNtCsiDsdoxUJBlR_16futures_executor10local_pool8block_onNCINvNtCsh74LAqVwWKW_21fvm_integration_tests6bundle13import_bundleNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreE0ECs7AwuCMXPzRZ_8fvm_fuzz:
  315|    318|pub fn block_on<F: Future>(f: F) -> F::Output {
  316|    318|    pin_mut!(f);
  317|    318|    run_executor(|cx| f.as_mut().poll(cx))
  318|    318|}
_RNCINvNtCsiDsdoxUJBlR_16futures_executor10local_pool8block_onNCINvNtCsh74LAqVwWKW_21fvm_integration_tests6bundle13import_bundleNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreE0E0Cs7AwuCMXPzRZ_8fvm_fuzz:
  317|    318|    run_executor(|cx| f.as_mut().poll(cx))
_RNCNvNvNtCsiDsdoxUJBlR_16futures_executor10local_pool21CURRENT_THREAD_NOTIFY7___getit0Cs7AwuCMXPzRZ_8fvm_fuzz:
   56|      1|thread_local! {
   57|      1|    static CURRENT_THREAD_NOTIFY: Arc<ThreadNotify> = Arc::new(ThreadNotify {
   58|      1|        thread: thread::current(),
   59|      1|        unparked: AtomicBool::new(false),
   60|      1|    });
   61|      1|}

_RNvXs_NtCseBbtBNPWb9W_10futures_io6if_stdQINtNtNtCsiUfFVXq5yp2_12futures_util2io4take4TakeQRShENtB4_9AsyncRead9poll_readCs7AwuCMXPzRZ_8fvm_fuzz:
  302|  11.7k|            fn poll_read(
  303|  11.7k|                mut self: Pin<&mut Self>,
  304|  11.7k|                cx: &mut Context<'_>,
  305|  11.7k|                buf: &mut [u8],
  306|  11.7k|            ) -> Poll<Result<usize>> {
  307|  11.7k|                Pin::new(&mut **self).poll_read(cx, buf)
  308|  11.7k|            }
_RNvXs_NtCseBbtBNPWb9W_10futures_io6if_stdQRShNtB4_9AsyncRead9poll_readCs7AwuCMXPzRZ_8fvm_fuzz:
  302|  21.9k|            fn poll_read(
  303|  21.9k|                mut self: Pin<&mut Self>,
  304|  21.9k|                cx: &mut Context<'_>,
  305|  21.9k|                buf: &mut [u8],
  306|  21.9k|            ) -> Poll<Result<usize>> {
  307|  21.9k|                Pin::new(&mut **self).poll_read(cx, buf)
  308|  21.9k|            }
_RNvXs_NtCseBbtBNPWb9W_10futures_io6if_stdQQRShNtB4_9AsyncRead9poll_readCs7AwuCMXPzRZ_8fvm_fuzz:
  302|  15.9k|            fn poll_read(
  303|  15.9k|                mut self: Pin<&mut Self>,
  304|  15.9k|                cx: &mut Context<'_>,
  305|  15.9k|                buf: &mut [u8],
  306|  15.9k|            ) -> Poll<Result<usize>> {
  307|  15.9k|                Pin::new(&mut **self).poll_read(cx, buf)
  308|  15.9k|            }
_RNvXs1_NtCseBbtBNPWb9W_10futures_io6if_stdRShNtB5_9AsyncRead9poll_read:
  352|  21.9k|            fn poll_read(
  353|  21.9k|                mut self: Pin<&mut Self>,
  354|  21.9k|                _: &mut Context<'_>,
  355|  21.9k|                buf: &mut [u8],
  356|  21.9k|            ) -> Poll<Result<usize>> {
  357|  21.9k|                Poll::Ready(io::Read::read(&mut *self, buf))
  358|  21.9k|            }

_RINvNtCs9vaofKgb65u_12futures_task5waker12waker_vtableNtNtCsiDsdoxUJBlR_16futures_executor10local_pool12ThreadNotifyECs7AwuCMXPzRZ_8fvm_fuzz:
    6|    318|pub(super) fn waker_vtable<W: ArcWake>() -> &'static RawWakerVTable {
    7|    318|    &RawWakerVTable::new(
    8|    318|        clone_arc_raw::<W>,
    9|    318|        wake_arc_raw::<W>,
   10|    318|        wake_by_ref_arc_raw::<W>,
   11|    318|        drop_arc_raw::<W>,
   12|    318|    )
   13|    318|}

_RINvNtCs9vaofKgb65u_12futures_task9waker_ref9waker_refNtNtCsiDsdoxUJBlR_16futures_executor10local_pool12ThreadNotifyECs7AwuCMXPzRZ_8fvm_fuzz:
   55|    318|pub fn waker_ref<W>(wake: &Arc<W>) -> WakerRef<'_>
   56|    318|where
   57|    318|    W: ArcWake,
   58|    318|{
   59|    318|    // simply copy the pointer instead of using Arc::into_raw,
   60|    318|    // as we don't actually keep a refcount by using ManuallyDrop.<
   61|    318|    let ptr = Arc::as_ptr(wake).cast::<()>();
   62|    318|
   63|    318|    let waker =
   64|    318|        ManuallyDrop::new(unsafe { Waker::from_raw(RawWaker::new(ptr, waker_vtable::<W>())) });
   65|    318|    WakerRef::new_unowned(waker)
   66|    318|}
_RNvXs_NtCs9vaofKgb65u_12futures_task9waker_refNtB4_8WakerRefNtNtNtCsiloedr2K6v7_4core3ops5deref5Deref5deref:
   45|    318|    fn deref(&self) -> &Waker {
   46|    318|        &self.waker
   47|    318|    }
_RNvMNtCs9vaofKgb65u_12futures_task9waker_refNtB2_8WakerRef11new_unowned:
   36|    318|    pub fn new_unowned(waker: ManuallyDrop<Waker>) -> Self {
   37|    318|        Self { waker, _marker: PhantomData }
   38|    318|    }

_RINvNtCsiUfFVXq5yp2_12futures_util6future13assert_futureINtNtCsiloedr2K6v7_4core6result6ResultjNtNtNtCsdyNNmftaNAQ_3std2io5error5ErrorEINtNtNtB4_2io11read_to_end9ReadToEndINtNtB2e_4take4TakeQRShEEECs7AwuCMXPzRZ_8fvm_fuzz:
  126|  5.72k|pub(crate) fn assert_future<T, F>(future: F) -> F
  127|  5.72k|where
  128|  5.72k|    F: Future<Output = T>,
  129|  5.72k|{
  130|  5.72k|    future
  131|  5.72k|}
_RINvNtCsiUfFVXq5yp2_12futures_util6future13assert_futureINtNtCsiloedr2K6v7_4core6result6ResultjNtNtNtCsdyNNmftaNAQ_3std2io5error5ErrorEINtNtNtB4_2io4read4ReadQRShEECs7AwuCMXPzRZ_8fvm_fuzz:
  126|  15.9k|pub(crate) fn assert_future<T, F>(future: F) -> F
  127|  15.9k|where
  128|  15.9k|    F: Future<Output = T>,
  129|  15.9k|{
  130|  15.9k|    future
  131|  15.9k|}

_RINvNtCsiUfFVXq5yp2_12futures_util2io10initializeINtNtCsiloedr2K6v7_4core3pin3PinQQINtNtB2_4take4TakeQRShEEECs7AwuCMXPzRZ_8fvm_fuzz:
   41|  11.4k|unsafe fn initialize<R: AsyncRead>(_reader: &R, buf: &mut [u8]) {
   42|  11.4k|    ptr::write_bytes(buf.as_mut_ptr(), 0, buf.len())
   43|  11.4k|}
_RINvNtCsiUfFVXq5yp2_12futures_util2io11assert_readINtNtB2_4take4TakeQRShEECs7AwuCMXPzRZ_8fvm_fuzz:
  828|  5.72k|pub(crate) fn assert_read<R>(reader: R) -> R
  829|  5.72k|where
  830|  5.72k|    R: AsyncRead,
  831|  5.72k|{
  832|  5.72k|    reader
  833|  5.72k|}
_RNvYQRShNtNtCsiUfFVXq5yp2_12futures_util2io12AsyncReadExt4takeCs7AwuCMXPzRZ_8fvm_fuzz:
  375|  5.72k|    fn take(self, limit: u64) -> Take<Self>
  376|  5.72k|    where
  377|  5.72k|        Self: Sized,
  378|  5.72k|    {
  379|  5.72k|        assert_read(Take::new(self, limit))
  380|  5.72k|    }
_RNvYQRShNtNtCsiUfFVXq5yp2_12futures_util2io12AsyncReadExt4readCs7AwuCMXPzRZ_8fvm_fuzz:
  204|  15.9k|    fn read<'a>(&'a mut self, buf: &'a mut [u8]) -> Read<'a, Self>
  205|  15.9k|    where
  206|  15.9k|        Self: Unpin,
  207|  15.9k|    {
  208|  15.9k|        assert_future::<Result<usize>, _>(Read::new(self, buf))
  209|  15.9k|    }
_RNvYINtNtNtCsiUfFVXq5yp2_12futures_util2io4take4TakeQRShENtB7_12AsyncReadExt11read_to_endCs7AwuCMXPzRZ_8fvm_fuzz:
  286|  5.72k|    fn read_to_end<'a>(&'a mut self, buf: &'a mut Vec<u8>) -> ReadToEnd<'a, Self>
  287|  5.72k|    where
  288|  5.72k|        Self: Unpin,
  289|  5.72k|    {
  290|  5.72k|        assert_future::<Result<usize>, _>(ReadToEnd::new(self, buf))
  291|  5.72k|    }

_RNvXs0_NtNtCsiUfFVXq5yp2_12futures_util2io4readINtB5_4ReadQRShENtNtNtCsiloedr2K6v7_4core6future6future6Future4pollCs7AwuCMXPzRZ_8fvm_fuzz:
   26|  15.9k|    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
   27|  15.9k|        let this = &mut *self;
   28|  15.9k|        Pin::new(&mut this.reader).poll_read(cx, this.buf)
   29|  15.9k|    }
_RNvMs_NtNtCsiUfFVXq5yp2_12futures_util2io4readINtB4_4ReadQRShE3newCs7AwuCMXPzRZ_8fvm_fuzz:
   18|  15.9k|    pub(super) fn new(reader: &'a mut R, buf: &'a mut [u8]) -> Self {
   19|  15.9k|        Self { reader, buf }
   20|  15.9k|    }

_RINvNtNtCsiUfFVXq5yp2_12futures_util2io11read_to_end20read_to_end_internalQINtNtB4_4take4TakeQRShEECs7AwuCMXPzRZ_8fvm_fuzz:
   49|  5.72k|pub(super) fn read_to_end_internal<R: AsyncRead + ?Sized>(
   50|  5.72k|    mut rd: Pin<&mut R>,
   51|  5.72k|    cx: &mut Context<'_>,
   52|  5.72k|    buf: &mut Vec<u8>,
   53|  5.72k|    start_len: usize,
   54|  5.72k|) -> Poll<io::Result<usize>> {
   55|  5.72k|    let mut g = Guard { len: buf.len(), buf };
   56|  11.7k|    loop {
   57|  11.7k|        if g.len == g.buf.len() {
   58|  11.4k|            unsafe {
   59|  11.4k|                g.buf.reserve(32);
   60|  11.4k|                let capacity = g.buf.capacity();
   61|  11.4k|                g.buf.set_len(capacity);
   62|  11.4k|                super::initialize(&rd, &mut g.buf[g.len..]);
   63|  11.4k|            }
   64|    318|        }
   65|       |
   66|  11.7k|        let buf = &mut g.buf[g.len..];
   67|  11.7k|        match ready!(rd.as_mut().poll_read(cx, buf)) {
   68|  5.72k|            Ok(0) => return Poll::Ready(Ok(g.len - start_len)),
   69|  6.04k|            Ok(n) => {
   70|  6.04k|                // We can't allow bogus values from read. If it is too large, the returned vec could have its length
   71|  6.04k|                // set past its capacity, or if it overflows the vec could be shortened which could create an invalid
   72|  6.04k|                // string if this is called via read_to_string.
   73|  6.04k|                assert!(n <= buf.len());
   74|  6.04k|                g.len += n;
   75|       |            }
   76|      0|            Err(e) => return Poll::Ready(Err(e)),
   77|       |        }
   78|       |    }
   79|  5.72k|}
_RNvXs1_NtNtCsiUfFVXq5yp2_12futures_util2io11read_to_endINtB5_9ReadToEndINtNtB7_4take4TakeQRShEENtNtNtCsiloedr2K6v7_4core6future6future6Future4pollCs7AwuCMXPzRZ_8fvm_fuzz:
   87|  5.72k|    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
   88|  5.72k|        let this = &mut *self;
   89|  5.72k|        read_to_end_internal(Pin::new(&mut this.reader), cx, this.buf, this.start_len)
   90|  5.72k|    }
_RNvMs_NtNtCsiUfFVXq5yp2_12futures_util2io11read_to_endINtB4_9ReadToEndINtNtB6_4take4TakeQRShEE3newCs7AwuCMXPzRZ_8fvm_fuzz:
   21|  5.72k|    pub(super) fn new(reader: &'a mut R, buf: &'a mut Vec<u8>) -> Self {
   22|  5.72k|        let start_len = buf.len();
   23|  5.72k|        Self { reader, buf, start_len }
   24|  5.72k|    }
_RNvXs0_NtNtCsiUfFVXq5yp2_12futures_util2io11read_to_endNtB5_5GuardNtNtNtCsiloedr2K6v7_4core3ops4drop4Drop4drop:
   33|  5.72k|    fn drop(&mut self) {
   34|  5.72k|        unsafe {
   35|  5.72k|            self.buf.set_len(self.len);
   36|  5.72k|        }
   37|  5.72k|    }

_RNvMNtNtCsiUfFVXq5yp2_12futures_util2io4takeINtB2_4TakeQRShE3newCs7AwuCMXPzRZ_8fvm_fuzz:
   20|  5.72k|    pub(super) fn new(inner: R, limit: u64) -> Self {
   21|  5.72k|        Self { inner, limit }
   22|  5.72k|    }
_RNvXs_NtNtCsiUfFVXq5yp2_12futures_util2io4takeINtB4_4TakeQRShENtNtCseBbtBNPWb9W_10futures_io6if_std9AsyncRead9poll_readCs7AwuCMXPzRZ_8fvm_fuzz:
   85|  11.7k|    fn poll_read(
   86|  11.7k|        self: Pin<&mut Self>,
   87|  11.7k|        cx: &mut Context<'_>,
   88|  11.7k|        buf: &mut [u8],
   89|  11.7k|    ) -> Poll<Result<usize, io::Error>> {
   90|  11.7k|        let this = self.project();
   91|  11.7k|
   92|  11.7k|        if *this.limit == 0 {
   93|  5.72k|            return Poll::Ready(Ok(0));
   94|  6.04k|        }
   95|  6.04k|
   96|  6.04k|        let max = cmp::min(buf.len() as u64, *this.limit) as usize;
   97|  6.04k|        let n = ready!(this.inner.poll_read(cx, &mut buf[..max]))?;
   98|  6.04k|        *this.limit -= n as u64;
   99|  6.04k|        Poll::Ready(Ok(n))
  100|  11.7k|    }

_RNvXNtCs5XPS5MtrE2B_13generic_array5implsINtB4_12GenericArrayhINtNtCs6DngFm1hXV4_7typenum4uint4UIntIBZ_IBZ_IBZ_IBZ_IBZ_NtB11_5UTermNtNtB13_3bit2B1ENtB27_2B0EB2l_EB2l_EB2l_EB2l_EENtNtCsiloedr2K6v7_4core7default7Default7defaultCsboUdcTbF1FS_15direct_syscalls:
   16|  1.90k|    fn default() -> Self {
   17|  1.90k|        Self::generate(|_| T::default())
   18|  1.90k|    }
_RNvXNtCs5XPS5MtrE2B_13generic_array5implsINtB4_12GenericArrayhINtNtCs6DngFm1hXV4_7typenum4uint4UIntIBZ_IBZ_IBZ_IBZ_IBZ_IBZ_NtB11_5UTermNtNtB13_3bit2B1ENtB2b_2B0EB2p_EB2p_EB2p_EB2p_EB2p_EENtNtCsiloedr2K6v7_4core7default7Default7defaultCsboUdcTbF1FS_15direct_syscalls:
   16|    954|    fn default() -> Self {
   17|    954|        Self::generate(|_| T::default())
   18|    954|    }
_RNCNvXNtCs5XPS5MtrE2B_13generic_array5implsINtB6_12GenericArrayhINtNtCs6DngFm1hXV4_7typenum4uint4UIntIB11_IB11_IB11_IB11_IB11_NtB13_5UTermNtNtB15_3bit2B1ENtB2e_2B0EB2s_EB2s_EB2s_EB2s_EENtNtCsiloedr2K6v7_4core7default7Default7default0CsboUdcTbF1FS_15direct_syscalls:
   17|  61.0k|        Self::generate(|_| T::default())
_RNCNvXNtCs5XPS5MtrE2B_13generic_array5implsINtB6_12GenericArrayhINtNtCs6DngFm1hXV4_7typenum4uint4UIntIB11_IB11_IB11_IB11_IB11_IB11_NtB13_5UTermNtNtB15_3bit2B1ENtB2j_2B0EB2x_EB2x_EB2x_EB2x_EB2x_EENtNtCsiloedr2K6v7_4core7default7Default7default0CsboUdcTbF1FS_15direct_syscalls:
   17|  61.0k|        Self::generate(|_| T::default())
_RNvXs3c_NtCs5XPS5MtrE2B_13generic_array5implsAhj20_INtNtCsiloedr2K6v7_4core7convert4FromINtB8_12GenericArrayhINtNtCs6DngFm1hXV4_7typenum4uint4UIntIB1K_IB1K_IB1K_IB1K_IB1K_NtB1M_5UTermNtNtB1O_3bit2B1ENtB2X_2B0EB3b_EB3b_EB3b_EB3b_EEE4fromCsboUdcTbF1FS_15direct_syscalls:
  139|    954|                fn from(sel: GenericArray<T, $ty>) -> [T; $n] {
  140|    954|                    unsafe { $crate::transmute(sel) }
  141|    954|                }

_RNvXs7_Cs5XPS5MtrE2B_13generic_arrayINtB5_12GenericArrayhINtNtCs6DngFm1hXV4_7typenum4uint4UIntIBU_IBU_IBU_IBU_IBU_NtBW_5UTermNtNtBY_3bit2B1ENtB21_2B0EB2e_EB2e_EB2e_EB2e_EENtNtNtCsiloedr2K6v7_4core3ops5deref5Deref5derefCsboUdcTbF1FS_15direct_syscalls:
  192|  2.86k|    fn deref(&self) -> &[T] {
  193|  2.86k|        unsafe { slice::from_raw_parts(self as *const Self as *const T, N::USIZE) }
  194|  2.86k|    }
_RNvMs9_Cs5XPS5MtrE2B_13generic_arrayINtB5_12ArrayBuilderhINtNtCs6DngFm1hXV4_7typenum4uint4UIntIBU_IBU_IBU_IBU_IBU_NtBW_5UTermNtNtBY_3bit2B1ENtB21_2B0EB2e_EB2e_EB2e_EB2e_EE3newCsboUdcTbF1FS_15direct_syscalls:
  221|  1.90k|    pub unsafe fn new() -> ArrayBuilder<T, N> {
  222|  1.90k|        ArrayBuilder {
  223|  1.90k|            array: MaybeUninit::uninit(),
  224|  1.90k|            position: 0,
  225|  1.90k|        }
  226|  1.90k|    }
_RINvXsg_Cs5XPS5MtrE2B_13generic_arrayINtB6_12GenericArrayhINtNtCs6DngFm1hXV4_7typenum4uint4UIntIBV_IBV_IBV_IBV_IBV_NtBX_5UTermNtNtBZ_3bit2B1ENtB22_2B0EB2f_EB2f_EB2f_EB2f_EEINtNtB6_8sequence15GenericSequencehE8generateNCNvXNtB6_5implsBz_NtNtCsiloedr2K6v7_4core7default7Default7default0ECsboUdcTbF1FS_15direct_syscalls:
  379|  1.90k|    fn generate<F>(mut f: F) -> GenericArray<T, N>
  380|  1.90k|    where
  381|  1.90k|        F: FnMut(usize) -> T,
  382|  1.90k|    {
  383|  1.90k|        unsafe {
  384|  1.90k|            let mut destination = ArrayBuilder::new();
  385|  1.90k|
  386|  1.90k|            {
  387|  1.90k|                let (destination_iter, position) = destination.iter_position();
  388|  1.90k|
  389|  1.90k|                destination_iter.enumerate().for_each(|(i, dst)| {
  390|       |                    ptr::write(dst, f(i));
  391|       |
  392|       |                    *position += 1;
  393|  1.90k|                });
  394|  1.90k|            }
  395|  1.90k|
  396|  1.90k|            destination.into_inner()
  397|  1.90k|        }
  398|  1.90k|    }
_RNvXs8_Cs5XPS5MtrE2B_13generic_arrayINtB5_12GenericArrayhINtNtCs6DngFm1hXV4_7typenum4uint4UIntIBU_IBU_IBU_IBU_IBU_NtBW_5UTermNtNtBY_3bit2B1ENtB21_2B0EB2e_EB2e_EB2e_EB2e_EENtNtNtCsiloedr2K6v7_4core3ops5deref8DerefMut9deref_mutCsboUdcTbF1FS_15direct_syscalls:
  202|  3.81k|    fn deref_mut(&mut self) -> &mut [T] {
  203|  3.81k|        unsafe { slice::from_raw_parts_mut(self as *mut Self as *mut T, N::USIZE) }
  204|  3.81k|    }
_RNvMs9_Cs5XPS5MtrE2B_13generic_arrayINtB5_12ArrayBuilderhINtNtCs6DngFm1hXV4_7typenum4uint4UIntIBU_IBU_IBU_IBU_IBU_IBU_NtBW_5UTermNtNtBY_3bit2B1ENtB25_2B0EB2i_EB2i_EB2i_EB2i_EB2i_EE3newCsboUdcTbF1FS_15direct_syscalls:
  221|    954|    pub unsafe fn new() -> ArrayBuilder<T, N> {
  222|    954|        ArrayBuilder {
  223|    954|            array: MaybeUninit::uninit(),
  224|    954|            position: 0,
  225|    954|        }
  226|    954|    }
_RNvXs8_Cs5XPS5MtrE2B_13generic_arrayINtB5_12GenericArrayhINtNtCs6DngFm1hXV4_7typenum4uint4UIntIBU_IBU_IBU_IBU_IBU_IBU_NtBW_5UTermNtNtBY_3bit2B1ENtB25_2B0EB2i_EB2i_EB2i_EB2i_EB2i_EENtNtNtCsiloedr2K6v7_4core3ops5deref8DerefMut9deref_mutCsboUdcTbF1FS_15direct_syscalls:
  202|  3.81k|    fn deref_mut(&mut self) -> &mut [T] {
  203|  3.81k|        unsafe { slice::from_raw_parts_mut(self as *mut Self as *mut T, N::USIZE) }
  204|  3.81k|    }
_RINvCs5XPS5MtrE2B_13generic_array9transmuteINtB2_12GenericArrayhINtNtCs6DngFm1hXV4_7typenum4uint4UIntIB11_IB11_IB11_IB11_IB11_NtB13_5UTermNtNtB15_3bit2B1ENtB2e_2B0EB2s_EB2s_EB2s_EB2s_EEAhj20_ECsboUdcTbF1FS_15direct_syscalls:
  642|    954|pub unsafe fn transmute<A, B>(a: A) -> B {
  643|    954|    let a = ManuallyDrop::new(a);
  644|    954|    ::core::ptr::read(&*a as *const A as *const B)
  645|    954|}
_RNvMs9_Cs5XPS5MtrE2B_13generic_arrayINtB5_12ArrayBuilderhINtNtCs6DngFm1hXV4_7typenum4uint4UIntIBU_IBU_IBU_IBU_IBU_NtBW_5UTermNtNtBY_3bit2B1ENtB21_2B0EB2e_EB2e_EB2e_EB2e_EE13iter_positionCsboUdcTbF1FS_15direct_syscalls:
  234|  1.90k|    pub unsafe fn iter_position(&mut self) -> (slice::IterMut<T>, &mut usize) {
  235|  1.90k|        ((&mut *self.array.as_mut_ptr()).iter_mut(), &mut self.position)
  236|  1.90k|    }
_RNvMs9_Cs5XPS5MtrE2B_13generic_arrayINtB5_12ArrayBuilderhINtNtCs6DngFm1hXV4_7typenum4uint4UIntIBU_IBU_IBU_IBU_IBU_IBU_NtBW_5UTermNtNtBY_3bit2B1ENtB25_2B0EB2i_EB2i_EB2i_EB2i_EB2i_EE13iter_positionCsboUdcTbF1FS_15direct_syscalls:
  234|    954|    pub unsafe fn iter_position(&mut self) -> (slice::IterMut<T>, &mut usize) {
  235|    954|        ((&mut *self.array.as_mut_ptr()).iter_mut(), &mut self.position)
  236|    954|    }
_RNvMs9_Cs5XPS5MtrE2B_13generic_arrayINtB5_12ArrayBuilderhINtNtCs6DngFm1hXV4_7typenum4uint4UIntIBU_IBU_IBU_IBU_IBU_NtBW_5UTermNtNtBY_3bit2B1ENtB21_2B0EB2e_EB2e_EB2e_EB2e_EE10into_innerCsboUdcTbF1FS_15direct_syscalls:
  242|  1.90k|    pub unsafe fn into_inner(self) -> GenericArray<T, N> {
  243|  1.90k|        let array = ptr::read(&self.array);
  244|  1.90k|
  245|  1.90k|        mem::forget(self);
  246|  1.90k|
  247|  1.90k|        array.assume_init()
  248|  1.90k|    }
_RNCINvXsg_Cs5XPS5MtrE2B_13generic_arrayINtB8_12GenericArrayhINtNtCs6DngFm1hXV4_7typenum4uint4UIntIBX_IBX_IBX_IBX_IBX_NtBZ_5UTermNtNtB11_3bit2B1ENtB24_2B0EB2i_EB2i_EB2i_EB2i_EEINtNtB8_8sequence15GenericSequencehE8generateNCNvXNtB8_5implsBB_NtNtCsiloedr2K6v7_4core7default7Default7default0E0CsboUdcTbF1FS_15direct_syscalls:
  389|  61.0k|                destination_iter.enumerate().for_each(|(i, dst)| {
  390|  61.0k|                    ptr::write(dst, f(i));
  391|  61.0k|
  392|  61.0k|                    *position += 1;
  393|  61.0k|                });
_RINvXsg_Cs5XPS5MtrE2B_13generic_arrayINtB6_12GenericArrayhINtNtCs6DngFm1hXV4_7typenum4uint4UIntIBV_IBV_IBV_IBV_IBV_IBV_NtBX_5UTermNtNtBZ_3bit2B1ENtB26_2B0EB2j_EB2j_EB2j_EB2j_EB2j_EEINtNtB6_8sequence15GenericSequencehE8generateNCNvXNtB6_5implsBz_NtNtCsiloedr2K6v7_4core7default7Default7default0ECsboUdcTbF1FS_15direct_syscalls:
  379|    954|    fn generate<F>(mut f: F) -> GenericArray<T, N>
  380|    954|    where
  381|    954|        F: FnMut(usize) -> T,
  382|    954|    {
  383|    954|        unsafe {
  384|    954|            let mut destination = ArrayBuilder::new();
  385|    954|
  386|    954|            {
  387|    954|                let (destination_iter, position) = destination.iter_position();
  388|    954|
  389|    954|                destination_iter.enumerate().for_each(|(i, dst)| {
  390|       |                    ptr::write(dst, f(i));
  391|       |
  392|       |                    *position += 1;
  393|    954|                });
  394|    954|            }
  395|    954|
  396|    954|            destination.into_inner()
  397|    954|        }
  398|    954|    }
_RNvMs9_Cs5XPS5MtrE2B_13generic_arrayINtB5_12ArrayBuilderhINtNtCs6DngFm1hXV4_7typenum4uint4UIntIBU_IBU_IBU_IBU_IBU_IBU_NtBW_5UTermNtNtBY_3bit2B1ENtB25_2B0EB2i_EB2i_EB2i_EB2i_EB2i_EE10into_innerCsboUdcTbF1FS_15direct_syscalls:
  242|    954|    pub unsafe fn into_inner(self) -> GenericArray<T, N> {
  243|    954|        let array = ptr::read(&self.array);
  244|    954|
  245|    954|        mem::forget(self);
  246|    954|
  247|    954|        array.assume_init()
  248|    954|    }
_RNCINvXsg_Cs5XPS5MtrE2B_13generic_arrayINtB8_12GenericArrayhINtNtCs6DngFm1hXV4_7typenum4uint4UIntIBX_IBX_IBX_IBX_IBX_IBX_NtBZ_5UTermNtNtB11_3bit2B1ENtB28_2B0EB2m_EB2m_EB2m_EB2m_EB2m_EEINtNtB8_8sequence15GenericSequencehE8generateNCNvXNtB8_5implsBB_NtNtCsiloedr2K6v7_4core7default7Default7default0E0CsboUdcTbF1FS_15direct_syscalls:
  389|  61.0k|                destination_iter.enumerate().for_each(|(i, dst)| {
  390|  61.0k|                    ptr::write(dst, f(i));
  391|  61.0k|
  392|  61.0k|                    *position += 1;
  393|  61.0k|                });
_RNvXs8_Cs5XPS5MtrE2B_13generic_arrayINtB5_12GenericArrayhINtNtCs6DngFm1hXV4_7typenum4uint4UIntIBU_IBU_IBU_IBU_IBU_IBU_NtBW_5UTermNtNtBY_3bit2B1ENtB25_2B0EB2i_EB2i_EB2i_EB2i_EB2i_EENtNtNtCsiloedr2K6v7_4core3ops5deref8DerefMut9deref_mutCslH3pn9Bu6yX_13fvm_ipld_hamt:
  202|    954|    fn deref_mut(&mut self) -> &mut [T] {
  203|    954|        unsafe { slice::from_raw_parts_mut(self as *mut Self as *mut T, N::USIZE) }
  204|    954|    }

_RNvCs3lQBDEFYXUn_9getrandom9getrandom:
  286|      1|pub fn getrandom(dest: &mut [u8]) -> Result<(), Error> {
  287|      1|    if dest.is_empty() {
  288|      0|        return Ok(());
  289|      1|    }
  290|      1|    imp::getrandom_inner(dest)
  291|      1|}

_RNCNvNtCs3lQBDEFYXUn_9getrandom3imp15getrandom_inner0B5_:
   20|      1|        sys_fill_exact(dest, |buf| unsafe {
   21|      1|            getrandom(buf.as_mut_ptr() as *mut libc::c_void, buf.len(), 0)
   22|      1|        })
_RNvNtCs3lQBDEFYXUn_9getrandom3imp22is_getrandom_available:
   28|      1|fn is_getrandom_available() -> bool {
   29|      1|    let res = unsafe { getrandom(core::ptr::null_mut(), 0, libc::GRND_NONBLOCK) };
   30|      1|    if res < 0 {
   31|      0|        match last_os_error().raw_os_error() {
   32|      0|            Some(libc::ENOSYS) => false, // No kernel support
   33|      0|            Some(libc::EPERM) => false,  // Blocked by seccomp
   34|      0|            _ => true,
   35|       |        }
   36|       |    } else {
   37|      1|        true
   38|       |    }
   39|      1|}
_RNvNtCs3lQBDEFYXUn_9getrandom3imp15getrandom_inner:
   16|      1|pub fn getrandom_inner(dest: &mut [u8]) -> Result<(), Error> {
   17|      1|    // getrandom(2) was introduced in Linux 3.17
   18|      1|    static HAS_GETRANDOM: LazyBool = LazyBool::new();
   19|      1|    if HAS_GETRANDOM.unsync_init(is_getrandom_available) {
   20|      1|        sys_fill_exact(dest, |buf| unsafe {
   21|       |            getrandom(buf.as_mut_ptr() as *mut libc::c_void, buf.len(), 0)
   22|      1|        })
   23|       |    } else {
   24|      0|        use_file::getrandom_inner(dest)
   25|       |    }
   26|      1|}
_RNvNtCs3lQBDEFYXUn_9getrandom3imp9getrandom:
   41|      2|unsafe fn getrandom(
   42|      2|    buf: *mut libc::c_void,
   43|      2|    buflen: libc::size_t,
   44|      2|    flags: libc::c_uint,
   45|      2|) -> libc::ssize_t {
   46|      2|    libc::syscall(libc::SYS_getrandom, buf, buflen, flags) as libc::ssize_t
   47|      2|}

_RNCINvMs_NtCs3lQBDEFYXUn_9getrandom4utilNtB7_8LazyBool11unsync_initNvNtB9_3imp22is_getrandom_availableE0B9_:
   62|      1|        self.0.unsync_init(|| init() as usize) != 0
_RINvMs_NtCs3lQBDEFYXUn_9getrandom4utilNtB5_8LazyBool11unsync_initNvNtB7_3imp22is_getrandom_availableEB7_:
   61|      1|    pub fn unsync_init(&self, init: impl FnOnce() -> bool) -> bool {
   62|      1|        self.0.unsync_init(|| init() as usize) != 0
   63|      1|    }
_RINvMNtCs3lQBDEFYXUn_9getrandom4utilNtB3_9LazyUsize11unsync_initNCINvMs_B3_NtB3_8LazyBool11unsync_initNvNtB5_3imp22is_getrandom_availableE0EB5_:
   42|      1|    pub fn unsync_init(&self, init: impl FnOnce() -> usize) -> usize {
   43|      1|        // Relaxed ordering is fine, as we only have a single atomic variable.
   44|      1|        let mut val = self.0.load(Relaxed);
   45|      1|        if val == Self::UNINIT {
   46|      1|            val = init();
   47|      1|            self.0.store(val, Relaxed);
   48|      1|        }
   49|      1|        val
   50|      1|    }

_RINvNtCs3lQBDEFYXUn_9getrandom9util_libc14sys_fill_exactNCNvNtB4_3imp15getrandom_inner0EB4_:
   61|      1|pub fn sys_fill_exact(
   62|      1|    mut buf: &mut [u8],
   63|      1|    sys_fill: impl Fn(&mut [u8]) -> libc::ssize_t,
   64|      1|) -> Result<(), Error> {
   65|      2|    while !buf.is_empty() {
   66|      1|        let res = sys_fill(buf);
   67|      1|        if res < 0 {
   68|      0|            let err = last_os_error();
   69|      0|            // We should try again if the call was interrupted.
   70|      0|            if err.raw_os_error() != Some(libc::EINTR) {
   71|      0|                return Err(err);
   72|      0|            }
   73|      1|        } else {
   74|      1|            // We don't check for EOF (ret = 0) as the data we are reading
   75|      1|            // should be an infinite stream of random bytes.
   76|      1|            buf = &mut buf[(res as usize)..];
   77|      1|        }
   78|       |    }
   79|      1|    Ok(())
   80|      1|}

_RNvXNtNtNtNtCslQVz95dJ1Sv_9hashbrown3raw5inner5alloc5innerNtB2_6GlobalNtB2_9Allocator10deallocate:
   50|  1.27k|        unsafe fn deallocate(&self, ptr: NonNull<u8>, layout: Layout) {
   51|  1.27k|            dealloc(ptr.as_ptr(), layout);
   52|  1.27k|        }
_RNvXNtNtNtNtCslQVz95dJ1Sv_9hashbrown3raw5inner5alloc5innerNtB2_6GlobalNtB2_9Allocator8allocate:
   46|  1.27k|        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {
   47|  1.27k|            unsafe { NonNull::new(alloc(layout)).ok_or(()) }
   48|  1.27k|        }
_RNvXs1_NtNtNtNtCslQVz95dJ1Sv_9hashbrown3raw5inner5alloc5innerNtB5_6GlobalNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
   42|  1.27k|    #[derive(Copy, Clone)]
_RINvNtNtNtNtCslQVz95dJ1Sv_9hashbrown3raw5inner5alloc5inner8do_allocNtB2_6GlobalECsaCHOb31h0oq_8wasmtime:
   61|  1.27k|    pub fn do_alloc<A: Allocator>(alloc: &A, layout: Layout) -> Result<NonNull<u8>, ()> {
   62|  1.27k|        alloc.allocate(layout)
   63|  1.27k|    }

_RNvMNtNtNtCslQVz95dJ1Sv_9hashbrown3raw5inner7bitmaskNtB2_7BitMask22lowest_set_bit_nonzero:
   73|  2.54k|    pub unsafe fn lowest_set_bit_nonzero(self) -> usize {
   74|  2.54k|        self.trailing_zeros()
   75|  2.54k|    }
_RNvMNtNtNtCslQVz95dJ1Sv_9hashbrown3raw5inner7bitmaskNtB2_7BitMask14trailing_zeros:
   79|  2.54k|    pub fn trailing_zeros(self) -> usize {
   80|       |        // ARM doesn't have a trailing_zeroes instruction, and instead uses
   81|       |        // reverse_bits (RBIT) + leading_zeroes (CLZ). However older ARM
   82|       |        // versions (pre-ARMv7) don't have RBIT and need to emulate it
   83|       |        // instead. Since we only have 1 bit set in each byte on ARM, we can
   84|       |        // use swap_bytes (REV) + leading_zeroes instead.
   85|      0|        if cfg!(target_arch = "arm") && BITMASK_STRIDE % 8 == 0 {
   86|      0|            self.0.swap_bytes().leading_zeros() as usize / BITMASK_STRIDE
   87|       |        } else {
   88|  2.54k|            self.0.trailing_zeros() as usize / BITMASK_STRIDE
   89|       |        }
   90|  2.54k|    }
_RNvMNtNtNtCslQVz95dJ1Sv_9hashbrown3raw5inner7bitmaskNtB2_7BitMask14lowest_set_bit:
   56|  3.81k|    pub fn lowest_set_bit(self) -> Option<usize> {
   57|  3.81k|        if self.0 == 0 {
   58|  1.27k|            None
   59|       |        } else {
   60|  2.54k|            Some(unsafe { self.lowest_set_bit_nonzero() })
   61|       |        }
   62|  3.81k|    }
_RNvXs_NtNtNtCslQVz95dJ1Sv_9hashbrown3raw5inner7bitmaskNtB4_7BitMaskNtNtNtNtCsiloedr2K6v7_4core4iter6traits7collect12IntoIterator9into_iter:
  104|  1.27k|    fn into_iter(self) -> BitMaskIter {
  105|  1.27k|        BitMaskIter(self)
  106|  1.27k|    }
_RNvMNtNtNtCslQVz95dJ1Sv_9hashbrown3raw5inner7bitmaskNtB2_7BitMask11any_bit_set:
   50|  1.27k|    pub fn any_bit_set(self) -> bool {
   51|  1.27k|        self.0 != 0
   52|  1.27k|    }
_RNvXs0_NtNtNtCslQVz95dJ1Sv_9hashbrown3raw5inner7bitmaskNtB5_11BitMaskIterNtNtNtNtCsiloedr2K6v7_4core4iter6traits8iterator8Iterator4next:
  117|  1.27k|    fn next(&mut self) -> Option<usize> {
  118|  1.27k|        let bit = self.0.lowest_set_bit()?;
  119|      0|        self.0 = self.0.remove_lowest_bit();
  120|      0|        Some(bit)
  121|  1.27k|    }

_RNvMs0_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerNtB5_11TableLayout20calculate_layout_for:
  242|  2.54k|    fn calculate_layout_for(self, buckets: usize) -> Option<(Layout, usize)> {
  243|  2.54k|        debug_assert!(buckets.is_power_of_two());
  244|       |
  245|  2.54k|        let TableLayout { size, ctrl_align } = self;
  246|       |        // Manual layout calculation since Layout methods are not yet stable.
  247|  2.54k|        let ctrl_offset =
  248|  2.54k|            size.checked_mul(buckets)?.checked_add(ctrl_align - 1)? & !(ctrl_align - 1);
  249|  2.54k|        let len = ctrl_offset.checked_add(buckets + Group::WIDTH)?;
  250|       |
  251|  2.54k|        Some((
  252|  2.54k|            unsafe { Layout::from_size_align_unchecked(len, ctrl_align) },
  253|  2.54k|            ctrl_offset,
  254|  2.54k|        ))
  255|  2.54k|    }
_RNvNtNtCslQVz95dJ1Sv_9hashbrown3raw5inner19capacity_to_buckets:
  185|  1.27k|fn capacity_to_buckets(cap: usize) -> Option<usize> {
  186|  1.27k|    debug_assert_ne!(cap, 0);
  187|       |
  188|       |    // For small tables we require at least 1 empty bucket so that lookups are
  189|       |    // guaranteed to terminate if an element doesn't exist in the table.
  190|  1.27k|    if cap < 8 {
  191|       |        // We don't bother with a table size of 2 buckets since that can only
  192|       |        // hold a single element. Instead we skip directly to a 4 bucket table
  193|       |        // which can hold 3 elements.
  194|  1.27k|        return Some(if cap < 4 { 4 } else { 8 });
  195|      0|    }
  196|       |
  197|       |    // Otherwise require 1/8 buckets to be empty (87.5% load)
  198|       |    //
  199|       |    // Be careful when modifying this, calculate_layout relies on the
  200|       |    // overflow check here.
  201|      0|    let adjusted_cap = cap.checked_mul(8)? / 7;
  202|       |
  203|       |    // Any overflows will have been caught by the checked_mul. Also, any
  204|       |    // rounding errors from the division above will be cleaned up by
  205|       |    // next_power_of_two (which can't overflow because of the previous division).
  206|      0|    Some(adjusted_cap.next_power_of_two())
  207|  1.27k|}
_RNvNtNtCslQVz95dJ1Sv_9hashbrown3raw5inner23bucket_mask_to_capacity:
  212|  2.54k|fn bucket_mask_to_capacity(bucket_mask: usize) -> usize {
  213|  2.54k|    if bucket_mask < 8 {
  214|       |        // For tables with 1/2/4/8 buckets, we always reserve one empty slot.
  215|       |        // Keep in mind that the bucket mask is one less than the bucket count.
  216|  2.54k|        bucket_mask
  217|       |    } else {
  218|       |        // For larger tables we reserve 12.5% of the slots as empty.
  219|      0|        ((bucket_mask + 1) / 8) * 7
  220|       |    }
  221|  2.54k|}
_RNvNtNtCslQVz95dJ1Sv_9hashbrown3raw5inner7is_full:
  112|  3.81k|fn is_full(ctrl: u8) -> bool {
  113|  3.81k|    ctrl & 0x80 == 0
  114|  3.81k|}
_RNvNtNtCslQVz95dJ1Sv_9hashbrown3raw5inner2h2:
  140|  2.54k|fn h2(hash: u64) -> u8 {
  141|  2.54k|    // Grab the top 7 bits of the hash. While the hash is normally a full 64-bit
  142|  2.54k|    // value, some hash functions (such as FxHash) produce a usize result
  143|  2.54k|    // instead, which means that the top 32 bits are 0 on 32-bit platforms.
  144|  2.54k|    let hash_len = usize::min(mem::size_of::<usize>(), mem::size_of::<u64>());
  145|  2.54k|    let top7 = hash >> (hash_len * 8 - 7);
  146|  2.54k|    (top7 & 0x7f) as u8 // truncation
  147|  2.54k|}
_RNvNtNtCslQVz95dJ1Sv_9hashbrown3raw5inner6likely:
   57|  1.27k|fn likely(b: bool) -> bool {
   58|  1.27k|    if !b {
   59|      0|        cold();
   60|  1.27k|    }
   61|  1.27k|    b
   62|  1.27k|}
_RNvNtNtCslQVz95dJ1Sv_9hashbrown3raw5inner4cold:
   53|  1.27k|fn cold() {}
_RNvNtNtCslQVz95dJ1Sv_9hashbrown3raw5inner8unlikely:
   65|  3.81k|fn unlikely(b: bool) -> bool {
   66|  3.81k|    if b {
   67|  1.27k|        cold();
   68|  2.54k|    }
   69|  3.81k|    b
   70|  3.81k|}
_RNvNtNtCslQVz95dJ1Sv_9hashbrown3raw5inner10is_special:
  118|  2.54k|fn is_special(ctrl: u8) -> bool {
  119|  2.54k|    ctrl & 0x80 != 0
  120|  2.54k|}
_RNvNtNtCslQVz95dJ1Sv_9hashbrown3raw5inner16special_is_empty:
  124|  2.54k|fn special_is_empty(ctrl: u8) -> bool {
  125|  2.54k|    debug_assert!(is_special(ctrl));
  126|  2.54k|    ctrl & 0x01 != 0
  127|  2.54k|}
_RNvNtNtCslQVz95dJ1Sv_9hashbrown3raw5inner2h1:
  132|  3.81k|fn h1(hash: u64) -> usize {
  133|  3.81k|    // On 32-bit platforms we simply ignore the higher hash bits.
  134|  3.81k|    hash as usize
  135|  3.81k|}
_RNvMs4_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerINtB5_8RawTablejE3newCskJihg1y13m7_3fvm:
  394|    636|    pub const fn new() -> Self {
  395|    636|        Self {
  396|    636|            table: RawTableInner::new_in(Global),
  397|    636|            marker: PhantomData,
  398|    636|        }
  399|    636|    }
_RNvMs8_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE6new_inCskJihg1y13m7_3fvm:
 1043|    636|    const fn new_in(alloc: A) -> Self {
 1044|    636|        Self {
 1045|    636|            // Be careful to cast the entire slice to a raw pointer.
 1046|    636|            ctrl: unsafe { NonNull::new_unchecked(Group::static_empty() as *const _ as *mut u8) },
 1047|    636|            bucket_mask: 0,
 1048|    636|            items: 0,
 1049|    636|            growth_left: 0,
 1050|    636|            alloc,
 1051|    636|        }
 1052|    636|    }
_RNvMs9_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE18is_empty_singletonCsaCHOb31h0oq_8wasmtime:
 1338|  3.18k|    fn is_empty_singleton(&self) -> bool {
 1339|  3.18k|        self.bucket_mask == 0
 1340|  3.18k|    }
_RNCNvMs9_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerINtB7_13RawTableInnerNtNtNtB7_5alloc5inner6GlobalE14prepare_resize0CsaCHOb31h0oq_8wasmtime:
 1368|  1.27k|        Ok(guard(new_table, move |self_| {
 1369|  1.27k|            if !self_.is_empty_singleton() {
 1370|      0|                self_.free_buckets(table_layout);
 1371|  1.27k|            }
 1372|  1.27k|        }))
_RNvMs5_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerINtB5_8RawTablejE13drop_elementsCsaCHOb31h0oq_8wasmtime:
  595|  1.27k|    unsafe fn drop_elements(&mut self) {
  596|  1.27k|        if mem::needs_drop::<T>() && !self.is_empty() {
  597|      0|            for item in self.iter() {
  598|      0|                item.drop();
  599|      0|            }
  600|  1.27k|        }
  601|  1.27k|    }
_RNvMs3_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerINtB5_6BucketjE5writeCsaCHOb31h0oq_8wasmtime:
  342|  1.27k|    pub unsafe fn write(&self, val: T) {
  343|  1.27k|        self.as_ptr().write(val);
  344|  1.27k|    }
_RNvMs9_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE22fallible_with_capacityCsaCHOb31h0oq_8wasmtime:
 1096|  1.27k|    fn fallible_with_capacity(
 1097|  1.27k|        alloc: A,
 1098|  1.27k|        table_layout: TableLayout,
 1099|  1.27k|        capacity: usize,
 1100|  1.27k|        fallibility: Fallibility,
 1101|  1.27k|    ) -> Result<Self, TryReserveError> {
 1102|  1.27k|        if capacity == 0 {
 1103|      0|            Ok(Self::new_in(alloc))
 1104|       |        } else {
 1105|       |            unsafe {
 1106|  1.27k|                let buckets =
 1107|  1.27k|                    capacity_to_buckets(capacity).ok_or_else(|| fallibility.capacity_overflow())?;
 1108|       |
 1109|  1.27k|                let result = Self::new_uninitialized(alloc, table_layout, buckets, fallibility)?;
 1110|  1.27k|                result.ctrl(0).write_bytes(EMPTY, result.num_ctrl_bytes());
 1111|  1.27k|
 1112|  1.27k|                Ok(result)
 1113|       |            }
 1114|       |        }
 1115|  1.27k|    }
_RNvMs9_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE14prepare_resizeCsaCHOb31h0oq_8wasmtime:
 1344|  1.27k|    unsafe fn prepare_resize(
 1345|  1.27k|        &self,
 1346|  1.27k|        table_layout: TableLayout,
 1347|  1.27k|        capacity: usize,
 1348|  1.27k|        fallibility: Fallibility,
 1349|  1.27k|    ) -> Result<crate::scopeguard::ScopeGuard<Self, impl FnMut(&mut Self)>, TryReserveError> {
 1350|  1.27k|        debug_assert!(self.items <= capacity);
 1351|       |
 1352|       |        // Allocate and initialize the new table.
 1353|  1.27k|        let mut new_table = RawTableInner::fallible_with_capacity(
 1354|  1.27k|            self.alloc.clone(),
 1355|  1.27k|            table_layout,
 1356|  1.27k|            capacity,
 1357|  1.27k|            fallibility,
 1358|  1.27k|        )?;
 1359|  1.27k|        new_table.growth_left -= self.items;
 1360|  1.27k|        new_table.items = self.items;
 1361|  1.27k|
 1362|  1.27k|        // The hash function may panic, in which case we simply free the new
 1363|  1.27k|        // table without dropping any elements that may have been copied into
 1364|  1.27k|        // it.
 1365|  1.27k|        //
 1366|  1.27k|        // This guard is also used to free the old table on success, see
 1367|  1.27k|        // the comment at the bottom of this function.
 1368|  1.27k|        Ok(guard(new_table, move |self_| {
 1369|       |            if !self_.is_empty_singleton() {
 1370|       |                self_.free_buckets(table_layout);
 1371|       |            }
 1372|  1.27k|        }))
 1373|  1.27k|    }
_RNvMs3_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerINtB5_6BucketjE15from_base_indexCsaCHOb31h0oq_8wasmtime:
  294|  1.27k|    unsafe fn from_base_index(base: NonNull<T>, index: usize) -> Self {
  295|  1.27k|        let ptr = if mem::size_of::<T>() == 0 {
  296|       |            // won't overflow because index must be less than length
  297|      0|            (index + 1) as *mut T
  298|       |        } else {
  299|  1.27k|            base.as_ptr().sub(index)
  300|       |        };
  301|  1.27k|        Self {
  302|  1.27k|            ptr: NonNull::new_unchecked(ptr),
  303|  1.27k|        }
  304|  1.27k|    }
_RNvMs9_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE21record_item_insert_atCsaCHOb31h0oq_8wasmtime:
 1264|  1.27k|    unsafe fn record_item_insert_at(&mut self, index: usize, old_ctrl: u8, hash: u64) {
 1265|  1.27k|        self.growth_left -= usize::from(special_is_empty(old_ctrl));
 1266|  1.27k|        self.set_ctrl_h2(index, hash);
 1267|  1.27k|        self.items += 1;
 1268|  1.27k|    }
_RNvMs9_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE10find_innerCsaCHOb31h0oq_8wasmtime:
 1169|  1.27k|    fn find_inner(&self, hash: u64, eq: &mut dyn FnMut(usize) -> bool) -> Option<usize> {
 1170|  1.27k|        let h2_hash = h2(hash);
 1171|  1.27k|        let mut probe_seq = self.probe_seq(hash);
 1172|       |
 1173|       |        loop {
 1174|  1.27k|            let group = unsafe { Group::load(self.ctrl(probe_seq.pos)) };
 1175|       |
 1176|  1.27k|            for bit in group.match_byte(h2_hash) {
 1177|      0|                let index = (probe_seq.pos + bit) & self.bucket_mask;
 1178|      0|
 1179|      0|                if likely(eq(index)) {
 1180|      0|                    return Some(index);
 1181|      0|                }
 1182|       |            }
 1183|       |
 1184|  1.27k|            if likely(group.match_empty().any_bit_set()) {
 1185|  1.27k|                return None;
 1186|      0|            }
 1187|      0|
 1188|      0|            probe_seq.move_next(self.bucket_mask);
 1189|       |        }
 1190|  1.27k|    }
_RNvMs5_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerINtB5_8RawTablejE8capacityCsaCHOb31h0oq_8wasmtime:
  909|  1.27k|    pub fn capacity(&self) -> usize {
  910|  1.27k|        self.table.items + self.table.growth_left
  911|  1.27k|    }
_RNvMs9_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE12resize_innerCsaCHOb31h0oq_8wasmtime:
 1419|  1.27k|    unsafe fn resize_inner(
 1420|  1.27k|        &mut self,
 1421|  1.27k|        capacity: usize,
 1422|  1.27k|        hasher: &dyn Fn(&mut Self, usize) -> u64,
 1423|  1.27k|        fallibility: Fallibility,
 1424|  1.27k|        layout: TableLayout,
 1425|  1.27k|    ) -> Result<(), TryReserveError> {
 1426|  1.27k|        let mut new_table = self.prepare_resize(layout, capacity, fallibility)?;
 1427|       |
 1428|       |        // Copy all elements to the new table.
 1429|  1.27k|        for i in 0..self.buckets() {
 1430|  1.27k|            if !is_full(*self.ctrl(i)) {
 1431|  1.27k|                continue;
 1432|      0|            }
 1433|      0|
 1434|      0|            // This may panic.
 1435|      0|            let hash = hasher(self, i);
 1436|      0|
 1437|      0|            // We can use a simpler version of insert() here since:
 1438|      0|            // - there are no DELETED entries.
 1439|      0|            // - we know there is enough space in the table.
 1440|      0|            // - all elements are unique.
 1441|      0|            let (index, _) = new_table.prepare_insert_slot(hash);
 1442|      0|
 1443|      0|            ptr::copy_nonoverlapping(
 1444|      0|                self.bucket_ptr(i, layout.size),
 1445|      0|                new_table.bucket_ptr(index, layout.size),
 1446|      0|                layout.size,
 1447|      0|            );
 1448|       |        }
 1449|       |
 1450|       |        // We successfully copied all elements without panicking. Now replace
 1451|       |        // self with the new table. The old table will have its memory freed but
 1452|       |        // the items will not be dropped (since they have been moved into the
 1453|       |        // new table).
 1454|  1.27k|        mem::swap(self, &mut new_table);
 1455|  1.27k|
 1456|  1.27k|        Ok(())
 1457|  1.27k|    }
_RNvMs9_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE8set_ctrlCsaCHOb31h0oq_8wasmtime:
 1295|  1.27k|    unsafe fn set_ctrl(&self, index: usize, ctrl: u8) {
 1296|  1.27k|        // Replicate the first Group::WIDTH control bytes at the end of
 1297|  1.27k|        // the array without using a branch:
 1298|  1.27k|        // - If index >= Group::WIDTH then index == index2.
 1299|  1.27k|        // - Otherwise index2 == self.bucket_mask + 1 + index.
 1300|  1.27k|        //
 1301|  1.27k|        // The very last replicated control byte is never actually read because
 1302|  1.27k|        // we mask the initial index for unaligned loads, but we write it
 1303|  1.27k|        // anyways because it makes the set_ctrl implementation simpler.
 1304|  1.27k|        //
 1305|  1.27k|        // If there are fewer buckets than Group::WIDTH then this code will
 1306|  1.27k|        // replicate the buckets at the end of the trailing group. For example
 1307|  1.27k|        // with 2 buckets and a group size of 4, the control bytes will look
 1308|  1.27k|        // like this:
 1309|  1.27k|        //
 1310|  1.27k|        //     Real    |             Replicated
 1311|  1.27k|        // ---------------------------------------------
 1312|  1.27k|        // | [A] | [B] | [EMPTY] | [EMPTY] | [A] | [B] |
 1313|  1.27k|        // ---------------------------------------------
 1314|  1.27k|        let index2 = ((index.wrapping_sub(Group::WIDTH)) & self.bucket_mask) + Group::WIDTH;
 1315|  1.27k|
 1316|  1.27k|        *self.ctrl(index) = ctrl;
 1317|  1.27k|        *self.ctrl(index2) = ctrl;
 1318|  1.27k|    }
_RINvMs5_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerINtB6_8RawTablejE6insertNCINvNtNtCsiTEx5AzCzpt_8indexmap3map4core8get_hashNtNtCs9pDt8l5wGDA_5alloc6string6StringNtCs15iRE7yYizN_14wasmtime_types11EntityIndexE0ECsaCHOb31h0oq_8wasmtime:
  716|  1.27k|    pub fn insert(&mut self, hash: u64, value: T, hasher: impl Fn(&T) -> u64) -> Bucket<T> {
  717|  1.27k|        unsafe {
  718|  1.27k|            let mut index = self.table.find_insert_slot(hash);
  719|  1.27k|
  720|  1.27k|            // We can avoid growing the table once we have reached our load
  721|  1.27k|            // factor if we are replacing a tombstone. This works since the
  722|  1.27k|            // number of EMPTY slots does not change in this case.
  723|  1.27k|            let old_ctrl = *self.table.ctrl(index);
  724|  1.27k|            if unlikely(self.table.growth_left == 0 && special_is_empty(old_ctrl)) {
  725|  1.27k|                self.reserve(1, hasher);
  726|  1.27k|                index = self.table.find_insert_slot(hash);
  727|  1.27k|            }
  728|       |
  729|  1.27k|            self.table.record_item_insert_at(index, old_ctrl, hash);
  730|  1.27k|
  731|  1.27k|            let bucket = self.bucket(index);
  732|  1.27k|            bucket.write(value);
  733|  1.27k|            bucket
  734|  1.27k|        }
  735|  1.27k|    }
_RINvMs5_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerINtB6_8RawTablejE4findNCINvNtNtCsiTEx5AzCzpt_8indexmap3map4core10equivalentNtNtCs9pDt8l5wGDA_5alloc6string6StringNtCs15iRE7yYizN_14wasmtime_types11EntityIndexB1V_E0ECsaCHOb31h0oq_8wasmtime:
  815|  1.27k|    pub fn find(&self, hash: u64, mut eq: impl FnMut(&T) -> bool) -> Option<Bucket<T>> {
  816|  1.27k|        let result = self.table.find_inner(hash, &mut |index| unsafe {
  817|       |            eq(self.bucket(index).as_ref())
  818|  1.27k|        });
  819|  1.27k|
  820|  1.27k|        // Avoid `Option::map` because it bloats LLVM IR.
  821|  1.27k|        match result {
  822|      0|            Some(index) => Some(unsafe { self.bucket(index) }),
  823|  1.27k|            None => None,
  824|       |        }
  825|  1.27k|    }
_RNvMs5_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerINtB5_8RawTablejE8data_endCsaCHOb31h0oq_8wasmtime:
  501|  1.27k|    pub unsafe fn data_end(&self) -> NonNull<T> {
  502|  1.27k|        NonNull::new_unchecked(self.table.ctrl.as_ptr().cast())
  503|  1.27k|    }
_RINvMs5_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerINtB6_8RawTablejE7reserveNCINvNtNtCsiTEx5AzCzpt_8indexmap3map4core8get_hashNtNtCs9pDt8l5wGDA_5alloc6string6StringNtCs15iRE7yYizN_14wasmtime_types11EntityIndexE0ECsaCHOb31h0oq_8wasmtime:
  643|  1.27k|    pub fn reserve(&mut self, additional: usize, hasher: impl Fn(&T) -> u64) {
  644|  1.27k|        if additional > self.table.growth_left {
  645|       |            // Avoid `Result::unwrap_or_else` because it bloats LLVM IR.
  646|  1.27k|            if self
  647|  1.27k|                .reserve_rehash(additional, hasher, Fallibility::Infallible)
  648|  1.27k|                .is_err()
  649|       |            {
  650|      0|                unsafe { hint::unreachable_unchecked() }
  651|  1.27k|            }
  652|      0|        }
  653|  1.27k|    }
_RINvMs5_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerINtB6_8RawTablejE14reserve_rehashNCINvNtNtCsiTEx5AzCzpt_8indexmap3map4core8get_hashNtNtCs9pDt8l5wGDA_5alloc6string6StringNtCs15iRE7yYizN_14wasmtime_types11EntityIndexE0ECsaCHOb31h0oq_8wasmtime:
  681|  1.27k|                additional,
  682|  1.27k|                &|table, index| hasher(table.bucket::<T>(index).as_ref()),
  683|  1.27k|                fallibility,
  684|  1.27k|                TableLayout::new::<T>(),
  685|  1.27k|                if mem::needs_drop::<T>() {
  686|      0|                    Some(mem::transmute(ptr::drop_in_place::<T> as unsafe fn(*mut T)))
  687|       |                } else {
  688|  1.27k|                    None
  689|       |                },
  690|       |            )
  691|       |        }
  692|  1.27k|    }
_RNvMs9_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE4ctrlCsaCHOb31h0oq_8wasmtime:
 1322|  12.7k|    unsafe fn ctrl(&self, index: usize) -> *mut u8 {
 1323|  12.7k|        debug_assert!(index < self.num_ctrl_bytes());
 1324|  12.7k|        self.ctrl.as_ptr().add(index)
 1325|  12.7k|    }
_RNvMs3_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerINtB5_6BucketjE6as_ptrCsaCHOb31h0oq_8wasmtime:
  314|  1.27k|    pub fn as_ptr(&self) -> *mut T {
  315|  1.27k|        if mem::size_of::<T>() == 0 {
  316|       |            // Just return an arbitrary ZST pointer which is properly aligned
  317|      0|            mem::align_of::<T>() as *mut T
  318|       |        } else {
  319|  1.27k|            unsafe { self.ptr.as_ptr().sub(1) }
  320|       |        }
  321|  1.27k|    }
_RNvMs5_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerINtB5_8RawTablejE6bucketCsaCHOb31h0oq_8wasmtime:
  520|  1.27k|    pub unsafe fn bucket(&self, index: usize) -> Bucket<T> {
  521|  1.27k|        debug_assert_ne!(self.table.bucket_mask, 0);
  522|  1.27k|        debug_assert!(index < self.buckets());
  523|  1.27k|        Bucket::from_base_index(self.data_end(), index)
  524|  1.27k|    }
_RNvMs9_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE17new_uninitializedCsaCHOb31h0oq_8wasmtime:
 1057|  1.27k|    unsafe fn new_uninitialized(
 1058|  1.27k|        alloc: A,
 1059|  1.27k|        table_layout: TableLayout,
 1060|  1.27k|        buckets: usize,
 1061|  1.27k|        fallibility: Fallibility,
 1062|  1.27k|    ) -> Result<Self, TryReserveError> {
 1063|  1.27k|        debug_assert!(buckets.is_power_of_two());
 1064|       |
 1065|       |        // Avoid `Option::ok_or_else` because it bloats LLVM IR.
 1066|  1.27k|        let (layout, ctrl_offset) = match table_layout.calculate_layout_for(buckets) {
 1067|  1.27k|            Some(lco) => lco,
 1068|      0|            None => return Err(fallibility.capacity_overflow()),
 1069|       |        };
 1070|       |
 1071|       |        // We need an additional check to ensure that the allocation doesn't
 1072|       |        // exceed `isize::MAX`. We can skip this check on 64-bit systems since
 1073|       |        // such allocations will never succeed anyways.
 1074|       |        //
 1075|       |        // This mirrors what Vec does in the standard library.
 1076|  1.27k|        if mem::size_of::<usize>() < 8 && layout.size() > isize::MAX as usize {
 1077|      0|            return Err(fallibility.capacity_overflow());
 1078|  1.27k|        }
 1079|       |
 1080|  1.27k|        let ptr: NonNull<u8> = match do_alloc(&alloc, layout) {
 1081|  1.27k|            Ok(block) => block.cast(),
 1082|      0|            Err(_) => return Err(fallibility.alloc_err(layout)),
 1083|       |        };
 1084|       |
 1085|  1.27k|        let ctrl = NonNull::new_unchecked(ptr.as_ptr().add(ctrl_offset));
 1086|  1.27k|        Ok(Self {
 1087|  1.27k|            ctrl,
 1088|  1.27k|            bucket_mask: buckets - 1,
 1089|  1.27k|            items: 0,
 1090|  1.27k|            growth_left: bucket_mask_to_capacity(buckets - 1),
 1091|  1.27k|            alloc,
 1092|  1.27k|        })
 1093|  1.27k|    }
_RNvMs9_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE11set_ctrl_h2CsaCHOb31h0oq_8wasmtime:
 1281|  1.27k|    unsafe fn set_ctrl_h2(&self, index: usize, hash: u64) {
 1282|  1.27k|        self.set_ctrl(index, h2(hash));
 1283|  1.27k|    }
_RNvMs9_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE16find_insert_slotCsaCHOb31h0oq_8wasmtime:
 1134|  2.54k|    fn find_insert_slot(&self, hash: u64) -> usize {
 1135|  2.54k|        let mut probe_seq = self.probe_seq(hash);
 1136|       |        loop {
 1137|       |            unsafe {
 1138|  2.54k|                let group = Group::load(self.ctrl(probe_seq.pos));
 1139|  2.54k|                if let Some(bit) = group.match_empty_or_deleted().lowest_set_bit() {
 1140|  2.54k|                    let result = (probe_seq.pos + bit) & self.bucket_mask;
 1141|  2.54k|
 1142|  2.54k|                    // In tables smaller than the group width, trailing control
 1143|  2.54k|                    // bytes outside the range of the table are filled with
 1144|  2.54k|                    // EMPTY entries. These will unfortunately trigger a
 1145|  2.54k|                    // match, but once masked may point to a full bucket that
 1146|  2.54k|                    // is already occupied. We detect this situation here and
 1147|  2.54k|                    // perform a second scan starting at the beginning of the
 1148|  2.54k|                    // table. This second scan is guaranteed to find an empty
 1149|  2.54k|                    // slot (due to the load factor) before hitting the trailing
 1150|  2.54k|                    // control bytes (containing EMPTY).
 1151|  2.54k|                    if unlikely(is_full(*self.ctrl(result))) {
 1152|      0|                        debug_assert!(self.bucket_mask < Group::WIDTH);
 1153|      0|                        debug_assert_ne!(probe_seq.pos, 0);
 1154|      0|                        return Group::load_aligned(self.ctrl(0))
 1155|      0|                            .match_empty_or_deleted()
 1156|      0|                            .lowest_set_bit_nonzero();
 1157|  2.54k|                    }
 1158|  2.54k|
 1159|  2.54k|                    return result;
 1160|      0|                }
 1161|      0|            }
 1162|      0|            probe_seq.move_next(self.bucket_mask);
 1163|       |        }
 1164|  2.54k|    }
_RNvMs9_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE12free_bucketsCsaCHOb31h0oq_8wasmtime:
 1549|  1.27k|    unsafe fn free_buckets(&mut self, table_layout: TableLayout) {
 1550|       |        // Avoid `Option::unwrap_or_else` because it bloats LLVM IR.
 1551|  1.27k|        let (layout, ctrl_offset) = match table_layout.calculate_layout_for(self.buckets()) {
 1552|  1.27k|            Some(lco) => lco,
 1553|      0|            None => hint::unreachable_unchecked(),
 1554|       |        };
 1555|  1.27k|        self.alloc.deallocate(
 1556|  1.27k|            NonNull::new_unchecked(self.ctrl.as_ptr().sub(ctrl_offset)),
 1557|  1.27k|            layout,
 1558|  1.27k|        );
 1559|  1.27k|    }
_RNvMs9_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE7bucketsCsaCHOb31h0oq_8wasmtime:
 1328|  2.54k|    fn buckets(&self) -> usize {
 1329|  2.54k|        self.bucket_mask + 1
 1330|  2.54k|    }
_RNvMs9_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE20reserve_rehash_innerCsaCHOb31h0oq_8wasmtime:
 1381|  1.27k|    unsafe fn reserve_rehash_inner(
 1382|  1.27k|        &mut self,
 1383|  1.27k|        additional: usize,
 1384|  1.27k|        hasher: &dyn Fn(&mut Self, usize) -> u64,
 1385|  1.27k|        fallibility: Fallibility,
 1386|  1.27k|        layout: TableLayout,
 1387|  1.27k|        drop: Option<fn(*mut u8)>,
 1388|  1.27k|    ) -> Result<(), TryReserveError> {
 1389|       |        // Avoid `Option::ok_or_else` because it bloats LLVM IR.
 1390|  1.27k|        let new_items = match self.items.checked_add(additional) {
 1391|  1.27k|            Some(new_items) => new_items,
 1392|      0|            None => return Err(fallibility.capacity_overflow()),
 1393|       |        };
 1394|  1.27k|        let full_capacity = bucket_mask_to_capacity(self.bucket_mask);
 1395|  1.27k|        if new_items <= full_capacity / 2 {
 1396|       |            // Rehash in-place without re-allocating if we have plenty of spare
 1397|       |            // capacity that is locked up due to DELETED entries.
 1398|      0|            self.rehash_in_place(hasher, layout.size, drop);
 1399|      0|            Ok(())
 1400|       |        } else {
 1401|       |            // Otherwise, conservatively resize to at least the next size up
 1402|       |            // to avoid churning deletes into frequent rehashes.
 1403|  1.27k|            self.resize_inner(
 1404|  1.27k|                usize::max(new_items, full_capacity + 1),
 1405|  1.27k|                hasher,
 1406|  1.27k|                fallibility,
 1407|  1.27k|                layout,
 1408|  1.27k|            )
 1409|       |        }
 1410|  1.27k|    }
_RINvMs0_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerNtB6_11TableLayout3newjECsaCHOb31h0oq_8wasmtime:
  233|  2.54k|    fn new<T>() -> Self {
  234|  2.54k|        let layout = Layout::new::<T>();
  235|  2.54k|        Self {
  236|  2.54k|            size: layout.size(),
  237|  2.54k|            ctrl_align: usize::max(layout.align(), Group::WIDTH),
  238|  2.54k|        }
  239|  2.54k|    }
_RNvMs9_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE14num_ctrl_bytesCsaCHOb31h0oq_8wasmtime:
 1333|  13.9k|    fn num_ctrl_bytes(&self) -> usize {
 1334|  13.9k|        self.bucket_mask + 1 + Group::WIDTH
 1335|  13.9k|    }
_RINvMs5_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerINtB6_8RawTablejE3getNCINvNtNtCsiTEx5AzCzpt_8indexmap3map4core10equivalentNtNtCs9pDt8l5wGDA_5alloc6string6StringNtCs15iRE7yYizN_14wasmtime_types11EntityIndexB1U_E0ECsaCHOb31h0oq_8wasmtime:
  829|  1.27k|    pub fn get(&self, hash: u64, eq: impl FnMut(&T) -> bool) -> Option<&T> {
  830|  1.27k|        // Avoid `Option::map` because it bloats LLVM IR.
  831|  1.27k|        match self.find(hash, eq) {
  832|      0|            Some(bucket) => Some(unsafe { bucket.as_ref() }),
  833|  1.27k|            None => None,
  834|       |        }
  835|  1.27k|    }
_RNvMs5_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerINtB5_8RawTablejE12free_bucketsCsaCHOb31h0oq_8wasmtime:
  495|  1.27k|    unsafe fn free_buckets(&mut self) {
  496|  1.27k|        self.table.free_buckets(TableLayout::new::<T>());
  497|  1.27k|    }
_RNvXse_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerINtB5_8RawTablejENtNtNtCsiloedr2K6v7_4core3ops4drop4Drop4dropCsaCHOb31h0oq_8wasmtime:
 1815|  1.90k|    fn drop(&mut self) {
 1816|  1.90k|        if !self.table.is_empty_singleton() {
 1817|  1.27k|            unsafe {
 1818|  1.27k|                self.drop_elements();
 1819|  1.27k|                self.free_buckets();
 1820|  1.27k|            }
 1821|    636|        }
 1822|  1.90k|    }
_RNvMs5_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerINtB5_8RawTablejE7bucketsCsaCHOb31h0oq_8wasmtime:
  927|  1.27k|    pub fn buckets(&self) -> usize {
  928|  1.27k|        self.table.bucket_mask + 1
  929|  1.27k|    }
_RNvMs9_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE9probe_seqCsaCHOb31h0oq_8wasmtime:
 1241|  3.81k|    fn probe_seq(&self, hash: u64) -> ProbeSeq {
 1242|  3.81k|        ProbeSeq {
 1243|  3.81k|            pos: h1(hash) & self.bucket_mask,
 1244|  3.81k|            stride: 0,
 1245|  3.81k|        }
 1246|  3.81k|    }
_RNvMs4_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerINtB5_8RawTablejE3newCs4vXvIybW1e9_16wasmtime_environ:
  394|  1.27k|    pub const fn new() -> Self {
  395|  1.27k|        Self {
  396|  1.27k|            table: RawTableInner::new_in(Global),
  397|  1.27k|            marker: PhantomData,
  398|  1.27k|        }
  399|  1.27k|    }
_RNvMs8_NtNtCslQVz95dJ1Sv_9hashbrown3raw5innerINtB5_13RawTableInnerNtNtNtB5_5alloc5inner6GlobalE6new_inCs4vXvIybW1e9_16wasmtime_environ:
 1043|  1.27k|    const fn new_in(alloc: A) -> Self {
 1044|  1.27k|        Self {
 1045|  1.27k|            // Be careful to cast the entire slice to a raw pointer.
 1046|  1.27k|            ctrl: unsafe { NonNull::new_unchecked(Group::static_empty() as *const _ as *mut u8) },
 1047|  1.27k|            bucket_mask: 0,
 1048|  1.27k|            items: 0,
 1049|  1.27k|            growth_left: 0,
 1050|  1.27k|            alloc,
 1051|  1.27k|        }
 1052|  1.27k|    }

_RNvMNtNtNtCslQVz95dJ1Sv_9hashbrown3raw5inner4sse2NtB2_5Group22match_empty_or_deleted:
  101|  2.54k|    pub fn match_empty_or_deleted(self) -> BitMask {
  102|  2.54k|        #[allow(
  103|  2.54k|            // byte: i32 as u16
  104|  2.54k|            //   note: _mm_movemask_epi8 returns a 16-bit mask in a i32, the
  105|  2.54k|            //   upper 16-bits of the i32 are zeroed:
  106|  2.54k|            clippy::cast_sign_loss,
  107|  2.54k|            clippy::cast_possible_truncation
  108|  2.54k|        )]
  109|  2.54k|        unsafe {
  110|  2.54k|            // A byte is EMPTY or DELETED iff the high bit is set
  111|  2.54k|            BitMask(x86::_mm_movemask_epi8(self.0) as u16)
  112|  2.54k|        }
  113|  2.54k|    }
_RNvMNtNtNtCslQVz95dJ1Sv_9hashbrown3raw5inner4sse2NtB2_5Group12static_empty:
   33|  1.90k|    pub const fn static_empty() -> &'static [u8; Group::WIDTH] {
   34|  1.90k|        #[repr(C)]
   35|  1.90k|        struct AlignedBytes {
   36|  1.90k|            _align: [Group; 0],
   37|  1.90k|            bytes: [u8; Group::WIDTH],
   38|  1.90k|        }
   39|  1.90k|        const ALIGNED_BYTES: AlignedBytes = AlignedBytes {
   40|  1.90k|            _align: [],
   41|  1.90k|            bytes: [EMPTY; Group::WIDTH],
   42|  1.90k|        };
   43|  1.90k|        &ALIGNED_BYTES.bytes
   44|  1.90k|    }
_RNvMNtNtNtCslQVz95dJ1Sv_9hashbrown3raw5inner4sse2NtB2_5Group4load:
   49|  3.81k|    pub unsafe fn load(ptr: *const u8) -> Self {
   50|  3.81k|        Group(x86::_mm_loadu_si128(ptr.cast()))
   51|  3.81k|    }
_RNvMNtNtNtCslQVz95dJ1Sv_9hashbrown3raw5inner4sse2NtB2_5Group11match_empty:
   94|  1.27k|    pub fn match_empty(self) -> BitMask {
   95|  1.27k|        self.match_byte(EMPTY)
   96|  1.27k|    }
_RNvMNtNtNtCslQVz95dJ1Sv_9hashbrown3raw5inner4sse2NtB2_5Group10match_byte:
   76|  2.54k|    pub fn match_byte(self, byte: u8) -> BitMask {
   77|  2.54k|        #[allow(
   78|  2.54k|            clippy::cast_possible_wrap, // byte: u8 as i8
   79|  2.54k|            // byte: i32 as u16
   80|  2.54k|            //   note: _mm_movemask_epi8 returns a 16-bit mask in a i32, the
   81|  2.54k|            //   upper 16-bits of the i32 are zeroed:
   82|  2.54k|            clippy::cast_sign_loss,
   83|  2.54k|            clippy::cast_possible_truncation
   84|  2.54k|        )]
   85|  2.54k|        unsafe {
   86|  2.54k|            let cmp = x86::_mm_cmpeq_epi8(self.0, x86::_mm_set1_epi8(byte as i8));
   87|  2.54k|            BitMask(x86::_mm_movemask_epi8(cmp) as u16)
   88|  2.54k|        }
   89|  2.54k|    }

_RINvNtCslQVz95dJ1Sv_9hashbrown10scopeguard5guardINtNtNtB4_3raw5inner13RawTableInnerNtNtNtBN_5alloc5inner6GlobalENCNvMs9_BN_BK_14prepare_resize0ECsaCHOb31h0oq_8wasmtime:
   17|  1.27k|pub fn guard<T, F>(value: T, dropfn: F) -> ScopeGuard<T, F>
   18|  1.27k|where
   19|  1.27k|    F: FnMut(&mut T),
   20|  1.27k|{
   21|  1.27k|    ScopeGuard { dropfn, value }
   22|  1.27k|}
_RNvXs0_NtCslQVz95dJ1Sv_9hashbrown10scopeguardINtB5_10ScopeGuardINtNtNtB7_3raw5inner13RawTableInnerNtNtNtB12_5alloc5inner6GlobalENCNvMs9_B12_BZ_14prepare_resize0ENtNtNtCsiloedr2K6v7_4core3ops5deref8DerefMut9deref_mutCsaCHOb31h0oq_8wasmtime:
   61|  1.27k|    fn deref_mut(&mut self) -> &mut T {
   62|  1.27k|        &mut self.value
   63|  1.27k|    }
_RNvXs1_NtCslQVz95dJ1Sv_9hashbrown10scopeguardINtB5_10ScopeGuardINtNtNtB7_3raw5inner13RawTableInnerNtNtNtB12_5alloc5inner6GlobalENCNvMs9_B12_BZ_14prepare_resize0ENtNtNtCsiloedr2K6v7_4core3ops4drop4Drop4dropCsaCHOb31h0oq_8wasmtime:
   71|  1.27k|    fn drop(&mut self) {
   72|  1.27k|        (self.dropfn)(&mut self.value);
   73|  1.27k|    }

_RNvXs1_NtCscrqpmgrAaA6_9humantime4dateNtB5_16Rfc3339TimestampNtNtCsiloedr2K6v7_4core3fmt7Display3fmt:
  251|    636|    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
  252|    636|        use self::Precision::*;
  253|    636|
  254|    636|        let dur = self.0.duration_since(UNIX_EPOCH)
  255|    636|            .expect("all times should be after the epoch");
  256|    636|        let secs_since_epoch = dur.as_secs();
  257|    636|        let nanos = dur.subsec_nanos();
  258|    636|
  259|    636|        if secs_since_epoch >= 253_402_300_800 { // year 9999
  260|      0|            return Err(fmt::Error);
  261|    636|        }
  262|    636|
  263|    636|        /* 2000-03-01 (mod 400 year, immediately after feb29 */
  264|    636|        const LEAPOCH: i64 = 11017;
  265|    636|        const DAYS_PER_400Y: i64 = 365*400 + 97;
  266|    636|        const DAYS_PER_100Y: i64 = 365*100 + 24;
  267|    636|        const DAYS_PER_4Y: i64 = 365*4 + 1;
  268|    636|
  269|    636|        let days = (secs_since_epoch / 86400) as i64 - LEAPOCH;
  270|    636|        let secs_of_day = secs_since_epoch % 86400;
  271|    636|
  272|    636|        let mut qc_cycles = days / DAYS_PER_400Y;
  273|    636|        let mut remdays = days % DAYS_PER_400Y;
  274|    636|
  275|    636|        if remdays < 0 {
  276|      0|            remdays += DAYS_PER_400Y;
  277|      0|            qc_cycles -= 1;
  278|    636|        }
  279|       |
  280|    636|        let mut c_cycles = remdays / DAYS_PER_100Y;
  281|    636|        if c_cycles == 4 { c_cycles -= 1; }
  282|    636|        remdays -= c_cycles * DAYS_PER_100Y;
  283|    636|
  284|    636|        let mut q_cycles = remdays / DAYS_PER_4Y;
  285|    636|        if q_cycles == 25 { q_cycles -= 1; }
  286|    636|        remdays -= q_cycles * DAYS_PER_4Y;
  287|    636|
  288|    636|        let mut remyears = remdays / 365;
  289|    636|        if remyears == 4 { remyears -= 1; }
  290|    636|        remdays -= remyears * 365;
  291|    636|
  292|    636|        let mut year = 2000 +
  293|    636|            remyears + 4*q_cycles + 100*c_cycles + 400*qc_cycles;
  294|    636|
  295|    636|        let months = [31,30,31,30,31,31,30,31,30,31,31,29];
  296|    636|        let mut mon = 0;
  297|  6.36k|        for mon_len in months.iter() {
  298|  6.36k|            mon += 1;
  299|  6.36k|            if remdays < *mon_len {
  300|    636|                break;
  301|  5.72k|            }
  302|  5.72k|            remdays -= *mon_len;
  303|       |        }
  304|    636|        let mday = remdays+1;
  305|    636|        let mon = if mon + 2 > 12 {
  306|      0|            year += 1;
  307|      0|            mon - 10
  308|       |        } else {
  309|    636|            mon + 2
  310|       |        };
  311|       |
  312|    636|        let mut buf: [u8; 30] = [
  313|    636|            // Too long to write as: b"0000-00-00T00:00:00.000000000Z"
  314|    636|            b'0', b'0', b'0', b'0', b'-', b'0', b'0', b'-', b'0', b'0', b'T',
  315|    636|            b'0', b'0', b':', b'0', b'0', b':', b'0', b'0',
  316|    636|            b'.', b'0', b'0', b'0', b'0', b'0', b'0', b'0', b'0', b'0', b'Z',
  317|    636|        ];
  318|    636|        buf[0] = b'0' + (year / 1000) as u8;
  319|    636|        buf[1] = b'0' + (year / 100 % 10) as u8;
  320|    636|        buf[2] = b'0' + (year / 10 % 10) as u8;
  321|    636|        buf[3] = b'0' + (year % 10) as u8;
  322|    636|        buf[5] = b'0' + (mon / 10) as u8;
  323|    636|        buf[6] = b'0' + (mon % 10) as u8;
  324|    636|        buf[8] = b'0' + (mday / 10) as u8;
  325|    636|        buf[9] = b'0' + (mday % 10) as u8;
  326|    636|        buf[11] = b'0' + (secs_of_day / 3600 / 10) as u8;
  327|    636|        buf[12] = b'0' + (secs_of_day / 3600 % 10) as u8;
  328|    636|        buf[14] = b'0' + (secs_of_day / 60 / 10 % 6) as u8;
  329|    636|        buf[15] = b'0' + (secs_of_day / 60 % 10) as u8;
  330|    636|        buf[17] = b'0' + (secs_of_day / 10 % 6) as u8;
  331|    636|        buf[18] = b'0' + (secs_of_day % 10) as u8;
  332|       |
  333|    636|        let offset = if self.1 == Seconds || nanos == 0 && self.1 == Smart {
  334|    636|            buf[19] = b'Z';
  335|    636|            19
  336|      0|        } else if self.1 == Millis {
  337|      0|            buf[20] = b'0' + (nanos / 100_000_000) as u8;
  338|      0|            buf[21] = b'0' + (nanos / 10_000_000 % 10) as u8;
  339|      0|            buf[22] = b'0' + (nanos / 1_000_000 % 10) as u8;
  340|      0|            buf[23] = b'Z';
  341|      0|            23
  342|      0|        } else if self.1 == Micros {
  343|      0|            buf[20] = b'0' + (nanos / 100_000_000) as u8;
  344|      0|            buf[21] = b'0' + (nanos / 10_000_000 % 10) as u8;
  345|      0|            buf[22] = b'0' + (nanos / 1_000_000 % 10) as u8;
  346|      0|            buf[23] = b'0' + (nanos / 100_000 % 10) as u8;
  347|      0|            buf[24] = b'0' + (nanos / 10_000 % 10) as u8;
  348|      0|            buf[25] = b'0' + (nanos / 1_000 % 10) as u8;
  349|      0|            buf[26] = b'Z';
  350|      0|            26
  351|       |        } else {
  352|      0|            buf[20] = b'0' + (nanos / 100_000_000) as u8;
  353|      0|            buf[21] = b'0' + (nanos / 10_000_000 % 10) as u8;
  354|      0|            buf[22] = b'0' + (nanos / 1_000_000 % 10) as u8;
  355|      0|            buf[23] = b'0' + (nanos / 100_000 % 10) as u8;
  356|      0|            buf[24] = b'0' + (nanos / 10_000 % 10) as u8;
  357|      0|            buf[25] = b'0' + (nanos / 1_000 % 10) as u8;
  358|      0|            buf[26] = b'0' + (nanos / 100 % 10) as u8;
  359|      0|            buf[27] = b'0' + (nanos / 10 % 10) as u8;
  360|      0|            buf[28] = b'0' + (nanos / 1 % 10) as u8;
  361|      0|            // 29th is 'Z'
  362|      0|            29
  363|       |        };
  364|       |
  365|       |        // we know our chars are all ascii
  366|    636|        f.write_str(str::from_utf8(&buf[..=offset]).expect("Conversion to utf8 failed"))
  367|    636|    }
_RNvXsa_NtCscrqpmgrAaA6_9humantime4dateNtB5_9PrecisionNtNtCsiloedr2K6v7_4core3cmp9PartialEq2eq:
   58|    636|#[derive(Debug, Clone, PartialEq, Eq)]
_RNvNtCscrqpmgrAaA6_9humantime4date22format_rfc3339_seconds:
  212|    636|pub fn format_rfc3339_seconds(system_time: SystemTime) -> Rfc3339Timestamp {
  213|    636|    Rfc3339Timestamp(system_time, Precision::Seconds)
  214|    636|}

_RNvMCsiTEx5AzCzpt_8indexmapNtB2_9HashValue3get:
  123|  2.54k|    fn get(self) -> u64 {
  124|  2.54k|        self.0 as u64
  125|  2.54k|    }

_RNvXs12_NtCsiTEx5AzCzpt_8indexmap3mapINtB6_8IndexMapNtNtCs9pDt8l5wGDA_5alloc6string6StringNtCs15iRE7yYizN_14wasmtime_types11EntityIndexENtNtCsiloedr2K6v7_4core7default7Default7defaultCskJihg1y13m7_3fvm:
 1495|    636|    fn default() -> Self {
 1496|    636|        Self::with_capacity_and_hasher(0, S::default())
 1497|    636|    }
_RNvMs2_NtCsiTEx5AzCzpt_8indexmap3mapINtB5_8IndexMapNtNtCs9pDt8l5wGDA_5alloc6string6StringNtCs15iRE7yYizN_14wasmtime_types11EntityIndexE24with_capacity_and_hasherCskJihg1y13m7_3fvm:
  167|    636|    pub fn with_capacity_and_hasher(n: usize, hash_builder: S) -> Self {
  168|    636|        if n == 0 {
  169|    636|            Self::with_hasher(hash_builder)
  170|       |        } else {
  171|      0|            IndexMap {
  172|      0|                core: IndexMapCore::with_capacity(n),
  173|      0|                hash_builder,
  174|      0|            }
  175|       |        }
  176|    636|    }
_RNvMs2_NtCsiTEx5AzCzpt_8indexmap3mapINtB5_8IndexMapNtNtCs9pDt8l5wGDA_5alloc6string6StringNtCs15iRE7yYizN_14wasmtime_types11EntityIndexE11with_hasherCskJihg1y13m7_3fvm:
  182|    636|    pub const fn with_hasher(hash_builder: S) -> Self {
  183|    636|        IndexMap {
  184|    636|            core: IndexMapCore::new(),
  185|    636|            hash_builder,
  186|    636|        }
  187|    636|    }
_RINvMs3_NtCsiTEx5AzCzpt_8indexmap3mapINtB6_8IndexMapNtNtCs9pDt8l5wGDA_5alloc6string6StringNtCs15iRE7yYizN_14wasmtime_types11EntityIndexE4hashBO_ECsaCHOb31h0oq_8wasmtime:
  345|  1.27k|    fn hash<Q: ?Sized + Hash>(&self, key: &Q) -> HashValue {
  346|  1.27k|        let mut h = self.hash_builder.build_hasher();
  347|  1.27k|        key.hash(&mut h);
  348|  1.27k|        HashValue(h.finish() as usize)
  349|  1.27k|    }
_RNvMs3_NtCsiTEx5AzCzpt_8indexmap3mapINtB5_8IndexMapNtNtCs9pDt8l5wGDA_5alloc6string6StringNtCs15iRE7yYizN_14wasmtime_types11EntityIndexE11insert_fullCsaCHOb31h0oq_8wasmtime:
  381|  1.27k|    pub fn insert_full(&mut self, key: K, value: V) -> (usize, Option<V>) {
  382|  1.27k|        let hash = self.hash(&key);
  383|  1.27k|        self.core.insert_full(hash, key, value)
  384|  1.27k|    }
_RNvMs3_NtCsiTEx5AzCzpt_8indexmap3mapINtB5_8IndexMapNtNtCs9pDt8l5wGDA_5alloc6string6StringNtCs15iRE7yYizN_14wasmtime_types11EntityIndexE6insertCsaCHOb31h0oq_8wasmtime:
  364|  1.27k|    pub fn insert(&mut self, key: K, value: V) -> Option<V> {
  365|  1.27k|        self.insert_full(key, value).1
  366|  1.27k|    }
_RNvMs2_NtCsiTEx5AzCzpt_8indexmap3mapINtB5_8IndexMapNtNtCs9pDt8l5wGDA_5alloc6string6StringNtCs15iRE7yYizN_14wasmtime_types11EntityIndexE24with_capacity_and_hasherCs4vXvIybW1e9_16wasmtime_environ:
  167|  1.27k|    pub fn with_capacity_and_hasher(n: usize, hash_builder: S) -> Self {
  168|  1.27k|        if n == 0 {
  169|  1.27k|            Self::with_hasher(hash_builder)
  170|       |        } else {
  171|      0|            IndexMap {
  172|      0|                core: IndexMapCore::with_capacity(n),
  173|      0|                hash_builder,
  174|      0|            }
  175|       |        }
  176|  1.27k|    }
_RNvXs12_NtCsiTEx5AzCzpt_8indexmap3mapINtB6_8IndexMapNtNtCs9pDt8l5wGDA_5alloc6string6StringNtCs15iRE7yYizN_14wasmtime_types11EntityIndexENtNtCsiloedr2K6v7_4core7default7Default7defaultCs4vXvIybW1e9_16wasmtime_environ:
 1495|  1.27k|    fn default() -> Self {
 1496|  1.27k|        Self::with_capacity_and_hasher(0, S::default())
 1497|  1.27k|    }
_RNvMs2_NtCsiTEx5AzCzpt_8indexmap3mapINtB5_8IndexMapNtNtCs9pDt8l5wGDA_5alloc6string6StringNtCs15iRE7yYizN_14wasmtime_types11EntityIndexE11with_hasherCs4vXvIybW1e9_16wasmtime_environ:
  182|  1.27k|    pub const fn with_hasher(hash_builder: S) -> Self {
  183|  1.27k|        IndexMap {
  184|  1.27k|            core: IndexMapCore::new(),
  185|  1.27k|            hash_builder,
  186|  1.27k|        }
  187|  1.27k|    }

_RNvMs1_NtNtCsiTEx5AzCzpt_8indexmap3map4coreINtB5_12IndexMapCoreNtNtCs9pDt8l5wGDA_5alloc6string6StringNtCs15iRE7yYizN_14wasmtime_types11EntityIndexE3newCskJihg1y13m7_3fvm:
  124|    636|    pub(crate) const fn new() -> Self {
  125|    636|        IndexMapCore {
  126|    636|            indices: RawTable::new(),
  127|    636|            entries: Vec::new(),
  128|    636|        }
  129|    636|    }
_RNvMs1_NtNtCsiTEx5AzCzpt_8indexmap3map4coreINtB5_12IndexMapCoreNtNtCs9pDt8l5wGDA_5alloc6string6StringNtCs15iRE7yYizN_14wasmtime_types11EntityIndexE15reserve_entriesCsaCHOb31h0oq_8wasmtime:
  200|  1.27k|    fn reserve_entries(&mut self) {
  201|  1.27k|        let additional = self.indices.capacity() - self.entries.len();
  202|  1.27k|        self.entries.reserve_exact(additional);
  203|  1.27k|    }
_RNvMs1_NtNtCsiTEx5AzCzpt_8indexmap3map4coreINtB5_12IndexMapCoreNtNtCs9pDt8l5wGDA_5alloc6string6StringNtCs15iRE7yYizN_14wasmtime_types11EntityIndexE4pushCsaCHOb31h0oq_8wasmtime:
  225|  1.27k|    fn push(&mut self, hash: HashValue, key: K, value: V) -> usize {
  226|  1.27k|        let i = self.entries.len();
  227|  1.27k|        self.indices.insert(hash.get(), i, get_hash(&self.entries));
  228|  1.27k|        if i == self.entries.capacity() {
  229|  1.27k|            // Reserve our own capacity synced to the indices,
  230|  1.27k|            // rather than letting `Vec::push` just double it.
  231|  1.27k|            self.reserve_entries();
  232|  1.27k|        }
  233|  1.27k|        self.entries.push(Bucket { hash, key, value });
  234|  1.27k|        i
  235|  1.27k|    }
_RINvNtNtCsiTEx5AzCzpt_8indexmap3map4core8get_hashNtNtCs9pDt8l5wGDA_5alloc6string6StringNtCs15iRE7yYizN_14wasmtime_types11EntityIndexECsaCHOb31h0oq_8wasmtime:
   33|  1.27k|fn get_hash<K, V>(entries: &[Bucket<K, V>]) -> impl Fn(&usize) -> u64 + '_ {
   34|       |    move |&i| entries[i].hash.get()
   35|  1.27k|}
_RNvMs1_NtNtCsiTEx5AzCzpt_8indexmap3map4coreINtB5_12IndexMapCoreNtNtCs9pDt8l5wGDA_5alloc6string6StringNtCs15iRE7yYizN_14wasmtime_types11EntityIndexE11insert_fullCsaCHOb31h0oq_8wasmtime:
  246|  1.27k|    pub(crate) fn insert_full(&mut self, hash: HashValue, key: K, value: V) -> (usize, Option<V>)
  247|  1.27k|    where
  248|  1.27k|        K: Eq,
  249|  1.27k|    {
  250|  1.27k|        match self.get_index_of(hash, &key) {
  251|      0|            Some(i) => (i, Some(replace(&mut self.entries[i].value, value))),
  252|  1.27k|            None => (self.push(hash, key, value), None),
  253|       |        }
  254|  1.27k|    }
_RINvMs1_NtNtCsiTEx5AzCzpt_8indexmap3map4coreINtB6_12IndexMapCoreNtNtCs9pDt8l5wGDA_5alloc6string6StringNtCs15iRE7yYizN_14wasmtime_types11EntityIndexE12get_index_ofB10_ECsaCHOb31h0oq_8wasmtime:
  238|  1.27k|    pub(crate) fn get_index_of<Q>(&self, hash: HashValue, key: &Q) -> Option<usize>
  239|  1.27k|    where
  240|  1.27k|        Q: ?Sized + Equivalent<K>,
  241|  1.27k|    {
  242|  1.27k|        let eq = equivalent(key, &self.entries);
  243|  1.27k|        self.indices.get(hash.get(), eq).copied()
  244|  1.27k|    }
_RINvNtNtCsiTEx5AzCzpt_8indexmap3map4core10equivalentNtNtCs9pDt8l5wGDA_5alloc6string6StringNtCs15iRE7yYizN_14wasmtime_types11EntityIndexBO_ECsaCHOb31h0oq_8wasmtime:
   38|  1.27k|fn equivalent<'a, K, V, Q: ?Sized + Equivalent<K>>(
   39|  1.27k|    key: &'a Q,
   40|  1.27k|    entries: &'a [Bucket<K, V>],
   41|  1.27k|) -> impl Fn(&usize) -> bool + 'a {
   42|       |    move |&i| Q::equivalent(key, &entries[i].key)
   43|  1.27k|}
_RNvMs1_NtNtCsiTEx5AzCzpt_8indexmap3map4coreINtB5_12IndexMapCoreNtNtCs9pDt8l5wGDA_5alloc6string6StringNtCs15iRE7yYizN_14wasmtime_types11EntityIndexE3newCs4vXvIybW1e9_16wasmtime_environ:
  124|  1.27k|    pub(crate) const fn new() -> Self {
  125|  1.27k|        IndexMapCore {
  126|  1.27k|            indices: RawTable::new(),
  127|  1.27k|            entries: Vec::new(),
  128|  1.27k|        }
  129|  1.27k|    }

_RNCINvXs2_NtCs6tDja42JiUB_16integer_encoding6readerQRShNtB8_17VarIntAsyncReader17read_varint_asyncjE0Cs7AwuCMXPzRZ_8fvm_fuzz:
   70|  6.04k|    async fn read_varint_async<VI: VarInt>(&mut self) -> Result<VI> {
   71|  6.04k|        let mut buf = [0 as u8; 1];
   72|  6.04k|        let mut p = VarIntProcessor::new::<VI>();
   73|       |
   74|  21.6k|        while !p.finished() {
   75|  15.9k|            let read = self.read(&mut buf).await?;
   76|       |
   77|       |            // EOF
   78|  15.9k|            if read == 0 && p.i == 0 {
   79|    318|                return Err(io::Error::new(io::ErrorKind::UnexpectedEof, "Reached EOF"));
   80|  15.5k|            }
   81|  15.5k|            if read == 0 {
   82|      0|                break;
   83|  15.5k|            }
   84|  15.5k|
   85|  15.5k|            p.push(buf[0])?;
   86|       |        }
   87|       |
   88|  5.72k|        p.decode()
   89|  5.72k|            .ok_or_else(|| io::Error::new(io::ErrorKind::UnexpectedEof, "Reached EOF"))
   90|  12.0k|    }
_RINvXs2_NtCs6tDja42JiUB_16integer_encoding6readerQRShNtB6_17VarIntAsyncReader17read_varint_asyncjECs7AwuCMXPzRZ_8fvm_fuzz:
   70|  6.04k|    async fn read_varint_async<VI: VarInt>(&mut self) -> Result<VI> {
_RNvXs1_NtCs6tDja42JiUB_16integer_encoding6readerNtB5_15VarIntProcessorNtNtCsiloedr2K6v7_4core7default7Default7default:
   34|  6.04k|#[derive(Default)]
_RINvMNtCs6tDja42JiUB_16integer_encoding6readerNtB3_15VarIntProcessor3newjECs7AwuCMXPzRZ_8fvm_fuzz:
   42|  6.04k|    fn new<VI: VarIntMaxSize>() -> VarIntProcessor {
   43|  6.04k|        VarIntProcessor {
   44|  6.04k|            maxsize: VI::varint_max_size(),
   45|  6.04k|            ..VarIntProcessor::default()
   46|  6.04k|        }
   47|  6.04k|    }
_RINvMNtCs6tDja42JiUB_16integer_encoding6readerNtB3_15VarIntProcessor6decodejECs7AwuCMXPzRZ_8fvm_fuzz:
   62|  5.72k|    fn decode<VI: VarInt>(&self) -> Option<VI> {
   63|  5.72k|        Some(VI::decode_var(&self.buf[0..self.i])?.0)
   64|  5.72k|    }
_RNvMNtCs6tDja42JiUB_16integer_encoding6readerNtB2_15VarIntProcessor8finished:
   59|  21.6k|    fn finished(&self) -> bool {
   60|  21.6k|        self.i > 0 && (self.buf[self.i - 1] & MSB == 0)
   61|  21.6k|    }
_RNvMNtCs6tDja42JiUB_16integer_encoding6readerNtB2_15VarIntProcessor4push:
   48|  15.5k|    fn push(&mut self, b: u8) -> Result<()> {
   49|  15.5k|        if self.i >= self.maxsize {
   50|      0|            return Err(io::Error::new(
   51|      0|                io::ErrorKind::InvalidData,
   52|      0|                "Unterminated varint",
   53|      0|            ));
   54|  15.5k|        }
   55|  15.5k|        self.buf[self.i] = b;
   56|  15.5k|        self.i += 1;
   57|  15.5k|        Ok(())
   58|  15.5k|    }

_RNvXNtCs6tDja42JiUB_16integer_encoding6varintjNtB2_13VarIntMaxSize15varint_max_sizeCs7AwuCMXPzRZ_8fvm_fuzz:
   74|  6.04k|    fn varint_max_size() -> usize {
   75|  6.04k|        (size_of::<VI>() * 8 + 7) / 7
   76|  6.04k|    }
_RNvXs_NtCs6tDja42JiUB_16integer_encoding6varintyNtB4_6VarInt10decode_var:
  133|  5.72k|    fn decode_var(src: &[u8]) -> Option<(Self, usize)> {
  134|  5.72k|        let mut result: u64 = 0;
  135|  5.72k|        let mut shift = 0;
  136|  5.72k|
  137|  5.72k|        let mut success = false;
  138|  15.5k|        for b in src.iter() {
  139|  15.5k|            let msb_dropped = b & DROP_MSB;
  140|  15.5k|            result |= (msb_dropped as u64) << shift;
  141|  15.5k|            shift += 7;
  142|  15.5k|
  143|  15.5k|            if b & MSB == 0 || shift > (9 * 7) {
  144|  5.72k|                success = b & MSB == 0;
  145|  5.72k|                break;
  146|  9.85k|            }
  147|       |        }
  148|       |
  149|  5.72k|        if success {
  150|  5.72k|            Some((result, shift / 7 as usize))
  151|       |        } else {
  152|      0|            None
  153|       |        }
  154|  5.72k|    }
_RNvXs1_NtCs6tDja42JiUB_16integer_encoding6varintjNtB5_6VarInt10decode_var:
   86|  5.72k|            fn decode_var(src: &[u8]) -> Option<(Self, usize)> {
   87|  5.72k|                let (n, s) = u64::decode_var(src)?;
   88|  5.72k|                Some((n as Self, s))
   89|  5.72k|            }

_RINvMNtCsaivYXJjNCMq_11lazy_static4lazyINtB3_4LazyNtNtNtCskJihg1y13m7_3fvm3gas10price_list9PriceListE3getNvNvXs5_BO_NtBO_12HYGGE_PRICESNtNtNtCsiloedr2K6v7_4core3ops5deref5Deref5deref23___static_ref_initializeEBS_:
   26|    636|    pub fn get<F>(&'static self, f: F) -> &T
   27|    636|    where
   28|    636|        F: FnOnce() -> T,
   29|    636|    {
   30|    636|        self.1.call_once(|| {
   31|       |            self.0.set(Some(f()));
   32|    636|        });
   33|    636|
   34|    636|        // `self.0` is guaranteed to be `Some` by this point
   35|    636|        // The `Once` will catch and propagate panics
   36|    636|        unsafe {
   37|    636|            match *self.0.as_ptr() {
   38|    636|                Some(ref x) => x,
   39|       |                None => {
   40|      0|                    debug_assert!(false, "attempted to derefence an uninitialized lazy static. This is a bug");
   41|       |
   42|      0|                    unreachable_unchecked()
   43|       |                },
   44|       |            }
   45|       |        }
   46|    636|    }
_RNCINvMNtCsaivYXJjNCMq_11lazy_static4lazyINtB5_4LazyNtNtNtCskJihg1y13m7_3fvm3gas10price_list9PriceListE3getNvNvXs5_BQ_NtBQ_12HYGGE_PRICESNtNtNtCsiloedr2K6v7_4core3ops5deref5Deref5deref23___static_ref_initializeE0BU_:
   30|      1|        self.1.call_once(|| {
   31|      1|            self.0.set(Some(f()));
   32|      1|        });
_RINvMNtCsaivYXJjNCMq_11lazy_static4lazyINtB3_4LazyNtNtCs83Z8YCK0meJ_10fvm_shared4econ11TokenAmountE3getNvNvXs_BQ_NtBQ_14TOTAL_FILECOINNtNtNtCsiloedr2K6v7_4core3ops5deref5Deref5deref23___static_ref_initializeEBQ_:
   26|    318|    pub fn get<F>(&'static self, f: F) -> &T
   27|    318|    where
   28|    318|        F: FnOnce() -> T,
   29|    318|    {
   30|    318|        self.1.call_once(|| {
   31|       |            self.0.set(Some(f()));
   32|    318|        });
   33|    318|
   34|    318|        // `self.0` is guaranteed to be `Some` by this point
   35|    318|        // The `Once` will catch and propagate panics
   36|    318|        unsafe {
   37|    318|            match *self.0.as_ptr() {
   38|    318|                Some(ref x) => x,
   39|       |                None => {
   40|      0|                    debug_assert!(false, "attempted to derefence an uninitialized lazy static. This is a bug");
   41|       |
   42|      0|                    unreachable_unchecked()
   43|       |                },
   44|       |            }
   45|       |        }
   46|    318|    }
_RNCINvMNtCsaivYXJjNCMq_11lazy_static4lazyINtB5_4LazyNtNtCs83Z8YCK0meJ_10fvm_shared4econ11TokenAmountE3getNvNvXs_BS_NtBS_14TOTAL_FILECOINNtNtNtCsiloedr2K6v7_4core3ops5deref5Deref5deref23___static_ref_initializeE0BS_:
   30|      1|        self.1.call_once(|| {
   31|      1|            self.0.set(Some(f()));
   32|      1|        });

_RNvNvXs5_NtNtCskJihg1y13m7_3fvm3gas10price_listNtB7_12HYGGE_PRICESNtNtNtCsiloedr2K6v7_4core3ops5deref5Deref5deref23___static_ref_initialize:
  137|      1|                fn __static_ref_initialize() -> $T { $e }
_RNvXs5_NtNtCskJihg1y13m7_3fvm3gas10price_listNtB5_12HYGGE_PRICESNtNtNtCsiloedr2K6v7_4core3ops5deref5Deref5deref:
  135|    636|            fn deref(&self) -> &$T {
  136|    636|                #[inline(always)]
  137|    636|                fn __static_ref_initialize() -> $T { $e }
  138|    636|
  139|    636|                #[inline(always)]
  140|    636|                fn __stability() -> &'static $T {
  141|    636|                    __lazy_static_create!(LAZY, $T);
  142|    636|                    LAZY.get(__static_ref_initialize)
  143|    636|                }
  144|    636|                __stability()
  145|    636|            }
_RNvNvXs5_NtNtCskJihg1y13m7_3fvm3gas10price_listNtB7_12HYGGE_PRICESNtNtNtCsiloedr2K6v7_4core3ops5deref5Deref5deref11___stability:
  140|    636|                fn __stability() -> &'static $T {
  141|    636|                    __lazy_static_create!(LAZY, $T);
  142|    636|                    LAZY.get(__static_ref_initialize)
  143|    636|                }
_RNvNvXs_Cs83Z8YCK0meJ_10fvm_sharedNtB6_14TOTAL_FILECOINNtNtNtCsiloedr2K6v7_4core3ops5deref5Deref5deref23___static_ref_initialize:
  137|      1|                fn __static_ref_initialize() -> $T { $e }
_RNvXs_Cs83Z8YCK0meJ_10fvm_sharedNtB4_14TOTAL_FILECOINNtNtNtCsiloedr2K6v7_4core3ops5deref5Deref5deref:
  135|    318|            fn deref(&self) -> &$T {
  136|    318|                #[inline(always)]
  137|    318|                fn __static_ref_initialize() -> $T { $e }
  138|    318|
  139|    318|                #[inline(always)]
  140|    318|                fn __stability() -> &'static $T {
  141|    318|                    __lazy_static_create!(LAZY, $T);
  142|    318|                    LAZY.get(__static_ref_initialize)
  143|    318|                }
  144|    318|                __stability()
  145|    318|            }
_RNvNvXs_Cs83Z8YCK0meJ_10fvm_sharedNtB6_14TOTAL_FILECOINNtNtNtCsiloedr2K6v7_4core3ops5deref5Deref5deref11___stability:
  140|    318|                fn __stability() -> &'static $T {
  141|    318|                    __lazy_static_create!(LAZY, $T);
  142|    318|                    LAZY.get(__static_ref_initialize)
  143|    318|                }

_RNvNvCsboUdcTbF1FS_15direct_syscalls1__3run:
  241|    318|            fn run($bytes: &[u8]) {
  242|    318|                $body
  243|    318|            }
rust_fuzzer_test_input:
  215|    318|                if let Some(path) = $crate::RUST_LIBFUZZER_DEBUG_PATH.get() {
  216|       |                    use std::io::Write;
  217|      0|                    let mut file = std::fs::File::create(path)
  218|      0|                        .expect("failed to create `RUST_LIBFUZZER_DEBUG_PATH` file");
  219|      0|                    writeln!(&mut file, "{:?}", bytes)
  220|      0|                        .expect("failed to write to `RUST_LIBFUZZER_DEBUG_PATH` file");
  221|      0|                    return 0;
  222|    318|                }
  223|    318|
  224|    318|                run(bytes);
  225|    318|                0
  226|    318|            }
LLVMFuzzerTestOneInput:
   58|    318|pub fn test_input_wrap(data: *const u8, size: usize) -> i32 {
   59|    318|    let test_input = ::std::panic::catch_unwind(|| unsafe {
   60|       |        let data_slice = ::std::slice::from_raw_parts(data, size);
   61|       |        rust_fuzzer_test_input(data_slice)
   62|    318|    });
   63|    318|
   64|    318|    match test_input {
   65|    318|        Ok(i) => i,
   66|       |        Err(_) => {
   67|       |            // hopefully the custom panic hook will be called before and abort the
   68|       |            // process before the stack frames are unwinded.
   69|      0|            ::std::process::abort();
   70|       |        }
   71|       |    }
   72|    318|}
_RNCNvCsectetNjpKGl_13libfuzzer_sys15test_input_wrap0B3_:
   59|    318|    let test_input = ::std::panic::catch_unwind(|| unsafe {
   60|    318|        let data_slice = ::std::slice::from_raw_parts(data, size);
   61|    318|        rust_fuzzer_test_input(data_slice)
   62|    318|    });
LLVMFuzzerInitialize:
   79|      2|pub fn initialize(_argc: *const isize, _argv: *const *const *const u8) -> isize {
   80|      2|    // Registers a panic hook that aborts the process before unwinding.
   81|      2|    // It is useful to abort before unwinding so that the fuzzer will then be
   82|      2|    // able to analyse the process stack frames to tell different bugs appart.
   83|      2|    //
   84|      2|    // HACK / FIXME: it would be better to use `-C panic=abort` but it's currently
   85|      2|    // impossible to build code using compiler plugins with this flag.
   86|      2|    // We will be able to remove this code when
   87|      2|    // https://github.com/rust-lang/cargo/issues/5423 is fixed.
   88|      2|    let default_hook = ::std::panic::take_hook();
   89|      2|    ::std::panic::set_hook(Box::new(move |panic_info| {
   90|       |        default_hook(panic_info);
   91|       |        ::std::process::abort();
   92|      2|    }));
   93|       |
   94|       |    // Initialize the `RUST_LIBFUZZER_DEBUG_PATH` cell with the path so it can be
   95|       |    // reused with little overhead.
   96|      2|    if let Ok(path) = std::env::var("RUST_LIBFUZZER_DEBUG_PATH") {
   97|      0|        RUST_LIBFUZZER_DEBUG_PATH
   98|      0|            .set(path)
   99|      0|            .expect("Since this is initialize it is only called once so can never fail");
  100|      2|    }
  101|      2|    0
  102|      2|}

_RINvXNtNtCs3TS9n28v4Rl_12libipld_core5serde2deNtNtB7_4ipld4IpldNtNtCssVaLrL3Upj_5serde2de11Deserialize11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECsboUdcTbF1FS_15direct_syscalls:
   60|  8.58k|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
   61|  8.58k|    where
   62|  8.58k|        D: de::Deserializer<'de>,
   63|  8.58k|    {
   64|  8.58k|        struct IpldVisitor;
   65|  8.58k|
   66|  8.58k|        impl<'de> de::Visitor<'de> for IpldVisitor {
   67|  8.58k|            type Value = Ipld;
   68|  8.58k|
   69|  8.58k|            fn expecting(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
   70|  8.58k|                fmt.write_str("any valid IPLD kind")
   71|  8.58k|            }
   72|  8.58k|
   73|  8.58k|            #[inline]
   74|  8.58k|            fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>
   75|  8.58k|            where
   76|  8.58k|                E: de::Error,
   77|  8.58k|            {
   78|  8.58k|                Ok(Ipld::String(String::from(value)))
   79|  8.58k|            }
   80|  8.58k|
   81|  8.58k|            #[inline]
   82|  8.58k|            fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>
   83|  8.58k|            where
   84|  8.58k|                E: de::Error,
   85|  8.58k|            {
   86|  8.58k|                self.visit_byte_buf(v.to_owned())
   87|  8.58k|            }
   88|  8.58k|
   89|  8.58k|            #[inline]
   90|  8.58k|            fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<Self::Value, E>
   91|  8.58k|            where
   92|  8.58k|                E: de::Error,
   93|  8.58k|            {
   94|  8.58k|                Ok(Ipld::Bytes(v))
   95|  8.58k|            }
   96|  8.58k|
   97|  8.58k|            #[inline]
   98|  8.58k|            fn visit_u64<E>(self, v: u64) -> Result<Self::Value, E>
   99|  8.58k|            where
  100|  8.58k|                E: de::Error,
  101|  8.58k|            {
  102|  8.58k|                Ok(Ipld::Integer(v.into()))
  103|  8.58k|            }
  104|  8.58k|
  105|  8.58k|            #[inline]
  106|  8.58k|            fn visit_i64<E>(self, v: i64) -> Result<Self::Value, E>
  107|  8.58k|            where
  108|  8.58k|                E: de::Error,
  109|  8.58k|            {
  110|  8.58k|                Ok(Ipld::Integer(v.into()))
  111|  8.58k|            }
  112|  8.58k|
  113|  8.58k|            #[inline]
  114|  8.58k|            fn visit_i128<E>(self, v: i128) -> Result<Self::Value, E>
  115|  8.58k|            where
  116|  8.58k|                E: de::Error,
  117|  8.58k|            {
  118|  8.58k|                Ok(Ipld::Integer(v))
  119|  8.58k|            }
  120|  8.58k|
  121|  8.58k|            #[inline]
  122|  8.58k|            fn visit_f64<E>(self, v: f64) -> Result<Self::Value, E>
  123|  8.58k|            where
  124|  8.58k|                E: de::Error,
  125|  8.58k|            {
  126|  8.58k|                Ok(Ipld::Float(v))
  127|  8.58k|            }
  128|  8.58k|
  129|  8.58k|            #[inline]
  130|  8.58k|            fn visit_bool<E>(self, v: bool) -> Result<Self::Value, E>
  131|  8.58k|            where
  132|  8.58k|                E: de::Error,
  133|  8.58k|            {
  134|  8.58k|                Ok(Ipld::Bool(v))
  135|  8.58k|            }
  136|  8.58k|
  137|  8.58k|            #[inline]
  138|  8.58k|            fn visit_none<E>(self) -> Result<Self::Value, E>
  139|  8.58k|            where
  140|  8.58k|                E: de::Error,
  141|  8.58k|            {
  142|  8.58k|                Ok(Ipld::Null)
  143|  8.58k|            }
  144|  8.58k|
  145|  8.58k|            #[inline]
  146|  8.58k|            fn visit_seq<V>(self, mut visitor: V) -> Result<Self::Value, V::Error>
  147|  8.58k|            where
  148|  8.58k|                V: de::SeqAccess<'de>,
  149|  8.58k|            {
  150|  8.58k|                let mut vec = Vec::with_capacity(visitor.size_hint().unwrap_or(0));
  151|  8.58k|
  152|  8.58k|                while let Some(elem) = visitor.next_element()? {
  153|  8.58k|                    vec.push(elem);
  154|  8.58k|                }
  155|  8.58k|
  156|  8.58k|                Ok(Ipld::List(vec))
  157|  8.58k|            }
  158|  8.58k|
  159|  8.58k|            #[inline]
  160|  8.58k|            fn visit_map<V>(self, mut visitor: V) -> Result<Self::Value, V::Error>
  161|  8.58k|            where
  162|  8.58k|                V: de::MapAccess<'de>,
  163|  8.58k|            {
  164|  8.58k|                let mut values = BTreeMap::new();
  165|  8.58k|
  166|  8.58k|                while let Some((key, value)) = visitor.next_entry()? {
  167|  8.58k|                    values.insert(key, value);
  168|  8.58k|                }
  169|  8.58k|
  170|  8.58k|                Ok(Ipld::Map(values))
  171|  8.58k|            }
  172|  8.58k|
  173|  8.58k|            /// Newtype structs are only used to deserialize CIDs.
  174|  8.58k|            #[inline]
  175|  8.58k|            fn visit_newtype_struct<D>(self, deserializer: D) -> Result<Self::Value, D::Error>
  176|  8.58k|            where
  177|  8.58k|                D: de::Deserializer<'de>,
  178|  8.58k|            {
  179|  8.58k|                deserializer
  180|  8.58k|                    .deserialize_bytes(BytesToCidVisitor)
  181|  8.58k|                    .map(Ipld::Link)
  182|  8.58k|            }
  183|  8.58k|        }
  184|  8.58k|
  185|  8.58k|        deserializer.deserialize_any(IpldVisitor)
  186|  8.58k|    }
_RINvNtNtCs3TS9n28v4Rl_12libipld_core5serde2de9visit_seqINtNvXsh_NtNtCssVaLrL3Upj_5serde2de5implsINtNtCs9pDt8l5wGDA_5alloc3vec3VecpENtB12_11Deserialize11deserialize10VecVisitorINtCslH3pn9Bu6yX_13fvm_ipld_hamt12KeyValuePairNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateEEECsboUdcTbF1FS_15direct_syscalls:
  552|    954|fn visit_seq<'de, V>(list: Vec<Ipld>, visitor: V) -> Result<V::Value, SerdeError>
  553|    954|where
  554|    954|    V: de::Visitor<'de>,
  555|    954|{
  556|    954|    let mut deserializer = SeqDeserializer::new(list);
  557|    954|    visitor.visit_seq(&mut deserializer)
  558|    954|}
_RINvXs0_NtNtCs3TS9n28v4Rl_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCssVaLrL3Upj_5serde2de12Deserializer15deserialize_seqINtNvXsh_NtB14_5implsINtNtCs9pDt8l5wGDA_5alloc3vec3VecpENtB14_11Deserialize11deserialize10VecVisitorINtCslH3pn9Bu6yX_13fvm_ipld_hamt12KeyValuePairNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateEEECsboUdcTbF1FS_15direct_syscalls:
  386|    954|    fn deserialize_seq<V: de::Visitor<'de>>(self, visitor: V) -> Result<V::Value, Self::Error> {
  387|    954|        match self {
  388|    954|            Self::List(list) => visit_seq(list, visitor),
  389|      0|            _ => error(format!(
  390|      0|                "Only `Ipld::List` can be deserialized to sequence, input was `{:#?}`",
  391|      0|                self
  392|      0|            )),
  393|       |        }
  394|    954|    }
_RINvXs4_NtNtCs3TS9n28v4Rl_12libipld_core5serde2deNtB6_15SeqDeserializerNtNtCssVaLrL3Upj_5serde2de9SeqAccess17next_element_seedINtNtCsiloedr2K6v7_4core6marker11PhantomDataINtCslH3pn9Bu6yX_13fvm_ipld_hamt12KeyValuePairNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateEEECsboUdcTbF1FS_15direct_syscalls:
  627|  1.90k|    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>
  628|  1.90k|    where
  629|  1.90k|        T: de::DeserializeSeed<'de>,
  630|  1.90k|    {
  631|  1.90k|        match self.iter.next() {
  632|    954|            Some(value) => seed.deserialize(value).map(Some),
  633|    954|            None => Ok(None),
  634|       |        }
  635|  1.90k|    }
_RINvXs0_NtNtCs3TS9n28v4Rl_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCssVaLrL3Upj_5serde2de12Deserializer26deserialize_newtype_structINtNvXs0_NtCsl4cFeht4Yol_3cid5serdeINtNtB2j_3cid3CidKpENtB14_11Deserialize11deserialize16MainEntryVisitorKj40_EECsboUdcTbF1FS_15direct_syscalls:
  471|  1.90k|    fn deserialize_newtype_struct<V: de::Visitor<'de>>(
  472|  1.90k|        self,
  473|  1.90k|        name: &str,
  474|  1.90k|        visitor: V,
  475|  1.90k|    ) -> Result<V::Value, Self::Error> {
  476|  1.90k|        if name == CID_SERDE_PRIVATE_IDENTIFIER {
  477|  1.90k|            match self {
  478|  1.90k|                Ipld::Link(cid) => visitor.visit_newtype_struct(CidDeserializer(cid)),
  479|      0|                _ => error(format!(
  480|      0|                    "Only `Ipld::Link`s can be deserialized to CIDs, input was `{:#?}`",
  481|      0|                    self
  482|      0|                )),
  483|       |            }
  484|       |        } else {
  485|      0|            visitor.visit_newtype_struct(self)
  486|       |        }
  487|  1.90k|    }
_RINvXNvXNtNtCs3TS9n28v4Rl_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCssVaLrL3Upj_5serde2de11Deserialize11deserializeNtB3_11IpldVisitorNtB14_7Visitor14visit_byte_bufINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsiloedr2K6v7_4core7convert10InfallibleEECsboUdcTbF1FS_15direct_syscalls:
   90|  1.90k|            fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<Self::Value, E>
   91|  1.90k|            where
   92|  1.90k|                E: de::Error,
   93|  1.90k|            {
   94|  1.90k|                Ok(Ipld::Bytes(v))
   95|  1.90k|            }
_RINvXs_NtNtCs3TS9n28v4Rl_12libipld_core5serde2deNtB5_15CidDeserializerNtNtCssVaLrL3Upj_5serde2de12Deserializer17deserialize_bytesNtNtCsl4cFeht4Yol_3cid5serde17BytesToCidVisitorECsboUdcTbF1FS_15direct_syscalls:
  224|  1.90k|    fn deserialize_bytes<V: de::Visitor<'de>>(self, visitor: V) -> Result<V::Value, Self::Error> {
  225|  1.90k|        visitor.visit_bytes(&self.0.to_bytes())
  226|  1.90k|    }
_RINvXNvXNtNtCs3TS9n28v4Rl_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCssVaLrL3Upj_5serde2de11Deserialize11deserializeNtB3_11IpldVisitorNtB14_7Visitor9visit_u64INtNtCshf5gyM0YXBy_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsiloedr2K6v7_4core7convert10InfallibleEECsboUdcTbF1FS_15direct_syscalls:
   98|    954|            fn visit_u64<E>(self, v: u64) -> Result<Self::Value, E>
   99|    954|            where
  100|    954|                E: de::Error,
  101|    954|            {
  102|    954|                Ok(Ipld::Integer(v.into()))
  103|    954|            }
_RINvXs0_NtNtCs3TS9n28v4Rl_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCssVaLrL3Upj_5serde2de12Deserializer17deserialize_tupleINtNvXNvCslH3pn9Bu6yX_13fvm_ipld_hamts_1__INtB27_12KeyValuePairppENtB14_11Deserialize11deserialize9___VisitorNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateEECsboUdcTbF1FS_15direct_syscalls:
  396|    954|    fn deserialize_tuple<V: de::Visitor<'de>>(
  397|    954|        self,
  398|    954|        len: usize,
  399|    954|        visitor: V,
  400|    954|    ) -> Result<V::Value, Self::Error> {
  401|    954|        match self {
  402|    954|            Self::List(list) => {
  403|    954|                if len == list.len() {
  404|    954|                    visit_seq(list, visitor)
  405|       |                } else {
  406|      0|                    error(format!("The tuple size must match the length of the `Ipld::List`, tuple size: {}, `Ipld::List` length: {}", len, list.len()))
  407|       |                }
  408|       |            }
  409|      0|            _ => error(format!(
  410|      0|                "Only `Ipld::List` can be deserialized to tuple, input was `{:#?}`",
  411|      0|                self
  412|      0|            )),
  413|       |        }
  414|    954|    }
_RINvXs4_NtNtCs3TS9n28v4Rl_12libipld_core5serde2deNtB6_15SeqDeserializerNtNtCssVaLrL3Upj_5serde2de9SeqAccess17next_element_seedINtNtCsiloedr2K6v7_4core6marker11PhantomDataNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateEECsboUdcTbF1FS_15direct_syscalls:
  627|    954|    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>
  628|    954|    where
  629|    954|        T: de::DeserializeSeed<'de>,
  630|    954|    {
  631|    954|        match self.iter.next() {
  632|    954|            Some(value) => seed.deserialize(value).map(Some),
  633|      0|            None => Ok(None),
  634|       |        }
  635|    954|    }
_RINvXs4_NtNtCs3TS9n28v4Rl_12libipld_core5serde2deNtB6_15SeqDeserializerNtNtCssVaLrL3Upj_5serde2de9SeqAccess17next_element_seedINtNtCsiloedr2K6v7_4core6marker11PhantomDataNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyEECsboUdcTbF1FS_15direct_syscalls:
  627|    954|    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>
  628|    954|    where
  629|    954|        T: de::DeserializeSeed<'de>,
  630|    954|    {
  631|    954|        match self.iter.next() {
  632|    954|            Some(value) => seed.deserialize(value).map(Some),
  633|      0|            None => Ok(None),
  634|       |        }
  635|    954|    }
_RINvXs0_NtNtCs3TS9n28v4Rl_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCssVaLrL3Upj_5serde2de12Deserializer15deserialize_u64NtNvXsX_NtB14_5implsyNtB14_11Deserialize11deserialize16PrimitiveVisitorECsboUdcTbF1FS_15direct_syscalls:
  191|    954|        fn $deserialize<V: de::Visitor<'de>>(self, visitor: V) -> Result<V::Value, Self::Error> {
  192|    954|            match self {
  193|    954|                Self::Integer(integer) => match $ty::try_from(integer) {
  194|    954|                    Ok(int) => visitor.$visit(int),
  195|      0|                    Err(_) => error(format!(
  196|      0|                        "`Ipld::Integer` value was bigger than `{}`",
  197|      0|                        stringify!($ty)
  198|      0|                    )),
  199|       |                },
  200|      0|                _ => error(format!(
  201|      0|                    "Only `Ipld::Integer` can be deserialized to `{}`, input was `{:#?}`",
  202|      0|                    stringify!($ty),
  203|      0|                    self
  204|      0|                )),
  205|       |            }
  206|    954|        }
_RINvXs4_NtNtCs3TS9n28v4Rl_12libipld_core5serde2deNtB6_15SeqDeserializerNtNtCssVaLrL3Upj_5serde2de9SeqAccess17next_element_seedINtNtCsiloedr2K6v7_4core6marker11PhantomDataNtNtCs83Z8YCK0meJ_10fvm_shared4econ11TokenAmountEECsboUdcTbF1FS_15direct_syscalls:
  627|    954|    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>
  628|    954|    where
  629|    954|        T: de::DeserializeSeed<'de>,
  630|    954|    {
  631|    954|        match self.iter.next() {
  632|    954|            Some(value) => seed.deserialize(value).map(Some),
  633|      0|            None => Ok(None),
  634|       |        }
  635|    954|    }
_RINvXs0_NtNtCs3TS9n28v4Rl_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCssVaLrL3Upj_5serde2de12Deserializer24deserialize_tuple_structNtNvXNvNvXsa_NtCskJihg1y13m7_3fvm10state_treeNtB2j_10ActorStateNtB14_11Deserialize11deserialize1__NtB2d_5InnerB37_11deserialize9___VisitorECsboUdcTbF1FS_15direct_syscalls:
  416|    954|    fn deserialize_tuple_struct<V: de::Visitor<'de>>(
  417|    954|        self,
  418|    954|        _name: &str,
  419|    954|        len: usize,
  420|    954|        visitor: V,
  421|    954|    ) -> Result<V::Value, Self::Error> {
  422|    954|        self.deserialize_tuple(len, visitor)
  423|    954|    }
_RINvXs0_NtNtCs3TS9n28v4Rl_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCssVaLrL3Upj_5serde2de12Deserializer20deserialize_byte_bufNtNtCsf2Bn5hSrLpu_14cs_serde_bytes7bytebuf14ByteBufVisitorECsboUdcTbF1FS_15direct_syscalls:
  373|    954|    fn deserialize_byte_buf<V: de::Visitor<'de>>(
  374|    954|        self,
  375|    954|        visitor: V,
  376|    954|    ) -> Result<V::Value, Self::Error> {
  377|    954|        match self {
  378|    954|            Self::Bytes(bytes) => visitor.visit_byte_buf(bytes),
  379|      0|            _ => error(format!(
  380|      0|                "Only `Ipld::Bytes` can be deserialized to bytes, input was `{:#?}`",
  381|      0|                self
  382|      0|            )),
  383|       |        }
  384|    954|    }
_RINvXNvXNtNtCs3TS9n28v4Rl_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCssVaLrL3Upj_5serde2de11Deserialize11deserializeNtB3_11IpldVisitorNtB14_7Visitor11visit_bytesINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsiloedr2K6v7_4core7convert10InfallibleEECsboUdcTbF1FS_15direct_syscalls:
   82|  1.90k|            fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>
   83|  1.90k|            where
   84|  1.90k|                E: de::Error,
   85|  1.90k|            {
   86|  1.90k|                self.visit_byte_buf(v.to_owned())
   87|  1.90k|            }
_RINvXs4_NtNtCs3TS9n28v4Rl_12libipld_core5serde2deNtB6_15SeqDeserializerNtNtCssVaLrL3Upj_5serde2de9SeqAccess17next_element_seedINtNtCsiloedr2K6v7_4core6marker11PhantomDataINtNtB25_6option6OptionNtNtCs83Z8YCK0meJ_10fvm_shared7address7AddressEEECsboUdcTbF1FS_15direct_syscalls:
  627|    954|    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>
  628|    954|    where
  629|    954|        T: de::DeserializeSeed<'de>,
  630|    954|    {
  631|    954|        match self.iter.next() {
  632|    954|            Some(value) => seed.deserialize(value).map(Some),
  633|      0|            None => Ok(None),
  634|       |        }
  635|    954|    }
_RINvXNvXNtNtCs3TS9n28v4Rl_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCssVaLrL3Upj_5serde2de11Deserialize11deserializeNtB3_11IpldVisitorNtB14_7Visitor20visit_newtype_structQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de15CidDeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECsboUdcTbF1FS_15direct_syscalls:
  175|  1.90k|            fn visit_newtype_struct<D>(self, deserializer: D) -> Result<Self::Value, D::Error>
  176|  1.90k|            where
  177|  1.90k|                D: de::Deserializer<'de>,
  178|  1.90k|            {
  179|  1.90k|                deserializer
  180|  1.90k|                    .deserialize_bytes(BytesToCidVisitor)
  181|  1.90k|                    .map(Ipld::Link)
  182|  1.90k|            }
_RINvXNvXNtNtCs3TS9n28v4Rl_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCssVaLrL3Upj_5serde2de11Deserialize11deserializeNtB3_11IpldVisitorNtB14_7Visitor10visit_noneINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsiloedr2K6v7_4core7convert10InfallibleEECsboUdcTbF1FS_15direct_syscalls:
  138|    954|            fn visit_none<E>(self) -> Result<Self::Value, E>
  139|    954|            where
  140|    954|                E: de::Error,
  141|    954|            {
  142|    954|                Ok(Ipld::Null)
  143|    954|            }
_RINvXs0_NtNtCs3TS9n28v4Rl_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCssVaLrL3Upj_5serde2de12Deserializer18deserialize_optionINtNtB14_5impls13OptionVisitorNtNtCs83Z8YCK0meJ_10fvm_shared7address7AddressEECsboUdcTbF1FS_15direct_syscalls:
  536|    954|    fn deserialize_option<V: de::Visitor<'de>>(self, visitor: V) -> Result<V::Value, Self::Error> {
  537|    954|        match self {
  538|    954|            Self::Null => visitor.visit_none(),
  539|      0|            _ => visitor.visit_some(self),
  540|       |        }
  541|    954|    }
_RINvXs0_NtNtCs3TS9n28v4Rl_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCssVaLrL3Upj_5serde2de12Deserializer24deserialize_tuple_structINtNvXNvCslH3pn9Bu6yX_13fvm_ipld_hamts_1__INtB2e_12KeyValuePairppENtB14_11Deserialize11deserialize9___VisitorNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateEECsboUdcTbF1FS_15direct_syscalls:
  416|    954|    fn deserialize_tuple_struct<V: de::Visitor<'de>>(
  417|    954|        self,
  418|    954|        _name: &str,
  419|    954|        len: usize,
  420|    954|        visitor: V,
  421|    954|    ) -> Result<V::Value, Self::Error> {
  422|    954|        self.deserialize_tuple(len, visitor)
  423|    954|    }
_RINvXs4_NtNtCs3TS9n28v4Rl_12libipld_core5serde2deNtB6_15SeqDeserializerNtNtCssVaLrL3Upj_5serde2de9SeqAccess17next_element_seedINtNtCsiloedr2K6v7_4core6marker11PhantomDatayEECsboUdcTbF1FS_15direct_syscalls:
  627|    954|    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>
  628|    954|    where
  629|    954|        T: de::DeserializeSeed<'de>,
  630|    954|    {
  631|    954|        match self.iter.next() {
  632|    954|            Some(value) => seed.deserialize(value).map(Some),
  633|      0|            None => Ok(None),
  634|       |        }
  635|    954|    }
_RINvNtNtCs3TS9n28v4Rl_12libipld_core5serde2de9visit_seqNtNvXNvNvXsa_NtCskJihg1y13m7_3fvm10state_treeNtB14_10ActorStateNtNtCssVaLrL3Upj_5serde2de11Deserialize11deserialize1__NtBY_5InnerB1S_11deserialize9___VisitorECsboUdcTbF1FS_15direct_syscalls:
  552|    954|fn visit_seq<'de, V>(list: Vec<Ipld>, visitor: V) -> Result<V::Value, SerdeError>
  553|    954|where
  554|    954|    V: de::Visitor<'de>,
  555|    954|{
  556|    954|    let mut deserializer = SeqDeserializer::new(list);
  557|    954|    visitor.visit_seq(&mut deserializer)
  558|    954|}
_RINvXs4_NtNtCs3TS9n28v4Rl_12libipld_core5serde2deNtB6_15SeqDeserializerNtNtCssVaLrL3Upj_5serde2de9SeqAccess17next_element_seedINtNtCsiloedr2K6v7_4core6marker11PhantomDataINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEECsboUdcTbF1FS_15direct_syscalls:
  627|  1.90k|    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>
  628|  1.90k|    where
  629|  1.90k|        T: de::DeserializeSeed<'de>,
  630|  1.90k|    {
  631|  1.90k|        match self.iter.next() {
  632|  1.90k|            Some(value) => seed.deserialize(value).map(Some),
  633|      0|            None => Ok(None),
  634|       |        }
  635|  1.90k|    }
_RINvXs0_NtNtCs3TS9n28v4Rl_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCssVaLrL3Upj_5serde2de12Deserializer17deserialize_tupleNtNvXNvNvXsa_NtCskJihg1y13m7_3fvm10state_treeNtB2c_10ActorStateNtB14_11Deserialize11deserialize1__NtB26_5InnerB30_11deserialize9___VisitorECsboUdcTbF1FS_15direct_syscalls:
  396|    954|    fn deserialize_tuple<V: de::Visitor<'de>>(
  397|    954|        self,
  398|    954|        len: usize,
  399|    954|        visitor: V,
  400|    954|    ) -> Result<V::Value, Self::Error> {
  401|    954|        match self {
  402|    954|            Self::List(list) => {
  403|    954|                if len == list.len() {
  404|    954|                    visit_seq(list, visitor)
  405|       |                } else {
  406|      0|                    error(format!("The tuple size must match the length of the `Ipld::List`, tuple size: {}, `Ipld::List` length: {}", len, list.len()))
  407|       |                }
  408|       |            }
  409|      0|            _ => error(format!(
  410|      0|                "Only `Ipld::List` can be deserialized to tuple, input was `{:#?}`",
  411|      0|                self
  412|      0|            )),
  413|       |        }
  414|    954|    }
_RINvXNvXNtNtCs3TS9n28v4Rl_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCssVaLrL3Upj_5serde2de11Deserialize11deserializeNtB3_11IpldVisitorNtB14_7Visitor9visit_seqINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECsboUdcTbF1FS_15direct_syscalls:
  146|  2.86k|            fn visit_seq<V>(self, mut visitor: V) -> Result<Self::Value, V::Error>
  147|  2.86k|            where
  148|  2.86k|                V: de::SeqAccess<'de>,
  149|  2.86k|            {
  150|  2.86k|                let mut vec = Vec::with_capacity(visitor.size_hint().unwrap_or(0));
  151|       |
  152|  10.4k|                while let Some(elem) = visitor.next_element()? {
  153|  7.63k|                    vec.push(elem);
  154|  7.63k|                }
  155|       |
  156|  2.86k|                Ok(Ipld::List(vec))
  157|  2.86k|            }
_RINvNtNtCs3TS9n28v4Rl_12libipld_core5serde2de9visit_seqINtNvXNvCslH3pn9Bu6yX_13fvm_ipld_hamts_1__INtBZ_12KeyValuePairppENtNtCssVaLrL3Upj_5serde2de11Deserialize11deserialize9___VisitorNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateEECsboUdcTbF1FS_15direct_syscalls:
  552|    954|fn visit_seq<'de, V>(list: Vec<Ipld>, visitor: V) -> Result<V::Value, SerdeError>
  553|    954|where
  554|    954|    V: de::Visitor<'de>,
  555|    954|{
  556|    954|    let mut deserializer = SeqDeserializer::new(list);
  557|    954|    visitor.visit_seq(&mut deserializer)
  558|    954|}
_RINvXs0_NtNtCs3TS9n28v4Rl_12libipld_core5serde2deNtNtBa_4ipld4IpldNtNtCssVaLrL3Upj_5serde2de12Deserializer17deserialize_bytesNtNvXs0_NtNtCsgVlqBW3KcNx_17fvm_ipld_encoding5bytes12strict_bytesINtNtCs9pDt8l5wGDA_5alloc6borrow3CowShENtB27_11Deserialize11deserialize10CowVisitorECsboUdcTbF1FS_15direct_syscalls:
  363|    954|    fn deserialize_bytes<V: de::Visitor<'de>>(self, visitor: V) -> Result<V::Value, Self::Error> {
  364|    954|        match self {
  365|    954|            Self::Bytes(bytes) => visitor.visit_bytes(&bytes),
  366|      0|            _ => error(format!(
  367|      0|                "Only `Ipld::Bytes` can be deserialized to bytes, input was `{:#?}`",
  368|      0|                self
  369|      0|            )),
  370|       |        }
  371|    954|    }
_RNvXs4_NtNtCs3TS9n28v4Rl_12libipld_core5serde2deNtB5_15SeqDeserializerNtNtCssVaLrL3Upj_5serde2de9SeqAccess9size_hint:
  638|    954|        match self.iter.size_hint() {
  639|    954|            (lower, Some(upper)) if lower == upper => Some(upper),
  640|      0|            _ => None,
  641|       |        }
  642|    954|    }
_RNvMs3_NtNtCs3TS9n28v4Rl_12libipld_core5serde2deNtB5_15SeqDeserializer3new:
  617|  2.86k|    fn new(vec: Vec<Ipld>) -> Self {
  618|  2.86k|        Self {
  619|  2.86k|            iter: vec.into_iter(),
  620|  2.86k|        }
  621|  2.86k|    }

_RNvXs2_CsbIC4eNc6bgl_3logNtB5_5LevelINtNtCsiloedr2K6v7_4core3cmp10PartialOrdNtB5_11LevelFilterE2le:
  511|  2.54k|    fn le(&self, other: &LevelFilter) -> bool {
  512|  2.54k|        *self as usize <= *other as usize
  513|  2.54k|    }
_RNvCsbIC4eNc6bgl_3log9max_level:
 1383|    954|pub fn max_level() -> LevelFilter {
 1384|    954|    // Since `LevelFilter` is `repr(usize)`,
 1385|    954|    // this transmute is sound if and only if `MAX_LOG_LEVEL_FILTER`
 1386|    954|    // is set to a usize that is a valid discriminant for `LevelFilter`.
 1387|    954|    // Since `MAX_LOG_LEVEL_FILTER` is private, the only time it's set
 1388|    954|    // is by `set_max_level` above, i.e. by casting a `LevelFilter` to `usize`.
 1389|    954|    // So any usize stored in `MAX_LOG_LEVEL_FILTER` is a valid discriminant.
 1390|    954|    unsafe { mem::transmute(MAX_LOG_LEVEL_FILTER.load(Ordering::Relaxed)) }
 1391|    954|}
_RNvMsh_CsbIC4eNc6bgl_3logNtB5_6Record8metadata:
  916|    954|    pub fn metadata(&self) -> &Metadata<'a> {
  917|    954|        &self.metadata
  918|    954|    }
_RNvMsh_CsbIC4eNc6bgl_3logNtB5_6Record4args:
  910|    636|    pub fn args(&self) -> &fmt::Arguments<'a> {
  911|    636|        &self.args
  912|    636|    }
_RNvMsh_CsbIC4eNc6bgl_3logNtB5_6Record6target:
  928|    636|    pub fn target(&self) -> &'a str {
  929|    636|        self.metadata.target()
  930|    636|    }
_RNvXsc_CsbIC4eNc6bgl_3logNtB5_11LevelFilterNtNtCsiloedr2K6v7_4core3cmp3Ord3cmp:
  735|    954|    fn cmp(&self, other: &LevelFilter) -> cmp::Ordering {
  736|    954|        (*self as usize).cmp(&(*other as usize))
  737|    954|    }
_RNvMsj_CsbIC4eNc6bgl_3logNtB5_8Metadata6target:
 1204|  1.59k|    pub fn target(&self) -> &'a str {
 1205|  1.59k|        self.target
 1206|  1.59k|    }
_RNvCsbIC4eNc6bgl_3log13set_max_level:
 1365|      1|pub fn set_max_level(level: LevelFilter) {
 1366|      1|    MAX_LOG_LEVEL_FILTER.store(level as usize, Ordering::Relaxed)
 1367|      1|}
_RNvMsh_CsbIC4eNc6bgl_3logNtB5_6Record5level:
  922|    636|    pub fn level(&self) -> Level {
  923|    636|        self.metadata.level()
  924|    636|    }
_RNvMsf_CsbIC4eNc6bgl_3logNtB5_11LevelFilter3max:
  774|    636|    pub fn max() -> LevelFilter {
  775|    636|        LevelFilter::Trace
  776|    636|    }
_RNvMsj_CsbIC4eNc6bgl_3logNtB5_8Metadata5level:
 1198|  1.59k|    pub fn level(&self) -> Level {
 1199|  1.59k|        self.level
 1200|  1.59k|    }
_RNvXsd_CsbIC4eNc6bgl_3logNtB5_11LevelFilterNtNtNtCsiloedr2K6v7_4core3str6traits7FromStr8from_str:
  742|  1.27k|    fn from_str(level: &str) -> Result<LevelFilter, Self::Err> {
  743|  1.27k|        ok_or(
  744|  1.27k|            LOG_LEVEL_NAMES
  745|  1.27k|                .iter()
  746|  1.27k|                .position(|&name| eq_ignore_ascii_case(name, level))
  747|  1.27k|                .map(|p| LevelFilter::from_usize(p).unwrap()),
  748|  1.27k|            ParseLevelError(()),
  749|  1.27k|        )
  750|  1.27k|    }
_RNCNvXsd_CsbIC4eNc6bgl_3logNtB7_11LevelFilterNtNtNtCsiloedr2K6v7_4core3str6traits7FromStr8from_strs_0B7_:
  747|    636|                .map(|p| LevelFilter::from_usize(p).unwrap()),
_RINvCsbIC4eNc6bgl_3log16set_logger_innerNCNvB2_16set_boxed_logger0EB2_:
 1470|    318|fn set_logger_inner<F>(make_logger: F) -> Result<(), SetLoggerError>
 1471|    318|where
 1472|    318|    F: FnOnce() -> &'static dyn Log,
 1473|    318|{
 1474|    318|    let old_state = match STATE.compare_exchange(
 1475|    318|        UNINITIALIZED,
 1476|    318|        INITIALIZING,
 1477|    318|        Ordering::SeqCst,
 1478|    318|        Ordering::SeqCst,
 1479|    318|    ) {
 1480|    318|        Ok(s) | Err(s) => s,
 1481|    318|    };
 1482|    318|    match old_state {
 1483|       |        UNINITIALIZED => {
 1484|      1|            unsafe {
 1485|      1|                LOGGER = make_logger();
 1486|      1|            }
 1487|      1|            STATE.store(INITIALIZED, Ordering::SeqCst);
 1488|      1|            Ok(())
 1489|       |        }
 1490|       |        INITIALIZING => {
 1491|      0|            while STATE.load(Ordering::SeqCst) == INITIALIZING {
 1492|      0|                // TODO: replace with `hint::spin_loop` once MSRV is 1.49.0.
 1493|      0|                #[allow(deprecated)]
 1494|      0|                std::sync::atomic::spin_loop_hint();
 1495|      0|            }
 1496|      0|            Err(SetLoggerError(()))
 1497|       |        }
 1498|    317|        _ => Err(SetLoggerError(())),
 1499|       |    }
 1500|    318|}
_RNvMsi_CsbIC4eNc6bgl_3logNtB5_13RecordBuilder18module_path_static:
 1104|    954|    pub fn module_path_static(&mut self, path: Option<&'static str>) -> &mut RecordBuilder<'a> {
 1105|    954|        self.record.module_path = path.map(MaybeStaticStr::Static);
 1106|    954|        self
 1107|    954|    }
_RNvMs6_CsbIC4eNc6bgl_3logNtB5_5Level6as_str:
  608|    636|    pub fn as_str(&self) -> &'static str {
  609|    636|        LOG_LEVEL_NAMES[*self as usize]
  610|    636|    }
_RNvMsf_CsbIC4eNc6bgl_3logNtB5_11LevelFilter10from_usize:
  760|    636|    fn from_usize(u: usize) -> Option<LevelFilter> {
  761|    636|        match u {
  762|      0|            0 => Some(LevelFilter::Off),
  763|      0|            1 => Some(LevelFilter::Error),
  764|      0|            2 => Some(LevelFilter::Warn),
  765|      0|            3 => Some(LevelFilter::Info),
  766|    318|            4 => Some(LevelFilter::Debug),
  767|    318|            5 => Some(LevelFilter::Trace),
  768|      0|            _ => None,
  769|       |        }
  770|    636|    }
_RNvMsj_CsbIC4eNc6bgl_3logNtB5_8Metadata7builder:
 1192|    954|    pub fn builder() -> MetadataBuilder<'a> {
 1193|    954|        MetadataBuilder::new()
 1194|    954|    }
_RNvMsk_CsbIC4eNc6bgl_3logNtB5_15MetadataBuilder3new:
 1238|    954|    pub fn new() -> MetadataBuilder<'a> {
 1239|    954|        MetadataBuilder {
 1240|    954|            metadata: Metadata {
 1241|    954|                level: Level::Info,
 1242|    954|                target: "",
 1243|    954|            },
 1244|    954|        }
 1245|    954|    }
_RNvMsi_CsbIC4eNc6bgl_3logNtB5_13RecordBuilder4line:
 1125|    954|    pub fn line(&mut self, line: Option<u32>) -> &mut RecordBuilder<'a> {
 1126|    954|        self.record.line = line;
 1127|    954|        self
 1128|    954|    }
_RNvXsQ_CsbIC4eNc6bgl_3logNtB5_8MetadataNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
 1183|  1.90k|#[derive(Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug)]
_RNvCsbIC4eNc6bgl_3log17___private_api_log:
 1591|    954|    if kvs.is_some() {
 1592|      0|        panic!(
 1593|      0|            "key-value support is experimental and must be enabled using the `kv_unstable` feature"
 1594|      0|        )
 1595|    954|    }
 1596|    954|
 1597|    954|    logger().log(
 1598|    954|        &Record::builder()
 1599|    954|            .args(args)
 1600|    954|            .level(level)
 1601|    954|            .target(target)
 1602|    954|            .module_path_static(Some(module_path))
 1603|    954|            .file_static(Some(file))
 1604|    954|            .line(Some(line))
 1605|    954|            .build(),
 1606|    954|    );
 1607|    954|}
_RNvMsi_CsbIC4eNc6bgl_3logNtB5_13RecordBuilder4args:
 1069|    954|    pub fn args(&mut self, args: fmt::Arguments<'a>) -> &mut RecordBuilder<'a> {
 1070|    954|        self.record.args = args;
 1071|    954|        self
 1072|    954|    }
_RNvMsi_CsbIC4eNc6bgl_3logNtB5_13RecordBuilder5level:
 1083|    954|    pub fn level(&mut self, level: Level) -> &mut RecordBuilder<'a> {
 1084|    954|        self.record.metadata.level = level;
 1085|    954|        self
 1086|    954|    }
_RNvNvCsbIC4eNc6bgl_3log20eq_ignore_ascii_case18to_ascii_uppercase:
  542|  8.26k|    fn to_ascii_uppercase(c: u8) -> u8 {
  543|  8.26k|        if c >= b'a' && c <= b'z' {
  544|  4.13k|            c - b'a' + b'A'
  545|       |        } else {
  546|  4.13k|            c
  547|       |        }
  548|  8.26k|    }
_RNvMsk_CsbIC4eNc6bgl_3logNtB5_15MetadataBuilder5build:
 1263|    954|    pub fn build(&self) -> Metadata<'a> {
 1264|    954|        self.metadata.clone()
 1265|    954|    }
_RNvMsh_CsbIC4eNc6bgl_3logNtB5_6Record7builder:
  904|    954|    pub fn builder() -> RecordBuilder<'a> {
  905|    954|        RecordBuilder::new()
  906|    954|    }
_RNvMsi_CsbIC4eNc6bgl_3logNtB5_13RecordBuilder11file_static:
 1118|    954|    pub fn file_static(&mut self, file: Option<&'static str>) -> &mut RecordBuilder<'a> {
 1119|    954|        self.record.file = file.map(MaybeStaticStr::Static);
 1120|    954|        self
 1121|    954|    }
_RNvCsbIC4eNc6bgl_3log20eq_ignore_ascii_case:
  541|  7.31k|fn eq_ignore_ascii_case(a: &str, b: &str) -> bool {
  542|  7.31k|    fn to_ascii_uppercase(c: u8) -> u8 {
  543|  7.31k|        if c >= b'a' && c <= b'z' {
  544|  7.31k|            c - b'a' + b'A'
  545|  7.31k|        } else {
  546|  7.31k|            c
  547|  7.31k|        }
  548|  7.31k|    }
  549|  7.31k|
  550|  7.31k|    if a.len() == b.len() {
  551|  1.59k|        a.bytes()
  552|  1.59k|            .zip(b.bytes())
  553|  1.59k|            .all(|(a, b)| to_ascii_uppercase(a) == to_ascii_uppercase(b))
  554|       |    } else {
  555|  5.72k|        false
  556|       |    }
  557|  7.31k|}
_RNvMsi_CsbIC4eNc6bgl_3logNtB5_13RecordBuilder5build:
 1140|    954|    pub fn build(&self) -> Record<'a> {
 1141|    954|        self.record.clone()
 1142|    954|    }
_RNvXsE_CsbIC4eNc6bgl_3logNtB5_14MaybeStaticStrNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
  812|  1.90k|#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug)]
_RNvCsbIC4eNc6bgl_3log6logger:
 1573|    954|pub fn logger() -> &'static dyn Log {
 1574|    954|    if STATE.load(Ordering::SeqCst) != INITIALIZED {
 1575|       |        static NOP: NopLogger = NopLogger;
 1576|      0|        &NOP
 1577|       |    } else {
 1578|    954|        unsafe { LOGGER }
 1579|       |    }
 1580|    954|}
_RNvCsbIC4eNc6bgl_3log16set_boxed_logger:
 1407|    318|pub fn set_boxed_logger(logger: Box<dyn Log>) -> Result<(), SetLoggerError> {
 1408|    318|    set_logger_inner(|| Box::leak(logger))
 1409|    318|}
_RNCNvCsbIC4eNc6bgl_3log16set_boxed_logger0B3_:
 1408|      1|    set_logger_inner(|| Box::leak(logger))
_RINvCsbIC4eNc6bgl_3log5ok_orNtB2_11LevelFilterNtB2_15ParseLevelErrorEB2_:
  533|  1.27k|fn ok_or<T, E>(t: Option<T>, e: E) -> Result<T, E> {
  534|  1.27k|    match t {
  535|    636|        Some(t) => Ok(t),
  536|    636|        None => Err(e),
  537|       |    }
  538|  1.27k|}
_RNCNvCsbIC4eNc6bgl_3log20eq_ignore_ascii_case0B3_:
  553|  4.13k|            .all(|(a, b)| to_ascii_uppercase(a) == to_ascii_uppercase(b))
_RNvXsN_CsbIC4eNc6bgl_3logNtB5_6RecordNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
  873|    954|#[derive(Clone, Debug)]
_RNvMsi_CsbIC4eNc6bgl_3logNtB5_13RecordBuilder3new:
 1053|    954|    pub fn new() -> RecordBuilder<'a> {
 1054|    954|        RecordBuilder {
 1055|    954|            record: Record {
 1056|    954|                args: format_args!(""),
 1057|    954|                metadata: Metadata::builder().build(),
 1058|    954|                module_path: None,
 1059|    954|                file: None,
 1060|    954|                line: None,
 1061|    954|                #[cfg(feature = "kv_unstable")]
 1062|    954|                key_values: KeyValues(&Option::None::<(kv::Key, kv::Value)>),
 1063|    954|            },
 1064|    954|        }
 1065|    954|    }
_RNCNvXsd_CsbIC4eNc6bgl_3logNtB7_11LevelFilterNtNtNtCsiloedr2K6v7_4core3str6traits7FromStr8from_str0B7_:
  746|  7.31k|                .position(|&name| eq_ignore_ascii_case(name, level))
_RNvXCsbIC4eNc6bgl_3logNtB2_5LevelNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
  453|  1.90k|    fn clone(&self) -> Level {
  454|  1.90k|        *self
  455|  1.90k|    }
_RNvXs5_CsbIC4eNc6bgl_3logNtB5_5LevelNtNtCsiloedr2K6v7_4core3fmt7Display3fmt:
  576|    636|    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
  577|    636|        fmt.pad(self.as_str())
  578|    636|    }
_RNvMsi_CsbIC4eNc6bgl_3logNtB5_13RecordBuilder6target:
 1090|    954|    pub fn target(&mut self, target: &'a str) -> &mut RecordBuilder<'a> {
 1091|    954|        self.record.metadata.target = target;
 1092|    954|        self
 1093|    954|    }

_RNvMNtCsfM5UhZV5He1_8minstant7instantNtB2_7Instant3now:
   25|    318|    pub fn now() -> Instant {
   26|    318|        Instant(crate::current_cycle())
   27|    318|    }

_RNvCsfM5UhZV5He1_8minstant16is_tsc_available:
   46|    318|pub fn is_tsc_available() -> bool {
   47|    318|    #[cfg(all(target_os = "linux", any(target_arch = "x86", target_arch = "x86_64")))]
   48|    318|    {
   49|    318|        tsc_now::is_tsc_available()
   50|    318|    }
   51|    318|    #[cfg(not(all(target_os = "linux", any(target_arch = "x86", target_arch = "x86_64"))))]
   52|    318|    {
   53|    318|        false
   54|    318|    }
   55|    318|}
_RNvCsfM5UhZV5He1_8minstant13current_cycle:
   58|    318|pub(crate) fn current_cycle() -> u64 {
   59|    318|    #[cfg(all(target_os = "linux", any(target_arch = "x86", target_arch = "x86_64")))]
   60|    318|    if is_tsc_available() {
   61|    318|        tsc_now::current_cycle()
   62|       |    } else {
   63|      0|        coarse_now::current_cycle()
   64|       |    }
   65|       |    #[cfg(not(all(target_os = "linux", any(target_arch = "x86", target_arch = "x86_64"))))]
   66|       |    {
   67|       |        coarse_now::current_cycle()
   68|       |    }
   69|    318|}

_RNvNtCsfM5UhZV5He1_8minstant7tsc_now16is_tsc_available:
   45|    318|pub(crate) fn is_tsc_available() -> bool {
   46|    318|    unsafe { *TSC_STATE.is_tsc_available.get() }
   47|    318|}
_RNvNtCsfM5UhZV5He1_8minstant7tsc_now3tsc:
  270|   744k|fn tsc() -> u64 {
  271|   744k|    #[cfg(target_arch = "x86")]
  272|   744k|    use core::arch::x86::_rdtsc;
  273|   744k|    #[cfg(target_arch = "x86_64")]
  274|   744k|    use core::arch::x86_64::_rdtsc;
  275|   744k|
  276|   744k|    unsafe { _rdtsc() }
  277|   744k|}
_RNvNtCsfM5UhZV5He1_8minstant7tsc_now13current_cycle:
   55|    318|pub(crate) fn current_cycle() -> u64 {
   56|    318|    match unsafe { &*TSC_STATE.tsc_level.get() } {
   57|       |        TSCLevel::Stable {
   58|    318|            cycles_from_anchor, ..
   59|    318|        } => tsc().wrapping_sub(*cycles_from_anchor),
   60|       |        TSCLevel::PerCPUStable {
   61|      0|            cycles_from_anchor, ..
   62|      0|        } => {
   63|      0|            let (tsc, cpuid) = tsc_with_cpuid();
   64|      0|            let anchor = cycles_from_anchor[cpuid];
   65|      0|            tsc.wrapping_sub(anchor)
   66|       |        }
   67|      0|        TSCLevel::Unstable => panic!("tsc is unstable"),
   68|       |    }
   69|    318|}
_RNvNtCsfM5UhZV5He1_8minstant7tsc_now13is_tsc_stable:
  182|      2|fn is_tsc_stable() -> bool {
  183|      2|    let clock_source =
  184|      2|        read_to_string("/sys/devices/system/clocksource/clocksource0/available_clocksource");
  185|      2|
  186|      2|    clock_source.map(|s| s.contains("tsc")).unwrap_or(false)
  187|      2|}
_RNCNvNtCsfM5UhZV5He1_8minstant7tsc_now13is_tsc_stable0B5_:
  186|      2|    clock_source.map(|s| s.contains("tsc")).unwrap_or(false)
_RNvNtCsfM5UhZV5He1_8minstant7tsc_now18monotonic_with_tsc:
  265|   744k|fn monotonic_with_tsc() -> (Instant, u64) {
  266|   744k|    (Instant::now(), tsc())
  267|   744k|}
_RNvNtCsfM5UhZV5He1_8minstant7tsc_now14cycles_per_sec:
  224|      2|fn cycles_per_sec(anchor: Instant) -> (u64, u64) {
  225|      2|    let (cps, last_monotonic, last_tsc) = _cycles_per_sec();
  226|      2|    let nanos_from_anchor = (last_monotonic - anchor).as_nanos();
  227|      2|    let cycles_flied = cps as f64 * nanos_from_anchor as f64 / 1_000_000_000.0;
  228|      2|    let cycles_from_anchor = last_tsc - cycles_flied.ceil() as u64;
  229|      2|
  230|      2|    (cps, cycles_from_anchor)
  231|      2|}
_RNvMs_NtCsfM5UhZV5He1_8minstant7tsc_nowNtB4_8TSCLevel17cycles_per_second:
  166|      2|    fn cycles_per_second(&self) -> u64 {
  167|      2|        match self {
  168|       |            TSCLevel::Stable {
  169|      2|                cycles_per_second, ..
  170|      2|            } => *cycles_per_second,
  171|       |            TSCLevel::PerCPUStable {
  172|      0|                cycles_per_second, ..
  173|      0|            } => *cycles_per_second,
  174|      0|            TSCLevel::Unstable => panic!("tsc is unstable"),
  175|       |        }
  176|      2|    }
_RNvNtCsfM5UhZV5He1_8minstant7tsc_now15__cycles_per_sec:
  234|      2|fn _cycles_per_sec() -> (u64, Instant, u64) {
  235|      2|    let mut cycles_per_sec;
  236|      2|    let mut last_monotonic;
  237|      2|    let mut last_tsc;
  238|      2|    let mut old_cycles = 0.0;
  239|       |
  240|       |    loop {
  241|      4|        let (t1, tsc1) = monotonic_with_tsc();
  242|   744k|        loop {
  243|   744k|            let (t2, tsc2) = monotonic_with_tsc();
  244|   744k|            last_monotonic = t2;
  245|   744k|            last_tsc = tsc2;
  246|   744k|            let elapsed_nanos = (t2 - t1).as_nanos();
  247|   744k|            if elapsed_nanos > 10_000_000 {
  248|      4|                cycles_per_sec = (tsc2 - tsc1) as f64 * 1_000_000_000.0 / elapsed_nanos as f64;
  249|      4|                break;
  250|   744k|            }
  251|       |        }
  252|      4|        let delta = f64::abs(cycles_per_sec - old_cycles);
  253|      4|        if delta / cycles_per_sec < 0.00001 {
  254|      2|            break;
  255|      2|        }
  256|      2|        old_cycles = cycles_per_sec;
  257|       |    }
  258|       |
  259|      2|    (cycles_per_sec.round() as u64, last_monotonic, last_tsc)
  260|      2|}
_RNvMs_NtCsfM5UhZV5He1_8minstant7tsc_nowNtB4_8TSCLevel3get:
   84|      2|    fn get() -> TSCLevel {
   85|      2|        let anchor = Instant::now();
   86|      2|        if is_tsc_stable() {
   87|      2|            let (cps, cfa) = cycles_per_sec(anchor);
   88|      2|            return TSCLevel::Stable {
   89|      2|                cycles_per_second: cps,
   90|      2|                cycles_from_anchor: cfa,
   91|      2|            };
   92|      0|        }
   93|      0|
   94|      0|        if is_tsc_percpu_stable() {
   95|       |            // Retrieve the IDs of all active CPUs.
   96|      0|            let cpuids = if let Ok(cpuids) = available_cpus() {
   97|      0|                if cpuids.is_empty() {
   98|      0|                    return TSCLevel::Unstable;
   99|      0|                }
  100|      0|
  101|      0|                cpuids
  102|       |            } else {
  103|      0|                return TSCLevel::Unstable;
  104|       |            };
  105|       |
  106|      0|            let max_cpu_id = *cpuids.iter().max().unwrap();
  107|      0|
  108|      0|            // Spread the threads to all CPUs and calculate
  109|      0|            // cycles from anchor separately
  110|      0|            let handles = cpuids.into_iter().map(|id| {
  111|       |                std::thread::spawn(move || {
  112|       |                    set_affinity(id).unwrap();
  113|       |
  114|       |                    // check if cpu id matches IA32_TSC_AUX
  115|       |                    let (_, cpuid) = tsc_with_cpuid();
  116|       |                    assert_eq!(cpuid, id);
  117|       |
  118|       |                    let (cps, cfa) = cycles_per_sec(anchor);
  119|       |
  120|       |                    (id, cps, cfa)
  121|       |                })
  122|      0|            });
  123|      0|
  124|      0|            // Block and wait for all threads finished
  125|      0|            let results = handles.map(|h| h.join()).collect::<Result<Vec<_>, _>>();
  126|       |
  127|      0|            let results = if let Ok(results) = results {
  128|      0|                results
  129|       |            } else {
  130|      0|                return TSCLevel::Unstable;
  131|       |            };
  132|       |
  133|       |            // Indexed by CPU ID
  134|      0|            let mut cycles_from_anchor = vec![0; max_cpu_id + 1];
  135|      0|
  136|      0|            // Rates of TSCs on different CPUs won't be a big gap
  137|      0|            // or it's unstable.
  138|      0|            let mut max_cps = std::u64::MIN;
  139|      0|            let mut min_cps = std::u64::MAX;
  140|      0|            let mut sum_cps = 0;
  141|      0|            let len = results.len();
  142|      0|            for (cpuid, cps, cfa) in results {
  143|      0|                if cps > max_cps {
  144|      0|                    max_cps = cps;
  145|      0|                }
  146|      0|                if cps < min_cps {
  147|      0|                    min_cps = cps;
  148|      0|                }
  149|      0|                sum_cps += cps;
  150|      0|                cycles_from_anchor[cpuid] = cfa;
  151|       |            }
  152|      0|            if (max_cps - min_cps) as f64 / min_cps as f64 > 0.0005 {
  153|      0|                return TSCLevel::Unstable;
  154|      0|            }
  155|      0|
  156|      0|            return TSCLevel::PerCPUStable {
  157|      0|                cycles_per_second: sum_cps / len as u64,
  158|      0|                cycles_from_anchor,
  159|      0|            };
  160|      0|        }
  161|      0|
  162|      0|        TSCLevel::Unstable
  163|      2|    }
_RNvNtCsfM5UhZV5He1_8minstant7tsc_now4init:
   29|      2|unsafe fn init() {
   30|      2|    let tsc_level = TSCLevel::get();
   31|      2|    let is_tsc_available = match &tsc_level {
   32|      2|        TSCLevel::Stable { .. } => true,
   33|      0|        TSCLevel::PerCPUStable { .. } => true,
   34|      0|        TSCLevel::Unstable => false,
   35|       |    };
   36|      2|    if is_tsc_available {
   37|      2|        *TSC_STATE.nanos_per_cycle.get() = 1_000_000_000.0 / tsc_level.cycles_per_second() as f64;
   38|      2|    }
   39|      2|    *TSC_STATE.is_tsc_available.get() = is_tsc_available;
   40|      2|    *TSC_STATE.tsc_level.get() = tsc_level;
   41|      2|    std::sync::atomic::fence(std::sync::atomic::Ordering::SeqCst);
   42|      2|}
_RNvNvNtCsfM5UhZV5He1_8minstant7tsc_now23init___rust_ctor___ctor23init___rust_ctor___ctor:
   28|      2|#[ctor::ctor]

_RINvMNtCs7FM8ZncE1MN_9multibase4baseNtB3_4Base6encodeRShECsboUdcTbF1FS_15direct_syscalls:
   34|    636|            pub fn encode<I: AsRef<[u8]>>(&self, input: I) -> String {
   35|    636|                match self {
   36|      0|                    $( Self::$base => $base::encode(input), )*
   37|       |                }
   38|    636|            }
_RNvMNtCs7FM8ZncE1MN_9multibase4baseNtB2_4Base4code:
   27|    636|            pub fn code(&self) -> char {
   28|    636|                match self {
   29|       |                    $( Self::$base => $code, )*
   30|       |                }
   31|    636|            }

_RINvXsc_NtCs7FM8ZncE1MN_9multibase5implsNtB6_11Base32LowerNtB6_9BaseCodec6encodeRShECsboUdcTbF1FS_15direct_syscalls:
   15|    636|                fn encode<I: AsRef<[u8]>>(input: I) -> String {
   16|    636|                    $encoding.encode(input.as_ref())
   17|    636|                }

_RINvCs7FM8ZncE1MN_9multibase6encodeAhj10_ECsboUdcTbF1FS_15direct_syscalls:
   51|    318|pub fn encode<T: AsRef<[u8]>>(base: Base, input: T) -> String {
   52|    318|    let input = input.as_ref();
   53|    318|    let mut encoded = base.encode(input.as_ref());
   54|    318|    encoded.insert(0, base.code());
   55|    318|    encoded
   56|    318|}
_RINvCs7FM8ZncE1MN_9multibase6encodeRShECsboUdcTbF1FS_15direct_syscalls:
   51|    318|pub fn encode<T: AsRef<[u8]>>(base: Base, input: T) -> String {
   52|    318|    let input = input.as_ref();
   53|    318|    let mut encoded = base.encode(input.as_ref());
   54|    318|    encoded.insert(0, base.code());
   55|    318|    encoded
   56|    318|}

_RNvXs_NtNtCsgR7ufpsWMe2_9multihash11hasher_impl7blake2bINtB4_13Blake2bHasherKj20_ENtNtB8_6hasher6Hasher6updateB8_:
   46|  2.22k|            fn update(&mut self, input: &[u8]) {
   47|  2.22k|                self.state.update(input);
   48|  2.22k|            }
_RNvXs_NtNtCsgR7ufpsWMe2_9multihash11hasher_impl7blake2bINtB4_13Blake2bHasherKj20_ENtNtB8_6hasher6Hasher8finalizeB8_:
   50|  2.22k|            fn finalize(&mut self) -> &[u8] {
   51|  2.22k|                let digest = self.state.finalize();
   52|  2.22k|                let digest_bytes = digest.as_bytes();
   53|  2.22k|                let digest_out = &mut self.digest[..digest_bytes.len().max(S)];
   54|  2.22k|                digest_out.copy_from_slice(digest_bytes);
   55|  2.22k|                digest_out
   56|  2.22k|            }
_RNvXNtNtCsgR7ufpsWMe2_9multihash11hasher_impl7blake2bINtB2_13Blake2bHasherKj20_ENtNtCsiloedr2K6v7_4core7default7Default7defaultB6_:
   35|  2.22k|            fn default() -> Self {
   36|  2.22k|                let mut params = $module::Params::new();
   37|  2.22k|                params.hash_length(S);
   38|  2.22k|                Self {
   39|  2.22k|                    state: params.to_state(),
   40|  2.22k|                    digest: [0; S],
   41|  2.22k|                }
   42|  2.22k|            }

_RINvXs0_NtCsgR7ufpsWMe2_9multihash9multihashINtB6_9MultihashKj40_ENtNtCsiloedr2K6v7_4core4hash4Hash4hashNtNtNtNtCsdyNNmftaNAQ_3std11collections4hash3map13DefaultHasherECsboUdcTbF1FS_15direct_syscalls:
  239|  18.1k|    fn hash<T: core::hash::Hasher>(&self, state: &mut T) {
  240|  18.1k|        self.code.hash(state);
  241|  18.1k|        self.digest().hash(state);
  242|  18.1k|    }
_RNvMs_NtCsgR7ufpsWMe2_9multihash9multihashINtB4_9MultihashKj40_E4sizeCsboUdcTbF1FS_15direct_syscalls:
  125|  4.77k|    pub const fn size(&self) -> u8 {
  126|  4.77k|        self.size
  127|  4.77k|    }
_RNvMs_NtCsgR7ufpsWMe2_9multihash9multihashINtB4_9MultihashKj40_E6digestCsboUdcTbF1FS_15direct_syscalls:
  130|  23.6k|    pub fn digest(&self) -> &[u8] {
  131|  23.6k|        &self.digest[..self.size as usize]
  132|  23.6k|    }
_RINvMs_NtCsgR7ufpsWMe2_9multihash9multihashINtB5_9MultihashKj40_E4readQRShECsboUdcTbF1FS_15direct_syscalls:
  135|  9.54k|    pub fn read<R: io::Read>(r: R) -> Result<Self, Error>
  136|  9.54k|    where
  137|  9.54k|        Self: Sized,
  138|  9.54k|    {
  139|  9.54k|        let (code, size, digest) = read_multihash(r)?;
  140|  9.54k|        Ok(Self { code, size, digest })
  141|  9.54k|    }
_RNvXs2_NtCsgR7ufpsWMe2_9multihash9multihashINtB5_9MultihashKj40_ENtNtCsiloedr2K6v7_4core3cmp9PartialEq2eqCsboUdcTbF1FS_15direct_syscalls:
  253|    367|    fn eq(&self, other: &Multihash<B>) -> bool {
  254|    367|        // NOTE: there's no need to explicitly check the sizes, that's implicit in the digest.
  255|    367|        self.code == other.code && self.digest() == other.digest()
  256|    367|    }
_RINvNtCsgR7ufpsWMe2_9multihash9multihash15write_multihashQQINtNtCs9pDt8l5wGDA_5alloc3vec3VechEECsboUdcTbF1FS_15direct_syscalls:
  296|  4.77k|pub fn write_multihash<W>(mut w: W, code: u64, size: u8, digest: &[u8]) -> Result<(), Error>
  297|  4.77k|where
  298|  4.77k|    W: io::Write,
  299|  4.77k|{
  300|  4.77k|    let mut code_buf = varint_encode::u64_buffer();
  301|  4.77k|    let code = varint_encode::u64(code, &mut code_buf);
  302|  4.77k|
  303|  4.77k|    let mut size_buf = varint_encode::u8_buffer();
  304|  4.77k|    let size = varint_encode::u8(size, &mut size_buf);
  305|  4.77k|
  306|  4.77k|    w.write_all(code)?;
  307|  4.77k|    w.write_all(size)?;
  308|  4.77k|    w.write_all(digest)?;
  309|  4.77k|    Ok(())
  310|  4.77k|}
_RINvNtCsgR7ufpsWMe2_9multihash9multihash14read_multihashQRShKj40_ECsboUdcTbF1FS_15direct_syscalls:
  318|  9.54k|pub fn read_multihash<R, const S: usize>(mut r: R) -> Result<(u64, u8, [u8; S]), Error>
  319|  9.54k|where
  320|  9.54k|    R: io::Read,
  321|  9.54k|{
  322|  9.54k|    let code = read_u64(&mut r)?;
  323|  9.54k|    let size = read_u64(&mut r)?;
  324|       |
  325|  9.54k|    if size > S as u64 || size > u8::MAX as u64 {
  326|      0|        return Err(Error::InvalidSize(size));
  327|  9.54k|    }
  328|  9.54k|
  329|  9.54k|    let mut digest = [0; S];
  330|  9.54k|    r.read_exact(&mut digest[..size as usize])?;
  331|  9.54k|    Ok((code, size as u8, digest))
  332|  9.54k|}
_RNvMs_NtCsgR7ufpsWMe2_9multihash9multihashINtB4_9MultihashKj40_E4codeCsboUdcTbF1FS_15direct_syscalls:
  120|  4.77k|    pub const fn code(&self) -> u64 {
  121|  4.77k|        self.code
  122|  4.77k|    }
_RINvMs_NtCsgR7ufpsWMe2_9multihash9multihashINtB5_9MultihashKj40_E5writeQQINtNtCs9pDt8l5wGDA_5alloc3vec3VechEECsboUdcTbF1FS_15direct_syscalls:
  163|  4.77k|    pub fn write<W: io::Write>(&self, w: W) -> Result<(), Error> {
  164|  4.77k|        write_multihash(w, self.code(), self.size(), self.digest())
  165|  4.77k|    }
_RNvMs_NtCsgR7ufpsWMe2_9multihash9multihashINtB4_9MultihashKj40_E4codeCs7AwuCMXPzRZ_8fvm_fuzz:
  120|    636|    pub const fn code(&self) -> u64 {
  121|    636|        self.code
  122|    636|    }
_RINvMs_NtCsgR7ufpsWMe2_9multihash9multihashINtB5_9MultihashKj40_E4readQINtNtNtCsdyNNmftaNAQ_3std2io6cursor6CursorRINtNtCs9pDt8l5wGDA_5alloc3vec3VechEEECs7AwuCMXPzRZ_8fvm_fuzz:
  135|  5.40k|    pub fn read<R: io::Read>(r: R) -> Result<Self, Error>
  136|  5.40k|    where
  137|  5.40k|        Self: Sized,
  138|  5.40k|    {
  139|  5.40k|        let (code, size, digest) = read_multihash(r)?;
  140|  5.40k|        Ok(Self { code, size, digest })
  141|  5.40k|    }
_RNvXs2_NtCsgR7ufpsWMe2_9multihash9multihashINtB5_9MultihashKj40_ENtNtCsiloedr2K6v7_4core3cmp9PartialEq2eqCs7AwuCMXPzRZ_8fvm_fuzz:
  253|    310|    fn eq(&self, other: &Multihash<B>) -> bool {
  254|    310|        // NOTE: there's no need to explicitly check the sizes, that's implicit in the digest.
  255|    310|        self.code == other.code && self.digest() == other.digest()
  256|    310|    }
_RNvMs_NtCsgR7ufpsWMe2_9multihash9multihashINtB4_9MultihashKj40_E6digestCs7AwuCMXPzRZ_8fvm_fuzz:
  130|  19.3k|    pub fn digest(&self) -> &[u8] {
  131|  19.3k|        &self.digest[..self.size as usize]
  132|  19.3k|    }
_RINvNtCsgR7ufpsWMe2_9multihash9multihash15write_multihashQQINtNtCs9pDt8l5wGDA_5alloc3vec3VechEECs7AwuCMXPzRZ_8fvm_fuzz:
  296|    636|pub fn write_multihash<W>(mut w: W, code: u64, size: u8, digest: &[u8]) -> Result<(), Error>
  297|    636|where
  298|    636|    W: io::Write,
  299|    636|{
  300|    636|    let mut code_buf = varint_encode::u64_buffer();
  301|    636|    let code = varint_encode::u64(code, &mut code_buf);
  302|    636|
  303|    636|    let mut size_buf = varint_encode::u8_buffer();
  304|    636|    let size = varint_encode::u8(size, &mut size_buf);
  305|    636|
  306|    636|    w.write_all(code)?;
  307|    636|    w.write_all(size)?;
  308|    636|    w.write_all(digest)?;
  309|    636|    Ok(())
  310|    636|}
_RINvNtCsgR7ufpsWMe2_9multihash9multihash14read_multihashQRShKj40_ECs7AwuCMXPzRZ_8fvm_fuzz:
  318|  5.40k|pub fn read_multihash<R, const S: usize>(mut r: R) -> Result<(u64, u8, [u8; S]), Error>
  319|  5.40k|where
  320|  5.40k|    R: io::Read,
  321|  5.40k|{
  322|  5.40k|    let code = read_u64(&mut r)?;
  323|  5.40k|    let size = read_u64(&mut r)?;
  324|       |
  325|  5.40k|    if size > S as u64 || size > u8::MAX as u64 {
  326|      0|        return Err(Error::InvalidSize(size));
  327|  5.40k|    }
  328|  5.40k|
  329|  5.40k|    let mut digest = [0; S];
  330|  5.40k|    r.read_exact(&mut digest[..size as usize])?;
  331|  5.40k|    Ok((code, size as u8, digest))
  332|  5.40k|}
_RINvMs_NtCsgR7ufpsWMe2_9multihash9multihashINtB5_9MultihashKj40_E5writeQQINtNtCs9pDt8l5wGDA_5alloc3vec3VechEECs7AwuCMXPzRZ_8fvm_fuzz:
  163|    636|    pub fn write<W: io::Write>(&self, w: W) -> Result<(), Error> {
  164|    636|        write_multihash(w, self.code(), self.size(), self.digest())
  165|    636|    }
_RINvXs0_NtCsgR7ufpsWMe2_9multihash9multihashINtB6_9MultihashKj40_ENtNtCsiloedr2K6v7_4core4hash4Hash4hashNtNtNtNtCsdyNNmftaNAQ_3std11collections4hash3map13DefaultHasherECs7AwuCMXPzRZ_8fvm_fuzz:
  239|  18.1k|    fn hash<T: core::hash::Hasher>(&self, state: &mut T) {
  240|  18.1k|        self.code.hash(state);
  241|  18.1k|        self.digest().hash(state);
  242|  18.1k|    }
_RINvNtCsgR7ufpsWMe2_9multihash9multihash14read_multihashQINtNtNtCsdyNNmftaNAQ_3std2io6cursor6CursorRINtNtCs9pDt8l5wGDA_5alloc3vec3VechEEKj40_ECs7AwuCMXPzRZ_8fvm_fuzz:
  318|  5.40k|pub fn read_multihash<R, const S: usize>(mut r: R) -> Result<(u64, u8, [u8; S]), Error>
  319|  5.40k|where
  320|  5.40k|    R: io::Read,
  321|  5.40k|{
  322|  5.40k|    let code = read_u64(&mut r)?;
  323|  5.40k|    let size = read_u64(&mut r)?;
  324|       |
  325|  5.40k|    if size > S as u64 || size > u8::MAX as u64 {
  326|      0|        return Err(Error::InvalidSize(size));
  327|  5.40k|    }
  328|  5.40k|
  329|  5.40k|    let mut digest = [0; S];
  330|  5.40k|    r.read_exact(&mut digest[..size as usize])?;
  331|  5.40k|    Ok((code, size as u8, digest))
  332|  5.40k|}
_RINvMs_NtCsgR7ufpsWMe2_9multihash9multihashINtB5_9MultihashKj40_E4readQRShECs7AwuCMXPzRZ_8fvm_fuzz:
  135|  5.40k|    pub fn read<R: io::Read>(r: R) -> Result<Self, Error>
  136|  5.40k|    where
  137|  5.40k|        Self: Sized,
  138|  5.40k|    {
  139|  5.40k|        let (code, size, digest) = read_multihash(r)?;
  140|  5.40k|        Ok(Self { code, size, digest })
  141|  5.40k|    }
_RNvMs_NtCsgR7ufpsWMe2_9multihash9multihashINtB4_9MultihashKj40_E4sizeCs7AwuCMXPzRZ_8fvm_fuzz:
  125|    636|    pub const fn size(&self) -> u8 {
  126|    636|        self.size
  127|    636|    }
_RNvMs_NtCsgR7ufpsWMe2_9multihash9multihashINtB4_9MultihashKj40_E6digestCs23Y5vRLZE35_19fvm_ipld_blockstore:
  130|  23.1k|    pub fn digest(&self) -> &[u8] {
  131|  23.1k|        &self.digest[..self.size as usize]
  132|  23.1k|    }
_RINvXs0_NtCsgR7ufpsWMe2_9multihash9multihashINtB6_9MultihashKj40_ENtNtCsiloedr2K6v7_4core4hash4Hash4hashNtNtNtNtCsdyNNmftaNAQ_3std11collections4hash3map13DefaultHasherECs23Y5vRLZE35_19fvm_ipld_blockstore:
  239|  17.4k|    fn hash<T: core::hash::Hasher>(&self, state: &mut T) {
  240|  17.4k|        self.code.hash(state);
  241|  17.4k|        self.digest().hash(state);
  242|  17.4k|    }
_RNvXs2_NtCsgR7ufpsWMe2_9multihash9multihashINtB5_9MultihashKj40_ENtNtCsiloedr2K6v7_4core3cmp9PartialEq2eqCs23Y5vRLZE35_19fvm_ipld_blockstore:
  253|  2.82k|    fn eq(&self, other: &Multihash<B>) -> bool {
  254|  2.82k|        // NOTE: there's no need to explicitly check the sizes, that's implicit in the digest.
  255|  2.82k|        self.code == other.code && self.digest() == other.digest()
  256|  2.82k|    }
_RNvMs_NtCsgR7ufpsWMe2_9multihash9multihashINtB4_9MultihashKj40_E4wrapB6_:
  101|  2.22k|    pub const fn wrap(code: u64, input_digest: &[u8]) -> Result<Self, Error> {
  102|  2.22k|        if input_digest.len() > S {
  103|      0|            return Err(Error::InvalidSize(input_digest.len() as _));
  104|  2.22k|        }
  105|  2.22k|        let size = input_digest.len();
  106|  2.22k|        let mut digest = [0; S];
  107|  2.22k|        let mut i = 0;
  108|  73.4k|        while i < size {
  109|  71.2k|            digest[i] = input_digest[i];
  110|  71.2k|            i += 1;
  111|  71.2k|        }
  112|  2.22k|        Ok(Self {
  113|  2.22k|            code,
  114|  2.22k|            size: size as u8,
  115|  2.22k|            digest,
  116|  2.22k|        })
  117|  2.22k|    }

_RNvXs3_NtCsgR7ufpsWMe2_9multihash14multihash_implNtB5_4CodeINtNtB7_9multihash15MultihashDigestKj40_E6digest:
   11|  2.22k|#[derive(Copy, Clone, Debug, Eq, Multihash, PartialEq)]

_RNvXse_NtCs9v2qPOzmHo1_10num_bigint6bigintNtB5_6BigIntNtNtCsaOMW4gJp9Em_10num_traits10identities4Zero4zero:
  213|  2.22k|    fn zero() -> BigInt {
  214|  2.22k|        BigInt {
  215|  2.22k|            sign: NoSign,
  216|  2.22k|            data: BigUint::zero(),
  217|  2.22k|        }
  218|  2.22k|    }
_RNvMsm_NtCs9v2qPOzmHo1_10num_bigint6bigintNtB5_6BigInt11to_bytes_be:
  731|    954|    pub fn to_bytes_be(&self) -> (Sign, Vec<u8>) {
  732|    954|        (self.sign, self.data.to_bytes_be())
  733|    954|    }
_RNvXs_NtCs9v2qPOzmHo1_10num_bigint6bigintNtB4_6BigIntNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
   71|  2.86k|    fn clone(&self) -> Self {
   72|  2.86k|        BigInt {
   73|  2.86k|            sign: self.sign,
   74|  2.86k|            data: self.data.clone(),
   75|  2.86k|        }
   76|  2.86k|    }
_RNvMsm_NtCs9v2qPOzmHo1_10num_bigint6bigintNtB5_6BigInt12from_biguint:
  582|    955|    pub fn from_biguint(mut sign: Sign, mut data: BigUint) -> BigInt {
  583|    955|        if sign == NoSign {
  584|      0|            data.assign_from_slice(&[]);
  585|    955|        } else if data.is_zero() {
  586|    636|            sign = NoSign;
  587|    636|        }
  588|       |
  589|    955|        BigInt { sign, data }
  590|    955|    }
_RNvXs5_NtCs9v2qPOzmHo1_10num_bigint6bigintNtB5_6BigIntNtNtCsiloedr2K6v7_4core7default7Default7default:
  134|    954|    fn default() -> BigInt {
  135|    954|        Zero::zero()
  136|    954|    }
_RNvXso_NtCs9v2qPOzmHo1_10num_bigint6bigintNtB5_4SignNtNtCsiloedr2K6v7_4core3cmp9PartialEq2eq:
   40|  2.54k|#[derive(PartialEq, PartialOrd, Eq, Ord, Copy, Clone, Debug, Hash)]
_RNvXse_NtCs9v2qPOzmHo1_10num_bigint6bigintNtB5_6BigIntNtNtCsaOMW4gJp9Em_10num_traits10identities4Zero7is_zero:
  227|    318|    fn is_zero(&self) -> bool {
  228|    318|        self.sign == NoSign
  229|    318|    }
_RNvXsj_NtCs9v2qPOzmHo1_10num_bigint6bigintNtB5_6BigIntNtCs6BGwtGqdCi_11num_integer7Integer7div_rem:
  356|    318|    fn div_rem(&self, other: &BigInt) -> (BigInt, BigInt) {
  357|    318|        // r.sign == self.sign
  358|    318|        let (d_ui, r_ui) = self.data.div_rem(&other.data);
  359|    318|        let d = BigInt::from_biguint(self.sign, d_ui);
  360|    318|        let r = BigInt::from_biguint(self.sign, r_ui);
  361|    318|        if other.is_negative() {
  362|      0|            (-d, r)
  363|       |        } else {
  364|    318|            (d, r)
  365|       |        }
  366|    318|    }
_RNvXsg_NtCs9v2qPOzmHo1_10num_bigint6bigintNtB5_6BigIntNtNtCsaOMW4gJp9Em_10num_traits4sign6Signed3abs:
  255|    636|    fn abs(&self) -> BigInt {
  256|    636|        match self.sign {
  257|    636|            Plus | NoSign => self.clone(),
  258|      0|            Minus => BigInt::from(self.data.clone()),
  259|       |        }
  260|    636|    }
_RNvXsg_NtCs9v2qPOzmHo1_10num_bigint6bigintNtB5_6BigIntNtNtCsaOMW4gJp9Em_10num_traits4sign6Signed11is_negative:
  286|  1.27k|    fn is_negative(&self) -> bool {
  287|  1.27k|        self.sign == Minus
  288|  1.27k|    }
_RNvMsm_NtCs9v2qPOzmHo1_10num_bigint6bigintNtB5_6BigInt12to_str_radix:
  870|    636|    pub fn to_str_radix(&self, radix: u32) -> String {
  871|    636|        let mut v = to_str_radix_reversed(&self.data, radix);
  872|    636|
  873|    636|        if self.is_negative() {
  874|      0|            v.push(b'-');
  875|    636|        }
  876|       |
  877|    636|        v.reverse();
  878|    636|        unsafe { String::from_utf8_unchecked(v) }
  879|    636|    }

_RNvXs4_NtNtCs9v2qPOzmHo1_10num_bigint6bigint7convertNtB7_6BigIntINtNtCsiloedr2K6v7_4core7convert4FromyE4from:
  228|    637|    fn from(n: u64) -> Self {
  229|    637|        if n > 0 {
  230|    637|            BigInt {
  231|    637|                sign: Plus,
  232|    637|                data: BigUint::from(n),
  233|    637|            }
  234|       |        } else {
  235|      0|            BigInt::zero()
  236|       |        }
  237|    637|    }
_RNvXNtNtCs9v2qPOzmHo1_10num_bigint6bigint7convertNtB4_6BigIntNtNtNtCsiloedr2K6v7_4core3str6traits7FromStr8from_str:
   19|    318|    fn from_str(s: &str) -> Result<BigInt, ParseBigIntError> {
   20|    318|        BigInt::from_str_radix(s, 10)
   21|    318|    }
_RNvXs_NtNtCs9v2qPOzmHo1_10num_bigint6bigint7convertNtB6_6BigIntNtCsaOMW4gJp9Em_10num_traits3Num14from_str_radix:
   29|    318|    fn from_str_radix(mut s: &str, radix: u32) -> Result<BigInt, ParseBigIntError> {
   30|    318|        let sign = if s.starts_with('-') {
   31|      0|            let tail = &s[1..];
   32|      0|            if !tail.starts_with('+') {
   33|      0|                s = tail
   34|      0|            }
   35|      0|            Minus
   36|       |        } else {
   37|    318|            Plus
   38|       |        };
   39|    318|        let bu = BigUint::from_str_radix(s, radix)?;
   40|    318|        Ok(BigInt::from_biguint(sign, bu))
   41|    318|    }
_RNvXs2_NtNtCs9v2qPOzmHo1_10num_bigint6bigint7convertNtB7_6BigIntINtNtCsiloedr2K6v7_4core7convert4FromxE4from:
  182|      1|    fn from(n: i64) -> Self {
  183|      1|        if n >= 0 {
  184|      1|            BigInt::from(n as u64)
  185|       |        } else {
  186|      0|            let u = core::u64::MAX - (n as u64) + 1;
  187|      0|            BigInt {
  188|      0|                sign: Minus,
  189|      0|                data: BigUint::from(u),
  190|      0|            }
  191|       |        }
  192|      1|    }

_RNvXs1_NtNtCs9v2qPOzmHo1_10num_bigint6bigint14multiplicationNtB7_6BigIntINtNtNtCsiloedr2K6v7_4core3ops5arith3MulyE3mul:
   97|      1|    fn mul(self, other: u64) -> BigInt {
   98|      1|        BigInt::from_biguint(self.sign, self.data * other)
   99|      1|    }

_RNvXsb_NtCs9v2qPOzmHo1_10num_bigint7biguintNtB5_7BigUintNtNtCsaOMW4gJp9Em_10num_traits10identities4Zero4zero:
  148|  3.18k|    fn zero() -> BigUint {
  149|  3.18k|        BigUint { data: Vec::new() }
  150|  3.18k|    }
_RNvXNtCs9v2qPOzmHo1_10num_bigint7biguintNtB2_7BigUintNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
   46|  3.49k|    fn clone(&self) -> Self {
   47|  3.49k|        BigUint {
   48|  3.49k|            data: self.data.clone(),
   49|  3.49k|        }
   50|  3.49k|    }
_RNvMsg_NtCs9v2qPOzmHo1_10num_bigint7biguintNtB5_7BigUint11to_bytes_be:
  678|    954|    pub fn to_bytes_be(&self) -> Vec<u8> {
  679|    954|        let mut v = self.to_bytes_le();
  680|    954|        v.reverse();
  681|    954|        v
  682|    954|    }
_RNvMsg_NtCs9v2qPOzmHo1_10num_bigint7biguintNtB5_7BigUint9normalize:
  848|    636|    fn normalize(&mut self) {
  849|    636|        if let Some(&0) = self.data.last() {
  850|    636|            let len = self.data.iter().rposition(|&d| d != 0).map_or(0, |i| i + 1);
  851|    636|            self.data.truncate(len);
  852|    636|        }
  853|    636|        if self.data.len() < self.data.capacity() / 4 {
  854|      0|            self.data.shrink_to_fit();
  855|    636|        }
  856|    636|    }
_RNvXsb_NtCs9v2qPOzmHo1_10num_bigint7biguintNtB5_7BigUintNtNtCsaOMW4gJp9Em_10num_traits10identities4Zero7is_zero:
  158|  4.13k|    fn is_zero(&self) -> bool {
  159|  4.13k|        self.data.is_empty()
  160|  4.13k|    }
_RNvMsg_NtCs9v2qPOzmHo1_10num_bigint7biguintNtB5_7BigUint11to_bytes_le:
  695|    954|    pub fn to_bytes_le(&self) -> Vec<u8> {
  696|    954|        if self.is_zero() {
  697|    954|            vec![0]
  698|       |        } else {
  699|      0|            convert::to_bitwise_digits_le(self, 8)
  700|       |        }
  701|    954|    }
_RNvMsg_NtCs9v2qPOzmHo1_10num_bigint7biguintNtB5_7BigUint10normalized:
  860|    636|    fn normalized(mut self) -> BigUint {
  861|    636|        self.normalize();
  862|    636|        self
  863|    636|    }
_RNvXse_NtCs9v2qPOzmHo1_10num_bigint7biguintNtB5_7BigUintNtCs6BGwtGqdCi_11num_integer7Integer7div_rem:
  185|    318|    fn div_rem(&self, other: &BigUint) -> (BigUint, BigUint) {
  186|    318|        division::div_rem_ref(self, other)
  187|    318|    }
_RNvMsg_NtCs9v2qPOzmHo1_10num_bigint7biguintNtB5_7BigUint4bits:
  837|    318|    pub fn bits(&self) -> u64 {
  838|    318|        if self.is_zero() {
  839|      0|            return 0;
  840|    318|        }
  841|    318|        let zeros: u64 = self.data.last().unwrap().leading_zeros().into();
  842|    318|        self.data.len() as u64 * u64::from(big_digit::BITS) - zeros
  843|    318|    }
_RNvNtCs9v2qPOzmHo1_10num_bigint7biguint16biguint_from_vec:
  514|    318|pub(crate) fn biguint_from_vec(digits: Vec<BigDigit>) -> BigUint {
  515|    318|    BigUint { data: digits }.normalized()
  516|    318|}
_RNCNvMsg_NtCs9v2qPOzmHo1_10num_bigint7biguintNtB7_7BigUint9normalize0B9_:
  850|    636|            let len = self.data.iter().rposition(|&d| d != 0).map_or(0, |i| i + 1);

_RNvXs2_NtNtCs9v2qPOzmHo1_10num_bigint7biguint7convertNtB7_7BigUintINtNtCsiloedr2K6v7_4core7convert4FromyE4from:
  476|    955|    fn from(mut n: u64) -> Self {
  477|    955|        let mut ret: BigUint = Zero::zero();
  478|       |
  479|  1.91k|        while n != 0 {
  480|    955|            ret.data.push(n as BigDigit);
  481|    955|            // don't overflow if BITS is 64:
  482|    955|            n = (n >> 1) >> (big_digit::BITS - 1);
  483|    955|        }
  484|       |
  485|    955|        ret
  486|    955|    }
_RNvXs_NtNtCs9v2qPOzmHo1_10num_bigint7biguint7convertNtB6_7BigUintNtCsaOMW4gJp9Em_10num_traits3Num14from_str_radix:
  214|    318|    fn from_str_radix(s: &str, radix: u32) -> Result<BigUint, ParseBigIntError> {
  215|    318|        assert!(2 <= radix && radix <= 36, "The radix must be within 2...36");
  216|    318|        let mut s = s;
  217|    318|        if s.starts_with('+') {
  218|      0|            let tail = &s[1..];
  219|      0|            if !tail.starts_with('+') {
  220|      0|                s = tail
  221|      0|            }
  222|    318|        }
  223|       |
  224|    318|        if s.is_empty() {
  225|      0|            return Err(ParseBigIntError::empty());
  226|    318|        }
  227|    318|
  228|    318|        if s.starts_with('_') {
  229|       |            // Must lead with a real digit!
  230|      0|            return Err(ParseBigIntError::invalid());
  231|    318|        }
  232|    318|
  233|    318|        // First normalize all characters to plain digit values
  234|    318|        let mut v = Vec::with_capacity(s.len());
  235|    318|        for b in s.bytes() {
  236|    318|            let d = match b {
  237|    318|                b'0'..=b'9' => b - b'0',
  238|      0|                b'a'..=b'z' => b - b'a' + 10,
  239|      0|                b'A'..=b'Z' => b - b'A' + 10,
  240|      0|                b'_' => continue,
  241|      0|                _ => core::u8::MAX,
  242|       |            };
  243|    318|            if d < radix as u8 {
  244|    318|                v.push(d);
  245|    318|            } else {
  246|      0|                return Err(ParseBigIntError::invalid());
  247|       |            }
  248|       |        }
  249|       |
  250|    318|        let res = if radix.is_power_of_two() {
  251|       |            // Powers of two can use bitwise masks and shifting instead of multiplication
  252|      0|            let bits = ilog2(radix);
  253|      0|            v.reverse();
  254|      0|            if big_digit::BITS % bits == 0 {
  255|      0|                from_bitwise_digits_le(&v, bits)
  256|       |            } else {
  257|      0|                from_inexact_bitwise_digits_le(&v, bits)
  258|       |            }
  259|       |        } else {
  260|    318|            from_radix_digits_be(&v, radix)
  261|       |        };
  262|    318|        Ok(res)
  263|    318|    }
_RNvNtNtCs9v2qPOzmHo1_10num_bigint7biguint7convert20from_radix_digits_be:
  101|    318|fn from_radix_digits_be(v: &[u8], radix: u32) -> BigUint {
  102|    318|    debug_assert!(!v.is_empty() && !radix.is_power_of_two());
  103|    318|    debug_assert!(v.iter().all(|&c| u32::from(c) < radix));
  104|       |
  105|       |    #[cfg(feature = "std")]
  106|    318|    let radix_log2 = f64::from(radix).log2();
  107|    318|    #[cfg(not(feature = "std"))]
  108|    318|    let radix_log2 = ilog2(radix.next_power_of_two()) as f64;
  109|    318|
  110|    318|    // Estimate how big the result will be, so we can pre-allocate it.
  111|    318|    let bits = radix_log2 * v.len() as f64;
  112|    318|    let big_digits = (bits / big_digit::BITS as f64).ceil();
  113|    318|    let mut data = Vec::with_capacity(big_digits.to_usize().unwrap_or(0));
  114|    318|
  115|    318|    let (base, power) = get_radix_base(radix, big_digit::BITS);
  116|    318|    let radix = radix as BigDigit;
  117|    318|
  118|    318|    let r = v.len() % power;
  119|    318|    let i = if r == 0 { power } else { r };
  120|    318|    let (head, tail) = v.split_at(i);
  121|    318|
  122|    318|    let first = head
  123|    318|        .iter()
  124|    318|        .fold(0, |acc, &d| acc * radix + BigDigit::from(d));
  125|    318|    data.push(first);
  126|       |
  127|    318|    debug_assert!(tail.len() % power == 0);
  128|    318|    for chunk in tail.chunks(power) {
  129|      0|        if data.last() != Some(&0) {
  130|      0|            data.push(0);
  131|      0|        }
  132|       |
  133|      0|        let mut carry = 0;
  134|      0|        for d in data.iter_mut() {
  135|      0|            *d = mac_with_carry(0, *d, base, &mut carry);
  136|      0|        }
  137|      0|        debug_assert!(carry == 0);
  138|       |
  139|      0|        let n = chunk
  140|      0|            .iter()
  141|      0|            .fold(0, |acc, &d| acc * radix + BigDigit::from(d));
  142|      0|        add2(&mut data, &[n]);
  143|       |    }
  144|       |
  145|    318|    biguint_from_vec(data)
  146|    318|}
_RNCNvNtNtCs9v2qPOzmHo1_10num_bigint7biguint7convert20from_radix_digits_be0B7_:
  124|    318|        .fold(0, |acc, &d| acc * radix + BigDigit::from(d));
_RNvNtNtCs9v2qPOzmHo1_10num_bigint7biguint7convert21to_str_radix_reversed:
  734|    636|pub(crate) fn to_str_radix_reversed(u: &BigUint, radix: u32) -> Vec<u8> {
  735|    636|    assert!(2 <= radix && radix <= 36, "The radix must be within 2...36");
  736|       |
  737|    636|    if u.is_zero() {
  738|    318|        return vec![b'0'];
  739|    318|    }
  740|    318|
  741|    318|    let mut res = to_radix_le(u, radix);
  742|       |
  743|       |    // Now convert everything to ASCII digits.
  744|  1.27k|    for r in &mut res {
  745|    954|        debug_assert!(u32::from(*r) < radix);
  746|    954|        if *r < 10 {
  747|    954|            *r += b'0';
  748|    954|        } else {
  749|      0|            *r += b'a' - 10;
  750|      0|        }
  751|       |    }
  752|    318|    res
  753|    636|}
_RNCNvNtNtCs9v2qPOzmHo1_10num_bigint7biguint7convert20from_radix_digits_bes0_0B7_:
  103|    318|    debug_assert!(v.iter().all(|&c| u32::from(c) < radix));
_RNvNtNtCs9v2qPOzmHo1_10num_bigint7biguint7convert18to_radix_digits_le:
  646|    318|pub(super) fn to_radix_digits_le(u: &BigUint, radix: u32) -> Vec<u8> {
  647|    318|    debug_assert!(!u.is_zero() && !radix.is_power_of_two());
  648|       |
  649|       |    #[cfg(feature = "std")]
  650|    318|    let radix_log2 = f64::from(radix).log2();
  651|    318|    #[cfg(not(feature = "std"))]
  652|    318|    let radix_log2 = ilog2(radix) as f64;
  653|    318|
  654|    318|    // Estimate how big the result will be, so we can pre-allocate it.
  655|    318|    let radix_digits = ((u.bits() as f64) / radix_log2).ceil();
  656|    318|    let mut res = Vec::with_capacity(radix_digits.to_usize().unwrap_or(0));
  657|    318|
  658|    318|    let mut digits = u.clone();
  659|    318|
  660|    318|    let (base, power) = get_radix_base(radix, big_digit::HALF_BITS);
  661|    318|    let radix = radix as BigDigit;
  662|    318|
  663|    318|    // For very large numbers, the O(n) loop of repeated `div_rem_digit` dominates the
  664|    318|    // performance. We can mitigate this by dividing into chunks of a larger base first.
  665|    318|    // The threshold for this was chosen by anecdotal performance measurements to
  666|    318|    // approximate where this starts to make a noticeable difference.
  667|    318|    if digits.data.len() >= 64 {
  668|      0|        let mut big_base = BigUint::from(base * base);
  669|      0|        let mut big_power = 2usize;
  670|      0|
  671|      0|        // Choose a target base length near n.
  672|      0|        let target_len = digits.data.len().sqrt();
  673|      0|        while big_base.data.len() < target_len {
  674|      0|            big_base = &big_base * &big_base;
  675|      0|            big_power *= 2;
  676|      0|        }
  677|       |
  678|       |        // This outer loop will run approximately n times.
  679|      0|        while digits > big_base {
  680|       |            // This is still the dominating factor, with n digits divided by n digits.
  681|      0|            let (q, mut big_r) = digits.div_rem(&big_base);
  682|      0|            digits = q;
  683|      0|
  684|      0|            // This inner loop now has O(n)=O(n) behavior altogether.
  685|      0|            for _ in 0..big_power {
  686|      0|                let (q, mut r) = div_rem_digit(big_r, base);
  687|      0|                big_r = q;
  688|      0|                for _ in 0..power {
  689|      0|                    res.push((r % radix) as u8);
  690|      0|                    r /= radix;
  691|      0|                }
  692|       |            }
  693|       |        }
  694|    318|    }
  695|       |
  696|    318|    while digits.data.len() > 1 {
  697|      0|        let (q, mut r) = div_rem_digit(digits, base);
  698|      0|        for _ in 0..power {
  699|      0|            res.push((r % radix) as u8);
  700|      0|            r /= radix;
  701|      0|        }
  702|      0|        digits = q;
  703|       |    }
  704|       |
  705|    318|    let mut r = digits.data[0];
  706|  1.27k|    while r != 0 {
  707|    954|        res.push((r % radix) as u8);
  708|    954|        r /= radix;
  709|    954|    }
  710|       |
  711|    318|    res
  712|    318|}
_RNvNtNtCs9v2qPOzmHo1_10num_bigint7biguint7convert11to_radix_le:
  714|    318|pub(super) fn to_radix_le(u: &BigUint, radix: u32) -> Vec<u8> {
  715|    318|    if u.is_zero() {
  716|      0|        vec![0]
  717|    318|    } else if radix.is_power_of_two() {
  718|       |        // Powers of two can use bitwise masks and shifting instead of division
  719|      0|        let bits = ilog2(radix);
  720|      0|        if big_digit::BITS % bits == 0 {
  721|      0|            to_bitwise_digits_le(u, bits)
  722|       |        } else {
  723|      0|            to_inexact_bitwise_digits_le(u, bits)
  724|       |        }
  725|    318|    } else if radix == 10 {
  726|       |        // 10 is so common that it's worth separating out for const-propagation.
  727|       |        // Optimizers can often turn constant division into a faster multiplication.
  728|    318|        to_radix_digits_le(u, 10)
  729|       |    } else {
  730|      0|        to_radix_digits_le(u, radix)
  731|       |    }
  732|    318|}
_RNvNtNtCs9v2qPOzmHo1_10num_bigint7biguint7convert14get_radix_base:
  757|    636|fn get_radix_base(radix: u32, bits: u8) -> (BigDigit, usize) {
  758|       |    mod gen {
  759|       |        include! { concat!(env!("OUT_DIR"), "/radix_bases.rs") }
  760|       |    }
  761|       |
  762|       |    debug_assert!(
  763|    636|        2 <= radix && radix <= 256,
  764|       |        "The radix must be within 2...256"
  765|       |    );
  766|    636|    debug_assert!(!radix.is_power_of_two());
  767|    636|    debug_assert!(bits <= big_digit::BITS);
  768|       |
  769|    636|    match bits {
  770|       |        16 => {
  771|      0|            let (base, power) = gen::BASES_16[radix as usize];
  772|      0|            (base as BigDigit, power)
  773|       |        }
  774|       |        32 => {
  775|    318|            let (base, power) = gen::BASES_32[radix as usize];
  776|    318|            (base as BigDigit, power)
  777|       |        }
  778|       |        64 => {
  779|    318|            let (base, power) = gen::BASES_64[radix as usize];
  780|    318|            (base as BigDigit, power)
  781|       |        }
  782|      0|        _ => panic!("Invalid bigdigit size"),
  783|       |    }
  784|    636|}

_RNvNtNtCs9v2qPOzmHo1_10num_bigint7biguint8division11div_rem_ref:
  166|    318|pub(super) fn div_rem_ref(u: &BigUint, d: &BigUint) -> (BigUint, BigUint) {
  167|    318|    if d.is_zero() {
  168|      0|        panic!("attempt to divide by zero")
  169|    318|    }
  170|    318|    if u.is_zero() {
  171|      0|        return (Zero::zero(), Zero::zero());
  172|    318|    }
  173|    318|
  174|    318|    if d.data.len() == 1 {
  175|    318|        if d.data == [1] {
  176|      0|            return (u.clone(), Zero::zero());
  177|    318|        }
  178|    318|
  179|    318|        let (div, rem) = div_rem_digit(u.clone(), d.data[0]);
  180|    318|        return (div, rem.into());
  181|      0|    }
  182|      0|
  183|      0|    // Required or the q_len calculation below can underflow:
  184|      0|    match u.cmp(d) {
  185|      0|        Less => return (Zero::zero(), u.clone()),
  186|      0|        Equal => return (One::one(), Zero::zero()),
  187|      0|        Greater => {} // Do nothing
  188|      0|    }
  189|      0|
  190|      0|    // This algorithm is from Knuth, TAOCP vol 2 section 4.3, algorithm D:
  191|      0|    //
  192|      0|    // First, normalize the arguments so the highest bit in the highest digit of the divisor is
  193|      0|    // set: the main loop uses the highest digit of the divisor for generating guesses, so we
  194|      0|    // want it to be the largest number we can efficiently divide by.
  195|      0|    //
  196|      0|    let shift = d.data.last().unwrap().leading_zeros() as usize;
  197|      0|
  198|      0|    if shift == 0 {
  199|       |        // no need to clone d
  200|      0|        div_rem_core(u.clone(), &d.data)
  201|       |    } else {
  202|      0|        let (q, r) = div_rem_core(u << shift, &(d << shift).data);
  203|      0|        // renormalize the remainder
  204|      0|        (q, r >> shift)
  205|       |    }
  206|    318|}
_RNvNtNtCs9v2qPOzmHo1_10num_bigint7biguint8division8div_wide:
   22|    318|fn div_wide(hi: BigDigit, lo: BigDigit, divisor: BigDigit) -> (BigDigit, BigDigit) {
   23|    318|    debug_assert!(hi < divisor);
   24|       |
   25|    318|    let lhs = big_digit::to_doublebigdigit(hi, lo);
   26|    318|    let rhs = DoubleBigDigit::from(divisor);
   27|    318|    ((lhs / rhs) as BigDigit, (lhs % rhs) as BigDigit)
   28|    318|}
_RNvNtNtCs9v2qPOzmHo1_10num_bigint7biguint8division13div_rem_digit:
   43|    318|pub(super) fn div_rem_digit(mut a: BigUint, b: BigDigit) -> (BigUint, BigDigit) {
   44|    318|    if b == 0 {
   45|      0|        panic!("attempt to divide by zero")
   46|    318|    }
   47|    318|
   48|    318|    let mut rem = 0;
   49|    318|
   50|    318|    if b <= big_digit::HALF {
   51|      0|        for d in a.data.iter_mut().rev() {
   52|      0|            let (q, r) = div_half(rem, *d, b);
   53|      0|            *d = q;
   54|      0|            rem = r;
   55|      0|        }
   56|       |    } else {
   57|    318|        for d in a.data.iter_mut().rev() {
   58|    318|            let (q, r) = div_wide(rem, *d, b);
   59|    318|            *d = q;
   60|    318|            rem = r;
   61|    318|        }
   62|       |    }
   63|       |
   64|    318|    (a.normalized(), rem)
   65|    318|}

_RNvXs0_NtNtCs9v2qPOzmHo1_10num_bigint7biguint14multiplicationNtB7_7BigUintINtNtNtCsiloedr2K6v7_4core3ops5arith3MulyE3mul:
  481|      1|    fn mul(mut self, other: u64) -> BigUint {
  482|      1|        self *= other;
  483|      1|        self
  484|      1|    }
_RNvXs1_NtNtCs9v2qPOzmHo1_10num_bigint7biguint14multiplicationNtB7_7BigUintINtNtNtCsiloedr2K6v7_4core3ops5arith9MulAssignyE10mul_assign:
  500|      1|    fn mul_assign(&mut self, other: u64) {
  501|      1|        scalar_mul(self, other);
  502|      1|    }
_RNvNtNtCs9v2qPOzmHo1_10num_bigint7biguint14multiplication14mul_with_carry:
   31|      1|fn mul_with_carry(a: BigDigit, b: BigDigit, acc: &mut DoubleBigDigit) -> BigDigit {
   32|      1|    *acc += DoubleBigDigit::from(a) * DoubleBigDigit::from(b);
   33|      1|    let lo = *acc as BigDigit;
   34|      1|    *acc >>= big_digit::BITS;
   35|      1|    lo
   36|      1|}
_RNvNtNtCs9v2qPOzmHo1_10num_bigint7biguint14multiplication10scalar_mul:
  360|      1|fn scalar_mul(a: &mut BigUint, b: BigDigit) {
  361|      1|    match b {
  362|      0|        0 => a.set_zero(),
  363|      0|        1 => {}
  364|       |        _ => {
  365|      1|            if b.is_power_of_two() {
  366|      0|                *a <<= b.trailing_zeros();
  367|      0|            } else {
  368|      1|                let mut carry = 0;
  369|      1|                for a in a.data.iter_mut() {
  370|      1|                    *a = mul_with_carry(*a, b, &mut carry);
  371|      1|                }
  372|      1|                if carry != 0 {
  373|      1|                    a.data.push(carry as BigDigit);
  374|      1|                }
  375|       |            }
  376|       |        }
  377|       |    }
  378|      1|}

_RNvNtCs9v2qPOzmHo1_10num_bigint9big_digit17to_doublebigdigit:
  291|    318|    pub(crate) fn to_doublebigdigit(hi: BigDigit, lo: BigDigit) -> DoubleBigDigit {
  292|    318|        DoubleBigDigit::from(lo) | (DoubleBigDigit::from(hi) << BITS)
  293|    318|    }

_RNvXse_NtCsaOMW4gJp9Em_10num_traits4castdNtB5_11ToPrimitive8to_usize:
  344|    636|        fn $method(&self) -> Option<$u> {
  345|    636|            // Float as int truncates toward zero, so we want to allow values
  346|    636|            // in the exclusive range `(-1, MAX+1)`.
  347|    636|            if size_of::<$f>() > size_of::<$u>() {
  348|       |                // With a larger size, we can represent the range exactly.
  349|       |                const MAX_P1: $f = $u::MAX as $f + 1.0;
  350|      0|                if *self > -1.0 && *self < MAX_P1 {
  351|      0|                    return Some(float_to_int_unchecked!(*self => $u));
  352|      0|                }
  353|       |            } else {
  354|       |                // We can't represent `MAX` exactly, but it will round up to exactly
  355|       |                // `MAX+1` (a power of two) when we cast it.
  356|       |                // (`u128::MAX as f32` is infinity, but this is still ok.)
  357|       |                const MAX_P1: $f = $u::MAX as $f;
  358|    636|                if *self > -1.0 && *self < MAX_P1 {
  359|    636|                    return Some(float_to_int_unchecked!(*self => $u));
  360|      0|                }
  361|       |            }
  362|      0|            None
  363|    636|        }

_RNvMs2_NtCs4gjKgEj0yVt_9once_cell3impINtB5_8OnceCellNtNtCs9pDt8l5wGDA_5alloc6string6StringE14is_initializedCsboUdcTbF1FS_15direct_syscalls:
   59|    318|    pub(crate) fn is_initialized(&self) -> bool {
   60|    318|        // An `Acquire` load is enough because that makes all the initialization
   61|    318|        // operations visible to us, and, this being a fast path, weaker
   62|    318|        // ordering helps with performance. This `Acquire` synchronizes with
   63|    318|        // `SeqCst` operations on the slow path.
   64|    318|        self.queue.load(Ordering::Acquire) == COMPLETE_PTR
   65|    318|    }
_RNvMs2_NtCs4gjKgEj0yVt_9once_cell3impINtB5_8OnceCellNtNtCsiloedr2K6v7_4core4time8DurationE3newCskJihg1y13m7_3fvm:
   41|    318|    pub(crate) const fn new() -> OnceCell<T> {
   42|    318|        OnceCell {
   43|    318|            queue: AtomicPtr::new(INCOMPLETE_PTR),
   44|    318|            _marker: PhantomData,
   45|    318|            value: UnsafeCell::new(None),
   46|    318|        }
   47|    318|    }
_RNvMs2_NtCs4gjKgEj0yVt_9once_cell3impINtB5_8OnceCellINtNtCsiloedr2K6v7_4core6result6ResultuNtNtCs9pDt8l5wGDA_5alloc6string6StringEE3newCsaCHOb31h0oq_8wasmtime:
   41|    636|    pub(crate) const fn new() -> OnceCell<T> {
   42|    636|        OnceCell {
   43|    636|            queue: AtomicPtr::new(INCOMPLETE_PTR),
   44|    636|            _marker: PhantomData,
   45|    636|            value: UnsafeCell::new(None),
   46|    636|        }
   47|    636|    }

_RNvMs4_NtCs4gjKgEj0yVt_9once_cell4syncINtB5_8OnceCellNtNtCs9pDt8l5wGDA_5alloc6string6StringE3getCsboUdcTbF1FS_15direct_syscalls:
  922|    318|        pub fn get(&self) -> Option<&T> {
  923|    318|            if self.0.is_initialized() {
  924|       |                // Safe b/c value is initialized.
  925|      0|                Some(unsafe { self.get_unchecked() })
  926|       |            } else {
  927|    318|                None
  928|       |            }
  929|    318|        }
_RNvXNtCs4gjKgEj0yVt_9once_cell4syncINtB2_8OnceCellNtNtCsiloedr2K6v7_4core4time8DurationENtNtBQ_7default7Default7defaultCskJihg1y13m7_3fvm:
  863|    318|        fn default() -> OnceCell<T> {
  864|    318|            OnceCell::new()
  865|    318|        }
_RNvMs4_NtCs4gjKgEj0yVt_9once_cell4syncINtB5_8OnceCellNtNtCsiloedr2K6v7_4core4time8DurationE3newCskJihg1y13m7_3fvm:
  909|    318|        pub const fn new() -> OnceCell<T> {
  910|    318|            OnceCell(Imp::new())
  911|    318|        }
_RNvMs4_NtCs4gjKgEj0yVt_9once_cell4syncINtB5_8OnceCellINtNtCsiloedr2K6v7_4core6result6ResultuNtNtCs9pDt8l5wGDA_5alloc6string6StringEE3newCsaCHOb31h0oq_8wasmtime:
  909|    636|        pub const fn new() -> OnceCell<T> {
  910|    636|            OnceCell(Imp::new())
  911|    636|        }

_RNvMNvNtNtCsiUfFVXq5yp2_12futures_util2io4take1__INtB4_4TakeQRShE7projectCs7AwuCMXPzRZ_8fvm_fuzz:
  926|  11.7k|        $proj_vis fn $method_ident<'__pin>(
  927|  11.7k|            self: $crate::__private::Pin<&'__pin $($mut)? Self>,
  928|  11.7k|        ) -> $proj_ty_ident <'__pin, $($ty_generics)*> {
  929|  11.7k|            unsafe {
  930|  11.7k|                let Self { $($field),* } = self.$get_method();
  931|  11.7k|                $proj_ty_ident {
  932|  11.7k|                    $(
  933|  11.7k|                        $field: $crate::__pin_project_make_unsafe_field_proj!(
  934|  11.7k|                            $(#[$pin])? $field
  935|  11.7k|                        )
  936|  11.7k|                    ),+
  937|  11.7k|                }
  938|  11.7k|            }
  939|  11.7k|        }

_RNvXs_NtCs11zJFIUYmdy_10ppv_lite864softINtB4_2x2INtNtNtNtB6_6x86_644sse24avx212u32x4x2_avx2NtBR_4NoNIENtBP_2G0ENtNtB6_5types16RotateEachWord3224rotate_each_word_right20CsjsLu06DJe91_11rand_chacha:
   42|    960|        fn $fn(self) -> Self {
   43|    960|            x2::new([self.0[0].$fn(), self.0[1].$fn()])
   44|    960|        }
_RNvXs_NtCs11zJFIUYmdy_10ppv_lite864softINtB4_2x2INtNtNtNtB6_6x86_644sse24avx212u32x4x2_avx2NtBR_4NoNIENtBP_2G0ENtNtB6_5types16RotateEachWord3224rotate_each_word_right25CsjsLu06DJe91_11rand_chacha:
   42|    960|        fn $fn(self) -> Self {
   43|    960|            x2::new([self.0[0].$fn(), self.0[1].$fn()])
   44|    960|        }
_RNvXsg_NtCs11zJFIUYmdy_10ppv_lite864softINtB5_2x2INtNtNtNtB7_6x86_644sse24avx212u32x4x2_avx2NtBS_4NoNIENtBQ_2G0ENtNtB7_5types10LaneWords422shuffle_lane_words1230CsjsLu06DJe91_11rand_chacha:
  208|    960|    fn shuffle_lane_words1230(self) -> Self {
  209|    960|        Self::new([
  210|    960|            self.0[0].shuffle_lane_words1230(),
  211|    960|            self.0[1].shuffle_lane_words1230(),
  212|    960|        ])
  213|    960|    }
_RNvXsg_NtCs11zJFIUYmdy_10ppv_lite864softINtB5_2x2INtNtNtNtB7_6x86_644sse24avx212u32x4x2_avx2NtBS_4NoNIENtBQ_2G0ENtNtB7_5types10LaneWords422shuffle_lane_words3012CsjsLu06DJe91_11rand_chacha:
  215|    960|    fn shuffle_lane_words3012(self) -> Self {
  216|    960|        Self::new([
  217|    960|            self.0[0].shuffle_lane_words3012(),
  218|    960|            self.0[1].shuffle_lane_words3012(),
  219|    960|        ])
  220|    960|    }
_RNvXs_NtCs11zJFIUYmdy_10ppv_lite864softINtB4_2x2INtNtNtNtB6_6x86_644sse24avx212u32x4x2_avx2NtBR_4NoNIENtBP_2G0ENtNtB6_5types16RotateEachWord3224rotate_each_word_right24CsjsLu06DJe91_11rand_chacha:
   42|    960|        fn $fn(self) -> Self {
   43|    960|            x2::new([self.0[0].$fn(), self.0[1].$fn()])
   44|    960|        }
_RNvXsM_NtCs11zJFIUYmdy_10ppv_lite864softINtB5_2x2INtNtNtNtB7_6x86_644sse24avx212u32x4x2_avx2NtBS_4NoNIENtBQ_2G0ENtNtNtCsiloedr2K6v7_4core3ops5arith9AddAssign10add_assignCsjsLu06DJe91_11rand_chacha:
   32|  3.84k|            fn $fn_assign(&mut self, rhs: Self) {
   33|  3.84k|                (self.0[0]).$fn_assign(rhs.0[0]);
   34|  3.84k|                (self.0[1]).$fn_assign(rhs.0[1]);
   35|  3.84k|            }
_RNvXs_NtCs11zJFIUYmdy_10ppv_lite864softINtB4_2x2INtNtNtNtB6_6x86_644sse24avx212u32x4x2_avx2NtBR_4NoNIENtBP_2G0ENtNtB6_5types16RotateEachWord3224rotate_each_word_right16CsjsLu06DJe91_11rand_chacha:
   42|    960|        fn $fn(self) -> Self {
   43|    960|            x2::new([self.0[0].$fn(), self.0[1].$fn()])
   44|    960|        }
_RNvMNtCs11zJFIUYmdy_10ppv_lite864softINtB2_2x2INtNtNtNtB4_6x86_644sse24avx212u32x4x2_avx2NtBP_4NoNIENtBN_2G0E3newCsjsLu06DJe91_11rand_chacha:
   13|  10.9k|    pub fn new(xs: [W; 2]) -> Self {
   14|  10.9k|        x2(xs, PhantomData)
   15|  10.9k|    }
_RNvXsg_NtCs11zJFIUYmdy_10ppv_lite864softINtB5_2x2INtNtNtNtB7_6x86_644sse24avx212u32x4x2_avx2NtBS_4NoNIENtBQ_2G0ENtNtB7_5types10LaneWords422shuffle_lane_words2301CsjsLu06DJe91_11rand_chacha:
  201|    960|    fn shuffle_lane_words2301(self) -> Self {
  202|    960|        Self::new([
  203|    960|            self.0[0].shuffle_lane_words2301(),
  204|    960|            self.0[1].shuffle_lane_words2301(),
  205|    960|        ])
  206|    960|    }
_RNvXsG_NtCs11zJFIUYmdy_10ppv_lite864softINtB5_2x2INtNtNtNtB7_6x86_644sse24avx212u32x4x2_avx2NtBS_4NoNIENtBQ_2G0ENtNtNtCsiloedr2K6v7_4core3ops3bit6BitXor6bitxorCsjsLu06DJe91_11rand_chacha:
   22|  3.84k|            fn $fn(self, rhs: Self) -> Self::Output {
   23|  3.84k|                x2::new([self.0[0].$fn(rhs.0[0]), self.0[1].$fn(rhs.0[1])])
   24|  3.84k|            }

_RINvYINtNtCs11zJFIUYmdy_10ppv_lite866x86_6410SseMachineNtB6_5YesS3NtB6_5YesS4NtB6_4NoNIENtNtB8_5types7Machine7read_leINtNtB6_4sse210u32x4_sse2BR_B12_B1d_EECsjsLu06DJe91_11rand_chacha:
  259|      2|    fn read_le<V>(self, input: &[u8]) -> V
  260|      2|    where
  261|      2|        V: StoreBytes,
  262|      2|    {
  263|      2|        unsafe { V::unsafe_read_le(input) }
  264|      2|    }
_RINvYINtNtCs11zJFIUYmdy_10ppv_lite866x86_6411Avx2MachineNtB6_4NoNIENtNtB8_5types7Machine6unpackNtB6_14vec128_storageINtNtB6_4sse210u32x4_sse2NtB6_5YesS3NtB6_5YesS4BS_EECsjsLu06DJe91_11rand_chacha:
  246|    720|    fn unpack<S, V: Store<S>>(self, s: S) -> V {
  247|    720|        unsafe { V::unpack(s) }
  248|    720|    }
_RINvYINtNtCs11zJFIUYmdy_10ppv_lite866x86_6411Avx2MachineNtB6_4NoNIENtNtB8_5types7Machine6unpackNtB6_14vec512_storageINtNtB8_4soft2x2INtNtNtB6_4sse24avx212u32x4x2_avx2BS_ENtB2b_2G0EECsjsLu06DJe91_11rand_chacha:
  246|     80|    fn unpack<S, V: Store<S>>(self, s: S) -> V {
  247|     80|        unsafe { V::unpack(s) }
  248|     80|    }
_RINvYINtNtCs11zJFIUYmdy_10ppv_lite866x86_6411Avx2MachineNtB6_4NoNIENtNtB8_5types7Machine3vecINtNtB6_4sse210u32x4_sse2NtB6_5YesS3NtB6_5YesS4BS_EAmj4_ECsjsLu06DJe91_11rand_chacha:
  251|     80|    fn vec<V, A>(self, a: A) -> V
  252|     80|    where
  253|     80|        V: MultiLane<A>,
  254|     80|    {
  255|     80|        V::from_lanes(a)
  256|     80|    }

_RNvXs_NtCs11zJFIUYmdy_10ppv_lite866x86_64INtB4_11Avx2MachineNtB4_4NoNIENtNtB6_5types7Machine8instanceCsjsLu06DJe91_11rand_chacha:
   92|     80|    unsafe fn instance() -> Self {
   93|     80|        Avx2Machine(PhantomData)
   94|     80|    }
_RNvNtCsjsLu06DJe91_11rand_chacha4guts11refill_wide:
  250|     80|        $($pub$(($krate))*)* fn $name($($arg: $argty),*) -> $ret {
  251|       |            #[inline(always)]
  252|       |            fn fn_impl<$MTy: $crate::Machine>($mach: $MTy, $($arg: $argty),*) -> $ret $body
  253|       |            use std::arch::x86_64::*;
  254|       |            #[target_feature(enable = "avx2")]
  255|       |            unsafe fn impl_avx2($($arg: $argty),*) -> $ret {
  256|       |                let ret = fn_impl($crate::x86_64::AVX2::instance(), $($arg),*);
  257|       |                _mm256_zeroupper();
  258|       |                ret
  259|       |            }
  260|       |            #[target_feature(enable = "avx")]
  261|       |            #[target_feature(enable = "sse4.1")]
  262|       |            #[target_feature(enable = "ssse3")]
  263|       |            unsafe fn impl_avx($($arg: $argty),*) -> $ret {
  264|       |                let ret = fn_impl($crate::x86_64::AVX::instance(), $($arg),*);
  265|       |                _mm256_zeroupper();
  266|       |                ret
  267|       |            }
  268|       |            #[target_feature(enable = "sse4.1")]
  269|       |            #[target_feature(enable = "ssse3")]
  270|       |            unsafe fn impl_sse41($($arg: $argty),*) -> $ret {
  271|       |                fn_impl($crate::x86_64::SSE41::instance(), $($arg),*)
  272|       |            }
  273|       |            #[target_feature(enable = "ssse3")]
  274|       |            unsafe fn impl_ssse3($($arg: $argty),*) -> $ret {
  275|       |                fn_impl($crate::x86_64::SSSE3::instance(), $($arg),*)
  276|       |            }
  277|       |            #[target_feature(enable = "sse2")]
  278|       |            unsafe fn impl_sse2($($arg: $argty),*) -> $ret {
  279|       |                fn_impl($crate::x86_64::SSE2::instance(), $($arg),*)
  280|       |            }
  281|       |            unsafe {
  282|      0|                if is_x86_feature_detected!("avx2") {
  283|     80|                    impl_avx2($($arg),*)
  284|      0|                } else if is_x86_feature_detected!("avx") {
  285|      0|                    impl_avx($($arg),*)
  286|      0|                } else if is_x86_feature_detected!("sse4.1") {
  287|      0|                    impl_sse41($($arg),*)
  288|      0|                } else if is_x86_feature_detected!("ssse3") {
  289|      0|                    impl_ssse3($($arg),*)
  290|      0|                } else if is_x86_feature_detected!("sse2") {
  291|      0|                    impl_sse2($($arg),*)
  292|       |                } else {
  293|      0|                    unimplemented!()
  294|       |                }
  295|       |            }
  296|     80|        }
_RNvXNtCs11zJFIUYmdy_10ppv_lite866x86_64INtB2_10SseMachineNtB2_5YesS3NtB2_5YesS4NtB2_4NoNIENtNtB4_5types7Machine8instanceCsjsLu06DJe91_11rand_chacha:
   64|      1|    unsafe fn instance() -> Self {
   65|      1|        SseMachine(PhantomData)
   66|      1|    }
_RNvNtCsjsLu06DJe91_11rand_chacha4guts11init_chacha:
  333|      1|        $($pub $(($krate))*)* fn $name($($arg: $argty),*) -> $ret {
  334|       |            #[inline(always)]
  335|       |            fn fn_impl<$MTy: $crate::Machine>($mach: $MTy, $($arg: $argty),*) -> $ret $body
  336|       |            use std::arch::x86_64::*;
  337|       |            #[target_feature(enable = "avx")]
  338|       |            unsafe fn impl_avx($($arg: $argty),*) -> $ret {
  339|       |                fn_impl($crate::x86_64::AVX::instance(), $($arg),*)
  340|       |            }
  341|       |            #[target_feature(enable = "sse2")]
  342|       |            unsafe fn impl_sse2($($arg: $argty),*) -> $ret {
  343|       |                fn_impl($crate::x86_64::SSE2::instance(), $($arg),*)
  344|       |            }
  345|       |            unsafe {
  346|      0|                if is_x86_feature_detected!("avx") {
  347|      1|                    impl_avx($($arg),*)
  348|      0|                } else if is_x86_feature_detected!("sse2") {
  349|      0|                    impl_sse2($($arg),*)
  350|       |                } else {
  351|      0|                    unimplemented!()
  352|       |                }
  353|       |            }
  354|      1|        }
_RNvNvNtCsjsLu06DJe91_11rand_chacha4guts11refill_wide9impl_avx2:
  255|     80|            unsafe fn impl_avx2($($arg: $argty),*) -> $ret {
  256|     80|                let ret = fn_impl($crate::x86_64::AVX2::instance(), $($arg),*);
  257|     80|                _mm256_zeroupper();
  258|     80|                ret
  259|     80|            }
_RNvXs2_NtCs11zJFIUYmdy_10ppv_lite866x86_64NtB5_14vec128_storageINtNtCsiloedr2K6v7_4core7convert4FromAmj4_E4from:
  130|      1|    fn from(u32x4: [u32; 4]) -> Self {
  131|      1|        vec128_storage { u32x4 }
  132|      1|    }
_RNvNvNtCsjsLu06DJe91_11rand_chacha4guts11init_chacha8impl_avx:
  338|      1|            unsafe fn impl_avx($($arg: $argty),*) -> $ret {
  339|      1|                fn_impl($crate::x86_64::AVX::instance(), $($arg),*)
  340|      1|            }

_RNvXsf_NtNtNtCs11zJFIUYmdy_10ppv_lite866x86_644sse24avx2INtNtBb_4soft2x2INtB5_12u32x4x2_avx2NtB9_4NoNIENtB7_2G0EINtNtBb_5types9MultiLaneAINtB7_10u32x4_sse2NtB9_5YesS3NtB9_5YesS4B1s_Ej4_E10from_lanesCsjsLu06DJe91_11rand_chacha:
 1617|    320|        fn from_lanes(x: [u32x4_sse2<YesS3, YesS4, NI>; 4]) -> Self {
 1618|    320|            let ab = u32x4x2_avx2::from_lanes([x[0], x[1]]);
 1619|    320|            let cd = u32x4x2_avx2::from_lanes([x[2], x[3]]);
 1620|    320|            Self::new([ab, cd])
 1621|    320|        }
_RNvXs10_NtNtCs11zJFIUYmdy_10ppv_lite866x86_644sse2INtB6_10u32x4_sse2NtB8_5YesS3NtB8_5YesS4NtB8_4NoNIENtNtBa_5types10StoreBytes8write_leCsjsLu06DJe91_11rand_chacha:
   89|  1.28k|            fn write_le(self, out: &mut [u8]) {
   90|  1.28k|                assert_eq!(out.len(), 16);
   91|  1.28k|                unsafe { _mm_storeu_si128(out.as_mut_ptr() as *mut _, self.x) }
   92|  1.28k|            }
_RNvXs2_NtNtNtCs11zJFIUYmdy_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIEINtNtBb_5types9MultiLaneAINtB7_10u32x4_sse2NtB9_5YesS3NtB9_5YesS4B1c_Ej2_E10from_lanesCsjsLu06DJe91_11rand_chacha:
 1439|    640|        fn from_lanes(x: [u32x4_sse2<YesS3, YesS4, NI>; 2]) -> Self {
 1440|    640|            Self::new(unsafe { _mm256_setr_m128i(x[0].x, x[1].x) })
 1441|    640|        }
_RNvXsq_NtNtNtCs11zJFIUYmdy_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtNtCsiloedr2K6v7_4core3ops5arith9AddAssign10add_assignCsjsLu06DJe91_11rand_chacha:
 1527|  7.68k|                fn $assign_fn(&mut self, rhs: Self) {
 1528|  7.68k|                    *self = self.$bin_fn(rhs);
 1529|  7.68k|                }
_RNvMsZ_NtNtCs11zJFIUYmdy_10ppv_lite866x86_644sse2INtB5_10u32x4_sse2NtB7_5YesS3NtB7_5YesS4NtB7_4NoNIE3newCsjsLu06DJe91_11rand_chacha:
   64|  4.48k|            fn new(x: __m128i) -> Self {
   65|  4.48k|                $vec {
   66|  4.48k|                    x,
   67|  4.48k|                    s3: PhantomData,
   68|  4.48k|                    s4: PhantomData,
   69|  4.48k|                    ni: PhantomData,
   70|  4.48k|                }
   71|  4.48k|            }
_RNvXs10_NtNtCs11zJFIUYmdy_10ppv_lite866x86_644sse2INtB6_10u32x4_sse2NtB8_5YesS3NtB8_5YesS4NtB8_4NoNIENtNtBa_5types10StoreBytes14unsafe_read_leCsjsLu06DJe91_11rand_chacha:
   79|      2|            unsafe fn unsafe_read_le(input: &[u8]) -> Self {
   80|      2|                assert_eq!(input.len(), 16);
   81|      2|                Self::new(_mm_loadu_si128(input.as_ptr() as *const _))
   82|      2|            }
_RNvXsX_NtNtCs11zJFIUYmdy_10ppv_lite866x86_644sse2INtB5_10u32x4_sse2NtB7_5YesS3NtB7_5YesS4NtB7_4NoNIEINtNtB9_5types5StoreNtB7_14vec128_storageE6unpackCsjsLu06DJe91_11rand_chacha:
   52|    720|            unsafe fn unpack(x: vec128_storage) -> Self {
   53|    720|                Self::new(x.sse2)
   54|    720|            }
_RNvXs2_NtNtNtCs11zJFIUYmdy_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIEINtNtBb_5types9MultiLaneAINtB7_10u32x4_sse2NtB9_5YesS3NtB9_5YesS4B1c_Ej2_E8to_lanesCsjsLu06DJe91_11rand_chacha:
 1430|    640|        fn to_lanes(self) -> [u32x4_sse2<YesS3, YesS4, NI>; 2] {
 1431|    640|            unsafe {
 1432|    640|                [
 1433|    640|                    u32x4_sse2::new(_mm256_extracti128_si256(self.x, 0)),
 1434|    640|                    u32x4_sse2::new(_mm256_extracti128_si256(self.x, 1)),
 1435|    640|                ]
 1436|    640|            }
 1437|    640|        }
_RNvXsl_NtNtCs11zJFIUYmdy_10ppv_lite866x86_644sse2INtB5_10u32x4_sse2NtB7_5YesS3NtB7_5YesS4NtB7_4NoNIEINtNtB9_5types4Vec4mE6insertCsjsLu06DJe91_11rand_chacha:
  523|  1.12k|    fn insert(self, v: u32, i: u32) -> Self {
  524|  1.12k|        Self::new(unsafe {
  525|  1.12k|            match i {
  526|    560|                0 => _mm_insert_epi32(self.x, v as i32, 0),
  527|    560|                1 => _mm_insert_epi32(self.x, v as i32, 1),
  528|      0|                2 => _mm_insert_epi32(self.x, v as i32, 2),
  529|      0|                3 => _mm_insert_epi32(self.x, v as i32, 3),
  530|      0|                _ => unreachable!(),
  531|       |            }
  532|       |        })
  533|  1.12k|    }
_RNvXs6_NtNtNtCs11zJFIUYmdy_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtBb_5types16RotateEachWord3224rotate_each_word_right16CsjsLu06DJe91_11rand_chacha:
 1470|  1.92k|            fn $name(self) -> Self {
 1471|  1.92k|                Self::new(unsafe {
 1472|  1.92k|                    _mm256_shuffle_epi8(self.x, _mm256_set_epi64x($k0, $k1, $k0, $k1))
 1473|  1.92k|                })
 1474|  1.92k|            }
_RNvXsl_NtNtCs11zJFIUYmdy_10ppv_lite866x86_644sse2INtB5_10u32x4_sse2NtB7_5YesS3NtB7_5YesS4NtB7_4NoNIEINtNtB9_5types4Vec4mE7extractCsjsLu06DJe91_11rand_chacha:
  519|    320|    fn extract(self, i: u32) -> u32 {
  520|    320|        self.to_lanes()[i as usize]
  521|    320|    }
_RNvXsc_NtNtNtCs11zJFIUYmdy_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtBb_5types10LaneWords422shuffle_lane_words2301CsjsLu06DJe91_11rand_chacha:
 1586|  1.92k|        fn shuffle_lane_words2301(self) -> Self {
 1587|  1.92k|            Self::new(unsafe { _mm256_shuffle_epi32(self.x, 0b0100_1110) })
 1588|  1.92k|        }
_RNvXs6_NtNtNtCs11zJFIUYmdy_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtBb_5types16RotateEachWord3224rotate_each_word_right25CsjsLu06DJe91_11rand_chacha:
 1480|  1.92k|            fn $name(self) -> Self {
 1481|  1.92k|                Self::new(unsafe {
 1482|  1.92k|                    _mm256_or_si256(
 1483|  1.92k|                        _mm256_srli_epi32(self.x, $i as i32),
 1484|  1.92k|                        _mm256_slli_epi32(self.x, 32 - $i as i32),
 1485|  1.92k|                    )
 1486|  1.92k|                })
 1487|  1.92k|            }
_RNvXsv_NtNtNtCs11zJFIUYmdy_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtNtCsiloedr2K6v7_4core3ops5arith3Add3addCsjsLu06DJe91_11rand_chacha:
 1543|  7.68k|                fn $op_fn(self, rhs: Self) -> Self::Output {
 1544|  7.68k|                    Self::new(unsafe { $impl_fn(self.x, rhs.x) })
 1545|  7.68k|                }
_RNvMNtNtNtCs11zJFIUYmdy_10ppv_lite866x86_644sse24avx2INtB2_12u32x4x2_avx2NtB6_4NoNIE3newCsjsLu06DJe91_11rand_chacha:
 1394|  29.6k|        fn new(x: __m256i) -> Self {
 1395|  29.6k|            Self { x, ni: PhantomData }
 1396|  29.6k|        }
_RNvXs1R_NtNtCs11zJFIUYmdy_10ppv_lite866x86_644sse2INtB6_10u32x4_sse2NtB8_5YesS3NtB8_5YesS4NtB8_4NoNIENtNtNtCsiloedr2K6v7_4core3ops5arith3Add3addCsjsLu06DJe91_11rand_chacha:
   18|  1.28k|            fn $fn(self, rhs: Self) -> Self::Output {
   19|  1.28k|                Self::new(unsafe { $impl_fn(self.x, rhs.x) })
   20|  1.28k|            }
_RNvXsc_NtNtNtCs11zJFIUYmdy_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtBb_5types10LaneWords422shuffle_lane_words3012CsjsLu06DJe91_11rand_chacha:
 1590|  1.92k|        fn shuffle_lane_words3012(self) -> Self {
 1591|  1.92k|            Self::new(unsafe { _mm256_shuffle_epi32(self.x, 0b0011_1001) })
 1592|  1.92k|        }
_RNvXs6_NtNtNtCs11zJFIUYmdy_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtBb_5types16RotateEachWord3224rotate_each_word_right24CsjsLu06DJe91_11rand_chacha:
 1470|  1.92k|            fn $name(self) -> Self {
 1471|  1.92k|                Self::new(unsafe {
 1472|  1.92k|                    _mm256_shuffle_epi8(self.x, _mm256_set_epi64x($k0, $k1, $k0, $k1))
 1473|  1.92k|                })
 1474|  1.92k|            }
_RNvXs6_NtNtCs11zJFIUYmdy_10ppv_lite866x86_644sse2INtB5_10u32x4_sse2NtB7_5YesS3NtB7_5YesS4NtB7_4NoNIEINtNtB9_5types9MultiLaneAmj4_E10from_lanesCsjsLu06DJe91_11rand_chacha:
  331|     80|    fn from_lanes(xs: [u32; 4]) -> Self {
  332|     80|        unsafe {
  333|     80|            let mut x = _mm_cvtsi64_si128((xs[0] as u64 | ((xs[1] as u64) << 32)) as i64);
  334|     80|            x = _mm_insert_epi64(x, (xs[2] as u64 | ((xs[3] as u64) << 32)) as i64, 1);
  335|     80|            Self::new(x)
  336|     80|        }
  337|     80|    }
_RNvXse_NtNtNtCs11zJFIUYmdy_10ppv_lite866x86_644sse24avx2INtNtBb_4soft2x2INtB5_12u32x4x2_avx2NtB9_4NoNIENtB7_2G0EINtNtBb_5types5StoreNtB9_14vec512_storageE6unpackCsjsLu06DJe91_11rand_chacha:
 1602|     80|        unsafe fn unpack(p: vec512_storage) -> Self {
 1603|     80|            Self::new([
 1604|     80|                u32x4x2_avx2::unpack(p.avx[0]),
 1605|     80|                u32x4x2_avx2::unpack(p.avx[1]),
 1606|     80|            ])
 1607|     80|        }
_RNvXs6_NtNtCs11zJFIUYmdy_10ppv_lite866x86_644sse2INtB5_10u32x4_sse2NtB7_5YesS3NtB7_5YesS4NtB7_4NoNIEINtNtB9_5types9MultiLaneAmj4_E8to_lanesCsjsLu06DJe91_11rand_chacha:
  323|    320|    fn to_lanes(self) -> [u32; 4] {
  324|    320|        unsafe {
  325|    320|            let x = _mm_cvtsi128_si64(self.x) as u64;
  326|    320|            let y = _mm_extract_epi64(self.x, 1) as u64;
  327|    320|            [x as u32, (x >> 32) as u32, y as u32, (y >> 32) as u32]
  328|    320|        }
  329|    320|    }
_RNvXs0_NtNtNtCs11zJFIUYmdy_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIEINtNtBb_5types5StoreNtB9_14vec256_storageE6unpackCsjsLu06DJe91_11rand_chacha:
 1402|    160|        unsafe fn unpack(p: vec256_storage) -> Self {
 1403|    160|            Self::new(p.avx)
 1404|    160|        }
_RNvXsY_NtNtCs11zJFIUYmdy_10ppv_lite866x86_644sse2NtB7_14vec128_storageINtNtCsiloedr2K6v7_4core7convert4FromINtB5_10u32x4_sse2NtB7_5YesS3NtB7_5YesS4NtB7_4NoNIEE4fromCsjsLu06DJe91_11rand_chacha:
   58|     82|            fn from(x: $vec<S3, S4, NI>) -> Self {
   59|     82|                vec128_storage { sse2: x.x }
   60|     82|            }
_RNvXsc_NtNtNtCs11zJFIUYmdy_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtBb_5types10LaneWords422shuffle_lane_words1230CsjsLu06DJe91_11rand_chacha:
 1582|  1.92k|        fn shuffle_lane_words1230(self) -> Self {
 1583|  1.92k|            Self::new(unsafe { _mm256_shuffle_epi32(self.x, 0b1001_0011) })
 1584|  1.92k|        }
_RNvXsj_NtNtNtCs11zJFIUYmdy_10ppv_lite866x86_644sse24avx2NtB9_14vec512_storageINtNtCsiloedr2K6v7_4core7convert4FromINtNtBb_4soft2x2INtB5_12u32x4x2_avx2NtB9_4NoNIENtB7_2G0EE4fromCsjsLu06DJe91_11rand_chacha:
 1683|     80|        fn from(x: u32x4x4_avx2<NI>) -> Self {
 1684|     80|            Self {
 1685|     80|                avx: [
 1686|     80|                    vec256_storage { avx: x.0[0].x },
 1687|     80|                    vec256_storage { avx: x.0[1].x },
 1688|     80|                ],
 1689|     80|            }
 1690|     80|        }
_RNvXs6_NtNtNtCs11zJFIUYmdy_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtBb_5types16RotateEachWord3224rotate_each_word_right20CsjsLu06DJe91_11rand_chacha:
 1480|  1.92k|            fn $name(self) -> Self {
 1481|  1.92k|                Self::new(unsafe {
 1482|  1.92k|                    _mm256_or_si256(
 1483|  1.92k|                        _mm256_srli_epi32(self.x, $i as i32),
 1484|  1.92k|                        _mm256_slli_epi32(self.x, 32 - $i as i32),
 1485|  1.92k|                    )
 1486|  1.92k|                })
 1487|  1.92k|            }
_RNvXsf_NtNtNtCs11zJFIUYmdy_10ppv_lite866x86_644sse24avx2INtNtBb_4soft2x2INtB5_12u32x4x2_avx2NtB9_4NoNIENtB7_2G0EINtNtBb_5types9MultiLaneAINtB7_10u32x4_sse2NtB9_5YesS3NtB9_5YesS4B1s_Ej4_E8to_lanesCsjsLu06DJe91_11rand_chacha:
 1611|    320|        fn to_lanes(self) -> [u32x4_sse2<YesS3, YesS4, NI>; 4] {
 1612|    320|            let [a, b] = self.0[0].to_lanes();
 1613|    320|            let [c, d] = self.0[1].to_lanes();
 1614|    320|            [a, b, c, d]
 1615|    320|        }
_RNvXsr_NtNtNtCs11zJFIUYmdy_10ppv_lite866x86_644sse24avx2INtB5_12u32x4x2_avx2NtB9_4NoNIENtNtNtCsiloedr2K6v7_4core3ops3bit6BitXor6bitxorCsjsLu06DJe91_11rand_chacha:
 1543|  7.68k|                fn $op_fn(self, rhs: Self) -> Self::Output {
 1544|  7.68k|                    Self::new(unsafe { $impl_fn(self.x, rhs.x) })
 1545|  7.68k|                }

_RINvXNtNtCsf3wFRFpNELZ_4rand13distributions7integerNtB5_8StandardINtNtB5_12distribution12DistributionhE6sampleNtNtNtB7_4rngs6thread9ThreadRngECsboUdcTbF1FS_15direct_syscalls:
   23|  5.08k|    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> u8 {
   24|  5.08k|        rng.next_u32() as u8
   25|  5.08k|    }

_RINvXsB_NtNtCsf3wFRFpNELZ_4rand13distributions5otherNtB8_8StandardINtNtB8_12distribution12DistributionAhj10_E6sampleNtNtNtBa_4rngs6thread9ThreadRngECsboUdcTbF1FS_15direct_syscalls:
  217|    318|            fn sample<R: Rng + ?Sized>(&self, _rng: &mut R) -> [T; $n] {
  218|    318|                [_rng.gen::<$t>(), $(_rng.gen::<$ts>()),*]
  219|    318|            }

_RINvCsf3wFRFpNELZ_4rand6randomAhj10_ECsboUdcTbF1FS_15direct_syscalls:
  183|    318|pub fn random<T>() -> T
  184|    318|where Standard: Distribution<T> {
  185|    318|    thread_rng().gen()
  186|    318|}

_RINvYNtNtNtCsf3wFRFpNELZ_4rand4rngs6thread9ThreadRngNtNtB9_3rng3Rng3genhECsboUdcTbF1FS_15direct_syscalls:
   93|  5.08k|    fn gen<T>(&mut self) -> T
   94|  5.08k|    where Standard: Distribution<T> {
   95|  5.08k|        Standard.sample(self)
   96|  5.08k|    }
_RINvYNtNtNtCsf3wFRFpNELZ_4rand4rngs6thread9ThreadRngNtNtB9_3rng3Rng3genAhj10_ECsboUdcTbF1FS_15direct_syscalls:
   93|    318|    fn gen<T>(&mut self) -> T
   94|    318|    where Standard: Distribution<T> {
   95|    318|        Standard.sample(self)
   96|    318|    }

_RNvXs_NtNtNtCsf3wFRFpNELZ_4rand4rngs7adapter9reseedingINtB4_12ReseedingRngNtNtCsjsLu06DJe91_11rand_chacha6chacha12ChaCha12CoreNtNtCsgsYztSU4Hoi_9rand_core2os5OsRngENtB24_7RngCore8next_u32CsboUdcTbF1FS_15direct_syscalls:
  119|  5.08k|    fn next_u32(&mut self) -> u32 {
  120|  5.08k|        self.0.next_u32()
  121|  5.08k|    }
_RNvMs3_NtNtNtCsf3wFRFpNELZ_4rand4rngs7adapter9reseedingINtB5_13ReseedingCoreNtNtCsjsLu06DJe91_11rand_chacha6chacha12ChaCha12CoreNtNtCsgsYztSU4Hoi_9rand_core2os5OsRngE9is_forkedCsboUdcTbF1FS_15direct_syscalls:
  226|     80|    fn is_forked(&self, global_fork_counter: usize) -> bool {
  227|     80|        // In theory, on 32-bit platforms, it is possible for
  228|     80|        // `global_fork_counter` to wrap around after ~4e9 forks.
  229|     80|        //
  230|     80|        // This check will detect a fork in the normal case where
  231|     80|        // `fork_counter < global_fork_counter`, and also when the difference
  232|     80|        // between both is greater than `isize::MAX` (wrapped around).
  233|     80|        //
  234|     80|        // It will still fail to detect a fork if there have been more than
  235|     80|        // `isize::MAX` forks, without any reseed in between. Seems unlikely
  236|     80|        // enough.
  237|     80|        (self.fork_counter.wrapping_sub(global_fork_counter) as isize) < 0
  238|     80|    }
_RNvXs2_NtNtNtCsf3wFRFpNELZ_4rand4rngs7adapter9reseedingINtB5_13ReseedingCoreNtNtCsjsLu06DJe91_11rand_chacha6chacha12ChaCha12CoreNtNtCsgsYztSU4Hoi_9rand_core2os5OsRngENtNtB26_5block12BlockRngCore8generateCsboUdcTbF1FS_15direct_syscalls:
  173|     80|    fn generate(&mut self, results: &mut Self::Results) {
  174|     80|        let global_fork_counter = fork::get_fork_counter();
  175|     80|        if self.bytes_until_reseed <= 0 || self.is_forked(global_fork_counter) {
  176|       |            // We get better performance by not calling only `reseed` here
  177|       |            // and continuing with the rest of the function, but by directly
  178|       |            // returning from a non-inlined function.
  179|      0|            return self.reseed_and_generate(results, global_fork_counter);
  180|     80|        }
  181|     80|        let num_bytes = results.as_ref().len() * size_of::<Self::Item>();
  182|     80|        self.bytes_until_reseed -= num_bytes as i64;
  183|     80|        self.inner.generate(results);
  184|     80|    }
_RNvMs3_NtNtNtCsf3wFRFpNELZ_4rand4rngs7adapter9reseedingINtB5_13ReseedingCoreNtNtCsjsLu06DJe91_11rand_chacha6chacha12ChaCha12CoreNtNtCsgsYztSU4Hoi_9rand_core2os5OsRngE3newBb_:
  193|      1|    fn new(rng: R, threshold: u64, reseeder: Rsdr) -> Self {
  194|      1|        use ::core::i64::MAX;
  195|      1|        fork::register_fork_handler();
  196|       |
  197|       |        // Because generating more values than `i64::MAX` takes centuries on
  198|       |        // current hardware, we just clamp to that value.
  199|       |        // Also we set a threshold of 0, which indicates no limit, to that
  200|       |        // value.
  201|      1|        let threshold = if threshold == 0 {
  202|      0|            MAX
  203|      1|        } else if threshold <= MAX as u64 {
  204|      1|            threshold as i64
  205|       |        } else {
  206|      0|            MAX
  207|       |        };
  208|       |
  209|      1|        ReseedingCore {
  210|      1|            inner: rng,
  211|      1|            reseeder,
  212|      1|            threshold: threshold as i64,
  213|      1|            bytes_until_reseed: threshold as i64,
  214|      1|            fork_counter: 0,
  215|      1|        }
  216|      1|    }
_RNvNtNtNtNtCsf3wFRFpNELZ_4rand4rngs7adapter9reseeding4fork21register_fork_handler:
  317|      1|    pub fn register_fork_handler() {
  318|      1|        static REGISTER: Once = Once::new();
  319|      1|        REGISTER.call_once(|| {
  320|       |            // Bump the counter before and after forking (see #1169):
  321|       |            let ret = unsafe { libc::pthread_atfork(
  322|       |                Some(fork_handler),
  323|       |                Some(fork_handler),
  324|       |                Some(fork_handler),
  325|       |            ) };
  326|       |            if ret != 0 {
  327|       |                panic!("libc::pthread_atfork failed with code {}", ret);
  328|       |            }
  329|      1|        });
  330|      1|    }
_RNvNtNtNtNtCsf3wFRFpNELZ_4rand4rngs7adapter9reseeding4fork16get_fork_counter:
  307|     80|    pub fn get_fork_counter() -> usize {
  308|     80|        RESEEDING_RNG_FORK_COUNTER.load(Ordering::Relaxed)
  309|     80|    }
_RNvMNtNtNtCsf3wFRFpNELZ_4rand4rngs7adapter9reseedingINtB2_12ReseedingRngNtNtCsjsLu06DJe91_11rand_chacha6chacha12ChaCha12CoreNtNtCsgsYztSU4Hoi_9rand_core2os5OsRngE3newB8_:
  101|      1|    pub fn new(rng: R, threshold: u64, reseeder: Rsdr) -> Self {
  102|      1|        ReseedingRng(BlockRng::new(ReseedingCore::new(rng, threshold, reseeder)))
  103|      1|    }
_RNCNvNtNtNtNtCsf3wFRFpNELZ_4rand4rngs7adapter9reseeding4fork21register_fork_handler0Bb_:
  319|      1|        REGISTER.call_once(|| {
  320|      1|            // Bump the counter before and after forking (see #1169):
  321|      1|            let ret = unsafe { libc::pthread_atfork(
  322|      1|                Some(fork_handler),
  323|      1|                Some(fork_handler),
  324|      1|                Some(fork_handler),
  325|      1|            ) };
  326|      1|            if ret != 0 {
  327|      0|                panic!("libc::pthread_atfork failed with code {}", ret);
  328|      1|            }
  329|      1|        });

_RNvXs_NtNtCsf3wFRFpNELZ_4rand4rngs6threadNtB4_9ThreadRngNtCsgsYztSU4Hoi_9rand_core7RngCore8next_u32:
  101|  5.08k|    fn next_u32(&mut self) -> u32 {
  102|  5.08k|        // SAFETY: We must make sure to stop using `rng` before anyone else
  103|  5.08k|        // creates another mutable reference
  104|  5.08k|        let rng = unsafe { &mut *self.rng.get() };
  105|  5.08k|        rng.next_u32()
  106|  5.08k|    }
_RNCNvNvNtNtCsf3wFRFpNELZ_4rand4rngs6thread14THREAD_RNG_KEY7___getit0B9_:
   67|      1|thread_local!(
   68|      1|    // We require Rc<..> to avoid premature freeing when thread_rng is used
   69|      1|    // within thread-local destructors. See #968.
   70|      1|    static THREAD_RNG_KEY: Rc<UnsafeCell<ReseedingRng<Core, OsRng>>> = {
   71|      1|        let r = Core::from_rng(OsRng).unwrap_or_else(|err|
   72|      1|                panic!("could not initialize thread_rng: {}", err));
   73|      1|        let rng = ReseedingRng::new(r,
   74|      1|                                    THREAD_RNG_RESEED_THRESHOLD,
   75|      1|                                    OsRng);
   76|      1|        Rc::new(UnsafeCell::new(rng))
   77|      1|    }
   78|      1|);
_RNCNvNtNtCsf3wFRFpNELZ_4rand4rngs6thread10thread_rng0B7_:
   89|    318|    let rng = THREAD_RNG_KEY.with(|t| t.clone());
_RNvNtNtCsf3wFRFpNELZ_4rand4rngs6thread10thread_rng:
   88|    318|pub fn thread_rng() -> ThreadRng {
   89|    318|    let rng = THREAD_RNG_KEY.with(|t| t.clone());
   90|    318|    ThreadRng { rng }
   91|    318|}

_RNvXsn_NtCsjsLu06DJe91_11rand_chacha6chachaNtB5_12ChaCha12CoreNtCsgsYztSU4Hoi_9rand_core11SeedableRng9from_seed:
  103|      1|            fn from_seed(seed: Self::Seed) -> Self {
  104|      1|                $ChaChaXCore { state: ChaCha::new(&seed, &[0u8; 8]) }
  105|      1|            }
_RNvXsm_NtCsjsLu06DJe91_11rand_chacha6chachaNtB5_12ChaCha12CoreNtNtCsgsYztSU4Hoi_9rand_core5block12BlockRngCore8generate:
   89|     80|            fn generate(&mut self, r: &mut Self::Results) {
   90|     80|                // Fill slice of words by writing to equivalent slice of bytes, then fixing endianness.
   91|     80|                self.state.refill4($rounds, unsafe {
   92|     80|                    &mut *(&mut *r as *mut Array64<u32> as *mut [u8; 256])
   93|     80|                });
   94|  5.12k|                for x in r.as_mut() {
   95|  5.12k|                    *x = x.to_le();
   96|  5.12k|                }
   97|     80|            }
_RNvXs_NtCsjsLu06DJe91_11rand_chacha6chachaINtB4_7Array64mEINtNtCsiloedr2K6v7_4core7convert5AsRefSmE6as_refCsboUdcTbF1FS_15direct_syscalls:
   46|  10.3k|    fn as_ref(&self) -> &[T] {
   47|  10.3k|        &self.0
   48|  10.3k|    }
_RNvXs0_NtCsjsLu06DJe91_11rand_chacha6chachaINtB5_7Array64mEINtNtCsiloedr2K6v7_4core7convert5AsMutSmE6as_mutCsboUdcTbF1FS_15direct_syscalls:
   51|     80|    fn as_mut(&mut self) -> &mut [T] {
   52|     80|        &mut self.0
   53|     80|    }
_RNvXNtCsjsLu06DJe91_11rand_chacha6chachaINtB2_7Array64mENtNtCsiloedr2K6v7_4core7default7Default7defaultCsf3wFRFpNELZ_4rand:
   32|      1|    fn default() -> Self {
   33|      1|        Self([
   34|      1|            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),
   35|      1|            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),
   36|      1|            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),
   37|      1|            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),
   38|      1|            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),
   39|      1|            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),
   40|      1|            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),
   41|      1|            T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(), T::default(),
   42|      1|        ])
   43|      1|    }
_RNvXs_NtCsjsLu06DJe91_11rand_chacha6chachaINtB4_7Array64mEINtNtCsiloedr2K6v7_4core7convert5AsRefSmE6as_refCsf3wFRFpNELZ_4rand:
   46|      1|    fn as_ref(&self) -> &[T] {
   47|      1|        &self.0
   48|      1|    }

_RNvMNtCsjsLu06DJe91_11rand_chacha4gutsNtB2_6ChaCha3new:
   72|      1|    pub fn new(key: &[u8; 32], nonce: &[u8]) -> Self {
   73|      1|        init_chacha(key, nonce)
   74|      1|    }
_RNvMNtCsjsLu06DJe91_11rand_chacha4gutsNtB2_6ChaCha7refill4:
   84|     80|    pub fn refill4(&mut self, drounds: u32, out: &mut [u8; BUFSZ]) {
   85|     80|        refill_wide(self, drounds, out)
   86|     80|    }
_RNvNtCsjsLu06DJe91_11rand_chacha4guts10read_u32le:
  229|      2|fn read_u32le(xs: &[u8]) -> u32 {
  230|      2|    assert_eq!(xs.len(), 4);
  231|      2|    u32::from(xs[0]) | (u32::from(xs[1]) << 8) | (u32::from(xs[2]) << 16) | (u32::from(xs[3]) << 24)
  232|      2|}
_RINvMNtCsjsLu06DJe91_11rand_chacha4gutsNtB3_6ChaCha5pos64INtNtCs11zJFIUYmdy_10ppv_lite866x86_6411Avx2MachineNtBW_4NoNIEEB5_:
   77|    160|    fn pos64<M: Machine>(&self, m: M) -> u64 {
   78|    160|        let d: M::u32x4 = m.unpack(self.d);
   79|    160|        ((d.extract(1) as u64) << 32) | d.extract(0) as u64
   80|    160|    }
_RINvNvNtCsjsLu06DJe91_11rand_chacha4guts11refill_wide7fn_implINtNtCs11zJFIUYmdy_10ppv_lite866x86_6411Avx2MachineNtB10_4NoNIEEB6_:
  172|     80|    fn refill_wide(state: &mut ChaCha, drounds: u32, out: &mut [u8; BUFSZ]) {
  173|     80|        refill_wide_impl(m, state, drounds, out);
  174|     80|    }
_RINvNtCsjsLu06DJe91_11rand_chacha4guts16refill_wide_implINtNtCs11zJFIUYmdy_10ppv_lite866x86_6411Avx2MachineNtBV_4NoNIEEB4_:
  116|     80|fn refill_wide_impl<Mach: Machine>(
  117|     80|    m: Mach, state: &mut ChaCha, drounds: u32, out: &mut [u8; BUFSZ],
  118|     80|) {
  119|     80|    let k = m.vec([0x6170_7865, 0x3320_646e, 0x7962_2d32, 0x6b20_6574]);
  120|     80|    let mut pos = state.pos64(m);
  121|     80|    let d0: Mach::u32x4 = m.unpack(state.d);
  122|     80|    pos = pos.wrapping_add(1);
  123|     80|    let d1 = d0.insert((pos >> 32) as u32, 1).insert(pos as u32, 0);
  124|     80|    pos = pos.wrapping_add(1);
  125|     80|    let d2 = d0.insert((pos >> 32) as u32, 1).insert(pos as u32, 0);
  126|     80|    pos = pos.wrapping_add(1);
  127|     80|    let d3 = d0.insert((pos >> 32) as u32, 1).insert(pos as u32, 0);
  128|     80|
  129|     80|    let b = m.unpack(state.b);
  130|     80|    let c = m.unpack(state.c);
  131|     80|    let mut x = State {
  132|     80|        a: Mach::u32x4x4::from_lanes([k, k, k, k]),
  133|     80|        b: Mach::u32x4x4::from_lanes([b, b, b, b]),
  134|     80|        c: Mach::u32x4x4::from_lanes([c, c, c, c]),
  135|     80|        d: m.unpack(Mach::u32x4x4::from_lanes([d0, d1, d2, d3]).into()),
  136|     80|    };
  137|    480|    for _ in 0..drounds {
  138|    480|        x = round(x);
  139|    480|        x = undiagonalize(round(diagonalize(x)));
  140|    480|    }
  141|     80|    let mut pos = state.pos64(m);
  142|     80|    let d0: Mach::u32x4 = m.unpack(state.d);
  143|     80|    pos = pos.wrapping_add(1);
  144|     80|    let d1 = d0.insert((pos >> 32) as u32, 1).insert(pos as u32, 0);
  145|     80|    pos = pos.wrapping_add(1);
  146|     80|    let d2 = d0.insert((pos >> 32) as u32, 1).insert(pos as u32, 0);
  147|     80|    pos = pos.wrapping_add(1);
  148|     80|    let d3 = d0.insert((pos >> 32) as u32, 1).insert(pos as u32, 0);
  149|     80|    pos = pos.wrapping_add(1);
  150|     80|    let d4 = d0.insert((pos >> 32) as u32, 1).insert(pos as u32, 0);
  151|     80|
  152|     80|    let (a, b, c, d) = (
  153|     80|        x.a.to_lanes(),
  154|     80|        x.b.to_lanes(),
  155|     80|        x.c.to_lanes(),
  156|     80|        x.d.to_lanes(),
  157|     80|    );
  158|     80|    let sb = m.unpack(state.b);
  159|     80|    let sc = m.unpack(state.c);
  160|     80|    let sd = [m.unpack(state.d), d1, d2, d3];
  161|     80|    state.d = d4.into();
  162|     80|    let mut words = out.chunks_exact_mut(16);
  163|    320|    for ((((&a, &b), &c), &d), &sd) in a.iter().zip(&b).zip(&c).zip(&d).zip(&sd) {
  164|    320|        (a + k).write_le(words.next().unwrap());
  165|    320|        (b + sb).write_le(words.next().unwrap());
  166|    320|        (c + sc).write_le(words.next().unwrap());
  167|    320|        (d + sd).write_le(words.next().unwrap());
  168|    320|    }
  169|     80|}
_RINvNtCsjsLu06DJe91_11rand_chacha4guts11diagonalizeINtNtCs11zJFIUYmdy_10ppv_lite864soft2x2INtNtNtNtBS_6x86_644sse24avx212u32x4x2_avx2NtB1x_4NoNIENtB1v_2G0EEB4_:
   56|    480|pub(crate) fn diagonalize<V: LaneWords4>(mut x: State<V>) -> State<V> {
   57|    480|    x.b = x.b.shuffle_lane_words3012();
   58|    480|    x.c = x.c.shuffle_lane_words2301();
   59|    480|    x.d = x.d.shuffle_lane_words1230();
   60|    480|    x
   61|    480|}
_RINvNtCsjsLu06DJe91_11rand_chacha4guts5roundINtNtCs11zJFIUYmdy_10ppv_lite864soft2x2INtNtNtNtBL_6x86_644sse24avx212u32x4x2_avx2NtB1q_4NoNIENtB1o_2G0EEB4_:
   43|    960|pub(crate) fn round<V: ArithOps + BitOps32>(mut x: State<V>) -> State<V> {
   44|    960|    x.a += x.b;
   45|    960|    x.d = (x.d ^ x.a).rotate_each_word_right16();
   46|    960|    x.c += x.d;
   47|    960|    x.b = (x.b ^ x.c).rotate_each_word_right20();
   48|    960|    x.a += x.b;
   49|    960|    x.d = (x.d ^ x.a).rotate_each_word_right24();
   50|    960|    x.c += x.d;
   51|    960|    x.b = (x.b ^ x.c).rotate_each_word_right25();
   52|    960|    x
   53|    960|}
_RINvNvNtCsjsLu06DJe91_11rand_chacha4guts11init_chacha7fn_implINtNtCs11zJFIUYmdy_10ppv_lite866x86_6410SseMachineNtB10_5YesS3NtB10_5YesS4NtB10_4NoNIEEB6_:
  235|      1|    fn init_chacha(key: &[u8; 32], nonce: &[u8]) -> ChaCha {
  236|      1|        let ctr_nonce = [
  237|       |            0,
  238|      1|            if nonce.len() == 12 {
  239|      0|                read_u32le(&nonce[0..4])
  240|       |            } else {
  241|      1|                0
  242|       |            },
  243|      1|            read_u32le(&nonce[nonce.len() - 8..nonce.len() - 4]),
  244|      1|            read_u32le(&nonce[nonce.len() - 4..]),
  245|      1|        ];
  246|      1|        let key0: Mach::u32x4 = m.read_le(&key[..16]);
  247|      1|        let key1: Mach::u32x4 = m.read_le(&key[16..]);
  248|      1|        ChaCha {
  249|      1|            b: key0.into(),
  250|      1|            c: key1.into(),
  251|      1|            d: ctr_nonce.into(),
  252|      1|        }
_RINvNtCsjsLu06DJe91_11rand_chacha4guts13undiagonalizeINtNtCs11zJFIUYmdy_10ppv_lite864soft2x2INtNtNtNtBU_6x86_644sse24avx212u32x4x2_avx2NtB1z_4NoNIENtB1x_2G0EEB4_:
   63|    480|pub(crate) fn undiagonalize<V: LaneWords4>(mut x: State<V>) -> State<V> {
   64|    480|    x.b = x.b.shuffle_lane_words1230();
   65|    480|    x.c = x.c.shuffle_lane_words2301();
   66|    480|    x.d = x.d.shuffle_lane_words3012();
   67|    480|    x
   68|    480|}

_RNvXs0_NtCsgsYztSU4Hoi_9rand_core5blockINtB5_8BlockRngINtNtNtNtCsf3wFRFpNELZ_4rand4rngs7adapter9reseeding13ReseedingCoreNtNtCsjsLu06DJe91_11rand_chacha6chacha12ChaCha12CoreNtNtB7_2os5OsRngEENtB7_7RngCore8next_u32CsboUdcTbF1FS_15direct_syscalls:
  186|  5.08k|    fn next_u32(&mut self) -> u32 {
  187|  5.08k|        if self.index >= self.results.as_ref().len() {
  188|     80|            self.generate_and_set(0);
  189|  5.00k|        }
  190|       |
  191|  5.08k|        let value = self.results.as_ref()[self.index];
  192|  5.08k|        self.index += 1;
  193|  5.08k|        value
  194|  5.08k|    }
_RNvMs_NtCsgsYztSU4Hoi_9rand_core5blockINtB4_8BlockRngINtNtNtNtCsf3wFRFpNELZ_4rand4rngs7adapter9reseeding13ReseedingCoreNtNtCsjsLu06DJe91_11rand_chacha6chacha12ChaCha12CoreNtNtB6_2os5OsRngEE16generate_and_setCsboUdcTbF1FS_15direct_syscalls:
  174|     80|    pub fn generate_and_set(&mut self, index: usize) {
  175|     80|        assert!(index < self.results.as_ref().len());
  176|     80|        self.core.generate(&mut self.results);
  177|     80|        self.index = index;
  178|     80|    }
_RNvMs_NtCsgsYztSU4Hoi_9rand_core5blockINtB4_8BlockRngINtNtNtNtCsf3wFRFpNELZ_4rand4rngs7adapter9reseeding13ReseedingCoreNtNtCsjsLu06DJe91_11rand_chacha6chacha12ChaCha12CoreNtNtB6_2os5OsRngEE3newBY_:
  145|      1|    pub fn new(core: R) -> BlockRng<R> {
  146|      1|        let results_empty = R::Results::default();
  147|      1|        BlockRng {
  148|      1|            core,
  149|      1|            index: results_empty.as_ref().len(),
  150|      1|            results: results_empty,
  151|      1|        }
  152|      1|    }

_RINvYNtNtCsjsLu06DJe91_11rand_chacha6chacha12ChaCha12CoreNtCsgsYztSU4Hoi_9rand_core11SeedableRng8from_rngNtNtBV_2os5OsRngECsf3wFRFpNELZ_4rand:
  390|      1|    fn from_rng<R: RngCore>(mut rng: R) -> Result<Self, Error> {
  391|      1|        let mut seed = Self::Seed::default();
  392|      1|        rng.try_fill_bytes(seed.as_mut())?;
  393|      1|        Ok(Self::from_seed(seed))
  394|      1|    }

_RNvXs_NtCsgsYztSU4Hoi_9rand_core2osNtB4_5OsRngNtB6_7RngCore14try_fill_bytes:
   68|      1|        getrandom(dest)?;
   69|      1|        Ok(())
   70|      1|    }

_RNvMs4_CsjDo9fZ7x0Pp_9regalloc2NtB5_4VReg4vreg:
  278|  57.2k|    pub const fn vreg(self) -> usize {
  279|  57.2k|        let vreg = (self.bits >> 1) as usize;
  280|  57.2k|        vreg
  281|  57.2k|    }
_RNvMCsjDo9fZ7x0Pp_9regalloc2NtB2_4PReg3new:
   97|  20.3k|    pub const fn new(hw_enc: usize, class: RegClass) -> Self {
   98|  20.3k|        // We don't have const panics yet (rust-lang/rust#85194) so we
   99|  20.3k|        // need to use a little indexing trick here. We unfortunately
  100|  20.3k|        // can't use the `static-assertions` crate because we need
  101|  20.3k|        // this to work both for const `hw_enc` and for runtime
  102|  20.3k|        // values.
  103|  20.3k|        const HW_ENC_MUST_BE_IN_BOUNDS: &[bool; PReg::MAX + 1] = &[true; PReg::MAX + 1];
  104|  20.3k|        let _ = HW_ENC_MUST_BE_IN_BOUNDS[hw_enc];
  105|  20.3k|
  106|  20.3k|        PReg {
  107|  20.3k|            bits: ((class as u8) << Self::MAX_BITS) | (hw_enc as u8),
  108|  20.3k|        }
  109|  20.3k|    }
_RNvMs4_CsjDo9fZ7x0Pp_9regalloc2NtB5_4VReg3new:
  266|  20.3k|    pub const fn new(virt_reg: usize, class: RegClass) -> Self {
  267|  20.3k|        // See comment in `PReg::new()`: we are emulating a const
  268|  20.3k|        // assert here until const panics are stable.
  269|  20.3k|        const VIRT_REG_MUST_BE_IN_BOUNDS: &[bool; VReg::MAX + 1] = &[true; VReg::MAX + 1];
  270|  20.3k|        let _ = VIRT_REG_MUST_BE_IN_BOUNDS[virt_reg];
  271|  20.3k|
  272|  20.3k|        VReg {
  273|  20.3k|            bits: ((virt_reg as u32) << 1) | (class as u8 as u32),
  274|  20.3k|        }
  275|  20.3k|    }
_RNvXsU_CsjDo9fZ7x0Pp_9regalloc2NtB5_4VRegNtNtCsiloedr2K6v7_4core3cmp9PartialEq2eq:
  255|    636|#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
_RNvMCsjDo9fZ7x0Pp_9regalloc2NtB2_4PReg5index:
  131|  20.3k|    pub const fn index(self) -> usize {
  132|  20.3k|        self.bits as usize
  133|  20.3k|    }
_RNvMCsjDo9fZ7x0Pp_9regalloc2NtB2_4PReg10from_index:
  137|  38.1k|    pub const fn from_index(index: usize) -> Self {
  138|  38.1k|        PReg {
  139|  38.1k|            bits: (index & (Self::NUM_INDEX - 1)) as u8,
  140|  38.1k|        }
  141|  38.1k|    }

_RNvNtNtNtNtCs8bE1srDPHCS_6rustix7backend4arch3asm11target_arch8syscall2:
   66|  2.54k|pub(in crate::backend) unsafe fn syscall2(
   67|  2.54k|    nr: SyscallNumber<'_>,
   68|  2.54k|    a0: ArgReg<'_, A0>,
   69|  2.54k|    a1: ArgReg<'_, A1>,
   70|  2.54k|) -> RetReg<R0> {
   71|  2.54k|    let r0;
   72|  2.54k|    asm!(
   73|  2.54k|        "syscall",
   74|  2.54k|        inlateout("rax") nr.to_asm() => r0,
   75|  2.54k|        in("rdi") a0.to_asm(),
   76|  2.54k|        in("rsi") a1.to_asm(),
   77|  2.54k|        lateout("rcx") _,
   78|  2.54k|        lateout("r11") _,
   79|  2.54k|        options(nostack, preserves_flags)
   80|  2.54k|    );
   81|  2.54k|    FromAsm::from_asm(r0)
   82|  2.54k|}
_RNvNtNtNtNtCs8bE1srDPHCS_6rustix7backend4arch3asm11target_arch8syscall6:
  242|  2.54k|pub(in crate::backend) unsafe fn syscall6(
  243|  2.54k|    nr: SyscallNumber<'_>,
  244|  2.54k|    a0: ArgReg<'_, A0>,
  245|  2.54k|    a1: ArgReg<'_, A1>,
  246|  2.54k|    a2: ArgReg<'_, A2>,
  247|  2.54k|    a3: ArgReg<'_, A3>,
  248|  2.54k|    a4: ArgReg<'_, A4>,
  249|  2.54k|    a5: ArgReg<'_, A5>,
  250|  2.54k|) -> RetReg<R0> {
  251|  2.54k|    let r0;
  252|  2.54k|    asm!(
  253|  2.54k|        "syscall",
  254|  2.54k|        inlateout("rax") nr.to_asm() => r0,
  255|  2.54k|        in("rdi") a0.to_asm(),
  256|  2.54k|        in("rsi") a1.to_asm(),
  257|  2.54k|        in("rdx") a2.to_asm(),
  258|  2.54k|        in("r10") a3.to_asm(),
  259|  2.54k|        in("r8") a4.to_asm(),
  260|  2.54k|        in("r9") a5.to_asm(),
  261|  2.54k|        lateout("rcx") _,
  262|  2.54k|        lateout("r11") _,
  263|  2.54k|        options(nostack, preserves_flags)
  264|  2.54k|    );
  265|  2.54k|    FromAsm::from_asm(r0)
  266|  2.54k|}

_RINvNtNtCs8bE1srDPHCS_6rustix7backend4conv10pass_usizeNtNtB4_3reg2A3ECslvZ9xuS3Qdd_16wasmtime_runtime:
   99|  2.54k|pub(super) fn pass_usize<'a, Num: ArgNumber>(t: usize) -> ArgReg<'a, Num> {
  100|  2.54k|    raw_arg(t as *mut _)
  101|  2.54k|}
_RNvNtNtCs8bE1srDPHCS_6rustix7backend4conv3ret:
  658|  2.54k|pub(super) unsafe fn ret(raw: RetReg<R0>) -> io::Result<()> {
  659|  2.54k|    try_decode_void(raw)
  660|  2.54k|}
_RNvNtNtCs8bE1srDPHCS_6rustix7backend4conv13ret_void_star:
  772|  2.54k|pub(super) fn ret_void_star(raw: RetReg<R0>) -> io::Result<*mut c::c_void> {
  773|  2.54k|    try_decode_void_star(raw)
  774|  2.54k|}
_RINvNtNtCs8bE1srDPHCS_6rustix7backend4conv10pass_usizeNtNtB4_3reg2A1ECslvZ9xuS3Qdd_16wasmtime_runtime:
   99|  5.08k|pub(super) fn pass_usize<'a, Num: ArgNumber>(t: usize) -> ArgReg<'a, Num> {
  100|  5.08k|    raw_arg(t as *mut _)
  101|  5.08k|}
_RNvXsf_NtNtCs8bE1srDPHCS_6rustix7backend4convINtNtB7_3reg6ArgRegNtBK_2A2EINtNtCsiloedr2K6v7_4core7convert4FromNtNtNtB7_2mm5types9ProtFlagsE4fromCslvZ9xuS3Qdd_16wasmtime_runtime:
  375|  2.54k|    fn from(flags: crate::backend::mm::types::ProtFlags) -> Self {
  376|  2.54k|        c_uint(flags.bits())
  377|  2.54k|    }
_RINvNtNtCs8bE1srDPHCS_6rustix7backend4conv6c_uintNtNtB4_3reg2A2ECslvZ9xuS3Qdd_16wasmtime_runtime:
  248|  2.54k|pub(super) fn c_uint<'a, Num: ArgNumber>(i: c::c_uint) -> ArgReg<'a, Num> {
  249|  2.54k|    pass_usize(i as usize)
  250|  2.54k|}
_RINvNtNtCs8bE1srDPHCS_6rustix7backend4conv15loff_t_from_u64NtNtB4_3reg2A5ECslvZ9xuS3Qdd_16wasmtime_runtime:
  260|  2.54k|pub(super) fn loff_t_from_u64<'a, Num: ArgNumber>(i: u64) -> ArgReg<'a, Num> {
  261|  2.54k|    // `loff_t` is signed, but syscalls which expect `loff_t` return `EINVAL`
  262|  2.54k|    // if it's outside the signed `i64` range, so we can silently cast.
  263|  2.54k|    pass_usize(i as usize)
  264|  2.54k|}
_RNvXNtNtCs8bE1srDPHCS_6rustix7backend4convINtNtB4_3reg6ArgRegNtBH_2A0EINtNtCsiloedr2K6v7_4core7convert4FromONtNtB1b_3ffi6c_voidE4fromCslvZ9xuS3Qdd_16wasmtime_runtime:
  105|  5.08k|    fn from(c: *mut T) -> ArgReg<'a, Num> {
  106|  5.08k|        raw_arg(c.cast())
  107|  5.08k|    }
_RINvNtNtCs8bE1srDPHCS_6rustix7backend4conv5no_fdNtNtB4_3reg2A4ECslvZ9xuS3Qdd_16wasmtime_runtime:
  178|  2.54k|pub(super) fn no_fd<'a, Num: ArgNumber>() -> ArgReg<'a, Num> {
  179|  2.54k|    pass_usize(!0_usize)
  180|  2.54k|}
_RINvNtNtCs8bE1srDPHCS_6rustix7backend4conv10pass_usizeNtNtB4_3reg2A2ECslvZ9xuS3Qdd_16wasmtime_runtime:
   99|  2.54k|pub(super) fn pass_usize<'a, Num: ArgNumber>(t: usize) -> ArgReg<'a, Num> {
  100|  2.54k|    raw_arg(t as *mut _)
  101|  2.54k|}
_RINvNtNtCs8bE1srDPHCS_6rustix7backend4conv10pass_usizeNtNtB4_3reg2A4ECslvZ9xuS3Qdd_16wasmtime_runtime:
   99|  2.54k|pub(super) fn pass_usize<'a, Num: ArgNumber>(t: usize) -> ArgReg<'a, Num> {
  100|  2.54k|    raw_arg(t as *mut _)
  101|  2.54k|}
_RINvNtNtCs8bE1srDPHCS_6rustix7backend4conv10pass_usizeNtNtB4_3reg2A5ECslvZ9xuS3Qdd_16wasmtime_runtime:
   99|  2.54k|pub(super) fn pass_usize<'a, Num: ArgNumber>(t: usize) -> ArgReg<'a, Num> {
  100|  2.54k|    raw_arg(t as *mut _)
  101|  2.54k|}
_RINvNtNtCs8bE1srDPHCS_6rustix7backend4conv6c_uintNtNtB4_3reg2A3ECslvZ9xuS3Qdd_16wasmtime_runtime:
  248|  2.54k|pub(super) fn c_uint<'a, Num: ArgNumber>(i: c::c_uint) -> ArgReg<'a, Num> {
  249|  2.54k|    pass_usize(i as usize)
  250|  2.54k|}

_RINvNtNtNtCs8bE1srDPHCS_6rustix7backend2io5errno20try_decode_void_starNtNtB6_3reg2R0ECslvZ9xuS3Qdd_16wasmtime_runtime:
  124|  2.54k|pub(in crate::backend) fn try_decode_void_star<Num: RetNumber>(
  125|  2.54k|    raw: RetReg<Num>,
  126|  2.54k|) -> io::Result<*mut c::c_void> {
  127|  2.54k|    if raw.is_in_range(-4095..0) {
  128|       |        // Safety: `raw` must be in `-4095..0`, and we just checked that raw is
  129|       |        // in that range.
  130|      0|        return Err(unsafe { Errno(raw.decode_error_code()) });
  131|  2.54k|    }
  132|  2.54k|
  133|  2.54k|    Ok(raw.decode_void_star())
  134|  2.54k|}
_RINvNtNtNtCs8bE1srDPHCS_6rustix7backend2io5errno15try_decode_voidNtNtB6_3reg2R0ECslvZ9xuS3Qdd_16wasmtime_runtime:
  187|  2.54k|pub(in crate::backend) unsafe fn try_decode_void<Num: RetNumber>(
  188|  2.54k|    raw: RetReg<Num>,
  189|  2.54k|) -> io::Result<()> {
  190|  2.54k|    // Instead of using `check_result` here, we just check for zero, since this
  191|  2.54k|    // function is only used for system calls which have no other return value,
  192|  2.54k|    // and this produces smaller code.
  193|  2.54k|    if raw.is_nonzero() {
  194|      0|        debug_assert!(raw.is_in_range(-4095..0));
  195|       |
  196|       |        // Tell the optimizer that we know the value is in the error range.
  197|       |        // This helps it avoid unnecessary integer conversions.
  198|       |        #[cfg(core_intrinsics)]
  199|      0|        {
  200|      0|            core::intrinsics::assume(raw.is_in_range(-4095..0));
  201|      0|        }
  202|      0|
  203|      0|        return Err(Errno(raw.decode_error_code()));
  204|  2.54k|    }
  205|  2.54k|
  206|  2.54k|    raw.decode_void();
  207|  2.54k|
  208|  2.54k|    Ok(())
  209|  2.54k|}

_RNvNtNtNtCs8bE1srDPHCS_6rustix7backend2mm8syscalls14mmap_anonymous:
   87|  2.54k|pub(crate) unsafe fn mmap_anonymous(
   88|  2.54k|    addr: *mut c::c_void,
   89|  2.54k|    length: usize,
   90|  2.54k|    prot: ProtFlags,
   91|  2.54k|    flags: MapFlags,
   92|  2.54k|) -> io::Result<*mut c::c_void> {
   93|  2.54k|    #[cfg(target_pointer_width = "32")]
   94|  2.54k|    {
   95|  2.54k|        ret_void_star(syscall!(
   96|  2.54k|            __NR_mmap2,
   97|  2.54k|            addr,
   98|  2.54k|            pass_usize(length),
   99|  2.54k|            prot,
  100|  2.54k|            c_uint(flags.bits() | MAP_ANONYMOUS),
  101|  2.54k|            no_fd(),
  102|  2.54k|            pass_usize(0)
  103|  2.54k|        ))
  104|  2.54k|    }
  105|  2.54k|    #[cfg(target_pointer_width = "64")]
  106|  2.54k|    {
  107|  2.54k|        ret_void_star(syscall!(
  108|  2.54k|            __NR_mmap,
  109|  2.54k|            addr,
  110|  2.54k|            pass_usize(length),
  111|  2.54k|            prot,
  112|  2.54k|            c_uint(flags.bits() | MAP_ANONYMOUS),
  113|  2.54k|            no_fd(),
  114|  2.54k|            loff_t_from_u64(0)
  115|  2.54k|        ))
  116|  2.54k|    }
  117|  2.54k|}
_RNvNtNtNtCs8bE1srDPHCS_6rustix7backend2mm8syscalls6munmap:
  133|  2.54k|pub(crate) unsafe fn munmap(addr: *mut c::c_void, length: usize) -> io::Result<()> {
  134|  2.54k|    ret(syscall!(__NR_munmap, addr, pass_usize(length)))
  135|  2.54k|}

_RNvXs7_NtNtCs8bE1srDPHCS_6rustix7backend3regINtB5_6RetRegNtB5_2R0ENtB5_7FromAsm8from_asmCslvZ9xuS3Qdd_16wasmtime_runtime:
  198|  5.08k|    unsafe fn from_asm(raw: *mut Opaque) -> Self {
  199|  5.08k|        Self {
  200|  5.08k|            raw,
  201|  5.08k|            _phantom: PhantomData,
  202|  5.08k|        }
  203|  5.08k|    }
_RNvXs5_NtNtCs8bE1srDPHCS_6rustix7backend3regINtB5_6ArgRegNtB5_2A5ENtB5_5ToAsm6to_asmCslvZ9xuS3Qdd_16wasmtime_runtime:
   95|  2.54k|    unsafe fn to_asm(self) -> *mut Opaque {
   96|  2.54k|        self.raw
   97|  2.54k|    }
_RNvXs5_NtNtCs8bE1srDPHCS_6rustix7backend3regINtB5_6ArgRegNtB5_2A1ENtB5_5ToAsm6to_asmCslvZ9xuS3Qdd_16wasmtime_runtime:
   95|  5.08k|    unsafe fn to_asm(self) -> *mut Opaque {
   96|  5.08k|        self.raw
   97|  5.08k|    }
_RNvMs6_NtNtCs8bE1srDPHCS_6rustix7backend3regINtB5_6RetRegNtB5_2R0E11is_in_rangeCslvZ9xuS3Qdd_16wasmtime_runtime:
  191|  2.54k|    pub(super) fn is_in_range(&self, range: core::ops::Range<isize>) -> bool {
  192|  2.54k|        range.contains(&(self.raw as isize))
  193|  2.54k|    }
_RNvXs5_NtNtCs8bE1srDPHCS_6rustix7backend3regINtB5_6ArgRegNtB5_2A0ENtB5_5ToAsm6to_asmCslvZ9xuS3Qdd_16wasmtime_runtime:
   95|  5.08k|    unsafe fn to_asm(self) -> *mut Opaque {
   96|  5.08k|        self.raw
   97|  5.08k|    }
_RNvMs6_NtNtCs8bE1srDPHCS_6rustix7backend3regINtB5_6RetRegNtB5_2R0E10is_nonzeroCslvZ9xuS3Qdd_16wasmtime_runtime:
  181|  2.54k|    pub(super) fn is_nonzero(&self) -> bool {
  182|  2.54k|        !self.raw.is_null()
  183|  2.54k|    }
_RNvNtNtCs8bE1srDPHCS_6rustix7backend3reg2nr:
  230|  5.08k|pub(super) const fn nr<'a>(nr: u32) -> SyscallNumber<'a> {
  231|  5.08k|    SyscallNumber {
  232|  5.08k|        nr: nr as usize,
  233|  5.08k|        _phantom: PhantomData,
  234|  5.08k|    }
  235|  5.08k|}
_RNvMs6_NtNtCs8bE1srDPHCS_6rustix7backend3regINtB5_6RetRegNtB5_2R0E16decode_void_starCslvZ9xuS3Qdd_16wasmtime_runtime:
  153|  2.54k|    pub(super) fn decode_void_star(self) -> *mut c::c_void {
  154|  2.54k|        self.raw.cast()
  155|  2.54k|    }
_RINvNtNtCs8bE1srDPHCS_6rustix7backend3reg7raw_argNtB2_2A3ECslvZ9xuS3Qdd_16wasmtime_runtime:
  221|  2.54k|pub(super) fn raw_arg<'a, Num: ArgNumber>(raw: *mut Opaque) -> ArgReg<'a, Num> {
  222|  2.54k|    ArgReg {
  223|  2.54k|        raw,
  224|  2.54k|        _phantom: PhantomData,
  225|  2.54k|    }
  226|  2.54k|}
_RNvXs5_NtNtCs8bE1srDPHCS_6rustix7backend3regINtB5_6ArgRegNtB5_2A2ENtB5_5ToAsm6to_asmCslvZ9xuS3Qdd_16wasmtime_runtime:
   95|  2.54k|    unsafe fn to_asm(self) -> *mut Opaque {
   96|  2.54k|        self.raw
   97|  2.54k|    }
_RNvMs6_NtNtCs8bE1srDPHCS_6rustix7backend3regINtB5_6RetRegNtB5_2R0E12decode_usizeCslvZ9xuS3Qdd_16wasmtime_runtime:
  114|  2.54k|    pub(super) fn decode_usize(self) -> usize {
  115|  2.54k|        debug_assert!(!(-4095..0).contains(&(self.raw as isize)));
  116|  2.54k|        self.raw as usize
  117|  2.54k|    }
_RINvNtNtCs8bE1srDPHCS_6rustix7backend3reg7raw_argNtB2_2A4ECslvZ9xuS3Qdd_16wasmtime_runtime:
  221|  2.54k|pub(super) fn raw_arg<'a, Num: ArgNumber>(raw: *mut Opaque) -> ArgReg<'a, Num> {
  222|  2.54k|    ArgReg {
  223|  2.54k|        raw,
  224|  2.54k|        _phantom: PhantomData,
  225|  2.54k|    }
  226|  2.54k|}
_RNvMs6_NtNtCs8bE1srDPHCS_6rustix7backend3regINtB5_6RetRegNtB5_2R0E11decode_voidCslvZ9xuS3Qdd_16wasmtime_runtime:
  164|  2.54k|    pub(super) fn decode_void(self) {
  165|  2.54k|        let ignore = self.decode_usize();
  166|  2.54k|        debug_assert_eq!(ignore, 0);
  167|  2.54k|    }
_RNvXs8_NtNtCs8bE1srDPHCS_6rustix7backend3regNtB5_13SyscallNumberNtB5_5ToAsm6to_asm:
  214|  5.08k|    unsafe fn to_asm(self) -> *mut Opaque {
  215|  5.08k|        self.nr as usize as *mut Opaque
  216|  5.08k|    }
_RINvNtNtCs8bE1srDPHCS_6rustix7backend3reg7raw_argNtB2_2A1ECslvZ9xuS3Qdd_16wasmtime_runtime:
  221|  5.08k|pub(super) fn raw_arg<'a, Num: ArgNumber>(raw: *mut Opaque) -> ArgReg<'a, Num> {
  222|  5.08k|    ArgReg {
  223|  5.08k|        raw,
  224|  5.08k|        _phantom: PhantomData,
  225|  5.08k|    }
  226|  5.08k|}
_RINvNtNtCs8bE1srDPHCS_6rustix7backend3reg7raw_argNtB2_2A5ECslvZ9xuS3Qdd_16wasmtime_runtime:
  221|  2.54k|pub(super) fn raw_arg<'a, Num: ArgNumber>(raw: *mut Opaque) -> ArgReg<'a, Num> {
  222|  2.54k|    ArgReg {
  223|  2.54k|        raw,
  224|  2.54k|        _phantom: PhantomData,
  225|  2.54k|    }
  226|  2.54k|}
_RINvNtNtCs8bE1srDPHCS_6rustix7backend3reg7raw_argNtB2_2A2ECslvZ9xuS3Qdd_16wasmtime_runtime:
  221|  2.54k|pub(super) fn raw_arg<'a, Num: ArgNumber>(raw: *mut Opaque) -> ArgReg<'a, Num> {
  222|  2.54k|    ArgReg {
  223|  2.54k|        raw,
  224|  2.54k|        _phantom: PhantomData,
  225|  2.54k|    }
  226|  2.54k|}
_RNvXs5_NtNtCs8bE1srDPHCS_6rustix7backend3regINtB5_6ArgRegNtB5_2A3ENtB5_5ToAsm6to_asmCslvZ9xuS3Qdd_16wasmtime_runtime:
   95|  2.54k|    unsafe fn to_asm(self) -> *mut Opaque {
   96|  2.54k|        self.raw
   97|  2.54k|    }
_RNvXs5_NtNtCs8bE1srDPHCS_6rustix7backend3regINtB5_6ArgRegNtB5_2A4ENtB5_5ToAsm6to_asmCslvZ9xuS3Qdd_16wasmtime_runtime:
   95|  2.54k|    unsafe fn to_asm(self) -> *mut Opaque {
   96|  2.54k|        self.raw
   97|  2.54k|    }
_RINvNtNtCs8bE1srDPHCS_6rustix7backend3reg7raw_argNtB2_2A0ECslvZ9xuS3Qdd_16wasmtime_runtime:
  221|  5.08k|pub(super) fn raw_arg<'a, Num: ArgNumber>(raw: *mut Opaque) -> ArgReg<'a, Num> {
  222|  5.08k|    ArgReg {
  223|  5.08k|        raw,
  224|  5.08k|        _phantom: PhantomData,
  225|  5.08k|    }
  226|  5.08k|}

_RNvNtNtCs8bE1srDPHCS_6rustix2mm4mmap6munmap:
   86|  2.54k|pub unsafe fn munmap(ptr: *mut c_void, len: usize) -> io::Result<()> {
   87|  2.54k|    backend::mm::syscalls::munmap(ptr, len)
   88|  2.54k|}
_RNvNtNtCs8bE1srDPHCS_6rustix2mm4mmap14mmap_anonymous:
   64|  2.54k|pub unsafe fn mmap_anonymous(
   65|  2.54k|    ptr: *mut c_void,
   66|  2.54k|    len: usize,
   67|  2.54k|    prot: ProtFlags,
   68|  2.54k|    flags: MapFlags,
   69|  2.54k|) -> io::Result<*mut c_void> {
   70|  2.54k|    backend::mm::syscalls::mmap_anonymous(ptr, len, prot, flags)
   71|  2.54k|}

_RNvXs4_CsboF1IjNS22E_10scopeguardINtB5_10ScopeGuardQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEFBN_EuENtNtNtCsiloedr2K6v7_4core3ops5deref8DerefMut9deref_mutCsboUdcTbF1FS_15direct_syscalls:
  443|  17.8k|    fn deref_mut(&mut self) -> &mut T {
  444|  17.8k|        &mut *self.value
  445|  17.8k|    }
_RNvXs5_CsboF1IjNS22E_10scopeguardINtB5_10ScopeGuardQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEFBN_EuENtNtNtCsiloedr2K6v7_4core3ops4drop4Drop4dropCsboUdcTbF1FS_15direct_syscalls:
  452|  17.8k|    fn drop(&mut self) {
  453|  17.8k|        // This is OK because the fields are `ManuallyDrop`s
  454|  17.8k|        // which will not be dropped by the compiler.
  455|  17.8k|        let (value, dropfn) = unsafe {
  456|  17.8k|            (ptr::read(&*self.value), ptr::read(&*self.dropfn))
  457|  17.8k|        };
  458|  17.8k|        if S::should_run() {
  459|  17.8k|            dropfn(value);
  460|  17.8k|        }
  461|  17.8k|    }
_RNvMs1_CsboF1IjNS22E_10scopeguardINtB5_10ScopeGuardQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEFBN_EuE13with_strategyCsboUdcTbF1FS_15direct_syscalls:
  317|  17.8k|    pub fn with_strategy(v: T, dropfn: F) -> ScopeGuard<T, F, S> {
  318|  17.8k|        ScopeGuard {
  319|  17.8k|            value: ManuallyDrop::new(v),
  320|  17.8k|            dropfn: ManuallyDrop::new(dropfn),
  321|  17.8k|            strategy: PhantomData,
  322|  17.8k|        }
  323|  17.8k|    }
_RNvXCsboF1IjNS22E_10scopeguardNtB2_6AlwaysNtB2_8Strategy10should_run:
  231|  23.8k|    fn should_run() -> bool { true }
_RINvCsboF1IjNS22E_10scopeguard5guardQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEFBy_EuECsboUdcTbF1FS_15direct_syscalls:
  367|  17.8k|pub fn guard<T, F>(v: T, dropfn: F) -> ScopeGuard<T, F, Always>
  368|  17.8k|    where F: FnOnce(T)
  369|  17.8k|{
  370|  17.8k|    ScopeGuard::with_strategy(v, dropfn)
  371|  17.8k|}
_RNvXs5_CsboF1IjNS22E_10scopeguardINtB5_10ScopeGuardQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEFBN_EuENtNtNtCsiloedr2K6v7_4core3ops4drop4Drop4dropCs7AwuCMXPzRZ_8fvm_fuzz:
  452|  6.04k|    fn drop(&mut self) {
  453|  6.04k|        // This is OK because the fields are `ManuallyDrop`s
  454|  6.04k|        // which will not be dropped by the compiler.
  455|  6.04k|        let (value, dropfn) = unsafe {
  456|  6.04k|            (ptr::read(&*self.value), ptr::read(&*self.dropfn))
  457|  6.04k|        };
  458|  6.04k|        if S::should_run() {
  459|  6.04k|            dropfn(value);
  460|  6.04k|        }
  461|  6.04k|    }
_RNvMs1_CsboF1IjNS22E_10scopeguardINtB5_10ScopeGuardQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEFBN_EuE13with_strategyCs7AwuCMXPzRZ_8fvm_fuzz:
  317|  6.04k|    pub fn with_strategy(v: T, dropfn: F) -> ScopeGuard<T, F, S> {
  318|  6.04k|        ScopeGuard {
  319|  6.04k|            value: ManuallyDrop::new(v),
  320|  6.04k|            dropfn: ManuallyDrop::new(dropfn),
  321|  6.04k|            strategy: PhantomData,
  322|  6.04k|        }
  323|  6.04k|    }
_RNvXs4_CsboF1IjNS22E_10scopeguardINtB5_10ScopeGuardQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEFBN_EuENtNtNtCsiloedr2K6v7_4core3ops5deref8DerefMut9deref_mutCs7AwuCMXPzRZ_8fvm_fuzz:
  443|  6.04k|    fn deref_mut(&mut self) -> &mut T {
  444|  6.04k|        &mut *self.value
  445|  6.04k|    }
_RINvCsboF1IjNS22E_10scopeguard5guardQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEFBy_EuECs7AwuCMXPzRZ_8fvm_fuzz:
  367|  6.04k|pub fn guard<T, F>(v: T, dropfn: F) -> ScopeGuard<T, F, Always>
  368|  6.04k|    where F: FnOnce(T)
  369|  6.04k|{
  370|  6.04k|    ScopeGuard::with_strategy(v, dropfn)
  371|  6.04k|}

_RINvXsX_NtNtCssVaLrL3Upj_5serde2de5implsyNtB8_11Deserialize11deserializeNtNtCs3TS9n28v4Rl_12libipld_core4ipld4IpldECsboUdcTbF1FS_15direct_syscalls:
  113|    954|            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  114|    954|            where
  115|    954|                D: Deserializer<'de>,
  116|    954|            {
  117|    954|                struct PrimitiveVisitor;
  118|    954|
  119|    954|                impl<'de> Visitor<'de> for PrimitiveVisitor {
  120|    954|                    type Value = $primitive;
  121|    954|
  122|    954|                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
  123|    954|                        formatter.write_str(stringify!($primitive))
  124|    954|                    }
  125|    954|
  126|    954|                    $($($method!($val : $visit);)*)*
  127|    954|                }
  128|    954|
  129|    954|                deserializer.$deserialize(PrimitiveVisitor)
  130|    954|            }
_RINvXNvXsX_NtNtCssVaLrL3Upj_5serde2de5implsyNtBb_11Deserialize11deserializeNtB3_16PrimitiveVisitorNtBb_7Visitor9visit_u64NtNtCs3TS9n28v4Rl_12libipld_core5error10SerdeErrorECsboUdcTbF1FS_15direct_syscalls:
  138|    954|        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>
  139|    954|        where
  140|    954|            E: Error,
  141|    954|        {
  142|    954|            Ok(v)
  143|    954|        }
_RINvXsX_NtNtCssVaLrL3Upj_5serde2de5implsyNtB8_11Deserialize11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECsboUdcTbF1FS_15direct_syscalls:
  113|    318|            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  114|    318|            where
  115|    318|                D: Deserializer<'de>,
  116|    318|            {
  117|    318|                struct PrimitiveVisitor;
  118|    318|
  119|    318|                impl<'de> Visitor<'de> for PrimitiveVisitor {
  120|    318|                    type Value = $primitive;
  121|    318|
  122|    318|                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
  123|    318|                        formatter.write_str(stringify!($primitive))
  124|    318|                    }
  125|    318|
  126|    318|                    $($($method!($val : $visit);)*)*
  127|    318|                }
  128|    318|
  129|    318|                deserializer.$deserialize(PrimitiveVisitor)
  130|    318|            }
_RINvXNvXsh_NtNtCssVaLrL3Upj_5serde2de5implsINtNtCs9pDt8l5wGDA_5alloc3vec3VecpENtBb_11Deserialize11deserializeINtB3_10VecVisitorINtCslH3pn9Bu6yX_13fvm_ipld_hamt12KeyValuePairNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateEENtBb_7Visitor9visit_seqQNtNtNtCs3TS9n28v4Rl_12libipld_core5serde2de15SeqDeserializerECsboUdcTbF1FS_15direct_syscalls:
 1031|    954|            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1032|    954|            where
 1033|    954|                A: SeqAccess<'de>,
 1034|    954|            {
 1035|    954|                let mut values = Vec::with_capacity(size_hint::cautious(seq.size_hint()));
 1036|       |
 1037|  1.90k|                while let Some(value) = try!(seq.next_element()) {
 1038|    954|                    values.push(value);
 1039|    954|                }
 1040|       |
 1041|    954|                Ok(values)
 1042|    954|            }
_RINvXse_NtNtCssVaLrL3Upj_5serde2de5implsINtNtCsiloedr2K6v7_4core6option6OptionNtNtCs83Z8YCK0meJ_10fvm_shared7address7AddressENtB8_11Deserialize11deserializeNtNtCs3TS9n28v4Rl_12libipld_core4ipld4IpldECsboUdcTbF1FS_15direct_syscalls:
  808|    954|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  809|    954|    where
  810|    954|        D: Deserializer<'de>,
  811|    954|    {
  812|    954|        deserializer.deserialize_option(OptionVisitor {
  813|    954|            marker: PhantomData,
  814|    954|        })
  815|    954|    }
_RINvXNvXsh_NtNtCssVaLrL3Upj_5serde2de5implsINtNtCs9pDt8l5wGDA_5alloc3vec3VecpENtBb_11Deserialize11deserializeINtB3_10VecVisitorINtNtCslH3pn9Bu6yX_13fvm_ipld_hamt7pointer7PointerNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtB26_14hash_algorithm6Sha256EENtBb_7Visitor9visit_seqINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECsboUdcTbF1FS_15direct_syscalls:
 1031|    318|            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1032|    318|            where
 1033|    318|                A: SeqAccess<'de>,
 1034|    318|            {
 1035|    318|                let mut values = Vec::with_capacity(size_hint::cautious(seq.size_hint()));
 1036|       |
 1037|  1.27k|                while let Some(value) = try!(seq.next_element()) {
 1038|    954|                    values.push(value);
 1039|    954|                }
 1040|       |
 1041|    318|                Ok(values)
 1042|    318|            }
_RINvXsh_NtNtCssVaLrL3Upj_5serde2de5implsINtNtCs9pDt8l5wGDA_5alloc3vec3VecINtNtCslH3pn9Bu6yX_13fvm_ipld_hamt7pointer7PointerNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtB1e_14hash_algorithm6Sha256EENtB8_11Deserialize11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECsboUdcTbF1FS_15direct_syscalls:
 1013|    318|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
 1014|    318|    where
 1015|    318|        D: Deserializer<'de>,
 1016|    318|    {
 1017|    318|        struct VecVisitor<T> {
 1018|    318|            marker: PhantomData<T>,
 1019|    318|        }
 1020|    318|
 1021|    318|        impl<'de, T> Visitor<'de> for VecVisitor<T>
 1022|    318|        where
 1023|    318|            T: Deserialize<'de>,
 1024|    318|        {
 1025|    318|            type Value = Vec<T>;
 1026|    318|
 1027|    318|            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
 1028|    318|                formatter.write_str("a sequence")
 1029|    318|            }
 1030|    318|
 1031|    318|            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1032|    318|            where
 1033|    318|                A: SeqAccess<'de>,
 1034|    318|            {
 1035|    318|                let mut values = Vec::with_capacity(size_hint::cautious(seq.size_hint()));
 1036|    318|
 1037|    318|                while let Some(value) = try!(seq.next_element()) {
 1038|    318|                    values.push(value);
 1039|    318|                }
 1040|    318|
 1041|    318|                Ok(values)
 1042|    318|            }
 1043|    318|        }
 1044|    318|
 1045|    318|        let visitor = VecVisitor {
 1046|    318|            marker: PhantomData,
 1047|    318|        };
 1048|    318|        deserializer.deserialize_seq(visitor)
 1049|    318|    }
_RINvXNvXsh_NtNtCssVaLrL3Upj_5serde2de5implsINtNtCs9pDt8l5wGDA_5alloc3vec3VecpENtBb_11Deserialize11deserializeINtB3_10VecVisitorTNtNtBK_6string6StringINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEENtBb_7Visitor9visit_seqINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECsboUdcTbF1FS_15direct_syscalls:
 1031|    318|            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1032|    318|            where
 1033|    318|                A: SeqAccess<'de>,
 1034|    318|            {
 1035|    318|                let mut values = Vec::with_capacity(size_hint::cautious(seq.size_hint()));
 1036|       |
 1037|  5.08k|                while let Some(value) = try!(seq.next_element()) {
 1038|  4.77k|                    values.push(value);
 1039|  4.77k|                }
 1040|       |
 1041|    318|                Ok(values)
 1042|    318|            }
_RINvXNvXsX_NtNtCssVaLrL3Upj_5serde2de5implsyNtBb_11Deserialize11deserializeNtB3_16PrimitiveVisitorNtBb_7Visitor9visit_u64INtNtCshf5gyM0YXBy_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsiloedr2K6v7_4core7convert10InfallibleEECsboUdcTbF1FS_15direct_syscalls:
  138|    318|        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>
  139|    318|        where
  140|    318|            E: Error,
  141|    318|        {
  142|    318|            Ok(v)
  143|    318|        }
_RINvXNvXs2M_NtNtCssVaLrL3Upj_5serde2de5implsTppENtBc_11Deserialize11deserializeINtB3_12TupleVisitorNtNtCslH3pn9Bu6yX_13fvm_ipld_hamt8bitfield8BitfieldINtNtCs9pDt8l5wGDA_5alloc3vec3VecINtNtB1D_7pointer7PointerNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtB1D_14hash_algorithm6Sha256EEENtBc_7Visitor9visit_seqINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECsboUdcTbF1FS_15direct_syscalls:
 1277|    318|                        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1278|    318|                        where
 1279|    318|                            A: SeqAccess<'de>,
 1280|    318|                        {
 1281|       |                            $(
 1282|    318|                                let $name = match try!(seq.next_element()) {
 1283|    318|                                    Some(value) => value,
 1284|      0|                                    None => return Err(Error::invalid_length($n, &self)),
 1285|       |                                };
 1286|       |                            )+
 1287|       |
 1288|    318|                            Ok(($($name,)+))
 1289|    318|                        }
_RINvXNvXsV_NtNtCssVaLrL3Upj_5serde2de5implsmNtBb_11Deserialize11deserializeNtB3_16PrimitiveVisitorNtBb_7Visitor9visit_u32INtNtCshf5gyM0YXBy_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsiloedr2K6v7_4core7convert10InfallibleEECsboUdcTbF1FS_15direct_syscalls:
  138|    318|        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>
  139|    318|        where
  140|    318|            E: Error,
  141|    318|        {
  142|    318|            Ok(v)
  143|    318|        }
_RINvXs2M_NtNtCssVaLrL3Upj_5serde2de5implsTNtNtCslH3pn9Bu6yX_13fvm_ipld_hamt8bitfield8BitfieldINtNtCs9pDt8l5wGDA_5alloc3vec3VecINtNtBI_7pointer7PointerNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtBI_14hash_algorithm6Sha256EEENtB9_11Deserialize11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECsboUdcTbF1FS_15direct_syscalls:
 1260|    318|                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
 1261|    318|                where
 1262|    318|                    D: Deserializer<'de>,
 1263|    318|                {
 1264|    318|                    struct TupleVisitor<$($name,)+> {
 1265|    318|                        marker: PhantomData<($($name,)+)>,
 1266|    318|                    }
 1267|    318|
 1268|    318|                    impl<'de, $($name: Deserialize<'de>),+> Visitor<'de> for TupleVisitor<$($name,)+> {
 1269|    318|                        type Value = ($($name,)+);
 1270|    318|
 1271|    318|                        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
 1272|    318|                            formatter.write_str(concat!("a tuple of size ", $len))
 1273|    318|                        }
 1274|    318|
 1275|    318|                        #[inline]
 1276|    318|                        #[allow(non_snake_case)]
 1277|    318|                        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1278|    318|                        where
 1279|    318|                            A: SeqAccess<'de>,
 1280|    318|                        {
 1281|    318|                            $(
 1282|    318|                                let $name = match try!(seq.next_element()) {
 1283|    318|                                    Some(value) => value,
 1284|    318|                                    None => return Err(Error::invalid_length($n, &self)),
 1285|    318|                                };
 1286|    318|                            )+
 1287|    318|
 1288|    318|                            Ok(($($name,)+))
 1289|    318|                        }
 1290|    318|                    }
 1291|    318|
 1292|    318|                    deserializer.deserialize_tuple($len, TupleVisitor { marker: PhantomData })
 1293|    318|                }
_RINvXNvXs2M_NtNtCssVaLrL3Upj_5serde2de5implsTppENtBc_11Deserialize11deserializeINtB3_12TupleVisitormINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EENtBc_7Visitor9visit_seqINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECsboUdcTbF1FS_15direct_syscalls:
 1277|    318|                        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1278|    318|                        where
 1279|    318|                            A: SeqAccess<'de>,
 1280|    318|                        {
 1281|       |                            $(
 1282|    318|                                let $name = match try!(seq.next_element()) {
 1283|    318|                                    Some(value) => value,
 1284|      0|                                    None => return Err(Error::invalid_length($n, &self)),
 1285|       |                                };
 1286|       |                            )+
 1287|       |
 1288|    318|                            Ok(($($name,)+))
 1289|    318|                        }
_RINvXs4_NtNtCssVaLrL3Upj_5serde2de5implsNtB6_13StringVisitorNtB8_7Visitor9visit_strINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsiloedr2K6v7_4core7convert10InfallibleEECsboUdcTbF1FS_15direct_syscalls:
  486|  4.77k|    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
  487|  4.77k|    where
  488|  4.77k|        E: Error,
  489|  4.77k|    {
  490|  4.77k|        Ok(v.to_owned())
  491|  4.77k|    }
_RINvXs6_NtNtCssVaLrL3Upj_5serde2de5implsNtNtCs9pDt8l5wGDA_5alloc6string6StringNtB8_11Deserialize11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECsboUdcTbF1FS_15direct_syscalls:
  582|  4.77k|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  583|  4.77k|    where
  584|  4.77k|        D: Deserializer<'de>,
  585|  4.77k|    {
  586|  4.77k|        deserializer.deserialize_string(StringVisitor)
  587|  4.77k|    }
_RINvXsV_NtNtCssVaLrL3Upj_5serde2de5implsmNtB8_11Deserialize11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECsboUdcTbF1FS_15direct_syscalls:
  113|    318|            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  114|    318|            where
  115|    318|                D: Deserializer<'de>,
  116|    318|            {
  117|    318|                struct PrimitiveVisitor;
  118|    318|
  119|    318|                impl<'de> Visitor<'de> for PrimitiveVisitor {
  120|    318|                    type Value = $primitive;
  121|    318|
  122|    318|                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
  123|    318|                        formatter.write_str(stringify!($primitive))
  124|    318|                    }
  125|    318|
  126|    318|                    $($($method!($val : $visit);)*)*
  127|    318|                }
  128|    318|
  129|    318|                deserializer.$deserialize(PrimitiveVisitor)
  130|    318|            }
_RINvXsh_NtNtCssVaLrL3Upj_5serde2de5implsINtNtCs9pDt8l5wGDA_5alloc3vec3VecINtCslH3pn9Bu6yX_13fvm_ipld_hamt12KeyValuePairNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateEENtB8_11Deserialize11deserializeNtNtCs3TS9n28v4Rl_12libipld_core4ipld4IpldECsboUdcTbF1FS_15direct_syscalls:
 1013|    954|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
 1014|    954|    where
 1015|    954|        D: Deserializer<'de>,
 1016|    954|    {
 1017|    954|        struct VecVisitor<T> {
 1018|    954|            marker: PhantomData<T>,
 1019|    954|        }
 1020|    954|
 1021|    954|        impl<'de, T> Visitor<'de> for VecVisitor<T>
 1022|    954|        where
 1023|    954|            T: Deserialize<'de>,
 1024|    954|        {
 1025|    954|            type Value = Vec<T>;
 1026|    954|
 1027|    954|            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
 1028|    954|                formatter.write_str("a sequence")
 1029|    954|            }
 1030|    954|
 1031|    954|            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1032|    954|            where
 1033|    954|                A: SeqAccess<'de>,
 1034|    954|            {
 1035|    954|                let mut values = Vec::with_capacity(size_hint::cautious(seq.size_hint()));
 1036|    954|
 1037|    954|                while let Some(value) = try!(seq.next_element()) {
 1038|    954|                    values.push(value);
 1039|    954|                }
 1040|    954|
 1041|    954|                Ok(values)
 1042|    954|            }
 1043|    954|        }
 1044|    954|
 1045|    954|        let visitor = VecVisitor {
 1046|    954|            marker: PhantomData,
 1047|    954|        };
 1048|    954|        deserializer.deserialize_seq(visitor)
 1049|    954|    }
_RINvXsd_NtNtCssVaLrL3Upj_5serde2de5implsINtB6_13OptionVisitorNtNtCs83Z8YCK0meJ_10fvm_shared7address7AddressENtB8_7Visitor10visit_noneNtNtCs3TS9n28v4Rl_12libipld_core5error10SerdeErrorECsboUdcTbF1FS_15direct_syscalls:
  781|    954|    fn visit_none<E>(self) -> Result<Self::Value, E>
  782|    954|    where
  783|    954|        E: Error,
  784|    954|    {
  785|    954|        Ok(None)
  786|    954|    }
_RINvXs2M_NtNtCssVaLrL3Upj_5serde2de5implsTmINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EENtB9_11Deserialize11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECsboUdcTbF1FS_15direct_syscalls:
 1260|    318|                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
 1261|    318|                where
 1262|    318|                    D: Deserializer<'de>,
 1263|    318|                {
 1264|    318|                    struct TupleVisitor<$($name,)+> {
 1265|    318|                        marker: PhantomData<($($name,)+)>,
 1266|    318|                    }
 1267|    318|
 1268|    318|                    impl<'de, $($name: Deserialize<'de>),+> Visitor<'de> for TupleVisitor<$($name,)+> {
 1269|    318|                        type Value = ($($name,)+);
 1270|    318|
 1271|    318|                        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
 1272|    318|                            formatter.write_str(concat!("a tuple of size ", $len))
 1273|    318|                        }
 1274|    318|
 1275|    318|                        #[inline]
 1276|    318|                        #[allow(non_snake_case)]
 1277|    318|                        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1278|    318|                        where
 1279|    318|                            A: SeqAccess<'de>,
 1280|    318|                        {
 1281|    318|                            $(
 1282|    318|                                let $name = match try!(seq.next_element()) {
 1283|    318|                                    Some(value) => value,
 1284|    318|                                    None => return Err(Error::invalid_length($n, &self)),
 1285|    318|                                };
 1286|    318|                            )+
 1287|    318|
 1288|    318|                            Ok(($($name,)+))
 1289|    318|                        }
 1290|    318|                    }
 1291|    318|
 1292|    318|                    deserializer.deserialize_tuple($len, TupleVisitor { marker: PhantomData })
 1293|    318|                }
_RINvXNvXs2M_NtNtCssVaLrL3Upj_5serde2de5implsTppENtBc_11Deserialize11deserializeINtB3_12TupleVisitorNtNtCs9pDt8l5wGDA_5alloc6string6StringINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EENtBc_7Visitor9visit_seqINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECsboUdcTbF1FS_15direct_syscalls:
 1277|  4.77k|                        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1278|  4.77k|                        where
 1279|  4.77k|                            A: SeqAccess<'de>,
 1280|  4.77k|                        {
 1281|       |                            $(
 1282|  4.77k|                                let $name = match try!(seq.next_element()) {
 1283|  4.77k|                                    Some(value) => value,
 1284|      0|                                    None => return Err(Error::invalid_length($n, &self)),
 1285|       |                                };
 1286|       |                            )+
 1287|       |
 1288|  4.77k|                            Ok(($($name,)+))
 1289|  4.77k|                        }
_RINvXs2M_NtNtCssVaLrL3Upj_5serde2de5implsTNtNtCs9pDt8l5wGDA_5alloc6string6StringINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EENtB9_11Deserialize11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECsboUdcTbF1FS_15direct_syscalls:
 1260|  4.77k|                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
 1261|  4.77k|                where
 1262|  4.77k|                    D: Deserializer<'de>,
 1263|  4.77k|                {
 1264|  4.77k|                    struct TupleVisitor<$($name,)+> {
 1265|  4.77k|                        marker: PhantomData<($($name,)+)>,
 1266|  4.77k|                    }
 1267|  4.77k|
 1268|  4.77k|                    impl<'de, $($name: Deserialize<'de>),+> Visitor<'de> for TupleVisitor<$($name,)+> {
 1269|  4.77k|                        type Value = ($($name,)+);
 1270|  4.77k|
 1271|  4.77k|                        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
 1272|  4.77k|                            formatter.write_str(concat!("a tuple of size ", $len))
 1273|  4.77k|                        }
 1274|  4.77k|
 1275|  4.77k|                        #[inline]
 1276|  4.77k|                        #[allow(non_snake_case)]
 1277|  4.77k|                        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1278|  4.77k|                        where
 1279|  4.77k|                            A: SeqAccess<'de>,
 1280|  4.77k|                        {
 1281|  4.77k|                            $(
 1282|  4.77k|                                let $name = match try!(seq.next_element()) {
 1283|  4.77k|                                    Some(value) => value,
 1284|  4.77k|                                    None => return Err(Error::invalid_length($n, &self)),
 1285|  4.77k|                                };
 1286|  4.77k|                            )+
 1287|  4.77k|
 1288|  4.77k|                            Ok(($($name,)+))
 1289|  4.77k|                        }
 1290|  4.77k|                    }
 1291|  4.77k|
 1292|  4.77k|                    deserializer.deserialize_tuple($len, TupleVisitor { marker: PhantomData })
 1293|  4.77k|                }
_RINvXsh_NtNtCssVaLrL3Upj_5serde2de5implsINtNtCs9pDt8l5wGDA_5alloc3vec3VecTNtNtBH_6string6StringINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEENtB8_11Deserialize11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECsboUdcTbF1FS_15direct_syscalls:
 1013|    318|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
 1014|    318|    where
 1015|    318|        D: Deserializer<'de>,
 1016|    318|    {
 1017|    318|        struct VecVisitor<T> {
 1018|    318|            marker: PhantomData<T>,
 1019|    318|        }
 1020|    318|
 1021|    318|        impl<'de, T> Visitor<'de> for VecVisitor<T>
 1022|    318|        where
 1023|    318|            T: Deserialize<'de>,
 1024|    318|        {
 1025|    318|            type Value = Vec<T>;
 1026|    318|
 1027|    318|            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
 1028|    318|                formatter.write_str("a sequence")
 1029|    318|            }
 1030|    318|
 1031|    318|            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1032|    318|            where
 1033|    318|                A: SeqAccess<'de>,
 1034|    318|            {
 1035|    318|                let mut values = Vec::with_capacity(size_hint::cautious(seq.size_hint()));
 1036|    318|
 1037|    318|                while let Some(value) = try!(seq.next_element()) {
 1038|    318|                    values.push(value);
 1039|    318|                }
 1040|    318|
 1041|    318|                Ok(values)
 1042|    318|            }
 1043|    318|        }
 1044|    318|
 1045|    318|        let visitor = VecVisitor {
 1046|    318|            marker: PhantomData,
 1047|    318|        };
 1048|    318|        deserializer.deserialize_seq(visitor)
 1049|    318|    }
_RINvXs2M_NtNtCssVaLrL3Upj_5serde2de5implsTNtNtCs9pDt8l5wGDA_5alloc6string6StringINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EENtB9_11Deserialize11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECs7AwuCMXPzRZ_8fvm_fuzz:
 1260|  4.77k|                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
 1261|  4.77k|                where
 1262|  4.77k|                    D: Deserializer<'de>,
 1263|  4.77k|                {
 1264|  4.77k|                    struct TupleVisitor<$($name,)+> {
 1265|  4.77k|                        marker: PhantomData<($($name,)+)>,
 1266|  4.77k|                    }
 1267|  4.77k|
 1268|  4.77k|                    impl<'de, $($name: Deserialize<'de>),+> Visitor<'de> for TupleVisitor<$($name,)+> {
 1269|  4.77k|                        type Value = ($($name,)+);
 1270|  4.77k|
 1271|  4.77k|                        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
 1272|  4.77k|                            formatter.write_str(concat!("a tuple of size ", $len))
 1273|  4.77k|                        }
 1274|  4.77k|
 1275|  4.77k|                        #[inline]
 1276|  4.77k|                        #[allow(non_snake_case)]
 1277|  4.77k|                        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1278|  4.77k|                        where
 1279|  4.77k|                            A: SeqAccess<'de>,
 1280|  4.77k|                        {
 1281|  4.77k|                            $(
 1282|  4.77k|                                let $name = match try!(seq.next_element()) {
 1283|  4.77k|                                    Some(value) => value,
 1284|  4.77k|                                    None => return Err(Error::invalid_length($n, &self)),
 1285|  4.77k|                                };
 1286|  4.77k|                            )+
 1287|  4.77k|
 1288|  4.77k|                            Ok(($($name,)+))
 1289|  4.77k|                        }
 1290|  4.77k|                    }
 1291|  4.77k|
 1292|  4.77k|                    deserializer.deserialize_tuple($len, TupleVisitor { marker: PhantomData })
 1293|  4.77k|                }
_RINvXs4_NtNtCssVaLrL3Upj_5serde2de5implsNtB6_13StringVisitorNtB8_7Visitor9visit_strINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsiloedr2K6v7_4core7convert10InfallibleEECs7AwuCMXPzRZ_8fvm_fuzz:
  486|  4.77k|    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
  487|  4.77k|    where
  488|  4.77k|        E: Error,
  489|  4.77k|    {
  490|  4.77k|        Ok(v.to_owned())
  491|  4.77k|    }
_RINvXNvXsV_NtNtCssVaLrL3Upj_5serde2de5implsmNtBb_11Deserialize11deserializeNtB3_16PrimitiveVisitorNtBb_7Visitor9visit_u32INtNtCshf5gyM0YXBy_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsiloedr2K6v7_4core7convert10InfallibleEECs7AwuCMXPzRZ_8fvm_fuzz:
  138|    318|        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>
  139|    318|        where
  140|    318|            E: Error,
  141|    318|        {
  142|    318|            Ok(v)
  143|    318|        }
_RINvXNvXs2M_NtNtCssVaLrL3Upj_5serde2de5implsTppENtBc_11Deserialize11deserializeINtB3_12TupleVisitormINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EENtBc_7Visitor9visit_seqINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECs7AwuCMXPzRZ_8fvm_fuzz:
 1277|    318|                        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1278|    318|                        where
 1279|    318|                            A: SeqAccess<'de>,
 1280|    318|                        {
 1281|       |                            $(
 1282|    318|                                let $name = match try!(seq.next_element()) {
 1283|    318|                                    Some(value) => value,
 1284|      0|                                    None => return Err(Error::invalid_length($n, &self)),
 1285|       |                                };
 1286|       |                            )+
 1287|       |
 1288|    318|                            Ok(($($name,)+))
 1289|    318|                        }
_RINvXsV_NtNtCssVaLrL3Upj_5serde2de5implsmNtB8_11Deserialize11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECs7AwuCMXPzRZ_8fvm_fuzz:
  113|    318|            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  114|    318|            where
  115|    318|                D: Deserializer<'de>,
  116|    318|            {
  117|    318|                struct PrimitiveVisitor;
  118|    318|
  119|    318|                impl<'de> Visitor<'de> for PrimitiveVisitor {
  120|    318|                    type Value = $primitive;
  121|    318|
  122|    318|                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
  123|    318|                        formatter.write_str(stringify!($primitive))
  124|    318|                    }
  125|    318|
  126|    318|                    $($($method!($val : $visit);)*)*
  127|    318|                }
  128|    318|
  129|    318|                deserializer.$deserialize(PrimitiveVisitor)
  130|    318|            }
_RINvXsh_NtNtCssVaLrL3Upj_5serde2de5implsINtNtCs9pDt8l5wGDA_5alloc3vec3VecINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EENtB8_11Deserialize11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECs7AwuCMXPzRZ_8fvm_fuzz:
 1013|    318|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
 1014|    318|    where
 1015|    318|        D: Deserializer<'de>,
 1016|    318|    {
 1017|    318|        struct VecVisitor<T> {
 1018|    318|            marker: PhantomData<T>,
 1019|    318|        }
 1020|    318|
 1021|    318|        impl<'de, T> Visitor<'de> for VecVisitor<T>
 1022|    318|        where
 1023|    318|            T: Deserialize<'de>,
 1024|    318|        {
 1025|    318|            type Value = Vec<T>;
 1026|    318|
 1027|    318|            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
 1028|    318|                formatter.write_str("a sequence")
 1029|    318|            }
 1030|    318|
 1031|    318|            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1032|    318|            where
 1033|    318|                A: SeqAccess<'de>,
 1034|    318|            {
 1035|    318|                let mut values = Vec::with_capacity(size_hint::cautious(seq.size_hint()));
 1036|    318|
 1037|    318|                while let Some(value) = try!(seq.next_element()) {
 1038|    318|                    values.push(value);
 1039|    318|                }
 1040|    318|
 1041|    318|                Ok(values)
 1042|    318|            }
 1043|    318|        }
 1044|    318|
 1045|    318|        let visitor = VecVisitor {
 1046|    318|            marker: PhantomData,
 1047|    318|        };
 1048|    318|        deserializer.deserialize_seq(visitor)
 1049|    318|    }
_RINvXsh_NtNtCssVaLrL3Upj_5serde2de5implsINtNtCs9pDt8l5wGDA_5alloc3vec3VecTNtNtBH_6string6StringINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEENtB8_11Deserialize11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECs7AwuCMXPzRZ_8fvm_fuzz:
 1013|    318|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
 1014|    318|    where
 1015|    318|        D: Deserializer<'de>,
 1016|    318|    {
 1017|    318|        struct VecVisitor<T> {
 1018|    318|            marker: PhantomData<T>,
 1019|    318|        }
 1020|    318|
 1021|    318|        impl<'de, T> Visitor<'de> for VecVisitor<T>
 1022|    318|        where
 1023|    318|            T: Deserialize<'de>,
 1024|    318|        {
 1025|    318|            type Value = Vec<T>;
 1026|    318|
 1027|    318|            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
 1028|    318|                formatter.write_str("a sequence")
 1029|    318|            }
 1030|    318|
 1031|    318|            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1032|    318|            where
 1033|    318|                A: SeqAccess<'de>,
 1034|    318|            {
 1035|    318|                let mut values = Vec::with_capacity(size_hint::cautious(seq.size_hint()));
 1036|    318|
 1037|    318|                while let Some(value) = try!(seq.next_element()) {
 1038|    318|                    values.push(value);
 1039|    318|                }
 1040|    318|
 1041|    318|                Ok(values)
 1042|    318|            }
 1043|    318|        }
 1044|    318|
 1045|    318|        let visitor = VecVisitor {
 1046|    318|            marker: PhantomData,
 1047|    318|        };
 1048|    318|        deserializer.deserialize_seq(visitor)
 1049|    318|    }
_RINvXs6_NtNtCssVaLrL3Upj_5serde2de5implsNtNtCs9pDt8l5wGDA_5alloc6string6StringNtB8_11Deserialize11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECs7AwuCMXPzRZ_8fvm_fuzz:
  582|  4.77k|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  583|  4.77k|    where
  584|  4.77k|        D: Deserializer<'de>,
  585|  4.77k|    {
  586|  4.77k|        deserializer.deserialize_string(StringVisitor)
  587|  4.77k|    }
_RINvXNvXsh_NtNtCssVaLrL3Upj_5serde2de5implsINtNtCs9pDt8l5wGDA_5alloc3vec3VecpENtBb_11Deserialize11deserializeINtB3_10VecVisitorTNtNtBK_6string6StringINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEENtBb_7Visitor9visit_seqINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECs7AwuCMXPzRZ_8fvm_fuzz:
 1031|    318|            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1032|    318|            where
 1033|    318|                A: SeqAccess<'de>,
 1034|    318|            {
 1035|    318|                let mut values = Vec::with_capacity(size_hint::cautious(seq.size_hint()));
 1036|       |
 1037|  5.08k|                while let Some(value) = try!(seq.next_element()) {
 1038|  4.77k|                    values.push(value);
 1039|  4.77k|                }
 1040|       |
 1041|    318|                Ok(values)
 1042|    318|            }
_RINvXNvXs2M_NtNtCssVaLrL3Upj_5serde2de5implsTppENtBc_11Deserialize11deserializeINtB3_12TupleVisitorNtNtCs9pDt8l5wGDA_5alloc6string6StringINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EENtBc_7Visitor9visit_seqINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECs7AwuCMXPzRZ_8fvm_fuzz:
 1277|  4.77k|                        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1278|  4.77k|                        where
 1279|  4.77k|                            A: SeqAccess<'de>,
 1280|  4.77k|                        {
 1281|       |                            $(
 1282|  4.77k|                                let $name = match try!(seq.next_element()) {
 1283|  4.77k|                                    Some(value) => value,
 1284|      0|                                    None => return Err(Error::invalid_length($n, &self)),
 1285|       |                                };
 1286|       |                            )+
 1287|       |
 1288|  4.77k|                            Ok(($($name,)+))
 1289|  4.77k|                        }
_RINvXs2M_NtNtCssVaLrL3Upj_5serde2de5implsTmINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EENtB9_11Deserialize11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECs7AwuCMXPzRZ_8fvm_fuzz:
 1260|    318|                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
 1261|    318|                where
 1262|    318|                    D: Deserializer<'de>,
 1263|    318|                {
 1264|    318|                    struct TupleVisitor<$($name,)+> {
 1265|    318|                        marker: PhantomData<($($name,)+)>,
 1266|    318|                    }
 1267|    318|
 1268|    318|                    impl<'de, $($name: Deserialize<'de>),+> Visitor<'de> for TupleVisitor<$($name,)+> {
 1269|    318|                        type Value = ($($name,)+);
 1270|    318|
 1271|    318|                        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
 1272|    318|                            formatter.write_str(concat!("a tuple of size ", $len))
 1273|    318|                        }
 1274|    318|
 1275|    318|                        #[inline]
 1276|    318|                        #[allow(non_snake_case)]
 1277|    318|                        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1278|    318|                        where
 1279|    318|                            A: SeqAccess<'de>,
 1280|    318|                        {
 1281|    318|                            $(
 1282|    318|                                let $name = match try!(seq.next_element()) {
 1283|    318|                                    Some(value) => value,
 1284|    318|                                    None => return Err(Error::invalid_length($n, &self)),
 1285|    318|                                };
 1286|    318|                            )+
 1287|    318|
 1288|    318|                            Ok(($($name,)+))
 1289|    318|                        }
 1290|    318|                    }
 1291|    318|
 1292|    318|                    deserializer.deserialize_tuple($len, TupleVisitor { marker: PhantomData })
 1293|    318|                }
_RINvXNvXsh_NtNtCssVaLrL3Upj_5serde2de5implsINtNtCs9pDt8l5wGDA_5alloc3vec3VecpENtBb_11Deserialize11deserializeINtB3_10VecVisitorINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EENtBb_7Visitor9visit_seqINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECs7AwuCMXPzRZ_8fvm_fuzz:
 1031|    318|            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
 1032|    318|            where
 1033|    318|                A: SeqAccess<'de>,
 1034|    318|            {
 1035|    318|                let mut values = Vec::with_capacity(size_hint::cautious(seq.size_hint()));
 1036|       |
 1037|    636|                while let Some(value) = try!(seq.next_element()) {
 1038|    318|                    values.push(value);
 1039|    318|                }
 1040|       |
 1041|    318|                Ok(values)
 1042|    318|            }
_RINvXsX_NtNtCssVaLrL3Upj_5serde2de5implsyNtB8_11Deserialize11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECs7AwuCMXPzRZ_8fvm_fuzz:
  113|    318|            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  114|    318|            where
  115|    318|                D: Deserializer<'de>,
  116|    318|            {
  117|    318|                struct PrimitiveVisitor;
  118|    318|
  119|    318|                impl<'de> Visitor<'de> for PrimitiveVisitor {
  120|    318|                    type Value = $primitive;
  121|    318|
  122|    318|                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
  123|    318|                        formatter.write_str(stringify!($primitive))
  124|    318|                    }
  125|    318|
  126|    318|                    $($($method!($val : $visit);)*)*
  127|    318|                }
  128|    318|
  129|    318|                deserializer.$deserialize(PrimitiveVisitor)
  130|    318|            }
_RINvXNvXsX_NtNtCssVaLrL3Upj_5serde2de5implsyNtBb_11Deserialize11deserializeNtB3_16PrimitiveVisitorNtBb_7Visitor9visit_u64INtNtCshf5gyM0YXBy_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsiloedr2K6v7_4core7convert10InfallibleEECs7AwuCMXPzRZ_8fvm_fuzz:
  138|    318|        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>
  139|    318|        where
  140|    318|            E: Error,
  141|    318|        {
  142|    318|            Ok(v)
  143|    318|        }

_RINvXs3_NtCssVaLrL3Upj_5serde2deINtNtCsiloedr2K6v7_4core6marker11PhantomDatayENtB6_15DeserializeSeed11deserializeNtNtCs3TS9n28v4Rl_12libipld_core4ipld4IpldECsboUdcTbF1FS_15direct_syscalls:
  788|    954|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    954|    where
  790|    954|        D: Deserializer<'de>,
  791|    954|    {
  792|    954|        T::deserialize(deserializer)
  793|    954|    }
_RINvXs3_NtCssVaLrL3Upj_5serde2deINtNtCsiloedr2K6v7_4core6marker11PhantomDataNtNtCs83Z8YCK0meJ_10fvm_shared4econ11TokenAmountENtB6_15DeserializeSeed11deserializeNtNtCs3TS9n28v4Rl_12libipld_core4ipld4IpldECsboUdcTbF1FS_15direct_syscalls:
  788|    954|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    954|    where
  790|    954|        D: Deserializer<'de>,
  791|    954|    {
  792|    954|        T::deserialize(deserializer)
  793|    954|    }
_RINvXs4_NtCssVaLrL3Upj_5serde2deQNtNtNtCs3TS9n28v4Rl_12libipld_core5serde2de15SeqDeserializerNtB6_9SeqAccess12next_elementNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateECsboUdcTbF1FS_15direct_syscalls:
 1757|    954|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1758|    954|    where
 1759|    954|        T: Deserialize<'de>,
 1760|    954|    {
 1761|    954|        (**self).next_element()
 1762|    954|    }
_RINvXs4_NtCssVaLrL3Upj_5serde2deQNtNtNtCs3TS9n28v4Rl_12libipld_core5serde2de15SeqDeserializerNtB6_9SeqAccess12next_elementyECsboUdcTbF1FS_15direct_syscalls:
 1757|    954|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1758|    954|    where
 1759|    954|        T: Deserialize<'de>,
 1760|    954|    {
 1761|    954|        (**self).next_element()
 1762|    954|    }
_RINvYINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de9SeqAccess12next_elementINtNtCslH3pn9Bu6yX_13fvm_ipld_hamt7pointer7PointerNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtB2C_14hash_algorithm6Sha256EECsboUdcTbF1FS_15direct_syscalls:
 1728|  1.27k|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|  1.27k|    where
 1730|  1.27k|        T: Deserialize<'de>,
 1731|  1.27k|    {
 1732|  1.27k|        self.next_element_seed(PhantomData)
 1733|  1.27k|    }
_RINvXs3_NtCssVaLrL3Upj_5serde2deINtNtCsiloedr2K6v7_4core6marker11PhantomDataINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EENtB6_15DeserializeSeed11deserializeNtNtCs3TS9n28v4Rl_12libipld_core4ipld4IpldECsboUdcTbF1FS_15direct_syscalls:
  788|  1.90k|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|  1.90k|    where
  790|  1.90k|        D: Deserializer<'de>,
  791|  1.90k|    {
  792|  1.90k|        T::deserialize(deserializer)
  793|  1.90k|    }
_RINvXs3_NtCssVaLrL3Upj_5serde2deINtNtCsiloedr2K6v7_4core6marker11PhantomDataNtNtCs9pDt8l5wGDA_5alloc6string6StringENtB6_15DeserializeSeed11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECsboUdcTbF1FS_15direct_syscalls:
  788|  4.77k|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|  4.77k|    where
  790|  4.77k|        D: Deserializer<'de>,
  791|  4.77k|    {
  792|  4.77k|        T::deserialize(deserializer)
  793|  4.77k|    }
_RINvYNtNtNtCs3TS9n28v4Rl_12libipld_core5serde2de15SeqDeserializerNtNtCssVaLrL3Upj_5serde2de9SeqAccess12next_elementyECsboUdcTbF1FS_15direct_syscalls:
 1728|    954|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|    954|    where
 1730|    954|        T: Deserialize<'de>,
 1731|    954|    {
 1732|    954|        self.next_element_seed(PhantomData)
 1733|    954|    }
_RINvXs3_NtCssVaLrL3Upj_5serde2deINtNtCsiloedr2K6v7_4core6marker11PhantomDataNtNtCslH3pn9Bu6yX_13fvm_ipld_hamt8bitfield8BitfieldENtB6_15DeserializeSeed11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECsboUdcTbF1FS_15direct_syscalls:
  788|    318|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    318|    where
  790|    318|        D: Deserializer<'de>,
  791|    318|    {
  792|    318|        T::deserialize(deserializer)
  793|    318|    }
_RINvXs3_NtCssVaLrL3Upj_5serde2deINtNtCsiloedr2K6v7_4core6marker11PhantomDataNtNtCs3TS9n28v4Rl_12libipld_core4ipld4IpldENtB6_15DeserializeSeed11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECsboUdcTbF1FS_15direct_syscalls:
  788|  7.63k|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|  7.63k|    where
  790|  7.63k|        D: Deserializer<'de>,
  791|  7.63k|    {
  792|  7.63k|        T::deserialize(deserializer)
  793|  7.63k|    }
_RNvXs4_NtCssVaLrL3Upj_5serde2deQNtNtNtCs3TS9n28v4Rl_12libipld_core5serde2de15SeqDeserializerNtB5_9SeqAccess9size_hintCsboUdcTbF1FS_15direct_syscalls:
 1765|    954|    fn size_hint(&self) -> Option<usize> {
 1766|    954|        (**self).size_hint()
 1767|    954|    }
_RINvYINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de9SeqAccess12next_elementNtNtCs83Z8YCK0meJ_10fvm_shared5state16StateTreeVersionECsboUdcTbF1FS_15direct_syscalls:
 1728|    318|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|    318|    where
 1730|    318|        T: Deserialize<'de>,
 1731|    318|    {
 1732|    318|        self.next_element_seed(PhantomData)
 1733|    318|    }
_RINvXs4_NtCssVaLrL3Upj_5serde2deQNtNtNtCs3TS9n28v4Rl_12libipld_core5serde2de15SeqDeserializerNtB6_9SeqAccess12next_elementINtNtCsiloedr2K6v7_4core6option6OptionNtNtCs83Z8YCK0meJ_10fvm_shared7address7AddressEECsboUdcTbF1FS_15direct_syscalls:
 1757|    954|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1758|    954|    where
 1759|    954|        T: Deserialize<'de>,
 1760|    954|    {
 1761|    954|        (**self).next_element()
 1762|    954|    }
_RINvYINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de9SeqAccess12next_elementINtNtCs9pDt8l5wGDA_5alloc3vec3VecINtNtCslH3pn9Bu6yX_13fvm_ipld_hamt7pointer7PointerNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtB39_14hash_algorithm6Sha256EEECsboUdcTbF1FS_15direct_syscalls:
 1728|    318|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|    318|    where
 1730|    318|        T: Deserialize<'de>,
 1731|    318|    {
 1732|    318|        self.next_element_seed(PhantomData)
 1733|    318|    }
_RINvYNtNtNtCs3TS9n28v4Rl_12libipld_core5serde2de15SeqDeserializerNtNtCssVaLrL3Upj_5serde2de9SeqAccess12next_elementNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyECsboUdcTbF1FS_15direct_syscalls:
 1728|    954|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|    954|    where
 1730|    954|        T: Deserialize<'de>,
 1731|    954|    {
 1732|    954|        self.next_element_seed(PhantomData)
 1733|    954|    }
_RINvYNtNtNtCssVaLrL3Upj_5serde2de5impls13StringVisitorNtB7_7Visitor18visit_borrowed_strINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsiloedr2K6v7_4core7convert10InfallibleEECsboUdcTbF1FS_15direct_syscalls:
 1509|  4.77k|    fn visit_borrowed_str<E>(self, v: &'de str) -> Result<Self::Value, E>
 1510|  4.77k|    where
 1511|  4.77k|        E: Error,
 1512|  4.77k|    {
 1513|  4.77k|        self.visit_str(v)
 1514|  4.77k|    }
_RINvYINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de9SeqAccess12next_elementNtNtCs3TS9n28v4Rl_12libipld_core4ipld4IpldECsboUdcTbF1FS_15direct_syscalls:
 1728|  10.4k|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|  10.4k|    where
 1730|  10.4k|        T: Deserialize<'de>,
 1731|  10.4k|    {
 1732|  10.4k|        self.next_element_seed(PhantomData)
 1733|  10.4k|    }
_RINvXs4_NtCssVaLrL3Upj_5serde2deQNtNtNtCs3TS9n28v4Rl_12libipld_core5serde2de15SeqDeserializerNtB6_9SeqAccess12next_elementINtCslH3pn9Bu6yX_13fvm_ipld_hamt12KeyValuePairNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateEECsboUdcTbF1FS_15direct_syscalls:
 1757|  1.90k|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1758|  1.90k|    where
 1759|  1.90k|        T: Deserialize<'de>,
 1760|  1.90k|    {
 1761|  1.90k|        (**self).next_element()
 1762|  1.90k|    }
_RINvXs3_NtCssVaLrL3Upj_5serde2deINtNtCsiloedr2K6v7_4core6marker11PhantomDatamENtB6_15DeserializeSeed11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECsboUdcTbF1FS_15direct_syscalls:
  788|    318|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    318|    where
  790|    318|        D: Deserializer<'de>,
  791|    318|    {
  792|    318|        T::deserialize(deserializer)
  793|    318|    }
_RINvXs3_NtCssVaLrL3Upj_5serde2deINtNtCsiloedr2K6v7_4core6marker11PhantomDataINtNtCs9pDt8l5wGDA_5alloc3vec3VecINtNtCslH3pn9Bu6yX_13fvm_ipld_hamt7pointer7PointerNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtB1O_14hash_algorithm6Sha256EEENtB6_15DeserializeSeed11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECsboUdcTbF1FS_15direct_syscalls:
  788|    318|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    318|    where
  790|    318|        D: Deserializer<'de>,
  791|    318|    {
  792|    318|        T::deserialize(deserializer)
  793|    318|    }
_RINvYINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de9SeqAccess12next_elementmECsboUdcTbF1FS_15direct_syscalls:
 1728|    318|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|    318|    where
 1730|    318|        T: Deserialize<'de>,
 1731|    318|    {
 1732|    318|        self.next_element_seed(PhantomData)
 1733|    318|    }
_RINvYNtNvXs_NtNtCsgVlqBW3KcNx_17fvm_ipld_encoding5bytes12strict_bytesINtNtCs9pDt8l5wGDA_5alloc3vec3VechENtBa_11Deserialize11deserialize10VecVisitorNtNtCssVaLrL3Upj_5serde2de7Visitor20visit_borrowed_bytesINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsiloedr2K6v7_4core7convert10InfallibleEECsboUdcTbF1FS_15direct_syscalls:
 1568|    318|    fn visit_borrowed_bytes<E>(self, v: &'de [u8]) -> Result<Self::Value, E>
 1569|    318|    where
 1570|    318|        E: Error,
 1571|    318|    {
 1572|    318|        self.visit_bytes(v)
 1573|    318|    }
_RINvYNtNtNtCs3TS9n28v4Rl_12libipld_core5serde2de15SeqDeserializerNtNtCssVaLrL3Upj_5serde2de9SeqAccess12next_elementINtNtCsiloedr2K6v7_4core6option6OptionNtNtCs83Z8YCK0meJ_10fvm_shared7address7AddressEECsboUdcTbF1FS_15direct_syscalls:
 1728|    954|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|    954|    where
 1730|    954|        T: Deserialize<'de>,
 1731|    954|    {
 1732|    954|        self.next_element_seed(PhantomData)
 1733|    954|    }
_RINvYINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de9SeqAccess12next_elementNtNtCs9pDt8l5wGDA_5alloc6string6StringECsboUdcTbF1FS_15direct_syscalls:
 1728|  4.77k|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|  4.77k|    where
 1730|  4.77k|        T: Deserialize<'de>,
 1731|  4.77k|    {
 1732|  4.77k|        self.next_element_seed(PhantomData)
 1733|  4.77k|    }
_RINvXs3_NtCssVaLrL3Upj_5serde2deINtNtCsiloedr2K6v7_4core6marker11PhantomDataNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateENtB6_15DeserializeSeed11deserializeNtNtCs3TS9n28v4Rl_12libipld_core4ipld4IpldECsboUdcTbF1FS_15direct_syscalls:
  788|    954|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    954|    where
  790|    954|        D: Deserializer<'de>,
  791|    954|    {
  792|    954|        T::deserialize(deserializer)
  793|    954|    }
_RINvYNtNvXNtNtCs3TS9n28v4Rl_12libipld_core5serde2deNtNtBc_4ipld4IpldNtNtCssVaLrL3Upj_5serde2de11Deserialize11deserialize11IpldVisitorNtB16_7Visitor20visit_borrowed_bytesINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsiloedr2K6v7_4core7convert10InfallibleEECsboUdcTbF1FS_15direct_syscalls:
 1568|  1.90k|    fn visit_borrowed_bytes<E>(self, v: &'de [u8]) -> Result<Self::Value, E>
 1569|  1.90k|    where
 1570|  1.90k|        E: Error,
 1571|  1.90k|    {
 1572|  1.90k|        self.visit_bytes(v)
 1573|  1.90k|    }
_RINvXs3_NtCssVaLrL3Upj_5serde2deINtNtCsiloedr2K6v7_4core6marker11PhantomDataINtCslH3pn9Bu6yX_13fvm_ipld_hamt12KeyValuePairNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateEENtB6_15DeserializeSeed11deserializeNtNtCs3TS9n28v4Rl_12libipld_core4ipld4IpldECsboUdcTbF1FS_15direct_syscalls:
  788|    954|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    954|    where
  790|    954|        D: Deserializer<'de>,
  791|    954|    {
  792|    954|        T::deserialize(deserializer)
  793|    954|    }
_RINvYINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de9SeqAccess12next_elementTNtNtCs9pDt8l5wGDA_5alloc6string6StringINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEECsboUdcTbF1FS_15direct_syscalls:
 1728|  5.08k|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|  5.08k|    where
 1730|  5.08k|        T: Deserialize<'de>,
 1731|  5.08k|    {
 1732|  5.08k|        self.next_element_seed(PhantomData)
 1733|  5.08k|    }
_RINvXs3_NtCssVaLrL3Upj_5serde2deINtNtCsiloedr2K6v7_4core6marker11PhantomDataINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EENtB6_15DeserializeSeed11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECsboUdcTbF1FS_15direct_syscalls:
  788|  5.72k|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|  5.72k|    where
  790|  5.72k|        D: Deserializer<'de>,
  791|  5.72k|    {
  792|  5.72k|        T::deserialize(deserializer)
  793|  5.72k|    }
_RINvYNtNtNtCs3TS9n28v4Rl_12libipld_core5serde2de15SeqDeserializerNtNtCssVaLrL3Upj_5serde2de9SeqAccess12next_elementINtCslH3pn9Bu6yX_13fvm_ipld_hamt12KeyValuePairNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateEECsboUdcTbF1FS_15direct_syscalls:
 1728|  1.90k|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|  1.90k|    where
 1730|  1.90k|        T: Deserialize<'de>,
 1731|  1.90k|    {
 1732|  1.90k|        self.next_element_seed(PhantomData)
 1733|  1.90k|    }
_RINvXs4_NtCssVaLrL3Upj_5serde2deQNtNtNtCs3TS9n28v4Rl_12libipld_core5serde2de15SeqDeserializerNtB6_9SeqAccess12next_elementNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyECsboUdcTbF1FS_15direct_syscalls:
 1757|    954|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1758|    954|    where
 1759|    954|        T: Deserialize<'de>,
 1760|    954|    {
 1761|    954|        (**self).next_element()
 1762|    954|    }
_RINvXs4_NtCssVaLrL3Upj_5serde2deQNtNtNtCs3TS9n28v4Rl_12libipld_core5serde2de15SeqDeserializerNtB6_9SeqAccess12next_elementNtNtCs83Z8YCK0meJ_10fvm_shared4econ11TokenAmountECsboUdcTbF1FS_15direct_syscalls:
 1757|    954|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1758|    954|    where
 1759|    954|        T: Deserialize<'de>,
 1760|    954|    {
 1761|    954|        (**self).next_element()
 1762|    954|    }
_RINvXs3_NtCssVaLrL3Upj_5serde2deINtNtCsiloedr2K6v7_4core6marker11PhantomDataTNtNtCs9pDt8l5wGDA_5alloc6string6StringINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEENtB6_15DeserializeSeed11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECsboUdcTbF1FS_15direct_syscalls:
  788|  4.77k|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|  4.77k|    where
  790|  4.77k|        D: Deserializer<'de>,
  791|  4.77k|    {
  792|  4.77k|        T::deserialize(deserializer)
  793|  4.77k|    }
_RINvXs3_NtCssVaLrL3Upj_5serde2deINtNtCsiloedr2K6v7_4core6marker11PhantomDataNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyENtB6_15DeserializeSeed11deserializeNtNtCs3TS9n28v4Rl_12libipld_core4ipld4IpldECsboUdcTbF1FS_15direct_syscalls:
  788|    954|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    954|    where
  790|    954|        D: Deserializer<'de>,
  791|    954|    {
  792|    954|        T::deserialize(deserializer)
  793|    954|    }
_RINvYNtNtCsl4cFeht4Yol_3cid5serde17BytesToCidVisitorNtNtCssVaLrL3Upj_5serde2de7Visitor20visit_borrowed_bytesINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsiloedr2K6v7_4core7convert10InfallibleEECsboUdcTbF1FS_15direct_syscalls:
 1568|  7.63k|    fn visit_borrowed_bytes<E>(self, v: &'de [u8]) -> Result<Self::Value, E>
 1569|  7.63k|    where
 1570|  7.63k|        E: Error,
 1571|  7.63k|    {
 1572|  7.63k|        self.visit_bytes(v)
 1573|  7.63k|    }
_RINvYNtNtNtCs3TS9n28v4Rl_12libipld_core5serde2de15SeqDeserializerNtNtCssVaLrL3Upj_5serde2de9SeqAccess12next_elementNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateECsboUdcTbF1FS_15direct_syscalls:
 1728|    954|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|    954|    where
 1730|    954|        T: Deserialize<'de>,
 1731|    954|    {
 1732|    954|        self.next_element_seed(PhantomData)
 1733|    954|    }
_RINvYNtNtNtCs3TS9n28v4Rl_12libipld_core5serde2de15SeqDeserializerNtNtCssVaLrL3Upj_5serde2de9SeqAccess12next_elementNtNtCs83Z8YCK0meJ_10fvm_shared4econ11TokenAmountECsboUdcTbF1FS_15direct_syscalls:
 1728|    954|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|    954|    where
 1730|    954|        T: Deserialize<'de>,
 1731|    954|    {
 1732|    954|        self.next_element_seed(PhantomData)
 1733|    954|    }
_RINvXs3_NtCssVaLrL3Upj_5serde2deINtNtCsiloedr2K6v7_4core6marker11PhantomDataINtNtBz_6option6OptionNtNtCs83Z8YCK0meJ_10fvm_shared7address7AddressEENtB6_15DeserializeSeed11deserializeNtNtCs3TS9n28v4Rl_12libipld_core4ipld4IpldECsboUdcTbF1FS_15direct_syscalls:
  788|    954|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    954|    where
  790|    954|        D: Deserializer<'de>,
  791|    954|    {
  792|    954|        T::deserialize(deserializer)
  793|    954|    }
_RINvYNtNtNtCs3TS9n28v4Rl_12libipld_core5serde2de15SeqDeserializerNtNtCssVaLrL3Upj_5serde2de9SeqAccess12next_elementINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EECsboUdcTbF1FS_15direct_syscalls:
 1728|  1.90k|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|  1.90k|    where
 1730|  1.90k|        T: Deserialize<'de>,
 1731|  1.90k|    {
 1732|  1.90k|        self.next_element_seed(PhantomData)
 1733|  1.90k|    }
_RINvYINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de9SeqAccess12next_elementINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EECsboUdcTbF1FS_15direct_syscalls:
 1728|  5.72k|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|  5.72k|    where
 1730|  5.72k|        T: Deserialize<'de>,
 1731|  5.72k|    {
 1732|  5.72k|        self.next_element_seed(PhantomData)
 1733|  5.72k|    }
_RINvXs3_NtCssVaLrL3Upj_5serde2deINtNtCsiloedr2K6v7_4core6marker11PhantomDataINtNtCslH3pn9Bu6yX_13fvm_ipld_hamt7pointer7PointerNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtB1h_14hash_algorithm6Sha256EENtB6_15DeserializeSeed11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECsboUdcTbF1FS_15direct_syscalls:
  788|    954|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    954|    where
  790|    954|        D: Deserializer<'de>,
  791|    954|    {
  792|    954|        T::deserialize(deserializer)
  793|    954|    }
_RINvXs4_NtCssVaLrL3Upj_5serde2deQNtNtNtCs3TS9n28v4Rl_12libipld_core5serde2de15SeqDeserializerNtB6_9SeqAccess12next_elementINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EECsboUdcTbF1FS_15direct_syscalls:
 1757|  1.90k|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1758|  1.90k|    where
 1759|  1.90k|        T: Deserialize<'de>,
 1760|  1.90k|    {
 1761|  1.90k|        (**self).next_element()
 1762|  1.90k|    }
_RINvYINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de9SeqAccess12next_elementNtNtCslH3pn9Bu6yX_13fvm_ipld_hamt8bitfield8BitfieldECsboUdcTbF1FS_15direct_syscalls:
 1728|    318|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|    318|    where
 1730|    318|        T: Deserialize<'de>,
 1731|    318|    {
 1732|    318|        self.next_element_seed(PhantomData)
 1733|    318|    }
_RINvXs3_NtCssVaLrL3Upj_5serde2deINtNtCsiloedr2K6v7_4core6marker11PhantomDataNtNtCs83Z8YCK0meJ_10fvm_shared5state16StateTreeVersionENtB6_15DeserializeSeed11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECsboUdcTbF1FS_15direct_syscalls:
  788|    318|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    318|    where
  790|    318|        D: Deserializer<'de>,
  791|    318|    {
  792|    318|        T::deserialize(deserializer)
  793|    318|    }
_RINvYINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de9SeqAccess12next_elementTNtNtCs9pDt8l5wGDA_5alloc6string6StringINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEECs7AwuCMXPzRZ_8fvm_fuzz:
 1728|  5.08k|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|  5.08k|    where
 1730|  5.08k|        T: Deserialize<'de>,
 1731|  5.08k|    {
 1732|  5.08k|        self.next_element_seed(PhantomData)
 1733|  5.08k|    }
_RINvXs3_NtCssVaLrL3Upj_5serde2deINtNtCsiloedr2K6v7_4core6marker11PhantomDatamENtB6_15DeserializeSeed11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECs7AwuCMXPzRZ_8fvm_fuzz:
  788|    318|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    318|    where
  790|    318|        D: Deserializer<'de>,
  791|    318|    {
  792|    318|        T::deserialize(deserializer)
  793|    318|    }
_RINvXs3_NtCssVaLrL3Upj_5serde2deINtNtCsiloedr2K6v7_4core6marker11PhantomDataINtNtCs9pDt8l5wGDA_5alloc3vec3VecINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEENtB6_15DeserializeSeed11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECs7AwuCMXPzRZ_8fvm_fuzz:
  788|    318|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    318|    where
  790|    318|        D: Deserializer<'de>,
  791|    318|    {
  792|    318|        T::deserialize(deserializer)
  793|    318|    }
_RINvXs3_NtCssVaLrL3Upj_5serde2deINtNtCsiloedr2K6v7_4core6marker11PhantomDataTNtNtCs9pDt8l5wGDA_5alloc6string6StringINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEENtB6_15DeserializeSeed11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECs7AwuCMXPzRZ_8fvm_fuzz:
  788|  4.77k|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|  4.77k|    where
  790|  4.77k|        D: Deserializer<'de>,
  791|  4.77k|    {
  792|  4.77k|        T::deserialize(deserializer)
  793|  4.77k|    }
_RINvYINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de9SeqAccess12next_elementINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EECs7AwuCMXPzRZ_8fvm_fuzz:
 1728|  5.72k|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|  5.72k|    where
 1730|  5.72k|        T: Deserialize<'de>,
 1731|  5.72k|    {
 1732|  5.72k|        self.next_element_seed(PhantomData)
 1733|  5.72k|    }
_RINvXs3_NtCssVaLrL3Upj_5serde2deINtNtCsiloedr2K6v7_4core6marker11PhantomDatayENtB6_15DeserializeSeed11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECs7AwuCMXPzRZ_8fvm_fuzz:
  788|    318|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    318|    where
  790|    318|        D: Deserializer<'de>,
  791|    318|    {
  792|    318|        T::deserialize(deserializer)
  793|    318|    }
_RINvYNtNvXNvCs7wiLZqa2F25_12fvm_ipld_cars_1__NtBa_9CarHeaderNtNtCssVaLrL3Upj_5serde2de11Deserialize11deserialize14___FieldVisitorNtBY_7Visitor18visit_borrowed_strINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsiloedr2K6v7_4core7convert10InfallibleEECs7AwuCMXPzRZ_8fvm_fuzz:
 1509|    636|    fn visit_borrowed_str<E>(self, v: &'de str) -> Result<Self::Value, E>
 1510|    636|    where
 1511|    636|        E: Error,
 1512|    636|    {
 1513|    636|        self.visit_str(v)
 1514|    636|    }
_RINvYINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de9SeqAccess12next_elementmECs7AwuCMXPzRZ_8fvm_fuzz:
 1728|    318|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|    318|    where
 1730|    318|        T: Deserialize<'de>,
 1731|    318|    {
 1732|    318|        self.next_element_seed(PhantomData)
 1733|    318|    }
_RINvXs3_NtCssVaLrL3Upj_5serde2deINtNtCsiloedr2K6v7_4core6marker11PhantomDataNtNtCs9pDt8l5wGDA_5alloc6string6StringENtB6_15DeserializeSeed11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECs7AwuCMXPzRZ_8fvm_fuzz:
  788|  4.77k|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|  4.77k|    where
  790|  4.77k|        D: Deserializer<'de>,
  791|  4.77k|    {
  792|  4.77k|        T::deserialize(deserializer)
  793|  4.77k|    }
_RINvYINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de9MapAccess10next_valueINtNtCs9pDt8l5wGDA_5alloc3vec3VecINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEECs7AwuCMXPzRZ_8fvm_fuzz:
 1867|    318|    fn next_value<V>(&mut self) -> Result<V, Self::Error>
 1868|    318|    where
 1869|    318|        V: Deserialize<'de>,
 1870|    318|    {
 1871|    318|        self.next_value_seed(PhantomData)
 1872|    318|    }
_RINvYINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de9MapAccess10next_valueyECs7AwuCMXPzRZ_8fvm_fuzz:
 1867|    318|    fn next_value<V>(&mut self) -> Result<V, Self::Error>
 1868|    318|    where
 1869|    318|        V: Deserialize<'de>,
 1870|    318|    {
 1871|    318|        self.next_value_seed(PhantomData)
 1872|    318|    }
_RINvXs3_NtCssVaLrL3Upj_5serde2deINtNtCsiloedr2K6v7_4core6marker11PhantomDataNtNvXNvCs7wiLZqa2F25_12fvm_ipld_cars_1__NtB1j_9CarHeaderNtB6_11Deserialize11deserialize7___FieldENtB6_15DeserializeSeed11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECs7AwuCMXPzRZ_8fvm_fuzz:
  788|    636|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|    636|    where
  790|    636|        D: Deserializer<'de>,
  791|    636|    {
  792|    636|        T::deserialize(deserializer)
  793|    636|    }
_RINvYNtNtCsl4cFeht4Yol_3cid5serde17BytesToCidVisitorNtNtCssVaLrL3Upj_5serde2de7Visitor20visit_borrowed_bytesINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsiloedr2K6v7_4core7convert10InfallibleEECs7AwuCMXPzRZ_8fvm_fuzz:
 1568|  5.40k|    fn visit_borrowed_bytes<E>(self, v: &'de [u8]) -> Result<Self::Value, E>
 1569|  5.40k|    where
 1570|  5.40k|        E: Error,
 1571|  5.40k|    {
 1572|  5.40k|        self.visit_bytes(v)
 1573|  5.40k|    }
_RINvYNtNtNtCssVaLrL3Upj_5serde2de5impls13StringVisitorNtB7_7Visitor18visit_borrowed_strINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsiloedr2K6v7_4core7convert10InfallibleEECs7AwuCMXPzRZ_8fvm_fuzz:
 1509|  4.77k|    fn visit_borrowed_str<E>(self, v: &'de str) -> Result<Self::Value, E>
 1510|  4.77k|    where
 1511|  4.77k|        E: Error,
 1512|  4.77k|    {
 1513|  4.77k|        self.visit_str(v)
 1514|  4.77k|    }
_RINvYINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de9MapAccess8next_keyNtNvXNvCs7wiLZqa2F25_12fvm_ipld_cars_1__NtB2z_9CarHeaderNtB1L_11Deserialize11deserialize7___FieldECs7AwuCMXPzRZ_8fvm_fuzz:
 1850|    954|    fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>
 1851|    954|    where
 1852|    954|        K: Deserialize<'de>,
 1853|    954|    {
 1854|    954|        self.next_key_seed(PhantomData)
 1855|    954|    }
_RINvXs3_NtCssVaLrL3Upj_5serde2deINtNtCsiloedr2K6v7_4core6marker11PhantomDataINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EENtB6_15DeserializeSeed11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECs7AwuCMXPzRZ_8fvm_fuzz:
  788|  5.40k|    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>
  789|  5.40k|    where
  790|  5.40k|        D: Deserializer<'de>,
  791|  5.40k|    {
  792|  5.40k|        T::deserialize(deserializer)
  793|  5.40k|    }
_RINvYINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de9SeqAccess12next_elementNtNtCs9pDt8l5wGDA_5alloc6string6StringECs7AwuCMXPzRZ_8fvm_fuzz:
 1728|  4.77k|    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>
 1729|  4.77k|    where
 1730|  4.77k|        T: Deserialize<'de>,
 1731|  4.77k|    {
 1732|  4.77k|        self.next_element_seed(PhantomData)
 1733|  4.77k|    }

_RNvNtNtCssVaLrL3Upj_5serde9___private9size_hint8cautious:
   12|  2.22k|pub fn cautious(hint: Option<usize>) -> usize {
   13|  2.22k|    cmp::min(hint.unwrap_or(0), 4096)
   14|  2.22k|}

_RINvXsG_NtNtCssVaLrL3Upj_5serde3ser5implsyNtB8_9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECsboUdcTbF1FS_15direct_syscalls:
   11|  1.27k|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   12|  1.27k|            where
   13|  1.27k|                S: Serializer,
   14|  1.27k|            {
   15|  1.27k|                serializer.$method(*self $($cast)*)
   16|  1.27k|            }
_RINvXs1G_NtNtCssVaLrL3Upj_5serde3ser5implsRyNtB9_9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECsboUdcTbF1FS_15direct_syscalls:
  386|    954|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|    954|            where
  388|    954|                S: Serializer,
  389|    954|            {
  390|    954|                (**self).serialize(serializer)
  391|    954|            }
_RINvXs3_NtNtCssVaLrL3Upj_5serde3ser5implsINtNtCsiloedr2K6v7_4core6option6OptionNtNtCs83Z8YCK0meJ_10fvm_shared7address7AddressENtB8_9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECsboUdcTbF1FS_15direct_syscalls:
  104|    954|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  105|    954|    where
  106|    954|        S: Serializer,
  107|    954|    {
  108|    954|        match *self {
  109|      0|            Some(ref value) => serializer.serialize_some(value),
  110|    954|            None => serializer.serialize_none(),
  111|       |        }
  112|    954|    }
_RINvXs1G_NtNtCssVaLrL3Upj_5serde3ser5implsRINtNtCslH3pn9Bu6yX_13fvm_ipld_hamt7pointer7PointerNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtBK_14hash_algorithm6Sha256ENtB9_9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECsboUdcTbF1FS_15direct_syscalls:
  386|    954|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|    954|            where
  388|    954|                S: Serializer,
  389|    954|            {
  390|    954|                (**self).serialize(serializer)
  391|    954|            }
_RINvXs1G_NtNtCssVaLrL3Upj_5serde3ser5implsRINtNtCs9pDt8l5wGDA_5alloc3vec3VecINtNtCslH3pn9Bu6yX_13fvm_ipld_hamt7pointer7PointerNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtB1h_14hash_algorithm6Sha256EENtB9_9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECsboUdcTbF1FS_15direct_syscalls:
  386|    318|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|    318|            where
  388|    318|                S: Serializer,
  389|    318|            {
  390|    318|                (**self).serialize(serializer)
  391|    318|            }
_RINvXs1G_NtNtCssVaLrL3Upj_5serde3ser5implsRINtCslH3pn9Bu6yX_13fvm_ipld_hamt12KeyValuePairNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateENtB9_9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECsboUdcTbF1FS_15direct_syscalls:
  386|    954|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|    954|            where
  388|    954|                S: Serializer,
  389|    954|            {
  390|    954|                (**self).serialize(serializer)
  391|    954|            }
_RINvXs1m_NtNtCssVaLrL3Upj_5serde3ser5implsINtNtCs9pDt8l5wGDA_5alloc3vec3VecINtNtCslH3pn9Bu6yX_13fvm_ipld_hamt7pointer7PointerNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtB1g_14hash_algorithm6Sha256EENtB9_9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECsboUdcTbF1FS_15direct_syscalls:
  194|    318|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  195|    318|            where
  196|    318|                S: Serializer,
  197|    318|            {
  198|    318|                serializer.collect_seq(self)
  199|    318|            }
_RINvXs1G_NtNtCssVaLrL3Upj_5serde3ser5implsRNtNtCslH3pn9Bu6yX_13fvm_ipld_hamt8bitfield8BitfieldNtB9_9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECsboUdcTbF1FS_15direct_syscalls:
  386|    318|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|    318|            where
  388|    318|                S: Serializer,
  389|    318|            {
  390|    318|                (**self).serialize(serializer)
  391|    318|            }
_RINvXs1G_NtNtCssVaLrL3Upj_5serde3ser5implsRINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_ENtB9_9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECsboUdcTbF1FS_15direct_syscalls:
  386|  2.54k|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|  2.54k|            where
  388|  2.54k|                S: Serializer,
  389|  2.54k|            {
  390|  2.54k|                (**self).serialize(serializer)
  391|  2.54k|            }
_RINvXs1G_NtNtCssVaLrL3Upj_5serde3ser5implsRNtNtCs83Z8YCK0meJ_10fvm_shared5state16StateTreeVersionNtB9_9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECsboUdcTbF1FS_15direct_syscalls:
  386|    318|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|    318|            where
  388|    318|                S: Serializer,
  389|    318|            {
  390|    318|                (**self).serialize(serializer)
  391|    318|            }
_RINvXs1G_NtNtCssVaLrL3Upj_5serde3ser5implsRNtNtCs83Z8YCK0meJ_10fvm_shared4econ11TokenAmountNtB9_9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECsboUdcTbF1FS_15direct_syscalls:
  386|    954|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|    954|            where
  388|    954|                S: Serializer,
  389|    954|            {
  390|    954|                (**self).serialize(serializer)
  391|    954|            }
_RINvXs1m_NtNtCssVaLrL3Upj_5serde3ser5implsINtNtCs9pDt8l5wGDA_5alloc3vec3VecINtCslH3pn9Bu6yX_13fvm_ipld_hamt12KeyValuePairNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateEENtB9_9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECsboUdcTbF1FS_15direct_syscalls:
  194|    954|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  195|    954|            where
  196|    954|                S: Serializer,
  197|    954|            {
  198|    954|                serializer.collect_seq(self)
  199|    954|            }
_RINvXs1p_NtNtCssVaLrL3Upj_5serde3ser5implsTRNtNtCslH3pn9Bu6yX_13fvm_ipld_hamt8bitfield8BitfieldRINtNtCs9pDt8l5wGDA_5alloc3vec3VecINtNtBK_7pointer7PointerNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtBK_14hash_algorithm6Sha256EEENtB9_9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECsboUdcTbF1FS_15direct_syscalls:
  314|    318|                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  315|    318|                where
  316|    318|                    S: Serializer,
  317|    318|                {
  318|    318|                    let mut tuple = try!(serializer.serialize_tuple($len));
  319|       |                    $(
  320|    318|                        try!(tuple.serialize_element(&self.$n));
  321|       |                    )+
  322|    318|                    tuple.end()
  323|    318|                }
_RINvXs1G_NtNtCssVaLrL3Upj_5serde3ser5implsRINtNtCsiloedr2K6v7_4core6option6OptionNtNtCs83Z8YCK0meJ_10fvm_shared7address7AddressENtB9_9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECsboUdcTbF1FS_15direct_syscalls:
  386|    954|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|    954|            where
  388|    954|                S: Serializer,
  389|    954|            {
  390|    954|                (**self).serialize(serializer)
  391|    954|            }
_RINvXs1G_NtNtCssVaLrL3Upj_5serde3ser5implsRINtNtCs9pDt8l5wGDA_5alloc3vec3VecINtNtCslH3pn9Bu6yX_13fvm_ipld_hamt7pointer7PointerNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtBK_6string6StringNtNtB1h_14hash_algorithm6Sha256EENtB9_9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECs7AwuCMXPzRZ_8fvm_fuzz:
  386|    318|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|    318|            where
  388|    318|                S: Serializer,
  389|    318|            {
  390|    318|                (**self).serialize(serializer)
  391|    318|            }
_RINvXsG_NtNtCssVaLrL3Upj_5serde3ser5implsyNtB8_9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECs7AwuCMXPzRZ_8fvm_fuzz:
   11|    318|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   12|    318|            where
   13|    318|                S: Serializer,
   14|    318|            {
   15|    318|                serializer.$method(*self $($cast)*)
   16|    318|            }
_RINvXs5_NtNtCssVaLrL3Upj_5serde3ser5implsAuj0_NtB8_9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECs7AwuCMXPzRZ_8fvm_fuzz:
  132|    636|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  133|    636|    where
  134|    636|        S: Serializer,
  135|    636|    {
  136|    636|        try!(serializer.serialize_tuple(0)).end()
  137|    636|    }
_RINvXs1G_NtNtCssVaLrL3Upj_5serde3ser5implsRNtNtCslH3pn9Bu6yX_13fvm_ipld_hamt8bitfield8BitfieldNtB9_9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECs7AwuCMXPzRZ_8fvm_fuzz:
  386|    318|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|    318|            where
  388|    318|                S: Serializer,
  389|    318|            {
  390|    318|                (**self).serialize(serializer)
  391|    318|            }
_RINvXs1p_NtNtCssVaLrL3Upj_5serde3ser5implsTRNtNtCslH3pn9Bu6yX_13fvm_ipld_hamt8bitfield8BitfieldRINtNtCs9pDt8l5wGDA_5alloc3vec3VecINtNtBK_7pointer7PointerNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtB1B_6string6StringNtNtBK_14hash_algorithm6Sha256EEENtB9_9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECs7AwuCMXPzRZ_8fvm_fuzz:
  314|    318|                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  315|    318|                where
  316|    318|                    S: Serializer,
  317|    318|                {
  318|    318|                    let mut tuple = try!(serializer.serialize_tuple($len));
  319|       |                    $(
  320|    318|                        try!(tuple.serialize_element(&self.$n));
  321|       |                    )+
  322|    318|                    tuple.end()
  323|    318|                }
_RINvXs1G_NtNtCssVaLrL3Upj_5serde3ser5implsRINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_ENtB9_9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECs7AwuCMXPzRZ_8fvm_fuzz:
  386|    636|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|    636|            where
  388|    636|                S: Serializer,
  389|    636|            {
  390|    636|                (**self).serialize(serializer)
  391|    636|            }
_RINvXs1G_NtNtCssVaLrL3Upj_5serde3ser5implsRyNtB9_9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECs7AwuCMXPzRZ_8fvm_fuzz:
  386|    318|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|    318|            where
  388|    318|                S: Serializer,
  389|    318|            {
  390|    318|                (**self).serialize(serializer)
  391|    318|            }
_RINvXs1m_NtNtCssVaLrL3Upj_5serde3ser5implsINtNtCs9pDt8l5wGDA_5alloc3vec3VecINtNtCslH3pn9Bu6yX_13fvm_ipld_hamt7pointer7PointerNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtBJ_6string6StringNtNtB1g_14hash_algorithm6Sha256EENtB9_9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECs7AwuCMXPzRZ_8fvm_fuzz:
  194|    318|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  195|    318|            where
  196|    318|                S: Serializer,
  197|    318|            {
  198|    318|                serializer.collect_seq(self)
  199|    318|            }
_RINvXs1G_NtNtCssVaLrL3Upj_5serde3ser5implsRNtNtCs9pDt8l5wGDA_5alloc6string6StringNtB9_9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECs7AwuCMXPzRZ_8fvm_fuzz:
  386|    318|            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  387|    318|            where
  388|    318|                S: Serializer,
  389|    318|            {
  390|    318|                (**self).serialize(serializer)
  391|    318|            }
_RINvXs_NtNtCssVaLrL3Upj_5serde3ser5implsNtNtCs9pDt8l5wGDA_5alloc6string6StringNtB7_9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECs7AwuCMXPzRZ_8fvm_fuzz:
   56|    318|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   57|    318|    where
   58|    318|        S: Serializer,
   59|    318|    {
   60|    318|        serializer.serialize_str(self)
   61|    318|    }

_RNCINvYQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser10Serializer11collect_seqRINtNtCs9pDt8l5wGDA_5alloc3vec3VecINtCslH3pn9Bu6yX_13fvm_ipld_hamt12KeyValuePairNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateEEE0CsboUdcTbF1FS_15direct_syscalls:
 1286|    954|            try!(iter.try_for_each(|item| serializer.serialize_element(&item)));
_RINvYQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser10Serializer11collect_seqRINtNtCs9pDt8l5wGDA_5alloc3vec3VecINtNtCslH3pn9Bu6yX_13fvm_ipld_hamt7pointer7PointerNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtB3e_14hash_algorithm6Sha256EEECsboUdcTbF1FS_15direct_syscalls:
 1275|    318|    fn collect_seq<I>(self, iter: I) -> Result<Self::Ok, Self::Error>
 1276|    318|    where
 1277|    318|        I: IntoIterator,
 1278|    318|        <I as IntoIterator>::Item: Serialize,
 1279|    318|    {
 1280|    318|        let iter = iter.into_iter();
 1281|    318|        let mut serializer = try!(self.serialize_seq(iterator_len_hint(&iter)));
 1282|       |
 1283|       |        #[cfg(not(no_iterator_try_fold))]
 1284|       |        {
 1285|    318|            let mut iter = iter;
 1286|    318|            try!(iter.try_for_each(|item| serializer.serialize_element(&item)));
 1287|       |        }
 1288|       |
 1289|       |        #[cfg(no_iterator_try_fold)]
 1290|       |        {
 1291|       |            for item in iter {
 1292|       |                try!(serializer.serialize_element(&item));
 1293|       |            }
 1294|       |        }
 1295|       |
 1296|    318|        serializer.end()
 1297|    318|    }
_RINvNtCssVaLrL3Upj_5serde3ser17iterator_len_hintINtNtNtCsiloedr2K6v7_4core5slice4iter4IterINtCslH3pn9Bu6yX_13fvm_ipld_hamt12KeyValuePairNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateEEECsboUdcTbF1FS_15direct_syscalls:
 1982|    954|    match iter.size_hint() {
 1983|    954|        (lo, Some(hi)) if lo == hi => Some(lo),
 1984|      0|        _ => None,
 1985|       |    }
 1986|    954|}
_RINvNtCssVaLrL3Upj_5serde3ser17iterator_len_hintINtNtNtCsiloedr2K6v7_4core5slice4iter4IterINtNtCslH3pn9Bu6yX_13fvm_ipld_hamt7pointer7PointerNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtB1v_14hash_algorithm6Sha256EEECsboUdcTbF1FS_15direct_syscalls:
 1982|    318|    match iter.size_hint() {
 1983|    318|        (lo, Some(hi)) if lo == hi => Some(lo),
 1984|      0|        _ => None,
 1985|       |    }
 1986|    318|}
_RNCINvYQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser10Serializer11collect_seqRINtNtCs9pDt8l5wGDA_5alloc3vec3VecINtNtCslH3pn9Bu6yX_13fvm_ipld_hamt7pointer7PointerNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtB3g_14hash_algorithm6Sha256EEE0CsboUdcTbF1FS_15direct_syscalls:
 1286|    954|            try!(iter.try_for_each(|item| serializer.serialize_element(&item)));
_RINvYQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser10Serializer11collect_seqRINtNtCs9pDt8l5wGDA_5alloc3vec3VecINtCslH3pn9Bu6yX_13fvm_ipld_hamt12KeyValuePairNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateEEECsboUdcTbF1FS_15direct_syscalls:
 1275|    954|    fn collect_seq<I>(self, iter: I) -> Result<Self::Ok, Self::Error>
 1276|    954|    where
 1277|    954|        I: IntoIterator,
 1278|    954|        <I as IntoIterator>::Item: Serialize,
 1279|    954|    {
 1280|    954|        let iter = iter.into_iter();
 1281|    954|        let mut serializer = try!(self.serialize_seq(iterator_len_hint(&iter)));
 1282|       |
 1283|       |        #[cfg(not(no_iterator_try_fold))]
 1284|       |        {
 1285|    954|            let mut iter = iter;
 1286|    954|            try!(iter.try_for_each(|item| serializer.serialize_element(&item)));
 1287|       |        }
 1288|       |
 1289|       |        #[cfg(no_iterator_try_fold)]
 1290|       |        {
 1291|       |            for item in iter {
 1292|       |                try!(serializer.serialize_element(&item));
 1293|       |            }
 1294|       |        }
 1295|       |
 1296|    954|        serializer.end()
 1297|    954|    }
_RINvNtCssVaLrL3Upj_5serde3ser17iterator_len_hintINtNtNtCsiloedr2K6v7_4core5slice4iter4IterINtNtCslH3pn9Bu6yX_13fvm_ipld_hamt7pointer7PointerNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCs9pDt8l5wGDA_5alloc6string6StringNtNtB1v_14hash_algorithm6Sha256EEECs7AwuCMXPzRZ_8fvm_fuzz:
 1982|    318|    match iter.size_hint() {
 1983|    318|        (lo, Some(hi)) if lo == hi => Some(lo),
 1984|      0|        _ => None,
 1985|       |    }
 1986|    318|}
_RINvYQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser10Serializer11collect_seqRINtNtCs9pDt8l5wGDA_5alloc3vec3VecINtNtCslH3pn9Bu6yX_13fvm_ipld_hamt7pointer7PointerNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtB2H_6string6StringNtNtB3e_14hash_algorithm6Sha256EEECs7AwuCMXPzRZ_8fvm_fuzz:
 1275|    318|    fn collect_seq<I>(self, iter: I) -> Result<Self::Ok, Self::Error>
 1276|    318|    where
 1277|    318|        I: IntoIterator,
 1278|    318|        <I as IntoIterator>::Item: Serialize,
 1279|    318|    {
 1280|    318|        let iter = iter.into_iter();
 1281|    318|        let mut serializer = try!(self.serialize_seq(iterator_len_hint(&iter)));
 1282|       |
 1283|       |        #[cfg(not(no_iterator_try_fold))]
 1284|       |        {
 1285|    318|            let mut iter = iter;
 1286|    318|            try!(iter.try_for_each(|item| serializer.serialize_element(&item)));
 1287|       |        }
 1288|       |
 1289|       |        #[cfg(no_iterator_try_fold)]
 1290|       |        {
 1291|       |            for item in iter {
 1292|       |                try!(serializer.serialize_element(&item));
 1293|       |            }
 1294|       |        }
 1295|       |
 1296|    318|        serializer.end()
 1297|    318|    }

_RINvXsc_NtCshzAOHAhpLd9_11serde_bytes7bytebufNtB6_7ByteBufNtNtCssVaLrL3Upj_5serde3ser9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser13CidSerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECsboUdcTbF1FS_15direct_syscalls:
  186|  2.54k|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  187|  2.54k|    where
  188|  2.54k|        S: Serializer,
  189|  2.54k|    {
  190|  2.54k|        serializer.serialize_bytes(&self.bytes)
  191|  2.54k|    }
_RINvMNtCshzAOHAhpLd9_11serde_bytes7bytebufNtB3_7ByteBuf4fromINtNtCs9pDt8l5wGDA_5alloc3vec3VechEECsboUdcTbF1FS_15direct_syscalls:
   60|  2.54k|    pub fn from<T: Into<Vec<u8>>>(bytes: T) -> Self {
   61|  2.54k|        ByteBuf {
   62|  2.54k|            bytes: bytes.into(),
   63|  2.54k|        }
   64|  2.54k|    }
_RINvXsc_NtCshzAOHAhpLd9_11serde_bytes7bytebufNtB6_7ByteBufNtNtCssVaLrL3Upj_5serde3ser9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser13CidSerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECs7AwuCMXPzRZ_8fvm_fuzz:
  186|    636|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  187|    636|    where
  188|    636|        S: Serializer,
  189|    636|    {
  190|    636|        serializer.serialize_bytes(&self.bytes)
  191|    636|    }
_RINvMNtCshzAOHAhpLd9_11serde_bytes7bytebufNtB3_7ByteBuf4fromINtNtCs9pDt8l5wGDA_5alloc3vec3VechEECs7AwuCMXPzRZ_8fvm_fuzz:
   60|    636|    pub fn from<T: Into<Vec<u8>>>(bytes: T) -> Self {
   61|    636|        ByteBuf {
   62|    636|            bytes: bytes.into(),
   63|    636|        }
   64|    636|    }

_RINvNtCshf5gyM0YXBy_18serde_ipld_dagcbor14cbor4ii_nonpub8peek_oneNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderECsboUdcTbF1FS_15direct_syscalls:
   26|  17.4k|pub(crate) fn peek_one<'a, R: dec::Read<'a>>(reader: &mut R) -> Result<u8, DecodeError<R::Error>> {
   27|  17.4k|    let buf = match reader.fill(1)? {
   28|  17.4k|        dec::Reference::Long(buf) => buf,
   29|      0|        dec::Reference::Short(buf) => buf,
   30|       |    };
   31|  17.4k|    let byte = buf.get(0).copied().ok_or(DecodeError::Eof)?;
   32|  16.2k|    Ok(byte)
   33|  17.4k|}
_RINvNtCshf5gyM0YXBy_18serde_ipld_dagcbor14cbor4ii_nonpub8peek_oneNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderECs7AwuCMXPzRZ_8fvm_fuzz:
   26|  6.36k|pub(crate) fn peek_one<'a, R: dec::Read<'a>>(reader: &mut R) -> Result<u8, DecodeError<R::Error>> {
   27|  6.36k|    let buf = match reader.fill(1)? {
   28|  6.36k|        dec::Reference::Long(buf) => buf,
   29|      0|        dec::Reference::Short(buf) => buf,
   30|       |    };
   31|  6.36k|    let byte = buf.get(0).copied().ok_or(DecodeError::Eof)?;
   32|  5.40k|    Ok(byte)
   33|  6.36k|}

_RNCNvMs_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deINtB6_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderE8try_step0CsboUdcTbF1FS_15direct_syscalls:
  106|  17.8k|            Ok(scopeguard::guard(self, |de| de.reader.step_out()))
_RNvMs_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deINtB4_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderE8try_stepCsboUdcTbF1FS_15direct_syscalls:
  101|  17.8k|    fn try_step<'a>(
  102|  17.8k|        &'a mut self,
  103|  17.8k|    ) -> Result<scopeguard::ScopeGuard<&'a mut Self, fn(&'a mut Self) -> ()>, DecodeError<R::Error>>
  104|  17.8k|    {
  105|  17.8k|        if self.reader.step_in() {
  106|  17.8k|            Ok(scopeguard::guard(self, |de| de.reader.step_out()))
  107|       |        } else {
  108|      0|            Err(DecodeError::DepthLimit)
  109|       |        }
  110|  17.8k|    }
_RINvXs0_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de12Deserializer15deserialize_seqNtNvXNtNtCs3TS9n28v4Rl_12libipld_core5serde2deNtNtB2Z_4ipld4IpldNtB1X_11Deserialize11deserialize11IpldVisitorECsboUdcTbF1FS_15direct_syscalls:
  334|  2.86k|    fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  335|  2.86k|    where
  336|  2.86k|        V: Visitor<'de>,
  337|  2.86k|    {
  338|  2.86k|        let mut de = self.try_step()?;
  339|  2.86k|        let seq = Accessor::array(&mut de)?;
  340|  2.86k|        visitor.visit_seq(seq)
  341|  2.86k|    }
_RINvXs2_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de9SeqAccess17next_element_seedINtNtCsiloedr2K6v7_4core6marker11PhantomDatamEECsboUdcTbF1FS_15direct_syscalls:
  484|    318|        if let Some(len) = self.len.as_mut() {
  485|    318|            if *len > 0 {
  486|    318|                *len -= 1;
  487|    318|                Ok(Some(seed.deserialize(&mut *self.de)?))
  488|       |            } else {
  489|      0|                Ok(None)
  490|       |            }
  491|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  492|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  493|       |        } else {
  494|      0|            self.de.reader.advance(1);
  495|      0|            Ok(None)
  496|       |        }
  497|    318|    }
_RINvNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de10from_sliceTmINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEECsboUdcTbF1FS_15direct_syscalls:
   40|    318|pub fn from_slice<'a, T>(buf: &'a [u8]) -> Result<T, DecodeError<Infallible>>
   41|    318|where
   42|    318|    T: de::Deserialize<'a>,
   43|    318|{
   44|    318|    let reader = SliceReader::new(buf);
   45|    318|    let mut deserializer = Deserializer::from_reader(reader);
   46|    318|    let value = serde::Deserialize::deserialize(&mut deserializer)?;
   47|    318|    deserializer.end()?;
   48|    318|    Ok(value)
   49|    318|}
_RINvXs2_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de9SeqAccess17next_element_seedINtNtCsiloedr2K6v7_4core6marker11PhantomDataNtNtCs83Z8YCK0meJ_10fvm_shared5state16StateTreeVersionEECsboUdcTbF1FS_15direct_syscalls:
  484|    318|        if let Some(len) = self.len.as_mut() {
  485|    318|            if *len > 0 {
  486|    318|                *len -= 1;
  487|    318|                Ok(Some(seed.deserialize(&mut *self.de)?))
  488|       |            } else {
  489|      0|                Ok(None)
  490|       |            }
  491|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  492|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  493|       |        } else {
  494|      0|            self.de.reader.advance(1);
  495|      0|            Ok(None)
  496|       |        }
  497|    318|    }
_RNvMs1_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deINtB5_8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderE5arrayCsboUdcTbF1FS_15direct_syscalls:
  434|  3.49k|    pub fn array(de: &'a mut Deserializer<R>) -> Result<Accessor<'a, R>, DecodeError<R::Error>> {
  435|  3.49k|        let array_start = dec::ArrayStart::decode(&mut de.reader)?;
  436|  3.49k|        Ok(Accessor {
  437|  3.49k|            de,
  438|  3.49k|            len: array_start.0,
  439|  3.49k|        })
  440|  3.49k|    }
_RINvXs0_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de12Deserializer17deserialize_bytesNtNvXNtNtCs3TS9n28v4Rl_12libipld_core5serde2deNtNtB31_4ipld4IpldNtB1X_11Deserialize11deserialize11IpldVisitorECsboUdcTbF1FS_15direct_syscalls:
  228|  1.90k|    fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  229|  1.90k|    where
  230|  1.90k|        V: Visitor<'de>,
  231|  1.90k|    {
  232|  1.90k|        match <types::Bytes<Cow<[u8]>>>::decode(&mut self.reader)?.0 {
  233|  1.90k|            Cow::Borrowed(buf) => visitor.visit_borrowed_bytes(buf),
  234|      0|            Cow::Owned(buf) => visitor.visit_byte_buf(buf),
  235|       |        }
  236|  1.90k|    }
_RINvXs0_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de12Deserializer17deserialize_bytesNtNvXs_NtNtCsgVlqBW3KcNx_17fvm_ipld_encoding5bytes12strict_bytesINtNtCs9pDt8l5wGDA_5alloc3vec3VechENtB2Z_11Deserialize11deserialize10VecVisitorECsboUdcTbF1FS_15direct_syscalls:
  228|    318|    fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  229|    318|    where
  230|    318|        V: Visitor<'de>,
  231|    318|    {
  232|    318|        match <types::Bytes<Cow<[u8]>>>::decode(&mut self.reader)?.0 {
  233|    318|            Cow::Borrowed(buf) => visitor.visit_borrowed_bytes(buf),
  234|      0|            Cow::Owned(buf) => visitor.visit_byte_buf(buf),
  235|       |        }
  236|    318|    }
_RINvXs2_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de9SeqAccess17next_element_seedINtNtCsiloedr2K6v7_4core6marker11PhantomDataINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEECsboUdcTbF1FS_15direct_syscalls:
  484|  5.72k|        if let Some(len) = self.len.as_mut() {
  485|  5.72k|            if *len > 0 {
  486|  5.72k|                *len -= 1;
  487|  5.72k|                Ok(Some(seed.deserialize(&mut *self.de)?))
  488|       |            } else {
  489|      0|                Ok(None)
  490|       |            }
  491|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  492|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  493|       |        } else {
  494|      0|            self.de.reader.advance(1);
  495|      0|            Ok(None)
  496|       |        }
  497|  5.72k|    }
_RNvMs1_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deINtB5_8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderE5tupleCsboUdcTbF1FS_15direct_syscalls:
  443|  5.72k|    pub fn tuple(
  444|  5.72k|        de: &'a mut Deserializer<R>,
  445|  5.72k|        len: usize,
  446|  5.72k|    ) -> Result<Accessor<'a, R>, DecodeError<R::Error>> {
  447|  5.72k|        let array_start = dec::ArrayStart::decode(&mut de.reader)?;
  448|       |
  449|  5.72k|        if array_start.0 == Some(len) {
  450|  5.72k|            Ok(Accessor {
  451|  5.72k|                de,
  452|  5.72k|                len: array_start.0,
  453|  5.72k|            })
  454|       |        } else {
  455|      0|            Err(DecodeError::RequireLength {
  456|      0|                name: "tuple",
  457|      0|                expect: len,
  458|      0|                value: array_start.0.unwrap_or(0),
  459|      0|            })
  460|       |        }
  461|  5.72k|    }
_RINvNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de10from_sliceNtNtCs83Z8YCK0meJ_10fvm_shared5state9StateRootECsboUdcTbF1FS_15direct_syscalls:
   40|    318|pub fn from_slice<'a, T>(buf: &'a [u8]) -> Result<T, DecodeError<Infallible>>
   41|    318|where
   42|    318|    T: de::Deserialize<'a>,
   43|    318|{
   44|    318|    let reader = SliceReader::new(buf);
   45|    318|    let mut deserializer = Deserializer::from_reader(reader);
   46|    318|    let value = serde::Deserialize::deserialize(&mut deserializer)?;
   47|    318|    deserializer.end()?;
   48|    318|    Ok(value)
   49|    318|}
_RINvXs0_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de12Deserializer15deserialize_u64NtNvXNtNtCs3TS9n28v4Rl_12libipld_core5serde2deNtNtB2Z_4ipld4IpldNtB1X_11Deserialize11deserialize11IpldVisitorECsboUdcTbF1FS_15direct_syscalls:
  142|    954|        fn $name<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  143|    954|        where V: Visitor<'de>
  144|    954|        {
  145|    954|            let value = <$t>::decode(&mut self.reader)?;
  146|    954|            visitor.$visit(value)
  147|    954|        }
_RINvXs0_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de12Deserializer15deserialize_u32NtNvXsV_NtB1X_5implsmNtB1X_11Deserialize11deserialize16PrimitiveVisitorECsboUdcTbF1FS_15direct_syscalls:
  142|    318|        fn $name<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  143|    318|        where V: Visitor<'de>
  144|    318|        {
  145|    318|            let value = <$t>::decode(&mut self.reader)?;
  146|    318|            visitor.$visit(value)
  147|    318|        }
_RINvXs0_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de12Deserializer20deserialize_byte_bufNtNvXs_NtNtCsgVlqBW3KcNx_17fvm_ipld_encoding5bytes12strict_bytesINtNtCs9pDt8l5wGDA_5alloc3vec3VechENtB32_11Deserialize11deserialize10VecVisitorECsboUdcTbF1FS_15direct_syscalls:
  239|    318|    fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  240|    318|    where
  241|    318|        V: Visitor<'de>,
  242|    318|    {
  243|    318|        self.deserialize_bytes(visitor)
  244|    318|    }
_RINvNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de10from_sliceINtNtCs9pDt8l5wGDA_5alloc3vec3VecTNtNtBW_6string6StringINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEEECsboUdcTbF1FS_15direct_syscalls:
   40|    318|pub fn from_slice<'a, T>(buf: &'a [u8]) -> Result<T, DecodeError<Infallible>>
   41|    318|where
   42|    318|    T: de::Deserialize<'a>,
   43|    318|{
   44|    318|    let reader = SliceReader::new(buf);
   45|    318|    let mut deserializer = Deserializer::from_reader(reader);
   46|    318|    let value = serde::Deserialize::deserialize(&mut deserializer)?;
   47|    318|    deserializer.end()?;
   48|    318|    Ok(value)
   49|    318|}
_RINvXs2_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de9SeqAccess17next_element_seedINtNtCsiloedr2K6v7_4core6marker11PhantomDataTNtNtCs9pDt8l5wGDA_5alloc6string6StringINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEEECsboUdcTbF1FS_15direct_syscalls:
  484|  5.08k|        if let Some(len) = self.len.as_mut() {
  485|  5.08k|            if *len > 0 {
  486|  4.77k|                *len -= 1;
  487|  4.77k|                Ok(Some(seed.deserialize(&mut *self.de)?))
  488|       |            } else {
  489|    318|                Ok(None)
  490|       |            }
  491|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  492|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  493|       |        } else {
  494|      0|            self.de.reader.advance(1);
  495|      0|            Ok(None)
  496|       |        }
  497|  5.08k|    }
_RINvNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de10from_sliceINtNtCslH3pn9Bu6yX_13fvm_ipld_hamt4node4NodeNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtBW_14hash_algorithm6Sha256EECsboUdcTbF1FS_15direct_syscalls:
   40|    318|pub fn from_slice<'a, T>(buf: &'a [u8]) -> Result<T, DecodeError<Infallible>>
   41|    318|where
   42|    318|    T: de::Deserialize<'a>,
   43|    318|{
   44|    318|    let reader = SliceReader::new(buf);
   45|    318|    let mut deserializer = Deserializer::from_reader(reader);
   46|    318|    let value = serde::Deserialize::deserialize(&mut deserializer)?;
   47|    318|    deserializer.end()?;
   48|    318|    Ok(value)
   49|    318|}
_RINvXs7_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deQINtB6_15CidDeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de12Deserializer17deserialize_bytesNtNtCsl4cFeht4Yol_3cid5serde17BytesToCidVisitorECsboUdcTbF1FS_15direct_syscalls:
  646|  7.63k|    fn deserialize_bytes<V: de::Visitor<'de>>(self, visitor: V) -> Result<V::Value, Self::Error> {
  647|  7.63k|        let byte = peek_one(&mut self.0.reader)?;
  648|  7.63k|        match dec::if_major(byte) {
  649|       |            major::BYTES => {
  650|       |                // CBOR encoded CIDs have a zero byte prefix we have to remove.
  651|  7.63k|                match <types::Bytes<Cow<[u8]>>>::decode(&mut self.0.reader)?.0 {
  652|  7.63k|                    Cow::Borrowed(buf) => {
  653|  7.63k|                        if buf.len() <= 1 || buf[0] != 0 {
  654|      0|                            Err(DecodeError::Msg("Invalid CID".into()))
  655|       |                        } else {
  656|  7.63k|                            visitor.visit_borrowed_bytes(&buf[1..])
  657|       |                        }
  658|       |                    }
  659|      0|                    Cow::Owned(mut buf) => {
  660|      0|                        if buf.len() <= 1 || buf[0] != 0 {
  661|      0|                            Err(DecodeError::Msg("Invalid CID".into()))
  662|       |                        } else {
  663|      0|                            buf.remove(0);
  664|      0|                            visitor.visit_byte_buf(buf)
  665|       |                        }
  666|       |                    }
  667|       |                }
  668|       |            }
  669|      0|            _ => Err(DecodeError::Unsupported { byte }),
  670|       |        }
  671|  7.63k|    }
_RINvXs0_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de12Deserializer15deserialize_anyNtNvXNtNtCs3TS9n28v4Rl_12libipld_core5serde2deNtNtB2Z_4ipld4IpldNtB1X_11Deserialize11deserialize11IpldVisitorECsboUdcTbF1FS_15direct_syscalls:
  159|  8.58k|    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  160|  8.58k|    where
  161|  8.58k|        V: Visitor<'de>,
  162|  8.58k|    {
  163|  8.58k|        let mut de = self.try_step()?;
  164|  8.58k|        let de = &mut *de;
  165|       |
  166|  8.58k|        let byte = peek_one(&mut de.reader)?;
  167|  8.58k|        match dec::if_major(byte) {
  168|    954|            major::UNSIGNED => de.deserialize_u64(visitor),
  169|      0|            major::NEGATIVE => de.deserialize_i64(visitor),
  170|  1.90k|            major::BYTES => de.deserialize_byte_buf(visitor),
  171|      0|            major::STRING => de.deserialize_string(visitor),
  172|  2.86k|            major::ARRAY => de.deserialize_seq(visitor),
  173|      0|            major::MAP => de.deserialize_map(visitor),
  174|       |            // The only supported tag is tag 42 (CID).
  175|  1.90k|            major::TAG => de.deserialize_cid(visitor),
  176|    954|            major::SIMPLE => match byte {
  177|       |                marker::FALSE => {
  178|      0|                    de.reader.advance(1);
  179|      0|                    visitor.visit_bool(false)
  180|       |                }
  181|       |                marker::TRUE => {
  182|      0|                    de.reader.advance(1);
  183|      0|                    visitor.visit_bool(true)
  184|       |                }
  185|       |                marker::NULL | marker::UNDEFINED => {
  186|    954|                    de.reader.advance(1);
  187|    954|                    visitor.visit_none()
  188|       |                }
  189|      0|                marker::F32 => de.deserialize_f32(visitor),
  190|      0|                marker::F64 => de.deserialize_f64(visitor),
  191|      0|                _ => Err(DecodeError::Unsupported { byte }),
  192|       |            },
  193|      0|            _ => Err(DecodeError::Unsupported { byte }),
  194|       |        }
  195|  8.58k|    }
_RINvXs2_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de9SeqAccess17next_element_seedINtNtCsiloedr2K6v7_4core6marker11PhantomDataINtNtCs9pDt8l5wGDA_5alloc3vec3VecINtNtCslH3pn9Bu6yX_13fvm_ipld_hamt7pointer7PointerNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtB42_14hash_algorithm6Sha256EEEECsboUdcTbF1FS_15direct_syscalls:
  484|    318|        if let Some(len) = self.len.as_mut() {
  485|    318|            if *len > 0 {
  486|    318|                *len -= 1;
  487|    318|                Ok(Some(seed.deserialize(&mut *self.de)?))
  488|       |            } else {
  489|      0|                Ok(None)
  490|       |            }
  491|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  492|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  493|       |        } else {
  494|      0|            self.de.reader.advance(1);
  495|      0|            Ok(None)
  496|       |        }
  497|    318|    }
_RNvMs_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deINtB4_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderE3endCsboUdcTbF1FS_15direct_syscalls:
  131|  1.27k|        match peek_one(&mut self.reader) {
  132|      0|            Ok(_) => Err(DecodeError::TrailingData),
  133|  1.27k|            Err(DecodeError::Eof) => Ok(()),
  134|      0|            Err(error) => Err(error),
  135|       |        }
  136|  1.27k|    }
_RINvMs_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deINtB5_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderE15deserialize_cidNtNvXNtNtCs3TS9n28v4Rl_12libipld_core5serde2deNtNtB2j_4ipld4IpldNtNtCssVaLrL3Upj_5serde2de11Deserialize11deserialize11IpldVisitorECsboUdcTbF1FS_15direct_syscalls:
  113|  1.90k|    fn deserialize_cid<V>(&mut self, visitor: V) -> Result<V::Value, DecodeError<R::Error>>
  114|  1.90k|    where
  115|  1.90k|        V: Visitor<'de>,
  116|  1.90k|    {
  117|  1.90k|        let tag = dec::TagStart::decode(&mut self.reader)?;
  118|       |
  119|  1.90k|        match tag.0 {
  120|  1.90k|            CBOR_TAGS_CID => visitor.visit_newtype_struct(&mut CidDeserializer(self)),
  121|      0|            _ => Err(DecodeError::TypeMismatch {
  122|      0|                name: "CBOR tag",
  123|      0|                byte: tag.0 as u8,
  124|      0|            }),
  125|       |        }
  126|  1.90k|    }
_RINvXs0_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de12Deserializer26deserialize_newtype_structINtNvXs0_NtCsl4cFeht4Yol_3cid5serdeINtNtB3c_3cid3CidKpENtB1X_11Deserialize11deserialize16MainEntryVisitorKj40_EECsboUdcTbF1FS_15direct_syscalls:
  318|  5.72k|    fn deserialize_newtype_struct<V>(
  319|  5.72k|        self,
  320|  5.72k|        name: &'static str,
  321|  5.72k|        visitor: V,
  322|  5.72k|    ) -> Result<V::Value, Self::Error>
  323|  5.72k|    where
  324|  5.72k|        V: Visitor<'de>,
  325|  5.72k|    {
  326|  5.72k|        if name == CID_SERDE_PRIVATE_IDENTIFIER {
  327|  5.72k|            self.deserialize_cid(visitor)
  328|       |        } else {
  329|      0|            visitor.visit_newtype_struct(self)
  330|       |        }
  331|  5.72k|    }
_RNvMNtCshf5gyM0YXBy_18serde_ipld_dagcbor2deINtB2_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderE11from_readerCsboUdcTbF1FS_15direct_syscalls:
   93|  1.27k|    pub fn from_reader(reader: R) -> Deserializer<R> {
   94|  1.27k|        Deserializer { reader }
   95|  1.27k|    }
_RINvXs0_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de12Deserializer17deserialize_tupleINtNvXs2M_NtB1X_5implsTppENtB1X_11Deserialize11deserialize12TupleVisitorNtNtCslH3pn9Bu6yX_13fvm_ipld_hamt8bitfield8BitfieldINtNtCs9pDt8l5wGDA_5alloc3vec3VecINtNtB46_7pointer7PointerNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtB46_14hash_algorithm6Sha256EEEECsboUdcTbF1FS_15direct_syscalls:
  344|    318|    fn deserialize_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>
  345|    318|    where
  346|    318|        V: Visitor<'de>,
  347|    318|    {
  348|    318|        let mut de = self.try_step()?;
  349|    318|        let seq = Accessor::tuple(&mut de, len)?;
  350|    318|        visitor.visit_seq(seq)
  351|    318|    }
_RINvXs0_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de12Deserializer24deserialize_tuple_structNtNvXNvNvXs9_NtCs83Z8YCK0meJ_10fvm_shared5stateNtB3c_9StateRootNtB1X_11Deserialize11deserialize1__NtB36_5InnerB40_11deserialize9___VisitorECsboUdcTbF1FS_15direct_syscalls:
  354|    318|    fn deserialize_tuple_struct<V>(
  355|    318|        self,
  356|    318|        _name: &'static str,
  357|    318|        len: usize,
  358|    318|        visitor: V,
  359|    318|    ) -> Result<V::Value, Self::Error>
  360|    318|    where
  361|    318|        V: Visitor<'de>,
  362|    318|    {
  363|    318|        self.deserialize_tuple(len, visitor)
  364|    318|    }
_RINvXs2_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de9SeqAccess17next_element_seedINtNtCsiloedr2K6v7_4core6marker11PhantomDataNtNtCslH3pn9Bu6yX_13fvm_ipld_hamt8bitfield8BitfieldEECsboUdcTbF1FS_15direct_syscalls:
  484|    318|        if let Some(len) = self.len.as_mut() {
  485|    318|            if *len > 0 {
  486|    318|                *len -= 1;
  487|    318|                Ok(Some(seed.deserialize(&mut *self.de)?))
  488|       |            } else {
  489|      0|                Ok(None)
  490|       |            }
  491|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  492|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  493|       |        } else {
  494|      0|            self.de.reader.advance(1);
  495|      0|            Ok(None)
  496|       |        }
  497|    318|    }
_RINvMs_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deINtB5_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderE15deserialize_cidINtNvXs0_NtCsl4cFeht4Yol_3cid5serdeINtNtB2l_3cid3CidKpENtNtCssVaLrL3Upj_5serde2de11Deserialize11deserialize16MainEntryVisitorKj40_EECsboUdcTbF1FS_15direct_syscalls:
  113|  5.72k|    fn deserialize_cid<V>(&mut self, visitor: V) -> Result<V::Value, DecodeError<R::Error>>
  114|  5.72k|    where
  115|  5.72k|        V: Visitor<'de>,
  116|  5.72k|    {
  117|  5.72k|        let tag = dec::TagStart::decode(&mut self.reader)?;
  118|       |
  119|  5.72k|        match tag.0 {
  120|  5.72k|            CBOR_TAGS_CID => visitor.visit_newtype_struct(&mut CidDeserializer(self)),
  121|      0|            _ => Err(DecodeError::TypeMismatch {
  122|      0|                name: "CBOR tag",
  123|      0|                byte: tag.0 as u8,
  124|      0|            }),
  125|       |        }
  126|  5.72k|    }
_RINvXs0_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de12Deserializer20deserialize_byte_bufNtNvXNtNtCs3TS9n28v4Rl_12libipld_core5serde2deNtNtB34_4ipld4IpldNtB1X_11Deserialize11deserialize11IpldVisitorECsboUdcTbF1FS_15direct_syscalls:
  239|  1.90k|    fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  240|  1.90k|    where
  241|  1.90k|        V: Visitor<'de>,
  242|  1.90k|    {
  243|  1.90k|        self.deserialize_bytes(visitor)
  244|  1.90k|    }
_RINvXs0_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de12Deserializer15deserialize_strNtNtB1X_5impls13StringVisitorECsboUdcTbF1FS_15direct_syscalls:
  252|  4.77k|        match <Cow<str>>::decode(&mut self.reader)? {
  253|  4.77k|            Cow::Borrowed(buf) => visitor.visit_borrowed_str(buf),
  254|      0|            Cow::Owned(buf) => visitor.visit_string(buf),
  255|       |        }
  256|       |
  257|       |        // Don't use this. This can lead to random panics and invalid CBOR.
  258|       |        #[cfg(feature = "_do_not_use_its_unsafe_and_invalid_cbor")]
  259|       |        match types::BadStr::<Cow<[u8]>>::decode(&mut self.reader)? {
  260|       |            types::BadStr(Cow::Borrowed(buf)) => {
  261|       |                visitor.visit_borrowed_str(unsafe { std::str::from_utf8_unchecked(buf) })
  262|       |            }
  263|       |            types::BadStr(Cow::Owned(buf)) => {
  264|       |                visitor.visit_string(unsafe { String::from_utf8_unchecked(buf) })
  265|       |            }
  266|       |        }
  267|  4.77k|    }
_RINvXs0_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de12Deserializer17deserialize_tupleINtNvXs2M_NtB1X_5implsTppENtB1X_11Deserialize11deserialize12TupleVisitormINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEECsboUdcTbF1FS_15direct_syscalls:
  344|    318|    fn deserialize_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>
  345|    318|    where
  346|    318|        V: Visitor<'de>,
  347|    318|    {
  348|    318|        let mut de = self.try_step()?;
  349|    318|        let seq = Accessor::tuple(&mut de, len)?;
  350|    318|        visitor.visit_seq(seq)
  351|    318|    }
_RINvXs0_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de12Deserializer15deserialize_u64NtNvXsX_NtB1X_5implsyNtB1X_11Deserialize11deserialize16PrimitiveVisitorECsboUdcTbF1FS_15direct_syscalls:
  142|    318|        fn $name<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  143|    318|        where V: Visitor<'de>
  144|    318|        {
  145|    318|            let value = <$t>::decode(&mut self.reader)?;
  146|    318|            visitor.$visit(value)
  147|    318|        }
_RINvXs0_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de12Deserializer17deserialize_tupleINtNvXs2M_NtB1X_5implsTppENtB1X_11Deserialize11deserialize12TupleVisitorNtNtCs9pDt8l5wGDA_5alloc6string6StringINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEECsboUdcTbF1FS_15direct_syscalls:
  344|  4.77k|    fn deserialize_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>
  345|  4.77k|    where
  346|  4.77k|        V: Visitor<'de>,
  347|  4.77k|    {
  348|  4.77k|        let mut de = self.try_step()?;
  349|  4.77k|        let seq = Accessor::tuple(&mut de, len)?;
  350|  4.77k|        visitor.visit_seq(seq)
  351|  4.77k|    }
_RINvXs0_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de12Deserializer15deserialize_seqINtNvXsh_NtB1X_5implsINtNtCs9pDt8l5wGDA_5alloc3vec3VecpENtB1X_11Deserialize11deserialize10VecVisitorINtNtCslH3pn9Bu6yX_13fvm_ipld_hamt7pointer7PointerNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtB4x_14hash_algorithm6Sha256EEECsboUdcTbF1FS_15direct_syscalls:
  334|    318|    fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  335|    318|    where
  336|    318|        V: Visitor<'de>,
  337|    318|    {
  338|    318|        let mut de = self.try_step()?;
  339|    318|        let seq = Accessor::array(&mut de)?;
  340|    318|        visitor.visit_seq(seq)
  341|    318|    }
_RINvXs0_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de12Deserializer17deserialize_tupleNtNvXNvNvXs9_NtCs83Z8YCK0meJ_10fvm_shared5stateNtB35_9StateRootNtB1X_11Deserialize11deserialize1__NtB2Z_5InnerB3T_11deserialize9___VisitorECsboUdcTbF1FS_15direct_syscalls:
  344|    318|    fn deserialize_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>
  345|    318|    where
  346|    318|        V: Visitor<'de>,
  347|    318|    {
  348|    318|        let mut de = self.try_step()?;
  349|    318|        let seq = Accessor::tuple(&mut de, len)?;
  350|    318|        visitor.visit_seq(seq)
  351|    318|    }
_RNvXs2_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deINtB5_8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de9SeqAccess9size_hintCsboUdcTbF1FS_15direct_syscalls:
  500|  3.49k|    fn size_hint(&self) -> Option<usize> {
  501|  3.49k|        self.len
  502|  3.49k|    }
_RINvXs0_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de12Deserializer18deserialize_stringNtNtB1X_5impls13StringVisitorECsboUdcTbF1FS_15direct_syscalls:
  270|  4.77k|    fn deserialize_string<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  271|  4.77k|    where
  272|  4.77k|        V: Visitor<'de>,
  273|  4.77k|    {
  274|  4.77k|        self.deserialize_str(visitor)
  275|  4.77k|    }
_RINvXs2_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de9SeqAccess17next_element_seedINtNtCsiloedr2K6v7_4core6marker11PhantomDataINtNtCslH3pn9Bu6yX_13fvm_ipld_hamt7pointer7PointerNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtB3v_14hash_algorithm6Sha256EEECsboUdcTbF1FS_15direct_syscalls:
  484|  1.27k|        if let Some(len) = self.len.as_mut() {
  485|  1.27k|            if *len > 0 {
  486|    954|                *len -= 1;
  487|    954|                Ok(Some(seed.deserialize(&mut *self.de)?))
  488|       |            } else {
  489|    318|                Ok(None)
  490|       |            }
  491|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  492|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  493|       |        } else {
  494|      0|            self.de.reader.advance(1);
  495|      0|            Ok(None)
  496|       |        }
  497|  1.27k|    }
_RINvXs0_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de12Deserializer15deserialize_seqINtNvXsh_NtB1X_5implsINtNtCs9pDt8l5wGDA_5alloc3vec3VecpENtB1X_11Deserialize11deserialize10VecVisitorTNtNtB3g_6string6StringINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEEECsboUdcTbF1FS_15direct_syscalls:
  334|    318|    fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  335|    318|    where
  336|    318|        V: Visitor<'de>,
  337|    318|    {
  338|    318|        let mut de = self.try_step()?;
  339|    318|        let seq = Accessor::array(&mut de)?;
  340|    318|        visitor.visit_seq(seq)
  341|    318|    }
_RINvXs2_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de9SeqAccess17next_element_seedINtNtCsiloedr2K6v7_4core6marker11PhantomDataNtNtCs3TS9n28v4Rl_12libipld_core4ipld4IpldEECsboUdcTbF1FS_15direct_syscalls:
  484|  10.4k|        if let Some(len) = self.len.as_mut() {
  485|  10.4k|            if *len > 0 {
  486|  7.63k|                *len -= 1;
  487|  7.63k|                Ok(Some(seed.deserialize(&mut *self.de)?))
  488|       |            } else {
  489|  2.86k|                Ok(None)
  490|       |            }
  491|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  492|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  493|       |        } else {
  494|      0|            self.de.reader.advance(1);
  495|      0|            Ok(None)
  496|       |        }
  497|  10.4k|    }
_RINvXs2_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de9SeqAccess17next_element_seedINtNtCsiloedr2K6v7_4core6marker11PhantomDataNtNtCs9pDt8l5wGDA_5alloc6string6StringEECsboUdcTbF1FS_15direct_syscalls:
  484|  4.77k|        if let Some(len) = self.len.as_mut() {
  485|  4.77k|            if *len > 0 {
  486|  4.77k|                *len -= 1;
  487|  4.77k|                Ok(Some(seed.deserialize(&mut *self.de)?))
  488|       |            } else {
  489|      0|                Ok(None)
  490|       |            }
  491|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  492|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  493|       |        } else {
  494|      0|            self.de.reader.advance(1);
  495|      0|            Ok(None)
  496|       |        }
  497|  4.77k|    }
_RINvXs2_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de9SeqAccess17next_element_seedINtNtCsiloedr2K6v7_4core6marker11PhantomDataNtNtCs9pDt8l5wGDA_5alloc6string6StringEECs7AwuCMXPzRZ_8fvm_fuzz:
  484|  4.77k|        if let Some(len) = self.len.as_mut() {
  485|  4.77k|            if *len > 0 {
  486|  4.77k|                *len -= 1;
  487|  4.77k|                Ok(Some(seed.deserialize(&mut *self.de)?))
  488|       |            } else {
  489|      0|                Ok(None)
  490|       |            }
  491|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  492|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  493|       |        } else {
  494|      0|            self.de.reader.advance(1);
  495|      0|            Ok(None)
  496|       |        }
  497|  4.77k|    }
_RINvXs2_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de9SeqAccess17next_element_seedINtNtCsiloedr2K6v7_4core6marker11PhantomDataTNtNtCs9pDt8l5wGDA_5alloc6string6StringINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEEECs7AwuCMXPzRZ_8fvm_fuzz:
  484|  5.08k|        if let Some(len) = self.len.as_mut() {
  485|  5.08k|            if *len > 0 {
  486|  4.77k|                *len -= 1;
  487|  4.77k|                Ok(Some(seed.deserialize(&mut *self.de)?))
  488|       |            } else {
  489|    318|                Ok(None)
  490|       |            }
  491|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  492|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  493|       |        } else {
  494|      0|            self.de.reader.advance(1);
  495|      0|            Ok(None)
  496|       |        }
  497|  5.08k|    }
_RINvXs7_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deQINtB6_15CidDeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de12Deserializer17deserialize_bytesNtNtCsl4cFeht4Yol_3cid5serde17BytesToCidVisitorECs7AwuCMXPzRZ_8fvm_fuzz:
  646|  5.40k|    fn deserialize_bytes<V: de::Visitor<'de>>(self, visitor: V) -> Result<V::Value, Self::Error> {
  647|  5.40k|        let byte = peek_one(&mut self.0.reader)?;
  648|  5.40k|        match dec::if_major(byte) {
  649|       |            major::BYTES => {
  650|       |                // CBOR encoded CIDs have a zero byte prefix we have to remove.
  651|  5.40k|                match <types::Bytes<Cow<[u8]>>>::decode(&mut self.0.reader)?.0 {
  652|  5.40k|                    Cow::Borrowed(buf) => {
  653|  5.40k|                        if buf.len() <= 1 || buf[0] != 0 {
  654|      0|                            Err(DecodeError::Msg("Invalid CID".into()))
  655|       |                        } else {
  656|  5.40k|                            visitor.visit_borrowed_bytes(&buf[1..])
  657|       |                        }
  658|       |                    }
  659|      0|                    Cow::Owned(mut buf) => {
  660|      0|                        if buf.len() <= 1 || buf[0] != 0 {
  661|      0|                            Err(DecodeError::Msg("Invalid CID".into()))
  662|       |                        } else {
  663|      0|                            buf.remove(0);
  664|      0|                            visitor.visit_byte_buf(buf)
  665|       |                        }
  666|       |                    }
  667|       |                }
  668|       |            }
  669|      0|            _ => Err(DecodeError::Unsupported { byte }),
  670|       |        }
  671|  5.40k|    }
_RINvXs0_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de12Deserializer17deserialize_tupleINtNvXs2M_NtB1X_5implsTppENtB1X_11Deserialize11deserialize12TupleVisitorNtNtCs9pDt8l5wGDA_5alloc6string6StringINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEECs7AwuCMXPzRZ_8fvm_fuzz:
  344|  4.77k|    fn deserialize_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>
  345|  4.77k|    where
  346|  4.77k|        V: Visitor<'de>,
  347|  4.77k|    {
  348|  4.77k|        let mut de = self.try_step()?;
  349|  4.77k|        let seq = Accessor::tuple(&mut de, len)?;
  350|  4.77k|        visitor.visit_seq(seq)
  351|  4.77k|    }
_RINvXs0_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de12Deserializer26deserialize_newtype_structINtNvXs0_NtCsl4cFeht4Yol_3cid5serdeINtNtB3c_3cid3CidKpENtB1X_11Deserialize11deserialize16MainEntryVisitorKj40_EECs7AwuCMXPzRZ_8fvm_fuzz:
  318|  5.40k|    fn deserialize_newtype_struct<V>(
  319|  5.40k|        self,
  320|  5.40k|        name: &'static str,
  321|  5.40k|        visitor: V,
  322|  5.40k|    ) -> Result<V::Value, Self::Error>
  323|  5.40k|    where
  324|  5.40k|        V: Visitor<'de>,
  325|  5.40k|    {
  326|  5.40k|        if name == CID_SERDE_PRIVATE_IDENTIFIER {
  327|  5.40k|            self.deserialize_cid(visitor)
  328|       |        } else {
  329|      0|            visitor.visit_newtype_struct(self)
  330|       |        }
  331|  5.40k|    }
_RINvNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de10from_sliceTmINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEECs7AwuCMXPzRZ_8fvm_fuzz:
   40|    318|pub fn from_slice<'a, T>(buf: &'a [u8]) -> Result<T, DecodeError<Infallible>>
   41|    318|where
   42|    318|    T: de::Deserialize<'a>,
   43|    318|{
   44|    318|    let reader = SliceReader::new(buf);
   45|    318|    let mut deserializer = Deserializer::from_reader(reader);
   46|    318|    let value = serde::Deserialize::deserialize(&mut deserializer)?;
   47|    318|    deserializer.end()?;
   48|    318|    Ok(value)
   49|    318|}
_RINvXs0_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de12Deserializer15deserialize_seqINtNvXsh_NtB1X_5implsINtNtCs9pDt8l5wGDA_5alloc3vec3VecpENtB1X_11Deserialize11deserialize10VecVisitorINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEECs7AwuCMXPzRZ_8fvm_fuzz:
  334|    318|    fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  335|    318|    where
  336|    318|        V: Visitor<'de>,
  337|    318|    {
  338|    318|        let mut de = self.try_step()?;
  339|    318|        let seq = Accessor::array(&mut de)?;
  340|    318|        visitor.visit_seq(seq)
  341|    318|    }
_RNvMs_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deINtB4_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderE8try_stepCs7AwuCMXPzRZ_8fvm_fuzz:
  101|  6.04k|    fn try_step<'a>(
  102|  6.04k|        &'a mut self,
  103|  6.04k|    ) -> Result<scopeguard::ScopeGuard<&'a mut Self, fn(&'a mut Self) -> ()>, DecodeError<R::Error>>
  104|  6.04k|    {
  105|  6.04k|        if self.reader.step_in() {
  106|  6.04k|            Ok(scopeguard::guard(self, |de| de.reader.step_out()))
  107|       |        } else {
  108|      0|            Err(DecodeError::DepthLimit)
  109|       |        }
  110|  6.04k|    }
_RINvXs0_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de12Deserializer15deserialize_strNtNtB1X_5impls13StringVisitorECs7AwuCMXPzRZ_8fvm_fuzz:
  252|  4.77k|        match <Cow<str>>::decode(&mut self.reader)? {
  253|  4.77k|            Cow::Borrowed(buf) => visitor.visit_borrowed_str(buf),
  254|      0|            Cow::Owned(buf) => visitor.visit_string(buf),
  255|       |        }
  256|       |
  257|       |        // Don't use this. This can lead to random panics and invalid CBOR.
  258|       |        #[cfg(feature = "_do_not_use_its_unsafe_and_invalid_cbor")]
  259|       |        match types::BadStr::<Cow<[u8]>>::decode(&mut self.reader)? {
  260|       |            types::BadStr(Cow::Borrowed(buf)) => {
  261|       |                visitor.visit_borrowed_str(unsafe { std::str::from_utf8_unchecked(buf) })
  262|       |            }
  263|       |            types::BadStr(Cow::Owned(buf)) => {
  264|       |                visitor.visit_string(unsafe { String::from_utf8_unchecked(buf) })
  265|       |            }
  266|       |        }
  267|  4.77k|    }
_RINvMs_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deINtB5_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderE15deserialize_cidINtNvXs0_NtCsl4cFeht4Yol_3cid5serdeINtNtB2l_3cid3CidKpENtNtCssVaLrL3Upj_5serde2de11Deserialize11deserialize16MainEntryVisitorKj40_EECs7AwuCMXPzRZ_8fvm_fuzz:
  113|  5.40k|    fn deserialize_cid<V>(&mut self, visitor: V) -> Result<V::Value, DecodeError<R::Error>>
  114|  5.40k|    where
  115|  5.40k|        V: Visitor<'de>,
  116|  5.40k|    {
  117|  5.40k|        let tag = dec::TagStart::decode(&mut self.reader)?;
  118|       |
  119|  5.40k|        match tag.0 {
  120|  5.40k|            CBOR_TAGS_CID => visitor.visit_newtype_struct(&mut CidDeserializer(self)),
  121|      0|            _ => Err(DecodeError::TypeMismatch {
  122|      0|                name: "CBOR tag",
  123|      0|                byte: tag.0 as u8,
  124|      0|            }),
  125|       |        }
  126|  5.40k|    }
_RINvXs3_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de9MapAccess15next_value_seedINtNtCsiloedr2K6v7_4core6marker11PhantomDatayEECs7AwuCMXPzRZ_8fvm_fuzz:
  529|    318|    fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>
  530|    318|    where
  531|    318|        V: de::DeserializeSeed<'de>,
  532|    318|    {
  533|    318|        seed.deserialize(&mut *self.de)
  534|    318|    }
_RINvXs0_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de12Deserializer17deserialize_tupleINtNvXs2M_NtB1X_5implsTppENtB1X_11Deserialize11deserialize12TupleVisitormINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEECs7AwuCMXPzRZ_8fvm_fuzz:
  344|    318|    fn deserialize_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>
  345|    318|    where
  346|    318|        V: Visitor<'de>,
  347|    318|    {
  348|    318|        let mut de = self.try_step()?;
  349|    318|        let seq = Accessor::tuple(&mut de, len)?;
  350|    318|        visitor.visit_seq(seq)
  351|    318|    }
_RINvXs0_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de12Deserializer22deserialize_identifierNtNvXNvCs7wiLZqa2F25_12fvm_ipld_cars_1__NtB34_9CarHeaderNtB1X_11Deserialize11deserialize14___FieldVisitorECs7AwuCMXPzRZ_8fvm_fuzz:
  405|    636|    fn deserialize_identifier<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  406|    636|    where
  407|    636|        V: Visitor<'de>,
  408|    636|    {
  409|    636|        self.deserialize_str(visitor)
  410|    636|    }
_RINvXs2_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de9SeqAccess17next_element_seedINtNtCsiloedr2K6v7_4core6marker11PhantomDataINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEECs7AwuCMXPzRZ_8fvm_fuzz:
  484|  5.72k|        if let Some(len) = self.len.as_mut() {
  485|  5.72k|            if *len > 0 {
  486|  5.40k|                *len -= 1;
  487|  5.40k|                Ok(Some(seed.deserialize(&mut *self.de)?))
  488|       |            } else {
  489|    318|                Ok(None)
  490|       |            }
  491|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  492|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  493|       |        } else {
  494|      0|            self.de.reader.advance(1);
  495|      0|            Ok(None)
  496|       |        }
  497|  5.72k|    }
_RNvXs2_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deINtB5_8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de9SeqAccess9size_hintCs7AwuCMXPzRZ_8fvm_fuzz:
  500|    636|    fn size_hint(&self) -> Option<usize> {
  501|    636|        self.len
  502|    636|    }
_RINvXs0_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de12Deserializer15deserialize_seqINtNvXsh_NtB1X_5implsINtNtCs9pDt8l5wGDA_5alloc3vec3VecpENtB1X_11Deserialize11deserialize10VecVisitorTNtNtB3g_6string6StringINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEEECs7AwuCMXPzRZ_8fvm_fuzz:
  334|    318|    fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  335|    318|    where
  336|    318|        V: Visitor<'de>,
  337|    318|    {
  338|    318|        let mut de = self.try_step()?;
  339|    318|        let seq = Accessor::array(&mut de)?;
  340|    318|        visitor.visit_seq(seq)
  341|    318|    }
_RINvXs0_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de12Deserializer15deserialize_u32NtNvXsV_NtB1X_5implsmNtB1X_11Deserialize11deserialize16PrimitiveVisitorECs7AwuCMXPzRZ_8fvm_fuzz:
  142|    318|        fn $name<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  143|    318|        where V: Visitor<'de>
  144|    318|        {
  145|    318|            let value = <$t>::decode(&mut self.reader)?;
  146|    318|            visitor.$visit(value)
  147|    318|        }
_RNvMNtCshf5gyM0YXBy_18serde_ipld_dagcbor2deINtB2_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderE11from_readerCs7AwuCMXPzRZ_8fvm_fuzz:
   93|    954|    pub fn from_reader(reader: R) -> Deserializer<R> {
   94|    954|        Deserializer { reader }
   95|    954|    }
_RINvXs0_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de12Deserializer18deserialize_structNtNvXNvCs7wiLZqa2F25_12fvm_ipld_cars_1__NtB30_9CarHeaderNtB1X_11Deserialize11deserialize9___VisitorECs7AwuCMXPzRZ_8fvm_fuzz:
  377|    318|    fn deserialize_struct<V>(
  378|    318|        self,
  379|    318|        _name: &'static str,
  380|    318|        _fields: &'static [&'static str],
  381|    318|        visitor: V,
  382|    318|    ) -> Result<V::Value, Self::Error>
  383|    318|    where
  384|    318|        V: Visitor<'de>,
  385|    318|    {
  386|    318|        self.deserialize_map(visitor)
  387|    318|    }
_RINvXs3_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de9MapAccess15next_value_seedINtNtCsiloedr2K6v7_4core6marker11PhantomDataINtNtCs9pDt8l5wGDA_5alloc3vec3VecINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEEECs7AwuCMXPzRZ_8fvm_fuzz:
  529|    318|    fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>
  530|    318|    where
  531|    318|        V: de::DeserializeSeed<'de>,
  532|    318|    {
  533|    318|        seed.deserialize(&mut *self.de)
  534|    318|    }
_RINvNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de10from_sliceNtCs7wiLZqa2F25_12fvm_ipld_car9CarHeaderECs7AwuCMXPzRZ_8fvm_fuzz:
   40|    318|pub fn from_slice<'a, T>(buf: &'a [u8]) -> Result<T, DecodeError<Infallible>>
   41|    318|where
   42|    318|    T: de::Deserialize<'a>,
   43|    318|{
   44|    318|    let reader = SliceReader::new(buf);
   45|    318|    let mut deserializer = Deserializer::from_reader(reader);
   46|    318|    let value = serde::Deserialize::deserialize(&mut deserializer)?;
   47|    318|    deserializer.end()?;
   48|    318|    Ok(value)
   49|    318|}
_RNvMs1_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deINtB5_8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderE5arrayCs7AwuCMXPzRZ_8fvm_fuzz:
  434|    636|    pub fn array(de: &'a mut Deserializer<R>) -> Result<Accessor<'a, R>, DecodeError<R::Error>> {
  435|    636|        let array_start = dec::ArrayStart::decode(&mut de.reader)?;
  436|    636|        Ok(Accessor {
  437|    636|            de,
  438|    636|            len: array_start.0,
  439|    636|        })
  440|    636|    }
_RINvNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de10from_sliceINtNtCs9pDt8l5wGDA_5alloc3vec3VecTNtNtBW_6string6StringINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEEECs7AwuCMXPzRZ_8fvm_fuzz:
   40|    318|pub fn from_slice<'a, T>(buf: &'a [u8]) -> Result<T, DecodeError<Infallible>>
   41|    318|where
   42|    318|    T: de::Deserialize<'a>,
   43|    318|{
   44|    318|    let reader = SliceReader::new(buf);
   45|    318|    let mut deserializer = Deserializer::from_reader(reader);
   46|    318|    let value = serde::Deserialize::deserialize(&mut deserializer)?;
   47|    318|    deserializer.end()?;
   48|    318|    Ok(value)
   49|    318|}
_RINvXs3_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de9MapAccess13next_key_seedINtNtCsiloedr2K6v7_4core6marker11PhantomDataNtNvXNvCs7wiLZqa2F25_12fvm_ipld_cars_1__NtB3t_9CarHeaderNtB1R_11Deserialize11deserialize7___FieldEECs7AwuCMXPzRZ_8fvm_fuzz:
  513|    954|        if let Some(len) = self.len.as_mut() {
  514|    954|            if *len > 0 {
  515|    636|                *len -= 1;
  516|    636|                Ok(Some(seed.deserialize(&mut *self.de)?))
  517|       |            } else {
  518|    318|                Ok(None)
  519|       |            }
  520|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  521|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  522|       |        } else {
  523|      0|            self.de.reader.advance(1);
  524|      0|            Ok(None)
  525|       |        }
  526|    954|    }
_RNvMs1_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deINtB5_8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderE5tupleCs7AwuCMXPzRZ_8fvm_fuzz:
  443|  5.08k|    pub fn tuple(
  444|  5.08k|        de: &'a mut Deserializer<R>,
  445|  5.08k|        len: usize,
  446|  5.08k|    ) -> Result<Accessor<'a, R>, DecodeError<R::Error>> {
  447|  5.08k|        let array_start = dec::ArrayStart::decode(&mut de.reader)?;
  448|       |
  449|  5.08k|        if array_start.0 == Some(len) {
  450|  5.08k|            Ok(Accessor {
  451|  5.08k|                de,
  452|  5.08k|                len: array_start.0,
  453|  5.08k|            })
  454|       |        } else {
  455|      0|            Err(DecodeError::RequireLength {
  456|      0|                name: "tuple",
  457|      0|                expect: len,
  458|      0|                value: array_start.0.unwrap_or(0),
  459|      0|            })
  460|       |        }
  461|  5.08k|    }
_RINvXs0_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de12Deserializer15deserialize_mapNtNvXNvCs7wiLZqa2F25_12fvm_ipld_cars_1__NtB2X_9CarHeaderNtB1X_11Deserialize11deserialize9___VisitorECs7AwuCMXPzRZ_8fvm_fuzz:
  367|    318|    fn deserialize_map<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  368|    318|    where
  369|    318|        V: Visitor<'de>,
  370|    318|    {
  371|    318|        let mut de = self.try_step()?;
  372|    318|        let map = Accessor::map(&mut de)?;
  373|    318|        visitor.visit_map(map)
  374|    318|    }
_RINvXs2_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deINtB6_8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de9SeqAccess17next_element_seedINtNtCsiloedr2K6v7_4core6marker11PhantomDatamEECs7AwuCMXPzRZ_8fvm_fuzz:
  484|    318|        if let Some(len) = self.len.as_mut() {
  485|    318|            if *len > 0 {
  486|    318|                *len -= 1;
  487|    318|                Ok(Some(seed.deserialize(&mut *self.de)?))
  488|       |            } else {
  489|      0|                Ok(None)
  490|       |            }
  491|      0|        } else if peek_one(&mut self.de.reader)? != marker::BREAK {
  492|      0|            Ok(Some(seed.deserialize(&mut *self.de)?))
  493|       |        } else {
  494|      0|            self.de.reader.advance(1);
  495|      0|            Ok(None)
  496|       |        }
  497|    318|    }
_RNvMs1_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deINtB5_8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderE3mapCs7AwuCMXPzRZ_8fvm_fuzz:
  464|    318|    pub fn map(de: &'a mut Deserializer<R>) -> Result<Accessor<'a, R>, DecodeError<R::Error>> {
  465|    318|        let map_start = dec::MapStart::decode(&mut de.reader)?;
  466|    318|        Ok(Accessor {
  467|    318|            de,
  468|    318|            len: map_start.0,
  469|    318|        })
  470|    318|    }
_RNvMs_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deINtB4_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderE3endCs7AwuCMXPzRZ_8fvm_fuzz:
  131|    954|        match peek_one(&mut self.reader) {
  132|      0|            Ok(_) => Err(DecodeError::TrailingData),
  133|    954|            Err(DecodeError::Eof) => Ok(()),
  134|      0|            Err(error) => Err(error),
  135|       |        }
  136|    954|    }
_RINvXs0_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de12Deserializer15deserialize_strNtNvXNvCs7wiLZqa2F25_12fvm_ipld_cars_1__NtB2X_9CarHeaderNtB1X_11Deserialize11deserialize14___FieldVisitorECs7AwuCMXPzRZ_8fvm_fuzz:
  252|    636|        match <Cow<str>>::decode(&mut self.reader)? {
  253|    636|            Cow::Borrowed(buf) => visitor.visit_borrowed_str(buf),
  254|      0|            Cow::Owned(buf) => visitor.visit_string(buf),
  255|       |        }
  256|       |
  257|       |        // Don't use this. This can lead to random panics and invalid CBOR.
  258|       |        #[cfg(feature = "_do_not_use_its_unsafe_and_invalid_cbor")]
  259|       |        match types::BadStr::<Cow<[u8]>>::decode(&mut self.reader)? {
  260|       |            types::BadStr(Cow::Borrowed(buf)) => {
  261|       |                visitor.visit_borrowed_str(unsafe { std::str::from_utf8_unchecked(buf) })
  262|       |            }
  263|       |            types::BadStr(Cow::Owned(buf)) => {
  264|       |                visitor.visit_string(unsafe { String::from_utf8_unchecked(buf) })
  265|       |            }
  266|       |        }
  267|    636|    }
_RINvXs0_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de12Deserializer15deserialize_u64NtNvXsX_NtB1X_5implsyNtB1X_11Deserialize11deserialize16PrimitiveVisitorECs7AwuCMXPzRZ_8fvm_fuzz:
  142|    318|        fn $name<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  143|    318|        where V: Visitor<'de>
  144|    318|        {
  145|    318|            let value = <$t>::decode(&mut self.reader)?;
  146|    318|            visitor.$visit(value)
  147|    318|        }
_RINvXs0_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deQINtB6_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderENtNtCssVaLrL3Upj_5serde2de12Deserializer18deserialize_stringNtNtB1X_5impls13StringVisitorECs7AwuCMXPzRZ_8fvm_fuzz:
  270|  4.77k|    fn deserialize_string<V>(self, visitor: V) -> Result<V::Value, Self::Error>
  271|  4.77k|    where
  272|  4.77k|        V: Visitor<'de>,
  273|  4.77k|    {
  274|  4.77k|        self.deserialize_str(visitor)
  275|  4.77k|    }
_RNCNvMs_NtCshf5gyM0YXBy_18serde_ipld_dagcbor2deINtB6_12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderE8try_step0Cs7AwuCMXPzRZ_8fvm_fuzz:
  106|  6.04k|            Ok(scopeguard::guard(self, |de| de.reader.step_out()))

_RINvXs2_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser20SerializeTupleStruct15serialize_fieldNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateECsboUdcTbF1FS_15direct_syscalls:
  403|    954|    fn serialize_field<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  404|    954|        value.serialize(&mut *self.ser)
  405|    954|    }
_RNvXs2_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serINtB5_14BoundedCollectNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser20SerializeTupleStruct3endCsboUdcTbF1FS_15direct_syscalls:
  408|  2.22k|    fn end(self) -> Result<Self::Ok, Self::Error> {
  409|  2.22k|        Ok(())
  410|  2.22k|    }
_RINvXs2_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser20SerializeTupleStruct15serialize_fieldNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyECsboUdcTbF1FS_15direct_syscalls:
  403|    954|    fn serialize_field<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  404|    954|        value.serialize(&mut *self.ser)
  405|    954|    }
_RINvXs0_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serINtB6_7CollectNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser12SerializeSeq17serialize_elementRINtNtCslH3pn9Bu6yX_13fvm_ipld_hamt7pointer7PointerNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtB2Q_14hash_algorithm6Sha256EECsboUdcTbF1FS_15direct_syscalls:
  369|    954|    fn serialize_element<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  370|    954|        value.serialize(&mut *self.ser)
  371|    954|    }
_RNvMNtCshf5gyM0YXBy_18serde_ipld_dagcbor3serINtB2_10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterE3newCsboUdcTbF1FS_15direct_syscalls:
   51|    636|    pub fn new(writer: W) -> Serializer<W> {
   52|    636|        Serializer { writer }
   53|    636|    }
_RNvXs1_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serINtB5_14BoundedCollectNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser14SerializeTuple3endCsboUdcTbF1FS_15direct_syscalls:
  393|    318|    fn end(self) -> Result<Self::Ok, Self::Error> {
  394|    318|        Ok(())
  395|    318|    }
_RNvXs_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serQINtB4_10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser10Serializer14serialize_noneCsboUdcTbF1FS_15direct_syscalls:
  166|    954|        types::Null.encode(&mut self.writer)?;
  167|    954|        Ok(())
  168|    954|    }
_RINvXs2_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser20SerializeTupleStruct15serialize_fieldRNtNtCs83Z8YCK0meJ_10fvm_shared5state16StateTreeVersionECsboUdcTbF1FS_15direct_syscalls:
  403|    318|    fn serialize_field<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  404|    318|        value.serialize(&mut *self.ser)
  405|    318|    }
_RINvXs2_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser20SerializeTupleStruct15serialize_fieldRINtNtCsiloedr2K6v7_4core6option6OptionNtNtCs83Z8YCK0meJ_10fvm_shared7address7AddressEECsboUdcTbF1FS_15direct_syscalls:
  403|    954|    fn serialize_field<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  404|    954|        value.serialize(&mut *self.ser)
  405|    954|    }
_RNvXs7_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serQINtB5_13CidSerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser10Serializer15serialize_bytesCsboUdcTbF1FS_15direct_syscalls:
  550|  2.54k|    fn serialize_bytes(self, value: &[u8]) -> Result<Self::Ok, Self::Error> {
  551|  2.54k|        // The bytes of the CID is prefixed with a null byte when encoded as CBOR.
  552|  2.54k|        let prefixed = [&[0x00], value].concat();
  553|  2.54k|        // CIDs are serialized with CBOR tag 42.
  554|  2.54k|        types::Tag(CBOR_TAGS_CID, types::Bytes(&prefixed[..])).encode(&mut self.0.writer)?;
  555|  2.54k|        Ok(())
  556|  2.54k|    }
_RINvXs_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serQINtB5_10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser10Serializer24serialize_newtype_structNtNtCshzAOHAhpLd9_11serde_bytes7bytebuf7ByteBufECsboUdcTbF1FS_15direct_syscalls:
  199|  2.54k|    fn serialize_newtype_struct<T: Serialize + ?Sized>(
  200|  2.54k|        self,
  201|  2.54k|        name: &'static str,
  202|  2.54k|        value: &T,
  203|  2.54k|    ) -> Result<Self::Ok, Self::Error> {
  204|  2.54k|        if name == CID_SERDE_PRIVATE_IDENTIFIER {
  205|  2.54k|            value.serialize(&mut CidSerializer(self))
  206|       |        } else {
  207|      0|            value.serialize(self)
  208|       |        }
  209|  2.54k|    }
_RNvXs_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serQINtB4_10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser10Serializer22serialize_tuple_structCsboUdcTbF1FS_15direct_syscalls:
  244|  2.22k|    fn serialize_tuple_struct(
  245|  2.22k|        self,
  246|  2.22k|        _name: &'static str,
  247|  2.22k|        len: usize,
  248|  2.22k|    ) -> Result<Self::SerializeTupleStruct, Self::Error> {
  249|  2.22k|        self.serialize_tuple(len)
  250|  2.22k|    }
_RNvXs0_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serINtB5_7CollectNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser12SerializeSeq3endCsboUdcTbF1FS_15direct_syscalls:
  374|  1.27k|    fn end(self) -> Result<Self::Ok, Self::Error> {
  375|  1.27k|        if !self.bounded {
  376|      0|            enc::End.encode(&mut self.ser.writer)?;
  377|  1.27k|        }
  378|       |
  379|  1.27k|        Ok(())
  380|  1.27k|    }
_RNvXs_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serQINtB4_10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser10Serializer15serialize_tupleCsboUdcTbF1FS_15direct_syscalls:
  239|  2.54k|        enc::ArrayStartBounded(len).encode(&mut self.writer)?;
  240|  2.54k|        Ok(BoundedCollect { ser: self })
  241|  2.54k|    }
_RINvXs2_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser20SerializeTupleStruct15serialize_fieldRINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EECsboUdcTbF1FS_15direct_syscalls:
  403|  2.54k|    fn serialize_field<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  404|  2.54k|        value.serialize(&mut *self.ser)
  405|  2.54k|    }
_RINvNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser6to_vecNtNtCs83Z8YCK0meJ_10fvm_shared5state9StateRootECsboUdcTbF1FS_15direct_syscalls:
   23|    318|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, EncodeError<TryReserveError>>
   24|    318|where
   25|    318|    T: Serialize + ?Sized,
   26|    318|{
   27|    318|    let writer = BufWriter::new(Vec::new());
   28|    318|    let mut serializer = Serializer::new(writer);
   29|    318|    value.serialize(&mut serializer)?;
   30|    318|    Ok(serializer.into_inner().into_inner())
   31|    318|}
_RNvXs_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serQINtB4_10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser10Serializer13serialize_seqCsboUdcTbF1FS_15direct_syscalls:
  226|  1.27k|        if let Some(len) = len {
  227|  1.27k|            enc::ArrayStartBounded(len).encode(&mut self.writer)?;
  228|       |        } else {
  229|      0|            enc::ArrayStartUnbounded.encode(&mut self.writer)?;
  230|       |        }
  231|  1.27k|        Ok(Collect {
  232|  1.27k|            bounded: len.is_some(),
  233|  1.27k|            ser: self,
  234|  1.27k|        })
  235|  1.27k|    }
_RINvXs1_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser14SerializeTuple17serialize_elementRNtNtCslH3pn9Bu6yX_13fvm_ipld_hamt8bitfield8BitfieldECsboUdcTbF1FS_15direct_syscalls:
  388|    318|    fn serialize_element<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  389|    318|        value.serialize(&mut *self.ser)
  390|    318|    }
_RINvXs0_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serINtB6_7CollectNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser12SerializeSeq17serialize_elementRINtCslH3pn9Bu6yX_13fvm_ipld_hamt12KeyValuePairNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateEECsboUdcTbF1FS_15direct_syscalls:
  369|    954|    fn serialize_element<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  370|    954|        value.serialize(&mut *self.ser)
  371|    954|    }
_RNvXs_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serQINtB4_10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser10Serializer13serialize_u64CsboUdcTbF1FS_15direct_syscalls:
  123|  1.27k|        v.encode(&mut self.writer)?;
  124|  1.27k|        Ok(())
  125|  1.27k|    }
_RINvNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser6to_vecINtNtCslH3pn9Bu6yX_13fvm_ipld_hamt4node4NodeNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtBS_14hash_algorithm6Sha256EECsboUdcTbF1FS_15direct_syscalls:
   23|    318|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, EncodeError<TryReserveError>>
   24|    318|where
   25|    318|    T: Serialize + ?Sized,
   26|    318|{
   27|    318|    let writer = BufWriter::new(Vec::new());
   28|    318|    let mut serializer = Serializer::new(writer);
   29|    318|    value.serialize(&mut serializer)?;
   30|    318|    Ok(serializer.into_inner().into_inner())
   31|    318|}
_RINvXs2_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser20SerializeTupleStruct15serialize_fieldRyECsboUdcTbF1FS_15direct_syscalls:
  403|    954|    fn serialize_field<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  404|    954|        value.serialize(&mut *self.ser)
  405|    954|    }
_RINvXs1_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser14SerializeTuple17serialize_elementRINtNtCs9pDt8l5wGDA_5alloc3vec3VecINtNtCslH3pn9Bu6yX_13fvm_ipld_hamt7pointer7PointerNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtB3x_14hash_algorithm6Sha256EEECsboUdcTbF1FS_15direct_syscalls:
  388|    318|    fn serialize_element<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  389|    318|        value.serialize(&mut *self.ser)
  390|    318|    }
_RNvMNtCshf5gyM0YXBy_18serde_ipld_dagcbor3serINtB2_10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterE10into_innerCsboUdcTbF1FS_15direct_syscalls:
   56|    636|    pub fn into_inner(self) -> W {
   57|    636|        self.writer
   58|    636|    }
_RINvXs2_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser20SerializeTupleStruct15serialize_fieldRNtNtCs83Z8YCK0meJ_10fvm_shared4econ11TokenAmountECsboUdcTbF1FS_15direct_syscalls:
  403|    954|    fn serialize_field<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  404|    954|        value.serialize(&mut *self.ser)
  405|    954|    }
_RNvXs_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serQINtB4_10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser10Serializer15serialize_bytesCsboUdcTbF1FS_15direct_syscalls:
  160|  2.22k|        types::Bytes(v).encode(&mut self.writer)?;
  161|  2.22k|        Ok(())
  162|  2.22k|    }
_RINvXs2_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser20SerializeTupleStruct15serialize_fieldRNtNtCs9pDt8l5wGDA_5alloc6string6StringECs7AwuCMXPzRZ_8fvm_fuzz:
  403|    318|    fn serialize_field<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  404|    318|        value.serialize(&mut *self.ser)
  405|    318|    }
_RNvXs_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serQINtB4_10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser10Serializer15serialize_tupleCs7AwuCMXPzRZ_8fvm_fuzz:
  239|  1.59k|        enc::ArrayStartBounded(len).encode(&mut self.writer)?;
  240|  1.59k|        Ok(BoundedCollect { ser: self })
  241|  1.59k|    }
_RNvXs_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serQINtB4_10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser10Serializer13serialize_u64Cs7AwuCMXPzRZ_8fvm_fuzz:
  123|    318|        v.encode(&mut self.writer)?;
  124|    318|        Ok(())
  125|    318|    }
_RNvXs_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serQINtB4_10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser10Serializer13serialize_strCs7AwuCMXPzRZ_8fvm_fuzz:
  154|    318|        v.encode(&mut self.writer)?;
  155|    318|        Ok(())
  156|    318|    }
_RINvXs1_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser14SerializeTuple17serialize_elementRNtNtCslH3pn9Bu6yX_13fvm_ipld_hamt8bitfield8BitfieldECs7AwuCMXPzRZ_8fvm_fuzz:
  388|    318|    fn serialize_element<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  389|    318|        value.serialize(&mut *self.ser)
  390|    318|    }
_RINvXs_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serQINtB5_10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser10Serializer24serialize_newtype_structNtNtCshzAOHAhpLd9_11serde_bytes7bytebuf7ByteBufECs7AwuCMXPzRZ_8fvm_fuzz:
  199|    636|    fn serialize_newtype_struct<T: Serialize + ?Sized>(
  200|    636|        self,
  201|    636|        name: &'static str,
  202|    636|        value: &T,
  203|    636|    ) -> Result<Self::Ok, Self::Error> {
  204|    636|        if name == CID_SERDE_PRIVATE_IDENTIFIER {
  205|    636|            value.serialize(&mut CidSerializer(self))
  206|       |        } else {
  207|      0|            value.serialize(self)
  208|       |        }
  209|    636|    }
_RNvMNtCshf5gyM0YXBy_18serde_ipld_dagcbor3serINtB2_10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterE10into_innerCs7AwuCMXPzRZ_8fvm_fuzz:
   56|  1.59k|    pub fn into_inner(self) -> W {
   57|  1.59k|        self.writer
   58|  1.59k|    }
_RINvNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser6to_vecAuj0_ECs7AwuCMXPzRZ_8fvm_fuzz:
   23|    318|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, EncodeError<TryReserveError>>
   24|    318|where
   25|    318|    T: Serialize + ?Sized,
   26|    318|{
   27|    318|    let writer = BufWriter::new(Vec::new());
   28|    318|    let mut serializer = Serializer::new(writer);
   29|    318|    value.serialize(&mut serializer)?;
   30|    318|    Ok(serializer.into_inner().into_inner())
   31|    318|}
_RNvXs_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serQINtB4_10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser10Serializer15serialize_bytesCs7AwuCMXPzRZ_8fvm_fuzz:
  160|    318|        types::Bytes(v).encode(&mut self.writer)?;
  161|    318|        Ok(())
  162|    318|    }
_RNvMNtCshf5gyM0YXBy_18serde_ipld_dagcbor3serINtB2_10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterE3newCs7AwuCMXPzRZ_8fvm_fuzz:
   51|  1.59k|    pub fn new(writer: W) -> Serializer<W> {
   52|  1.59k|        Serializer { writer }
   53|  1.59k|    }
_RNvXs1_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serINtB5_14BoundedCollectNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser14SerializeTuple3endCs7AwuCMXPzRZ_8fvm_fuzz:
  393|    954|    fn end(self) -> Result<Self::Ok, Self::Error> {
  394|    954|        Ok(())
  395|    954|    }
_RINvNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser6to_vecINtNtCslH3pn9Bu6yX_13fvm_ipld_hamt4node4NodeNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCs9pDt8l5wGDA_5alloc6string6StringNtNtBS_14hash_algorithm6Sha256EECs7AwuCMXPzRZ_8fvm_fuzz:
   23|    318|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, EncodeError<TryReserveError>>
   24|    318|where
   25|    318|    T: Serialize + ?Sized,
   26|    318|{
   27|    318|    let writer = BufWriter::new(Vec::new());
   28|    318|    let mut serializer = Serializer::new(writer);
   29|    318|    value.serialize(&mut serializer)?;
   30|    318|    Ok(serializer.into_inner().into_inner())
   31|    318|}
_RINvXs2_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser20SerializeTupleStruct15serialize_fieldRyECs7AwuCMXPzRZ_8fvm_fuzz:
  403|    318|    fn serialize_field<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  404|    318|        value.serialize(&mut *self.ser)
  405|    318|    }
_RINvNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser6to_vecNtNtCskJihg1y13m7_3fvm10init_actor5StateECs7AwuCMXPzRZ_8fvm_fuzz:
   23|    318|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, EncodeError<TryReserveError>>
   24|    318|where
   25|    318|    T: Serialize + ?Sized,
   26|    318|{
   27|    318|    let writer = BufWriter::new(Vec::new());
   28|    318|    let mut serializer = Serializer::new(writer);
   29|    318|    value.serialize(&mut serializer)?;
   30|    318|    Ok(serializer.into_inner().into_inner())
   31|    318|}
_RINvXs2_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser20SerializeTupleStruct15serialize_fieldRINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EECs7AwuCMXPzRZ_8fvm_fuzz:
  403|    636|    fn serialize_field<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  404|    636|        value.serialize(&mut *self.ser)
  405|    636|    }
_RNvXs0_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serINtB5_7CollectNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser12SerializeSeq3endCs7AwuCMXPzRZ_8fvm_fuzz:
  374|    318|    fn end(self) -> Result<Self::Ok, Self::Error> {
  375|    318|        if !self.bounded {
  376|      0|            enc::End.encode(&mut self.ser.writer)?;
  377|    318|        }
  378|       |
  379|    318|        Ok(())
  380|    318|    }
_RINvNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser6to_vecNtNtCs83Z8YCK0meJ_10fvm_shared5state10StateInfo0ECs7AwuCMXPzRZ_8fvm_fuzz:
   23|    318|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, EncodeError<TryReserveError>>
   24|    318|where
   25|    318|    T: Serialize + ?Sized,
   26|    318|{
   27|    318|    let writer = BufWriter::new(Vec::new());
   28|    318|    let mut serializer = Serializer::new(writer);
   29|    318|    value.serialize(&mut serializer)?;
   30|    318|    Ok(serializer.into_inner().into_inner())
   31|    318|}
_RNvXs7_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serQINtB5_13CidSerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser10Serializer15serialize_bytesCs7AwuCMXPzRZ_8fvm_fuzz:
  550|    636|    fn serialize_bytes(self, value: &[u8]) -> Result<Self::Ok, Self::Error> {
  551|    636|        // The bytes of the CID is prefixed with a null byte when encoded as CBOR.
  552|    636|        let prefixed = [&[0x00], value].concat();
  553|    636|        // CIDs are serialized with CBOR tag 42.
  554|    636|        types::Tag(CBOR_TAGS_CID, types::Bytes(&prefixed[..])).encode(&mut self.0.writer)?;
  555|    636|        Ok(())
  556|    636|    }
_RNvXs2_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serINtB5_14BoundedCollectNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser20SerializeTupleStruct3endCs7AwuCMXPzRZ_8fvm_fuzz:
  408|    636|    fn end(self) -> Result<Self::Ok, Self::Error> {
  409|    636|        Ok(())
  410|    636|    }
_RNvXs_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serQINtB4_10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser10Serializer13serialize_seqCs7AwuCMXPzRZ_8fvm_fuzz:
  226|    318|        if let Some(len) = len {
  227|    318|            enc::ArrayStartBounded(len).encode(&mut self.writer)?;
  228|       |        } else {
  229|      0|            enc::ArrayStartUnbounded.encode(&mut self.writer)?;
  230|       |        }
  231|    318|        Ok(Collect {
  232|    318|            bounded: len.is_some(),
  233|    318|            ser: self,
  234|    318|        })
  235|    318|    }
_RINvNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser6to_vecNtNtCskJihg1y13m7_3fvm12system_actor5StateECs7AwuCMXPzRZ_8fvm_fuzz:
   23|    318|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, EncodeError<TryReserveError>>
   24|    318|where
   25|    318|    T: Serialize + ?Sized,
   26|    318|{
   27|    318|    let writer = BufWriter::new(Vec::new());
   28|    318|    let mut serializer = Serializer::new(writer);
   29|    318|    value.serialize(&mut serializer)?;
   30|    318|    Ok(serializer.into_inner().into_inner())
   31|    318|}
_RINvXs1_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serINtB6_14BoundedCollectNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser14SerializeTuple17serialize_elementRINtNtCs9pDt8l5wGDA_5alloc3vec3VecINtNtCslH3pn9Bu6yX_13fvm_ipld_hamt7pointer7PointerNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtB30_6string6StringNtNtB3x_14hash_algorithm6Sha256EEECs7AwuCMXPzRZ_8fvm_fuzz:
  388|    318|    fn serialize_element<T: Serialize + ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> {
  389|    318|        value.serialize(&mut *self.ser)
  390|    318|    }
_RNvXs_NtCshf5gyM0YXBy_18serde_ipld_dagcbor3serQINtB4_10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterENtNtCssVaLrL3Upj_5serde3ser10Serializer22serialize_tuple_structCs7AwuCMXPzRZ_8fvm_fuzz:
  244|    636|    fn serialize_tuple_struct(
  245|    636|        self,
  246|    636|        _name: &'static str,
  247|    636|        len: usize,
  248|    636|    ) -> Result<Self::SerializeTupleStruct, Self::Error> {
  249|    636|        self.serialize_tuple(len)
  250|    636|    }

_RNvXCscrDzOC3hEIR_11serde_tupleINtB2_10SerializerQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEENtNtCssVaLrL3Upj_5serde3ser10Serializer22serialize_tuple_structCsboUdcTbF1FS_15direct_syscalls:
  158|  1.27k|    fn serialize_tuple_struct(
  159|  1.27k|        self,
  160|  1.27k|        name: &'static str,
  161|  1.27k|        len: usize,
  162|  1.27k|    ) -> Result<Self::SerializeTupleStruct, Self::Error> {
  163|  1.27k|        self.0.serialize_tuple_struct(name, len)
  164|  1.27k|    }
_RINvXs_CscrDzOC3hEIR_11serde_tupleINtB5_12DeserializerQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEENtNtCssVaLrL3Upj_5serde2de12Deserializer24deserialize_tuple_structNtNvXNvNvXs9_NtCs83Z8YCK0meJ_10fvm_shared5stateNtB3U_9StateRootNtB2F_11Deserialize11deserialize1__NtB3O_5InnerB4I_11deserialize9___VisitorECsboUdcTbF1FS_15direct_syscalls:
  353|    318|    fn deserialize_tuple_struct<V>(
  354|    318|        self,
  355|    318|        name: &'static str,
  356|    318|        len: usize,
  357|    318|        visitor: V,
  358|    318|    ) -> Result<V::Value, Self::Error>
  359|    318|    where
  360|    318|        V: serde::de::Visitor<'de>,
  361|    318|    {
  362|    318|        self.0.deserialize_tuple_struct(name, len, visitor)
  363|    318|    }
_RINvXs_CscrDzOC3hEIR_11serde_tupleINtB5_12DeserializerNtNtCs3TS9n28v4Rl_12libipld_core4ipld4IpldENtNtCssVaLrL3Upj_5serde2de12Deserializer24deserialize_tuple_structNtNvXNvNvXsa_NtCskJihg1y13m7_3fvm10state_treeNtB2O_10ActorStateNtB1z_11Deserialize11deserialize1__NtB2I_5InnerB3C_11deserialize9___VisitorECsboUdcTbF1FS_15direct_syscalls:
  353|    954|    fn deserialize_tuple_struct<V>(
  354|    954|        self,
  355|    954|        name: &'static str,
  356|    954|        len: usize,
  357|    954|        visitor: V,
  358|    954|    ) -> Result<V::Value, Self::Error>
  359|    954|    where
  360|    954|        V: serde::de::Visitor<'de>,
  361|    954|    {
  362|    954|        self.0.deserialize_tuple_struct(name, len, visitor)
  363|    954|    }
_RNvXCscrDzOC3hEIR_11serde_tupleINtB2_10SerializerQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEENtNtCssVaLrL3Upj_5serde3ser10Serializer22serialize_tuple_structCs7AwuCMXPzRZ_8fvm_fuzz:
  158|    636|    fn serialize_tuple_struct(
  159|    636|        self,
  160|    636|        name: &'static str,
  161|    636|        len: usize,
  162|    636|    ) -> Result<Self::SerializeTupleStruct, Self::Error> {
  163|    636|        self.0.serialize_tuple_struct(name, len)
  164|    636|    }
_RINvXCscrDzOC3hEIR_11serde_tupleINtB3_10SerializerQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEENtNtCssVaLrL3Upj_5serde3ser10Serializer24serialize_newtype_structRINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EECs7AwuCMXPzRZ_8fvm_fuzz:
  123|    318|    fn serialize_newtype_struct<T: ?Sized>(
  124|    318|        self,
  125|    318|        name: &'static str,
  126|    318|        value: &T,
  127|    318|    ) -> Result<Self::Ok, Self::Error>
  128|    318|    where
  129|    318|        T: serde::Serialize,
  130|    318|    {
  131|       |        use serde::ser::SerializeTupleStruct;
  132|    318|        let mut out = self.serialize_tuple_struct(name, 1)?;
  133|    318|        out.serialize_field(value)?;
  134|    318|        out.end()
  135|    318|    }

_RNvXs3_NtCs6hBXtUubyyi_4sha28core_apiNtB5_13Sha256VarCoreNtNtCs9RD1cWfVxpd_6digest8core_api18VariableOutputCore22finalize_variable_core:
   60|    954|    fn finalize_variable_core(&mut self, buffer: &mut Buffer<Self>, out: &mut Output<Self>) {
   61|    954|        let bs = Self::BlockSize::U64;
   62|    954|        let bit_len = 8 * (buffer.get_pos() as u64 + bs * self.block_len);
   63|    954|        buffer.len64_padding_be(bit_len, |b| compress256(&mut self.state, from_ref(b)));
   64|       |
   65|  7.63k|        for (chunk, v) in out.chunks_exact_mut(4).zip(self.state.iter()) {
   66|  7.63k|            chunk.copy_from_slice(&v.to_be_bytes());
   67|  7.63k|        }
   68|    954|    }
_RNCNvXs3_NtCs6hBXtUubyyi_4sha28core_apiNtB7_13Sha256VarCoreNtNtCs9RD1cWfVxpd_6digest8core_api18VariableOutputCore22finalize_variable_core0CsboUdcTbF1FS_15direct_syscalls:
   63|    954|        buffer.len64_padding_be(bit_len, |b| compress256(&mut self.state, from_ref(b)));
_RNvXs3_NtCs6hBXtUubyyi_4sha28core_apiNtB5_13Sha256VarCoreNtNtCs9RD1cWfVxpd_6digest8core_api18VariableOutputCore3new:
   49|    954|    fn new(output_size: usize) -> Result<Self, InvalidOutputSize> {
   50|    954|        let state = match output_size {
   51|      0|            28 => consts::H256_224,
   52|    954|            32 => consts::H256_256,
   53|      0|            _ => return Err(InvalidOutputSize),
   54|       |        };
   55|    954|        let block_len = 0;
   56|    954|        Ok(Self { state, block_len })
   57|    954|    }

_RNvNtCs6hBXtUubyyi_4sha26sha25611compress256:
   31|    954|pub fn compress256(state: &mut [u32; 8], blocks: &[GenericArray<u8, U64>]) {
   32|    954|    // SAFETY: GenericArray<u8, U64> and [u8; 64] have
   33|    954|    // exactly the same memory layout
   34|    954|    let p = blocks.as_ptr() as *const [u8; 64];
   35|    954|    let blocks = unsafe { core::slice::from_raw_parts(p, blocks.len()) };
   36|    954|    compress(state, blocks)
   37|    954|}

_RNvNtNtCs6hBXtUubyyi_4sha26sha2564soft22sha256_digest_round_x2:
   74|  30.5k|fn sha256_digest_round_x2(cdgh: [u32; 4], abef: [u32; 4], wk: [u32; 4]) -> [u32; 4] {
   75|  30.5k|    macro_rules! big_sigma0 {
   76|  30.5k|        ($a:expr) => {
   77|  30.5k|            ($a.rotate_right(2) ^ $a.rotate_right(13) ^ $a.rotate_right(22))
   78|  30.5k|        };
   79|  30.5k|    }
   80|  30.5k|    macro_rules! big_sigma1 {
   81|  30.5k|        ($a:expr) => {
   82|  30.5k|            ($a.rotate_right(6) ^ $a.rotate_right(11) ^ $a.rotate_right(25))
   83|  30.5k|        };
   84|  30.5k|    }
   85|  30.5k|    macro_rules! bool3ary_202 {
   86|  30.5k|        ($a:expr, $b:expr, $c:expr) => {
   87|  30.5k|            $c ^ ($a & ($b ^ $c))
   88|  30.5k|        };
   89|  30.5k|    } // Choose, MD5F, SHA1C
   90|  30.5k|    macro_rules! bool3ary_232 {
   91|  30.5k|        ($a:expr, $b:expr, $c:expr) => {
   92|  30.5k|            ($a & $b) ^ ($a & $c) ^ ($b & $c)
   93|  30.5k|        };
   94|  30.5k|    } // Majority, SHA1M
   95|  30.5k|
   96|  30.5k|    let [_, _, wk1, wk0] = wk;
   97|  30.5k|    let [a0, b0, e0, f0] = abef;
   98|  30.5k|    let [c0, d0, g0, h0] = cdgh;
   99|  30.5k|
  100|  30.5k|    // a round
  101|  30.5k|    let x0 = big_sigma1!(e0)
  102|  30.5k|        .wrapping_add(bool3ary_202!(e0, f0, g0))
  103|  30.5k|        .wrapping_add(wk0)
  104|  30.5k|        .wrapping_add(h0);
  105|  30.5k|    let y0 = big_sigma0!(a0).wrapping_add(bool3ary_232!(a0, b0, c0));
  106|  30.5k|    let (a1, b1, c1, d1, e1, f1, g1, h1) = (
  107|  30.5k|        x0.wrapping_add(y0),
  108|  30.5k|        a0,
  109|  30.5k|        b0,
  110|  30.5k|        c0,
  111|  30.5k|        x0.wrapping_add(d0),
  112|  30.5k|        e0,
  113|  30.5k|        f0,
  114|  30.5k|        g0,
  115|  30.5k|    );
  116|  30.5k|
  117|  30.5k|    // a round
  118|  30.5k|    let x1 = big_sigma1!(e1)
  119|  30.5k|        .wrapping_add(bool3ary_202!(e1, f1, g1))
  120|  30.5k|        .wrapping_add(wk1)
  121|  30.5k|        .wrapping_add(h1);
  122|  30.5k|    let y1 = big_sigma0!(a1).wrapping_add(bool3ary_232!(a1, b1, c1));
  123|  30.5k|    let (a2, b2, _, _, e2, f2, _, _) = (
  124|  30.5k|        x1.wrapping_add(y1),
  125|  30.5k|        a1,
  126|  30.5k|        b1,
  127|  30.5k|        c1,
  128|  30.5k|        x1.wrapping_add(d1),
  129|  30.5k|        e1,
  130|  30.5k|        f1,
  131|  30.5k|        g1,
  132|  30.5k|    );
  133|  30.5k|
  134|  30.5k|    [a2, b2, e2, f2]
  135|  30.5k|}
_RNvNtNtCs6hBXtUubyyi_4sha26sha2564soft8schedule:
  137|  11.4k|fn schedule(v0: [u32; 4], v1: [u32; 4], v2: [u32; 4], v3: [u32; 4]) -> [u32; 4] {
  138|  11.4k|    let t1 = sha256msg1(v0, v1);
  139|  11.4k|    let t2 = sha256load(v2, v3);
  140|  11.4k|    let t3 = add(t1, t2);
  141|  11.4k|    sha256msg2(t3, v3)
  142|  11.4k|}
_RNvNtNtCs6hBXtUubyyi_4sha26sha2564soft10sha256msg1:
   43|  11.4k|fn sha256msg1(v0: [u32; 4], v1: [u32; 4]) -> [u32; 4] {
   44|  11.4k|    // sigma 0 on vectors
   45|  11.4k|    #[inline]
   46|  11.4k|    fn sigma0x4(x: [u32; 4]) -> [u32; 4] {
   47|  11.4k|        let t1 = or(shl(x, 7), shr(x, 25));
   48|  11.4k|        let t2 = or(shl(x, 18), shr(x, 14));
   49|  11.4k|        let t3 = shl(x, 3);
   50|  11.4k|        xor(xor(t1, t2), t3)
   51|  11.4k|    }
   52|  11.4k|
   53|  11.4k|    add(v0, sigma0x4(sha256load(v0, v1)))
   54|  11.4k|}
_RNvNtNtCs6hBXtUubyyi_4sha26sha2564soft3shl:
    6|  34.3k|fn shl(v: [u32; 4], o: u32) -> [u32; 4] {
    7|  34.3k|    [v[0] >> o, v[1] >> o, v[2] >> o, v[3] >> o]
    8|  34.3k|}
_RNvNtNtCs6hBXtUubyyi_4sha26sha2564soft8compress:
  206|    954|pub fn compress(state: &mut [u32; 8], blocks: &[[u8; 64]]) {
  207|    954|    let mut block_u32 = [0u32; BLOCK_LEN];
  208|    954|    // since LLVM can't properly use aliasing yet it will make
  209|    954|    // unnecessary state stores without this copy
  210|    954|    let mut state_cpy = *state;
  211|  1.90k|    for block in blocks {
  212|  15.2k|        for (o, chunk) in block_u32.iter_mut().zip(block.chunks_exact(4)) {
  213|  15.2k|            *o = u32::from_be_bytes(chunk.try_into().unwrap());
  214|  15.2k|        }
  215|    954|        sha256_digest_block_u32(&mut state_cpy, &block_u32);
  216|       |    }
  217|    954|    *state = state_cpy;
  218|    954|}
_RNvNvNtNtCs6hBXtUubyyi_4sha26sha2564soft10sha256msg18sigma0x4:
   46|  11.4k|    fn sigma0x4(x: [u32; 4]) -> [u32; 4] {
   47|  11.4k|        let t1 = or(shl(x, 7), shr(x, 25));
   48|  11.4k|        let t2 = or(shl(x, 18), shr(x, 14));
   49|  11.4k|        let t3 = shl(x, 3);
   50|  11.4k|        xor(xor(t1, t2), t3)
   51|  11.4k|    }
_RNvNtNtCs6hBXtUubyyi_4sha26sha2564soft10sha256msg2:
   56|  11.4k|fn sha256msg2(v4: [u32; 4], v3: [u32; 4]) -> [u32; 4] {
   57|  11.4k|    macro_rules! sigma1 {
   58|  11.4k|        ($a:expr) => {
   59|  11.4k|            $a.rotate_right(17) ^ $a.rotate_right(19) ^ ($a >> 10)
   60|  11.4k|        };
   61|  11.4k|    }
   62|  11.4k|
   63|  11.4k|    let [x3, x2, x1, x0] = v4;
   64|  11.4k|    let [w15, w14, _, _] = v3;
   65|  11.4k|
   66|  11.4k|    let w16 = x0.wrapping_add(sigma1!(w14));
   67|  11.4k|    let w17 = x1.wrapping_add(sigma1!(w15));
   68|  11.4k|    let w18 = x2.wrapping_add(sigma1!(w16));
   69|  11.4k|    let w19 = x3.wrapping_add(sigma1!(w17));
   70|  11.4k|
   71|  11.4k|    [w19, w18, w17, w16]
   72|  11.4k|}
_RNvNtNtCs6hBXtUubyyi_4sha26sha2564soft3shr:
   11|  22.8k|fn shr(v: [u32; 4], o: u32) -> [u32; 4] {
   12|  22.8k|    [v[0] << o, v[1] << o, v[2] << o, v[3] << o]
   13|  22.8k|}
_RNvNtNtCs6hBXtUubyyi_4sha26sha2564soft3add:
   26|  38.1k|fn add(a: [u32; 4], b: [u32; 4]) -> [u32; 4] {
   27|  38.1k|    [
   28|  38.1k|        a[0].wrapping_add(b[0]),
   29|  38.1k|        a[1].wrapping_add(b[1]),
   30|  38.1k|        a[2].wrapping_add(b[2]),
   31|  38.1k|        a[3].wrapping_add(b[3]),
   32|  38.1k|    ]
   33|  38.1k|}
_RNvNtNtCs6hBXtUubyyi_4sha26sha2564soft23sha256_digest_block_u32:
  165|    954|fn sha256_digest_block_u32(state: &mut [u32; 8], block: &[u32; 16]) {
  166|    954|    let mut abef = [state[0], state[1], state[4], state[5]];
  167|    954|    let mut cdgh = [state[2], state[3], state[6], state[7]];
  168|    954|
  169|    954|    // Rounds 0..64
  170|    954|    let mut w0 = [block[3], block[2], block[1], block[0]];
  171|    954|    let mut w1 = [block[7], block[6], block[5], block[4]];
  172|    954|    let mut w2 = [block[11], block[10], block[9], block[8]];
  173|    954|    let mut w3 = [block[15], block[14], block[13], block[12]];
  174|    954|    let mut w4;
  175|    954|
  176|    954|    rounds4!(abef, cdgh, w0, 0);
  177|    954|    rounds4!(abef, cdgh, w1, 1);
  178|    954|    rounds4!(abef, cdgh, w2, 2);
  179|    954|    rounds4!(abef, cdgh, w3, 3);
  180|    954|    schedule_rounds4!(abef, cdgh, w0, w1, w2, w3, w4, 4);
  181|    954|    schedule_rounds4!(abef, cdgh, w1, w2, w3, w4, w0, 5);
  182|    954|    schedule_rounds4!(abef, cdgh, w2, w3, w4, w0, w1, 6);
  183|    954|    schedule_rounds4!(abef, cdgh, w3, w4, w0, w1, w2, 7);
  184|    954|    schedule_rounds4!(abef, cdgh, w4, w0, w1, w2, w3, 8);
  185|    954|    schedule_rounds4!(abef, cdgh, w0, w1, w2, w3, w4, 9);
  186|    954|    schedule_rounds4!(abef, cdgh, w1, w2, w3, w4, w0, 10);
  187|    954|    schedule_rounds4!(abef, cdgh, w2, w3, w4, w0, w1, 11);
  188|    954|    schedule_rounds4!(abef, cdgh, w3, w4, w0, w1, w2, 12);
  189|    954|    schedule_rounds4!(abef, cdgh, w4, w0, w1, w2, w3, 13);
  190|    954|    schedule_rounds4!(abef, cdgh, w0, w1, w2, w3, w4, 14);
  191|    954|    schedule_rounds4!(abef, cdgh, w1, w2, w3, w4, w0, 15);
  192|    954|
  193|    954|    let [a, b, e, f] = abef;
  194|    954|    let [c, d, g, h] = cdgh;
  195|    954|
  196|    954|    state[0] = state[0].wrapping_add(a);
  197|    954|    state[1] = state[1].wrapping_add(b);
  198|    954|    state[2] = state[2].wrapping_add(c);
  199|    954|    state[3] = state[3].wrapping_add(d);
  200|    954|    state[4] = state[4].wrapping_add(e);
  201|    954|    state[5] = state[5].wrapping_add(f);
  202|    954|    state[6] = state[6].wrapping_add(g);
  203|    954|    state[7] = state[7].wrapping_add(h);
  204|    954|}
_RNvNtNtCs6hBXtUubyyi_4sha26sha2564soft2or:
   16|  22.8k|fn or(a: [u32; 4], b: [u32; 4]) -> [u32; 4] {
   17|  22.8k|    [a[0] | b[0], a[1] | b[1], a[2] | b[2], a[3] | b[3]]
   18|  22.8k|}
_RNvNtNtCs6hBXtUubyyi_4sha26sha2564soft10sha256load:
   35|  22.8k|fn sha256load(v2: [u32; 4], v3: [u32; 4]) -> [u32; 4] {
   36|  22.8k|    [v3[3], v2[0], v2[1], v2[2]]
   37|  22.8k|}
_RNvNtNtCs6hBXtUubyyi_4sha26sha2564soft3xor:
   21|  22.8k|fn xor(a: [u32; 4], b: [u32; 4]) -> [u32; 4] {
   22|  22.8k|    [a[0] ^ b[0], a[1] ^ b[1], a[2] ^ b[2], a[3] ^ b[3]]
   23|  22.8k|}
_RNvNtNtCs6hBXtUubyyi_4sha26sha2564soft10sha256swap:
   39|  15.2k|fn sha256swap(v0: [u32; 4]) -> [u32; 4] {
   40|  15.2k|    [v0[2], v0[3], v0[0], v0[1]]
   41|  15.2k|}

_RNvNtNtCs6hBXtUubyyi_4sha26sha2563x868compress:
  102|    954|pub fn compress(state: &mut [u32; 8], blocks: &[[u8; 64]]) {
  103|    954|    // TODO: Replace with https://github.com/rust-lang/rfcs/pull/2725
  104|    954|    // after stabilization
  105|    954|    if shani_cpuid::get() {
  106|      0|        unsafe {
  107|      0|            digest_blocks(state, blocks);
  108|      0|        }
  109|    954|    } else {
  110|    954|        super::soft::compress(state, blocks);
  111|    954|    }
  112|    954|}

_RNvXs1G_NtCs2n9sFhuaVtJ_14target_lexicon7targetsNtB6_15OperatingSystemNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
  434|    636|#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
_RNvXs1y_NtCs2n9sFhuaVtJ_14target_lexicon7targetsNtB6_6VendorNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
  403|    636|#[derive(Clone, Debug, PartialEq, Eq, Hash)]
_RNvXst_NtCs2n9sFhuaVtJ_14target_lexicon7targetsNtB5_12ArchitectureNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
   13|    636|#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
_RNvXs1W_NtCs2n9sFhuaVtJ_14target_lexicon7targetsNtB6_12BinaryFormatNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
  515|    636|#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
_RNvXs1O_NtCs2n9sFhuaVtJ_14target_lexicon7targetsNtB6_11EnvironmentNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
  476|    636|#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]

_RNvXsr_NtCs2n9sFhuaVtJ_14target_lexicon6tripleNtB5_6TripleNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
   87|    636|#[derive(Clone, Debug, PartialEq, Eq, Hash)]

_RNvXsk_CsfJ4C6dxOl3T_9termcolorNtB5_6BufferNtNtCsdyNNmftaNAQ_3std2io5Write5write:
 1140|  9.54k|    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
 1141|  9.54k|        match self.0 {
 1142|  9.54k|            BufferInner::NoColor(ref mut w) => w.write(buf),
 1143|      0|            BufferInner::Ansi(ref mut w) => w.write(buf),
 1144|       |            #[cfg(windows)]
 1145|       |            BufferInner::Windows(ref mut w) => w.write(buf),
 1146|       |        }
 1147|  9.54k|    }
_RNvXsn_CsfJ4C6dxOl3T_9termcolorINtB5_7NoColorINtNtCs9pDt8l5wGDA_5alloc3vec3VechEENtNtCsdyNNmftaNAQ_3std2io5Write5writeCscSNP6bGsstK_10env_logger:
 1225|  9.54k|    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
 1226|  9.54k|        self.0.write(buf)
 1227|  9.54k|    }
_RNvXsR_CsfJ4C6dxOl3T_9termcolorNtB5_5ColorNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
 1805|  1.27k|#[derive(Clone, Copy, Debug, Eq, PartialEq)]
_RNvXsl_CsfJ4C6dxOl3T_9termcolorNtB5_6BufferNtB5_10WriteColor5reset:
 1182|  1.90k|    fn reset(&mut self) -> io::Result<()> {
 1183|  1.90k|        match self.0 {
 1184|  1.90k|            BufferInner::NoColor(ref mut w) => w.reset(),
 1185|      0|            BufferInner::Ansi(ref mut w) => w.reset(),
 1186|       |            #[cfg(windows)]
 1187|       |            BufferInner::Windows(ref mut w) => w.reset(),
 1188|       |        }
 1189|  1.90k|    }
_RNvXsl_CsfJ4C6dxOl3T_9termcolorNtB5_6BufferNtB5_10WriteColor9set_color:
 1172|  1.90k|    fn set_color(&mut self, spec: &ColorSpec) -> io::Result<()> {
 1173|  1.90k|        match self.0 {
 1174|  1.90k|            BufferInner::NoColor(ref mut w) => w.set_color(spec),
 1175|      0|            BufferInner::Ansi(ref mut w) => w.set_color(spec),
 1176|       |            #[cfg(windows)]
 1177|       |            BufferInner::Windows(ref mut w) => w.set_color(spec),
 1178|       |        }
 1179|  1.90k|    }
_RNvXso_CsfJ4C6dxOl3T_9termcolorINtB5_7NoColorINtNtCs9pDt8l5wGDA_5alloc3vec3VechEENtB5_10WriteColor9set_colorCscSNP6bGsstK_10env_logger:
 1242|  1.90k|    fn set_color(&mut self, _: &ColorSpec) -> io::Result<()> {
 1243|  1.90k|        Ok(())
 1244|  1.90k|    }
_RNvXsL_CsfJ4C6dxOl3T_9termcolorNtB5_9ColorSpecNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
 1579|  1.27k|#[derive(Clone, Debug, Eq, PartialEq)]
_RNvXso_CsfJ4C6dxOl3T_9termcolorINtB5_7NoColorINtNtCs9pDt8l5wGDA_5alloc3vec3VechEENtB5_10WriteColor5resetCscSNP6bGsstK_10env_logger:
 1247|  1.90k|    fn reset(&mut self) -> io::Result<()> {
 1248|  1.90k|        Ok(())
 1249|  1.90k|    }
_RNvMsv_CsfJ4C6dxOl3T_9termcolorNtB5_9ColorSpec11set_intense:
 1741|  1.27k|    pub fn set_intense(&mut self, yes: bool) -> &mut ColorSpec {
 1742|  1.27k|        self.intense = yes;
 1743|  1.27k|        self
 1744|  1.27k|    }
_RNvMsB_CsfJ4C6dxOl3T_9termcolorINtB5_19LossyStandardStreamNtB5_16IoStandardStreamE3newB5_:
 2010|    318|    fn new(wtr: W) -> LossyStandardStream<W> {
 2011|    318|        LossyStandardStream { wtr: wtr }
 2012|    318|    }
_RNvMsi_CsfJ4C6dxOl3T_9termcolorNtB5_12BufferWriter5print:
  974|    636|    pub fn print(&self, buf: &Buffer) -> io::Result<()> {
  975|    636|        if buf.is_empty() {
  976|      0|            return Ok(());
  977|    636|        }
  978|    636|        let mut stream = self.stream.wrap(self.stream.get_ref().lock());
  979|    636|        if let Some(ref sep) = self.separator {
  980|      0|            if self.printed.load(Ordering::SeqCst) {
  981|      0|                stream.write_all(sep)?;
  982|      0|                stream.write_all(b"\n")?;
  983|      0|            }
  984|    636|        }
  985|    636|        match buf.0 {
  986|    636|            BufferInner::NoColor(ref b) => stream.write_all(&b.0)?,
  987|      0|            BufferInner::Ansi(ref b) => stream.write_all(&b.0)?,
  988|       |            #[cfg(windows)]
  989|       |            BufferInner::Windows(ref b) => {
  990|       |                // We guarantee by construction that we have a console here.
  991|       |                // Namely, a BufferWriter is the only way to produce a Buffer.
  992|       |                let console_mutex = self
  993|       |                    .console
  994|       |                    .as_ref()
  995|       |                    .expect("got Windows buffer but have no Console");
  996|       |                let mut console = console_mutex.lock().unwrap();
  997|       |                b.print(&mut *console, &mut stream)?;
  998|       |            }
  999|       |        }
 1000|    636|        self.printed.store(true, Ordering::SeqCst);
 1001|    636|        Ok(())
 1002|    636|    }
_RINvMsB_CsfJ4C6dxOl3T_9termcolorINtB6_19LossyStandardStreamNtB6_16IoStandardStreamE4wrapNtB6_20IoStandardStreamLockEB6_:
 2022|    636|    fn wrap<Q: io::Write>(&self, wtr: Q) -> LossyStandardStream<Q> {
 2023|    636|        LossyStandardStream::new(wtr)
 2024|    636|    }
_RNvMsj_CsfJ4C6dxOl3T_9termcolorNtB5_6Buffer3len:
 1085|    636|    pub fn len(&self) -> usize {
 1086|    636|        match self.0 {
 1087|    636|            BufferInner::NoColor(ref b) => b.0.len(),
 1088|      0|            BufferInner::Ansi(ref b) => b.0.len(),
 1089|       |            #[cfg(windows)]
 1090|       |            BufferInner::Windows(ref b) => b.buf.len(),
 1091|       |        }
 1092|    636|    }
_RNvMsi_CsfJ4C6dxOl3T_9termcolorNtB5_12BufferWriter6create:
  874|    318|    fn create(sty: StandardStreamType, choice: ColorChoice) -> BufferWriter {
  875|    318|        BufferWriter {
  876|    318|            stream: LossyStandardStream::new(IoStandardStream::new(sty)),
  877|    318|            printed: AtomicBool::new(false),
  878|    318|            separator: None,
  879|    318|            color_choice: choice,
  880|    318|        }
  881|    318|    }
_RNvMsj_CsfJ4C6dxOl3T_9termcolorNtB5_6Buffer8is_empty:
 1080|    636|    pub fn is_empty(&self) -> bool {
 1081|    636|        self.len() == 0
 1082|    636|    }
_RNvMsB_CsfJ4C6dxOl3T_9termcolorINtB5_19LossyStandardStreamNtB5_16IoStandardStreamE7get_refB5_:
 2031|    636|    fn get_ref(&self) -> &W {
 2032|    636|        &self.wtr
 2033|    636|    }
_RNvMsv_CsfJ4C6dxOl3T_9termcolorNtB5_9ColorSpec6set_fg:
 1618|  1.90k|    pub fn set_fg(&mut self, color: Option<Color>) -> &mut ColorSpec {
 1619|  1.90k|        self.fg_color = color;
 1620|  1.90k|        self
 1621|  1.90k|    }
_RNvMs1_CsfJ4C6dxOl3T_9termcolorNtB5_16IoStandardStream3new:
  313|    318|    fn new(sty: StandardStreamType) -> IoStandardStream {
  314|    318|        match sty {
  315|       |            StandardStreamType::Stdout => {
  316|      0|                IoStandardStream::Stdout(io::stdout())
  317|       |            }
  318|       |            StandardStreamType::Stderr => {
  319|    318|                IoStandardStream::Stderr(io::stderr())
  320|       |            }
  321|       |            StandardStreamType::StdoutBuffered => {
  322|      0|                let wtr = io::BufWriter::new(io::stdout());
  323|      0|                IoStandardStream::StdoutBuffered(wtr)
  324|       |            }
  325|       |            StandardStreamType::StderrBuffered => {
  326|      0|                let wtr = io::BufWriter::new(io::stderr());
  327|      0|                IoStandardStream::StderrBuffered(wtr)
  328|       |            }
  329|       |        }
  330|    318|    }
_RNvMsi_CsfJ4C6dxOl3T_9termcolorNtB5_12BufferWriter6stderr:
  939|    318|    pub fn stderr(choice: ColorChoice) -> BufferWriter {
  940|    318|        BufferWriter::create(StandardStreamType::Stderr, choice)
  941|    318|    }
_RNvXs3_CsfJ4C6dxOl3T_9termcolorNtB5_20IoStandardStreamLockNtNtCsdyNNmftaNAQ_3std2io5Write5write:
  381|    636|    fn write(&mut self, b: &[u8]) -> io::Result<usize> {
  382|    636|        match *self {
  383|      0|            IoStandardStreamLock::StdoutLock(ref mut s) => s.write(b),
  384|    636|            IoStandardStreamLock::StderrLock(ref mut s) => s.write(b),
  385|       |        }
  386|    636|    }
_RNvMsB_CsfJ4C6dxOl3T_9termcolorINtB5_19LossyStandardStreamNtB5_20IoStandardStreamLockE3newB5_:
 2010|    636|    fn new(wtr: W) -> LossyStandardStream<W> {
 2011|    636|        LossyStandardStream { wtr: wtr }
 2012|    636|    }
_RNvMsj_CsfJ4C6dxOl3T_9termcolorNtB5_6Buffer8no_color:
 1064|      1|    pub fn no_color() -> Buffer {
 1065|      1|        Buffer(BufferInner::NoColor(NoColor(vec![])))
 1066|      1|    }
_RNvMsj_CsfJ4C6dxOl3T_9termcolorNtB5_6Buffer5clear:
 1095|    636|    pub fn clear(&mut self) {
 1096|    636|        match self.0 {
 1097|    636|            BufferInner::NoColor(ref mut b) => b.0.clear(),
 1098|      0|            BufferInner::Ansi(ref mut b) => b.0.clear(),
 1099|       |            #[cfg(windows)]
 1100|       |            BufferInner::Windows(ref mut b) => b.clear(),
 1101|       |        }
 1102|    636|    }
_RNvMsj_CsfJ4C6dxOl3T_9termcolorNtB5_6Buffer3new:
 1035|      1|    fn new(choice: ColorChoice) -> Buffer {
 1036|      1|        if choice.should_attempt_color() {
 1037|      0|            Buffer::ansi()
 1038|       |        } else {
 1039|      1|            Buffer::no_color()
 1040|       |        }
 1041|      1|    }
_RNvMsv_CsfJ4C6dxOl3T_9termcolorNtB5_9ColorSpec3new:
 1608|  1.90k|    pub fn new() -> ColorSpec {
 1609|  1.90k|        ColorSpec::default()
 1610|  1.90k|    }
_RNvMs1_CsfJ4C6dxOl3T_9termcolorNtB5_16IoStandardStream4lock:
  332|    636|    fn lock(&self) -> IoStandardStreamLock<'_> {
  333|    636|        match *self {
  334|      0|            IoStandardStream::Stdout(ref s) => {
  335|      0|                IoStandardStreamLock::StdoutLock(s.lock())
  336|       |            }
  337|    636|            IoStandardStream::Stderr(ref s) => {
  338|    636|                IoStandardStreamLock::StderrLock(s.lock())
  339|       |            }
  340|       |            IoStandardStream::StdoutBuffered(_)
  341|       |            | IoStandardStream::StderrBuffered(_) => {
  342|       |                // We don't permit this case to ever occur in the public API,
  343|       |                // so it's OK to panic.
  344|      0|                panic!("cannot lock a buffered standard stream")
  345|       |            }
  346|       |        }
  347|    636|    }
_RNvMsi_CsfJ4C6dxOl3T_9termcolorNtB5_12BufferWriter6buffer:
  956|      1|    pub fn buffer(&self) -> Buffer {
  957|      1|        Buffer::new(self.color_choice)
  958|      1|    }
_RNvXsu_CsfJ4C6dxOl3T_9termcolorNtB5_9ColorSpecNtNtCsiloedr2K6v7_4core7default7Default7default:
 1592|  1.90k|    fn default() -> ColorSpec {
 1593|  1.90k|        ColorSpec {
 1594|  1.90k|            fg_color: None,
 1595|  1.90k|            bg_color: None,
 1596|  1.90k|            bold: false,
 1597|  1.90k|            intense: false,
 1598|  1.90k|            underline: false,
 1599|  1.90k|            dimmed: false,
 1600|  1.90k|            italic: false,
 1601|  1.90k|            reset: true,
 1602|  1.90k|        }
 1603|  1.90k|    }
_RNvMs0_CsfJ4C6dxOl3T_9termcolorNtB5_11ColorChoice20should_attempt_color:
  224|      1|    fn should_attempt_color(&self) -> bool {
  225|      1|        match *self {
  226|      0|            ColorChoice::Always => true,
  227|      0|            ColorChoice::AlwaysAnsi => true,
  228|      1|            ColorChoice::Never => false,
  229|      0|            ColorChoice::Auto => self.env_allows_color(),
  230|       |        }
  231|      1|    }
_RNvXsD_CsfJ4C6dxOl3T_9termcolorINtB5_19LossyStandardStreamNtB5_20IoStandardStreamLockENtNtCsdyNNmftaNAQ_3std2io5Write5writeB5_:
 2053|    636|    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
 2054|    636|        self.wtr.write(buf)
 2055|    636|    }

_RNvNtCsglAtTAky90E_15unsigned_varint6decode7is_last:
   90|   244k|pub fn is_last(b: u8) -> bool {
   91|   244k|    b & 0x80 == 0
   92|   244k|}
_RNvNtCsglAtTAky90E_15unsigned_varint6decode3u64:
  122|  81.4k|pub fn u64(buf: &[u8]) -> Result<(u64, &[u8]), Error> {
  123|  81.4k|    decode!(buf, 9, u64)
  124|  81.4k|}

_RNvNtCsglAtTAky90E_15unsigned_varint6encode3u64:
   69|  17.1k|pub fn u64(number: u64, buf: &mut [u8; U64_LEN]) -> &[u8] {
   70|  17.1k|    encode!(number, buf)
   71|  17.1k|}
_RNvNtCsglAtTAky90E_15unsigned_varint6encode10u64_buffer:
  119|  98.5k|pub fn u64_buffer() -> [u8; U64_LEN] {
  120|  98.5k|    [0; U64_LEN]
  121|  98.5k|}
_RNvNtCsglAtTAky90E_15unsigned_varint6encode2u8:
   45|  5.40k|pub fn u8(number: u8, buf: &mut [u8; U8_LEN]) -> &[u8] {
   46|  5.40k|    encode!(number, buf)
   47|  5.40k|}
_RNvNtCsglAtTAky90E_15unsigned_varint6encode9u8_buffer:
  101|  5.40k|pub fn u8_buffer() -> [u8; U8_LEN] {
  102|  5.40k|    [0; U8_LEN]
  103|  5.40k|}

_RINvNtCsglAtTAky90E_15unsigned_varint2io8read_u64QQRShECsboUdcTbF1FS_15direct_syscalls:
   31|  38.1k|            pub fn $name<R: io::Read>(mut reader: R) -> Result<$t, ReadError> {
   32|  38.1k|                let mut b = encode::$b();
   33|  57.2k|                for i in 0 .. b.len() {
   34|  57.2k|                    let n = reader.read(&mut b[i .. i + 1])?;
   35|  57.2k|                    if n == 0 {
   36|      0|                        return Err(ReadError::Io(io::ErrorKind::UnexpectedEof.into()))
   37|  57.2k|                    }
   38|  57.2k|                    if decode::is_last(b[i]) {
   39|  38.1k|                        return Ok(decode::$t(&b[..= i])?.0)
   40|  19.0k|                    }
   41|       |                }
   42|      0|                Err(decode::Error::Overflow.into())
   43|  38.1k|            }
_RINvNtCsglAtTAky90E_15unsigned_varint2io8read_u64QQRShECs7AwuCMXPzRZ_8fvm_fuzz:
   31|  21.6k|            pub fn $name<R: io::Read>(mut reader: R) -> Result<$t, ReadError> {
   32|  21.6k|                let mut b = encode::$b();
   33|  32.4k|                for i in 0 .. b.len() {
   34|  32.4k|                    let n = reader.read(&mut b[i .. i + 1])?;
   35|  32.4k|                    if n == 0 {
   36|      0|                        return Err(ReadError::Io(io::ErrorKind::UnexpectedEof.into()))
   37|  32.4k|                    }
   38|  32.4k|                    if decode::is_last(b[i]) {
   39|  21.6k|                        return Ok(decode::$t(&b[..= i])?.0)
   40|  10.8k|                    }
   41|       |                }
   42|      0|                Err(decode::Error::Overflow.into())
   43|  21.6k|            }
_RINvNtCsglAtTAky90E_15unsigned_varint2io8read_u64QQINtNtNtCsdyNNmftaNAQ_3std2io6cursor6CursorRINtNtCs9pDt8l5wGDA_5alloc3vec3VechEEECs7AwuCMXPzRZ_8fvm_fuzz:
   31|  21.6k|            pub fn $name<R: io::Read>(mut reader: R) -> Result<$t, ReadError> {
   32|  21.6k|                let mut b = encode::$b();
   33|  32.4k|                for i in 0 .. b.len() {
   34|  32.4k|                    let n = reader.read(&mut b[i .. i + 1])?;
   35|  32.4k|                    if n == 0 {
   36|      0|                        return Err(ReadError::Io(io::ErrorKind::UnexpectedEof.into()))
   37|  32.4k|                    }
   38|  32.4k|                    if decode::is_last(b[i]) {
   39|  21.6k|                        return Ok(decode::$t(&b[..= i])?.0)
   40|  10.8k|                    }
   41|       |                }
   42|      0|                Err(decode::Error::Overflow.into())
   43|  21.6k|            }

_RNvXse_NtCs6qGkHiX15uk_10wasmparser9validatorNtB5_12WasmFeaturesNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
  208|    636|#[derive(Hash, Debug, Copy, Clone)]
_RNvXs1_NtCs6qGkHiX15uk_10wasmparser9validatorNtB5_12WasmFeaturesNtNtCsiloedr2K6v7_4core7default7Default7default:
  267|    636|    fn default() -> WasmFeatures {
  268|    636|        WasmFeatures {
  269|    636|            // off-by-default features
  270|    636|            relaxed_simd: false,
  271|    636|            threads: false,
  272|    636|            tail_call: false,
  273|    636|            multi_memory: false,
  274|    636|            exceptions: false,
  275|    636|            memory64: false,
  276|    636|            extended_const: false,
  277|    636|            component_model: false,
  278|    636|            deterministic_only: cfg!(feature = "deterministic"),
  279|    636|
  280|    636|            // on-by-default features
  281|    636|            mutable_global: true,
  282|    636|            saturating_float_to_int: true,
  283|    636|            sign_extension: true,
  284|    636|            bulk_memory: true,
  285|    636|            multi_value: true,
  286|    636|            reference_types: true,
  287|    636|            simd: true,
  288|    636|        }
  289|    636|    }

_RNvMs3_NtCsaCHOb31h0oq_8wasmtime6configNtB5_6Config19allocation_strategy:
  994|    636|    pub fn allocation_strategy(&mut self, strategy: InstanceAllocationStrategy) -> &mut Self {
  995|    636|        self.allocation_strategy = strategy;
  996|    636|        self
  997|    636|    }
_RNvMs3_NtCsaCHOb31h0oq_8wasmtime6configNtB5_6Config16wasm_multi_value:
  736|  1.27k|    pub fn wasm_multi_value(&mut self, enable: bool) -> &mut Self {
  737|  1.27k|        self.features.multi_value = enable;
  738|  1.27k|        self
  739|  1.27k|    }
_RNvMs3_NtCsaCHOb31h0oq_8wasmtime6configNtB5_6Config22wasm_backtrace_details:
  411|    636|    pub fn wasm_backtrace_details(&mut self, enable: WasmBacktraceDetails) -> &mut Self {
  412|    636|        self.wasm_backtrace_details_env_used = false;
  413|    636|        self.tunables.parse_wasm_debuginfo = match enable {
  414|      0|            WasmBacktraceDetails::Enable => true,
  415|      0|            WasmBacktraceDetails::Disable => false,
  416|       |            WasmBacktraceDetails::Environment => {
  417|    636|                self.wasm_backtrace_details_env_used = true;
  418|    636|                std::env::var("WASMTIME_BACKTRACE_DETAILS")
  419|    636|                    .map(|s| s == "1")
  420|    636|                    .unwrap_or(false)
  421|       |            }
  422|       |        };
  423|    636|        self
  424|    636|    }
_RNvMs3_NtCsaCHOb31h0oq_8wasmtime6configNtB5_6Config10debug_info:
  379|    636|    pub fn debug_info(&mut self, enable: bool) -> &mut Self {
  380|    636|        self.tunables.generate_native_debuginfo = enable;
  381|    636|        self
  382|    636|    }
_RNvMs3_NtCsaCHOb31h0oq_8wasmtime6configNtB5_6Config14max_wasm_stack:
  604|    636|    pub fn max_wasm_stack(&mut self, size: usize) -> &mut Self {
  605|    636|        self.max_wasm_stack = size;
  606|    636|        self
  607|    636|    }
_RNvMs3_NtCsaCHOb31h0oq_8wasmtime6configNtB5_6Config14wasm_backtrace:
  395|    636|    pub fn wasm_backtrace(&mut self, enable: bool) -> &mut Self {
  396|    636|        self.wasm_backtrace = enable;
  397|    636|        self
  398|    636|    }
_RNvXsl_NtCsaCHOb31h0oq_8wasmtime6configNtB5_17ProfilingStrategyNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
 1643|    636|#[derive(Debug, Clone, Copy)]
_RNvXs6_NtCsaCHOb31h0oq_8wasmtime6configNtB5_26InstanceAllocationStrategyNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
   23|    636|#[derive(Clone)]
_RNvMs3_NtCsaCHOb31h0oq_8wasmtime6configNtB5_6Config26guard_before_linear_memory:
 1257|    636|    pub fn guard_before_linear_memory(&mut self, guard: bool) -> &mut Self {
 1258|    636|        self.tunables.guard_before_linear_memory = guard;
 1259|    636|        self
 1260|    636|    }
_RNvMs3_NtCsaCHOb31h0oq_8wasmtime6configNtB5_6Config20wasm_reference_types:
  678|  1.27k|    pub fn wasm_reference_types(&mut self, enable: bool) -> &mut Self {
  679|  1.27k|        self.features.reference_types = enable;
  680|  1.27k|        self
  681|  1.27k|    }
_RNvMs3_NtCsaCHOb31h0oq_8wasmtime6configNtB5_6Config18native_unwind_info:
  439|    636|    pub fn native_unwind_info(&mut self, enable: bool) -> &mut Self {
  440|    636|        self.native_unwind_info = enable;
  441|    636|        self
  442|    636|    }
_RNvMs3_NtCsaCHOb31h0oq_8wasmtime6configNtB5_6Config14build_profiler:
 1471|    636|    pub(crate) fn build_profiler(&self) -> Result<Box<dyn ProfilingAgent>> {
 1472|    636|        Ok(match self.profiling_strategy {
 1473|      0|            ProfilingStrategy::JitDump => Box::new(JitDumpAgent::new()?) as Box<dyn ProfilingAgent>,
 1474|      0|            ProfilingStrategy::VTune => Box::new(VTuneAgent::new()?) as Box<dyn ProfilingAgent>,
 1475|    636|            ProfilingStrategy::None => Box::new(NullProfilerAgent),
 1476|       |        })
 1477|    636|    }
_RNvXs4_NtCsaCHOb31h0oq_8wasmtime6configNtB5_6ConfigNtNtCsiloedr2K6v7_4core7default7Default7default:
 1565|    636|    fn default() -> Config {
 1566|    636|        Config::new()
 1567|    636|    }
_RNvMs3_NtCsaCHOb31h0oq_8wasmtime6configNtB5_6Config12wasm_threads:
  657|    636|    pub fn wasm_threads(&mut self, enable: bool) -> &mut Self {
  658|    636|        self.features.threads = enable;
  659|    636|        self
  660|    636|    }
_RNvMs3_NtCsaCHOb31h0oq_8wasmtime6configNtB5_6Config20parallel_compilation:
 1288|    636|    pub fn parallel_compilation(&mut self, parallel: bool) -> &mut Self {
 1289|    636|        self.parallel_compilation = parallel;
 1290|    636|        self
 1291|    636|    }
_RNvMs3_NtCsaCHOb31h0oq_8wasmtime6configNtB5_6Config17wasm_multi_memory:
  750|    636|    pub fn wasm_multi_memory(&mut self, enable: bool) -> &mut Self {
  751|    636|        self.features.multi_memory = enable;
  752|    636|        self
  753|    636|    }
_RNvXs8_NtCsaCHOb31h0oq_8wasmtime6configNtB5_6ConfigNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
   88|    636|#[derive(Clone)]
_RNvXsb_NtCsaCHOb31h0oq_8wasmtime6configNtB5_8StrategyNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
 1610|    636|#[derive(Clone, Debug, Copy)]
_RNvMs3_NtCsaCHOb31h0oq_8wasmtime6configNtB5_6Config18epoch_interruption:
  553|    636|    pub fn epoch_interruption(&mut self, enable: bool) -> &mut Self {
  554|    636|        self.tunables.epoch_interruption = enable;
  555|    636|        self
  556|    636|    }
_RNvMs3_NtCsaCHOb31h0oq_8wasmtime6configNtB5_6Config3new:
  169|    636|    pub fn new() -> Self {
  170|    636|        let mut ret = Self {
  171|    636|            tunables: Tunables::default(),
  172|    636|            #[cfg(compiler)]
  173|    636|            compiler_config: CompilerConfig::default(),
  174|    636|            #[cfg(feature = "cache")]
  175|    636|            cache_config: CacheConfig::new_cache_disabled(),
  176|    636|            profiling_strategy: ProfilingStrategy::None,
  177|    636|            mem_creator: None,
  178|    636|            allocation_strategy: InstanceAllocationStrategy::OnDemand,
  179|    636|            // 512k of stack -- note that this is chosen currently to not be too
  180|    636|            // big, not be too small, and be a good default for most platforms.
  181|    636|            // One platform of particular note is Windows where the stack size
  182|    636|            // of the main thread seems to, by default, be smaller than that of
  183|    636|            // Linux and macOS. This 512k value at least lets our current test
  184|    636|            // suite pass on the main thread of Windows (using `--test-threads
  185|    636|            // 1` forces this), or at least it passed when this change was
  186|    636|            // committed.
  187|    636|            max_wasm_stack: 512 * 1024,
  188|    636|            wasm_backtrace: true,
  189|    636|            wasm_backtrace_details_env_used: false,
  190|    636|            native_unwind_info: true,
  191|    636|            features: WasmFeatures::default(),
  192|    636|            #[cfg(feature = "async")]
  193|    636|            async_stack_size: 2 << 20,
  194|    636|            async_support: false,
  195|    636|            module_version: ModuleVersionStrategy::default(),
  196|    636|            parallel_compilation: true,
  197|    636|            memory_init_cow: true,
  198|    636|            memory_guaranteed_dense_image_size: 16 << 20,
  199|    636|            force_memory_init_memfd: false,
  200|    636|            async_stack_zeroing: false,
  201|    636|        };
  202|    636|        #[cfg(compiler)]
  203|    636|        {
  204|    636|            ret.cranelift_debug_verifier(false);
  205|    636|            ret.cranelift_opt_level(OptLevel::Speed);
  206|    636|        }
  207|    636|        ret.wasm_reference_types(true);
  208|    636|        ret.wasm_multi_value(true);
  209|    636|        ret.wasm_bulk_memory(true);
  210|    636|        ret.wasm_simd(true);
  211|    636|        ret.wasm_backtrace_details(WasmBacktraceDetails::Environment);
  212|    636|        ret
  213|    636|    }
_RNvMs3_NtCsaCHOb31h0oq_8wasmtime6configNtB5_6Config30cranelift_nan_canonicalization:
  866|    636|    pub fn cranelift_nan_canonicalization(&mut self, enable: bool) -> &mut Self {
  867|    636|        let val = if enable { "true" } else { "false" };
  868|    636|        self.compiler_config
  869|    636|            .settings
  870|    636|            .insert("enable_nan_canonicalization".to_string(), val.to_string());
  871|    636|        self
  872|    636|    }
_RNvXs2_NtCsaCHOb31h0oq_8wasmtime6configNtB5_14CompilerConfigNtNtCsiloedr2K6v7_4core7default7Default7default:
  161|    636|    fn default() -> Self {
  162|    636|        Self::new(Strategy::Auto)
  163|    636|    }
_RNvMs3_NtCsaCHOb31h0oq_8wasmtime6configNtB5_6Config19cranelift_opt_level:
  844|  1.27k|    pub fn cranelift_opt_level(&mut self, level: OptLevel) -> &mut Self {
  845|  1.27k|        let val = match level {
  846|      0|            OptLevel::None => "none",
  847|  1.27k|            OptLevel::Speed => "speed",
  848|      0|            OptLevel::SpeedAndSize => "speed_and_size",
  849|       |        };
  850|  1.27k|        self.compiler_config
  851|  1.27k|            .settings
  852|  1.27k|            .insert("opt_level".to_string(), val.to_string());
  853|  1.27k|        self
  854|  1.27k|    }
_RNvMs3_NtCsaCHOb31h0oq_8wasmtime6configNtB5_6Config15build_allocator:
 1445|    636|    pub(crate) fn build_allocator(&self) -> Result<Box<dyn InstanceAllocator>> {
 1446|    636|        #[cfg(feature = "async")]
 1447|    636|        let stack_size = self.async_stack_size;
 1448|    636|
 1449|    636|        #[cfg(not(feature = "async"))]
 1450|    636|        let stack_size = 0;
 1451|    636|
 1452|    636|        match self.allocation_strategy {
 1453|      0|            InstanceAllocationStrategy::OnDemand => Ok(Box::new(OnDemandInstanceAllocator::new(
 1454|      0|                self.mem_creator.clone(),
 1455|      0|                stack_size,
 1456|      0|            ))),
 1457|       |            #[cfg(feature = "pooling-allocator")]
 1458|       |            InstanceAllocationStrategy::Pooling {
 1459|    636|                strategy,
 1460|    636|                instance_limits,
 1461|    636|            } => Ok(Box::new(wasmtime_runtime::PoolingInstanceAllocator::new(
 1462|    636|                strategy,
 1463|    636|                instance_limits,
 1464|    636|                stack_size,
 1465|    636|                &self.tunables,
 1466|    636|                self.async_stack_zeroing,
 1467|    636|            )?)),
 1468|       |        }
 1469|    636|    }
_RNvMs3_NtCsaCHOb31h0oq_8wasmtime6configNtB5_6Config13wasm_memory64:
  765|    636|    pub fn wasm_memory64(&mut self, enable: bool) -> &mut Self {
  766|    636|        self.features.memory64 = enable;
  767|    636|        self
  768|    636|    }
_RNvMs3_NtCsaCHOb31h0oq_8wasmtime6configNtB5_6Config12consume_fuel:
  459|    636|    pub fn consume_fuel(&mut self, enable: bool) -> &mut Self {
  460|    636|        self.tunables.consume_fuel = enable;
  461|    636|        self
  462|    636|    }
_RNvXsa_NtCsaCHOb31h0oq_8wasmtime6configNtB5_14CompilerConfigNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
  117|    636|#[derive(Debug, Clone)]
_RNvMs3_NtCsaCHOb31h0oq_8wasmtime6configNtB5_6Config8validate:
 1422|    636|    pub(crate) fn validate(&self) -> Result<()> {
 1423|    636|        if self.features.reference_types && !self.features.bulk_memory {
 1424|      0|            bail!("feature 'reference_types' requires 'bulk_memory' to be enabled");
 1425|    636|        }
 1426|    636|        if self.features.threads && !self.features.bulk_memory {
 1427|      0|            bail!("feature 'threads' requires 'bulk_memory' to be enabled");
 1428|    636|        }
 1429|    636|        #[cfg(feature = "async")]
 1430|    636|        if self.max_wasm_stack > self.async_stack_size {
 1431|    636|            bail!("max_wasm_stack size cannot exceed the async_stack_size");
 1432|    636|        }
 1433|    636|        if self.max_wasm_stack == 0 {
 1434|      0|            bail!("max_wasm_stack size cannot be zero");
 1435|    636|        }
 1436|    636|        if self.tunables.static_memory_offset_guard_size
 1437|    636|            < self.tunables.dynamic_memory_offset_guard_size
 1438|       |        {
 1439|      0|            bail!("static memory guard size cannot be smaller than dynamic memory guard size");
 1440|    636|        }
 1441|    636|
 1442|    636|        Ok(())
 1443|    636|    }
_RNvMs1_NtCsaCHOb31h0oq_8wasmtime6configNtB5_14CompilerConfig3new:
  129|    636|    fn new(strategy: Strategy) -> Self {
  130|    636|        Self {
  131|    636|            strategy,
  132|    636|            target: None,
  133|    636|            settings: HashMap::new(),
  134|    636|            flags: HashSet::new(),
  135|    636|            cache_store: None,
  136|    636|        }
  137|    636|    }
_RNvMs3_NtCsaCHOb31h0oq_8wasmtime6configNtB5_6Config9wasm_simd:
  699|  1.27k|    pub fn wasm_simd(&mut self, enable: bool) -> &mut Self {
  700|  1.27k|        self.features.simd = enable;
  701|  1.27k|        self
  702|  1.27k|    }
_RNvMs3_NtCsaCHOb31h0oq_8wasmtime6configNtB5_6Config24cranelift_debug_verifier:
  827|  1.27k|    pub fn cranelift_debug_verifier(&mut self, enable: bool) -> &mut Self {
  828|  1.27k|        let val = if enable { "true" } else { "false" };
  829|  1.27k|        self.compiler_config
  830|  1.27k|            .settings
  831|  1.27k|            .insert("enable_verifier".to_string(), val.to_string());
  832|  1.27k|        self
  833|  1.27k|    }
_RNvMs3_NtCsaCHOb31h0oq_8wasmtime6configNtB5_6Config20generate_address_map:
 1302|    636|    pub fn generate_address_map(&mut self, generate: bool) -> &mut Self {
 1303|    636|        self.tunables.generate_address_map = generate;
 1304|    636|        self
 1305|    636|    }
_RNvXs0_NtCsaCHOb31h0oq_8wasmtime6configNtB5_21ModuleVersionStrategyNtNtCsiloedr2K6v7_4core7default7Default7default:
   75|    636|    fn default() -> Self {
   76|    636|        ModuleVersionStrategy::WasmtimeVersion
   77|    636|    }
_RNvMs3_NtCsaCHOb31h0oq_8wasmtime6configNtB5_6Config26static_memory_maximum_size:
 1087|    636|    pub fn static_memory_maximum_size(&mut self, max_size: u64) -> &mut Self {
 1088|    636|        let max_pages = max_size / u64::from(wasmtime_environ::WASM_PAGE_SIZE);
 1089|    636|        self.tunables.static_memory_bound = max_pages;
 1090|    636|        self
 1091|    636|    }
_RNvMs3_NtCsaCHOb31h0oq_8wasmtime6configNtB5_6Config14build_compiler:
 1480|    636|    pub(crate) fn build_compiler(&mut self) -> Result<Box<dyn wasmtime_environ::Compiler>> {
 1481|    636|        let mut compiler = match self.compiler_config.strategy {
 1482|    636|            Strategy::Auto | Strategy::Cranelift => wasmtime_cranelift::builder(),
 1483|       |        };
 1484|    636|        if let Some(target) = &self.compiler_config.target {
 1485|      0|            compiler.target(target.clone())?;
 1486|    636|        }
 1487|       |
 1488|    636|        if self.native_unwind_info ||
 1489|       |            // Windows always needs unwind info, since it is part of the ABI.
 1490|    636|            self
 1491|    636|                .compiler_config
 1492|    636|                .target
 1493|    636|                .as_ref()
 1494|    636|                .map_or(cfg!(target_os = "windows"), |target| {
 1495|       |                    target.operating_system == target_lexicon::OperatingSystem::Windows
 1496|    636|                })
 1497|       |        {
 1498|      0|            if !self
 1499|      0|                .compiler_config
 1500|      0|                .ensure_setting_unset_or_given("unwind_info", "true")
 1501|       |            {
 1502|      0|                bail!("compiler option 'unwind_info' must be enabled profiling");
 1503|      0|            }
 1504|    636|        }
 1505|       |
 1506|       |        // We require frame pointers for correct stack walking, which is safety
 1507|       |        // critical in the presence of reference types, and otherwise it is just
 1508|       |        // really bad developer experience to get wrong.
 1509|    636|        self.compiler_config
 1510|    636|            .settings
 1511|    636|            .insert("preserve_frame_pointers".into(), "true".into());
 1512|    636|
 1513|    636|        // check for incompatible compiler options and set required values
 1514|    636|        if self.features.reference_types {
 1515|      0|            if !self
 1516|      0|                .compiler_config
 1517|      0|                .ensure_setting_unset_or_given("enable_safepoints", "true")
 1518|       |            {
 1519|      0|                bail!("compiler option 'enable_safepoints' must be enabled when 'reference types' is enabled");
 1520|      0|            }
 1521|    636|        }
 1522|    636|        if self.features.simd {
 1523|      0|            if !self
 1524|      0|                .compiler_config
 1525|      0|                .ensure_setting_unset_or_given("enable_simd", "true")
 1526|       |            {
 1527|      0|                bail!("compiler option 'enable_simd' must be enabled when 'simd' is enabled");
 1528|      0|            }
 1529|    636|        }
 1530|       |
 1531|       |        // Apply compiler settings and flags
 1532|  2.54k|        for (k, v) in self.compiler_config.settings.iter() {
 1533|  2.54k|            compiler.set(k, v)?;
 1534|       |        }
 1535|    636|        for flag in self.compiler_config.flags.iter() {
 1536|      0|            compiler.enable(flag)?;
 1537|       |        }
 1538|       |
 1539|    636|        if let Some(cache_store) = &self.compiler_config.cache_store {
 1540|      0|            compiler.enable_incremental_compilation(cache_store.clone());
 1541|    636|        }
 1542|       |
 1543|    636|        compiler.build()
 1544|    636|    }
_RNvMs3_NtCsaCHOb31h0oq_8wasmtime6configNtB5_6Config16wasm_bulk_memory:
  722|  1.27k|    pub fn wasm_bulk_memory(&mut self, enable: bool) -> &mut Self {
  723|  1.27k|        self.features.bulk_memory = enable;
  724|  1.27k|        self
  725|  1.27k|    }
_RNvXs7_NtCsaCHOb31h0oq_8wasmtime6configNtB5_21ModuleVersionStrategyNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
   63|    636|#[derive(Clone)]
_RNvMs3_NtCsaCHOb31h0oq_8wasmtime6configNtB5_6Config15memory_init_cow:
 1348|    636|    pub fn memory_init_cow(&mut self, enable: bool) -> &mut Self {
 1349|    636|        self.memory_init_cow = enable;
 1350|    636|        self
 1351|    636|    }

_RNvMNtCsaCHOb31h0oq_8wasmtime6engineNtB2_6Engine6config:
  126|  1.27k|    pub fn config(&self) -> &Config {
  127|  1.27k|        &self.inner.config
  128|  1.27k|    }
_RNvXs0_NtCsaCHOb31h0oq_8wasmtime6engineNtB5_6EngineNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
   37|    636|#[derive(Clone)]
_RNvMNtCsaCHOb31h0oq_8wasmtime6engineNtB2_6Engine3new:
   70|    636|    pub fn new(config: &Config) -> Result<Engine> {
   71|    636|        // Ensure that wasmtime_runtime's signal handlers are configured. This
   72|    636|        // is the per-program initialization required for handling traps, such
   73|    636|        // as configuring signals, vectored exception handlers, etc.
   74|    636|        wasmtime_runtime::init_traps(crate::module::is_wasm_trap_pc);
   75|    636|        debug_builtins::ensure_exported();
   76|    636|
   77|    636|        let registry = SignatureRegistry::new();
   78|    636|        let mut config = config.clone();
   79|    636|        config.validate()?;
   80|       |
   81|       |        #[cfg(compiler)]
   82|    636|        let compiler = config.build_compiler()?;
   83|       |
   84|    636|        let allocator = config.build_allocator()?;
   85|    636|        allocator.adjust_tunables(&mut config.tunables);
   86|    636|        let profiler = config.build_profiler()?;
   87|       |
   88|    636|        Ok(Engine {
   89|    636|            inner: Arc::new(EngineInner {
   90|    636|                #[cfg(compiler)]
   91|    636|                compiler,
   92|    636|                config,
   93|    636|                allocator,
   94|    636|                profiler,
   95|    636|                signatures: registry,
   96|    636|                epoch: AtomicU64::new(0),
   97|    636|                unique_id_allocator: CompiledModuleIdAllocator::new(),
   98|    636|                compatible_with_native_host: OnceCell::new(),
   99|    636|            }),
  100|    636|        })
  101|    636|    }
_RNvMNtCsaCHOb31h0oq_8wasmtime6engineNtB2_6Engine13epoch_counter:
  157|  1.90k|    pub(crate) fn epoch_counter(&self) -> &AtomicU64 {
  158|  1.90k|        &self.inner.epoch
  159|  1.90k|    }
_RNvMNtCsaCHOb31h0oq_8wasmtime6engineNtB2_6Engine9allocator:
  135|    636|    pub(crate) fn allocator(&self) -> &dyn InstanceAllocator {
  136|    636|        self.inner.allocator.as_ref()
  137|    636|    }

_RINvMs4_NtCsaCHOb31h0oq_8wasmtime9externalsNtB6_6Global3newQINtNtB8_5store5StoreuEECskJihg1y13m7_3fvm:
  244|    636|    pub fn new(mut store: impl AsContextMut, ty: GlobalType, val: Val) -> Result<Global> {
  245|    636|        Global::_new(store.as_context_mut().0, ty, val)
  246|    636|    }
_RNvMs4_NtCsaCHOb31h0oq_8wasmtime9externalsNtB5_6Global4__new:
  248|    636|    fn _new(store: &mut StoreOpaque, ty: GlobalType, val: Val) -> Result<Global> {
  249|    636|        if !val.comes_from_same_store(store) {
  250|      0|            bail!("cross-`Store` globals are not supported");
  251|    636|        }
  252|    636|        if val.ty() != *ty.content() {
  253|      0|            bail!("value provided does not match the type of this global");
  254|    636|        }
  255|       |        unsafe {
  256|    636|            let wasmtime_export = generate_global_export(store, &ty, val)?;
  257|    636|            Ok(Global::from_wasmtime_global(wasmtime_export, store))
  258|       |        }
  259|    636|    }
_RNvMs4_NtCsaCHOb31h0oq_8wasmtime9externalsNtB5_6Global20from_wasmtime_global:
  346|    636|    pub(crate) unsafe fn from_wasmtime_global(
  347|    636|        wasmtime_export: wasmtime_runtime::ExportGlobal,
  348|    636|        store: &mut StoreOpaque,
  349|    636|    ) -> Global {
  350|    636|        Global(store.store_data_mut().insert(wasmtime_export))
  351|    636|    }

_RINvMs0_NtCsaCHOb31h0oq_8wasmtime6memoryNtB6_6Memory3newQINtNtB8_5store5StoreuEECskJihg1y13m7_3fvm:
  231|    636|    pub fn new(mut store: impl AsContextMut, ty: MemoryType) -> Result<Memory> {
  232|    636|        Self::_new(store.as_context_mut().0, ty)
  233|    636|    }
_RNvMs0_NtCsaCHOb31h0oq_8wasmtime6memoryNtB5_6Memory20from_wasmtime_memory:
  550|    636|    pub(crate) unsafe fn from_wasmtime_memory(
  551|    636|        wasmtime_export: wasmtime_runtime::ExportMemory,
  552|    636|        store: &mut StoreOpaque,
  553|    636|    ) -> Memory {
  554|    636|        Memory(store.store_data_mut().insert(wasmtime_export))
  555|    636|    }
_RNvMs0_NtCsaCHOb31h0oq_8wasmtime6memoryNtB5_6Memory4__new:
  261|    636|    fn _new(store: &mut StoreOpaque, ty: MemoryType) -> Result<Memory> {
  262|       |        unsafe {
  263|    636|            let export = generate_memory_export(store, &ty, None)?;
  264|    636|            Ok(Memory::from_wasmtime_memory(export, store))
  265|       |        }
  266|    636|    }

_RNvXs4_NtCsaCHOb31h0oq_8wasmtime6moduleNtB5_14BareModuleInfoNtCslvZ9xuS3Qdd_16wasmtime_runtime17ModuleRuntimeInfo6module:
 1035|  13.3k|    fn module(&self) -> &Arc<wasmtime_environ::Module> {
 1036|  13.3k|        &self.module
 1037|  13.3k|    }
_RNvMs3_NtCsaCHOb31h0oq_8wasmtime6moduleNtB5_14BareModuleInfo5empty:
 1008|    636|    pub(crate) fn empty(module: Arc<wasmtime_environ::Module>) -> Self {
 1009|    636|        BareModuleInfo {
 1010|    636|            module,
 1011|    636|            image_base: 0,
 1012|    636|            one_signature: None,
 1013|    636|            function_info: PrimaryMap::default(),
 1014|    636|        }
 1015|    636|    }
_RNvMs3_NtCsaCHOb31h0oq_8wasmtime6moduleNtB5_14BareModuleInfo13into_traitobj:
 1029|  1.90k|    pub(crate) fn into_traitobj(self) -> Arc<dyn wasmtime_runtime::ModuleRuntimeInfo> {
 1030|  1.90k|        Arc::new(self)
 1031|  1.90k|    }
_RNvMs3_NtCsaCHOb31h0oq_8wasmtime6moduleNtB5_14BareModuleInfo19maybe_imported_func:
 1017|  1.27k|    pub(crate) fn maybe_imported_func(
 1018|  1.27k|        module: Arc<wasmtime_environ::Module>,
 1019|  1.27k|        one_signature: Option<(SignatureIndex, VMSharedSignatureIndex)>,
 1020|  1.27k|    ) -> Self {
 1021|  1.27k|        BareModuleInfo {
 1022|  1.27k|            module,
 1023|  1.27k|            image_base: 0,
 1024|  1.27k|            one_signature,
 1025|  1.27k|            function_info: PrimaryMap::default(),
 1026|  1.27k|        }
 1027|  1.27k|    }
_RNvXs4_NtCsaCHOb31h0oq_8wasmtime6moduleNtB5_14BareModuleInfoNtCslvZ9xuS3Qdd_16wasmtime_runtime17ModuleRuntimeInfo13signature_ids:
 1067|  1.90k|    fn signature_ids(&self) -> &[VMSharedSignatureIndex] {
 1068|  1.90k|        match &self.one_signature {
 1069|      0|            Some((_, id)) => std::slice::from_ref(id),
 1070|  1.90k|            None => &[],
 1071|       |        }
 1072|  1.90k|    }

_RNvXs_NtNtCsaCHOb31h0oq_8wasmtime6module8registryNtB4_14ModuleRegistryNtNtCsiloedr2K6v7_4core7default7Default7default:
   28|    636|#[derive(Default)]

_RNvMs2_NtCsaCHOb31h0oq_8wasmtime10signaturesNtB5_17SignatureRegistry3new:
  217|    636|    pub fn new() -> Self {
  218|    636|        Self(Arc::new(RwLock::new(SignatureRegistryInner::default())))
  219|    636|    }
_RNvXs6_NtCsaCHOb31h0oq_8wasmtime10signaturesNtB5_22SignatureRegistryInnerNtNtCsiloedr2K6v7_4core7default7Default7default:
   80|    636|#[derive(Debug, Default)]
_RNvXs1_NtCsaCHOb31h0oq_8wasmtime10signaturesNtB5_22SignatureRegistryInnerNtNtNtCsiloedr2K6v7_4core3ops4drop4Drop4drop:
  198|    636|    fn drop(&mut self) {
  199|    636|        assert!(
  200|    636|            self.map.is_empty() && self.free.len() == self.entries.len(),
  201|      0|            "signature registry not empty"
  202|       |        );
  203|    636|    }

_RNvMs9_NtCsaCHOb31h0oq_8wasmtime5storeNtB5_11StoreOpaque6engine:
 1157|  1.27k|    pub fn engine(&self) -> &Engine {
 1158|  1.27k|        &self.engine
 1159|  1.27k|    }
_RNvMs9_NtCsaCHOb31h0oq_8wasmtime5storeNtB5_11StoreOpaque14store_data_mut:
 1167|  1.27k|    pub fn store_data_mut(&mut self) -> &mut StoreData {
 1168|  1.27k|        &mut self.store_data
 1169|  1.27k|    }
_RNvMs9_NtCsaCHOb31h0oq_8wasmtime5storeNtB5_11StoreOpaque16vmruntime_limits:
 1452|  1.90k|    pub fn vmruntime_limits(&self) -> *mut VMRuntimeLimits {
 1453|  1.90k|        &self.runtime_limits as *const VMRuntimeLimits as *mut VMRuntimeLimits
 1454|  1.90k|    }
_RNvXs_NtCsaCHOb31h0oq_8wasmtime5storeINtB4_10StoreInneruENtNtNtCsiloedr2K6v7_4core3ops5deref5Deref5derefCskJihg1y13m7_3fvm:
  234|  3.81k|    fn deref(&self) -> &Self::Target {
  235|  3.81k|        &self.inner
  236|  3.81k|    }
_RNvXs0_NtCsaCHOb31h0oq_8wasmtime5storeINtB5_10StoreInneruENtNtNtCsiloedr2K6v7_4core3ops5deref8DerefMut9deref_mutCskJihg1y13m7_3fvm:
  240|  1.90k|    fn deref_mut(&mut self) -> &mut Self::Target {
  241|  1.90k|        &mut self.inner
  242|  1.90k|    }
_RNvXsb_NtCsaCHOb31h0oq_8wasmtime5storeINtB5_10StoreInneruENtCslvZ9xuS3Qdd_16wasmtime_runtime5Store16vmruntime_limitsCskJihg1y13m7_3fvm:
 1793|  1.90k|    fn vmruntime_limits(&self) -> *mut VMRuntimeLimits {
 1794|  1.90k|        <StoreOpaque>::vmruntime_limits(self)
 1795|  1.90k|    }
_RNvXsf_NtCsaCHOb31h0oq_8wasmtime5storeINtB5_5StoreuENtNtNtCsiloedr2K6v7_4core3ops4drop4Drop4dropCskJihg1y13m7_3fvm:
 2026|    636|    fn drop(&mut self) {
 2027|    636|        // for documentation on this `unsafe`, see `into_data`.
 2028|    636|        unsafe {
 2029|    636|            ManuallyDrop::drop(&mut self.inner.data);
 2030|    636|            ManuallyDrop::drop(&mut self.inner);
 2031|    636|        }
 2032|    636|    }
_RNvXsb_NtCsaCHOb31h0oq_8wasmtime5storeINtB5_10StoreInneruENtCslvZ9xuS3Qdd_16wasmtime_runtime5Store9epoch_ptrCskJihg1y13m7_3fvm:
 1797|  1.90k|    fn epoch_ptr(&self) -> *const AtomicU64 {
 1798|  1.90k|        self.engine.epoch_counter() as *const _
 1799|  1.90k|    }
_RNvXsb_NtCsaCHOb31h0oq_8wasmtime5storeINtB5_10StoreInneruENtCslvZ9xuS3Qdd_16wasmtime_runtime5Store14memory_growingCskJihg1y13m7_3fvm:
 1811|    636|    fn memory_growing(
 1812|    636|        &mut self,
 1813|    636|        current: usize,
 1814|    636|        desired: usize,
 1815|    636|        maximum: Option<usize>,
 1816|    636|    ) -> Result<bool, anyhow::Error> {
 1817|    636|        match self.limiter {
 1818|      0|            Some(ResourceLimiterInner::Sync(ref mut limiter)) => {
 1819|      0|                Ok(limiter(&mut self.data).memory_growing(current, desired, maximum))
 1820|       |            }
 1821|       |            #[cfg(feature = "async")]
 1822|       |            Some(ResourceLimiterInner::Async(ref mut limiter)) => unsafe {
 1823|       |                Ok(self
 1824|       |                    .inner
 1825|       |                    .async_cx()
 1826|       |                    .expect("ResourceLimiterAsync requires async Store")
 1827|       |                    .block_on(
 1828|       |                        limiter(&mut self.data)
 1829|       |                            .memory_growing(current, desired, maximum)
 1830|       |                            .as_mut(),
 1831|       |                    )?)
 1832|       |            },
 1833|    636|            None => Ok(true),
 1834|       |        }
 1835|    636|    }
_RNvXsb_NtCsaCHOb31h0oq_8wasmtime5storeINtB5_10StoreInneruENtCslvZ9xuS3Qdd_16wasmtime_runtime5Store27externref_activations_tableCskJihg1y13m7_3fvm:
 1801|  1.90k|    fn externref_activations_table(
 1802|  1.90k|        &mut self,
 1803|  1.90k|    ) -> (
 1804|  1.90k|        &mut VMExternRefActivationsTable,
 1805|  1.90k|        &dyn wasmtime_runtime::ModuleInfoLookup,
 1806|  1.90k|    ) {
 1807|  1.90k|        let inner = &mut self.inner;
 1808|  1.90k|        (&mut inner.externref_activations_table, &inner.modules)
 1809|  1.90k|    }
_RNvMs5_NtCsaCHOb31h0oq_8wasmtime5storeINtB5_5StoreuE3newCskJihg1y13m7_3fvm:
  450|    636|    pub fn new(engine: &Engine, data: T) -> Self {
  451|    636|        // Wasmtime uses the callee argument to host functions to learn about
  452|    636|        // the original pointer to the `Store` itself, allowing it to
  453|    636|        // reconstruct a `StoreContextMut<T>`. When we initially call a `Func`,
  454|    636|        // however, there's no "callee" to provide. To fix this we allocate a
  455|    636|        // single "default callee" for the entire `Store`. This is then used as
  456|    636|        // part of `Func::call` to guarantee that the `callee: *mut VMContext`
  457|    636|        // is never null.
  458|    636|        let default_callee = unsafe {
  459|    636|            let module = Arc::new(wasmtime_environ::Module::default());
  460|    636|            let shim = BareModuleInfo::empty(module).into_traitobj();
  461|    636|            OnDemandInstanceAllocator::default()
  462|    636|                .allocate(InstanceAllocationRequest {
  463|    636|                    host_state: Box::new(()),
  464|    636|                    imports: Default::default(),
  465|    636|                    store: StorePtr::empty(),
  466|    636|                    runtime_info: &shim,
  467|    636|                })
  468|    636|                .expect("failed to allocate default callee")
  469|    636|        };
  470|    636|
  471|    636|        let mut inner = Box::new(StoreInner {
  472|    636|            inner: StoreOpaque {
  473|    636|                _marker: marker::PhantomPinned,
  474|    636|                engine: engine.clone(),
  475|    636|                runtime_limits: Default::default(),
  476|    636|                instances: Vec::new(),
  477|    636|                signal_handler: None,
  478|    636|                externref_activations_table: VMExternRefActivationsTable::new(),
  479|    636|                modules: ModuleRegistry::default(),
  480|    636|                host_trampolines: HashMap::default(),
  481|    636|                host_func_trampolines_registered: 0,
  482|    636|                instance_count: 0,
  483|    636|                instance_limit: crate::DEFAULT_INSTANCE_LIMIT,
  484|    636|                memory_count: 0,
  485|    636|                memory_limit: crate::DEFAULT_MEMORY_LIMIT,
  486|    636|                table_count: 0,
  487|    636|                table_limit: crate::DEFAULT_TABLE_LIMIT,
  488|    636|                fuel_adj: 0,
  489|    636|                #[cfg(feature = "async")]
  490|    636|                async_state: AsyncState {
  491|    636|                    current_suspend: UnsafeCell::new(ptr::null()),
  492|    636|                    current_poll_cx: UnsafeCell::new(ptr::null_mut()),
  493|    636|                },
  494|    636|                out_of_gas_behavior: OutOfGas::Trap,
  495|    636|                store_data: ManuallyDrop::new(StoreData::new()),
  496|    636|                default_caller: default_callee,
  497|    636|                hostcall_val_storage: Vec::new(),
  498|    636|                wasm_val_raw_storage: Vec::new(),
  499|    636|                rooted_host_funcs: ManuallyDrop::new(Vec::new()),
  500|    636|            },
  501|    636|            limiter: None,
  502|    636|            call_hook: None,
  503|    636|            epoch_deadline_behavior: EpochDeadline::Trap,
  504|    636|            data: ManuallyDrop::new(data),
  505|    636|        });
  506|    636|
  507|    636|        // Once we've actually allocated the store itself we can configure the
  508|    636|        // trait object pointer of the default callee. Note the erasure of the
  509|    636|        // lifetime here into `'static`, so in general usage of this trait
  510|    636|        // object must be strictly bounded to the `Store` itself, and is a
  511|    636|        // variant that we have to maintain throughout Wasmtime.
  512|    636|        unsafe {
  513|    636|            let traitobj = std::mem::transmute::<
  514|    636|                *mut (dyn wasmtime_runtime::Store + '_),
  515|    636|                *mut (dyn wasmtime_runtime::Store + 'static),
  516|    636|            >(&mut *inner);
  517|    636|            inner.default_caller.set_store(traitobj);
  518|    636|        }
  519|    636|
  520|    636|        Self {
  521|    636|            inner: ManuallyDrop::new(inner),
  522|    636|        }
  523|    636|    }
_RNvMs9_NtCsaCHOb31h0oq_8wasmtime5storeNtB5_11StoreOpaque12add_instance:
 1181|  1.27k|    pub unsafe fn add_instance(&mut self, handle: InstanceHandle, ondemand: bool) -> InstanceId {
 1182|  1.27k|        self.instances.push(StoreInstance {
 1183|  1.27k|            handle: handle.clone(),
 1184|  1.27k|            ondemand,
 1185|  1.27k|        });
 1186|  1.27k|        InstanceId(self.instances.len() - 1)
 1187|  1.27k|    }
_RNvMs9_NtCsaCHOb31h0oq_8wasmtime5storeNtB5_11StoreOpaque8traitobj:
 1465|  1.90k|    pub fn traitobj(&self) -> *mut dyn wasmtime_runtime::Store {
 1466|  1.90k|        self.default_caller.store()
 1467|  1.90k|    }
_RNvXsg_NtCsaCHOb31h0oq_8wasmtime5storeNtB5_11StoreOpaqueNtNtNtCsiloedr2K6v7_4core3ops4drop4Drop4drop:
 2036|    636|    fn drop(&mut self) {
 2037|    636|        // NB it's important that this destructor does not access `self.data`.
 2038|    636|        // That is deallocated by `Drop for Store<T>` above.
 2039|    636|
 2040|    636|        unsafe {
 2041|    636|            let allocator = self.engine.allocator();
 2042|    636|            let ondemand = OnDemandInstanceAllocator::default();
 2043|  1.27k|            for instance in self.instances.iter() {
 2044|  1.27k|                if instance.ondemand {
 2045|  1.27k|                    ondemand.deallocate(&instance.handle);
 2046|  1.27k|                } else {
 2047|      0|                    allocator.deallocate(&instance.handle);
 2048|      0|                }
 2049|       |            }
 2050|    636|            ondemand.deallocate(&self.default_caller);
 2051|    636|
 2052|    636|            // See documentation for these fields on `StoreOpaque` for why they
 2053|    636|            // must be dropped in this order.
 2054|    636|            ManuallyDrop::drop(&mut self.store_data);
 2055|    636|            ManuallyDrop::drop(&mut self.rooted_host_funcs);
 2056|    636|        }
 2057|    636|    }
_RNvMs9_NtCsaCHOb31h0oq_8wasmtime5storeNtB5_11StoreOpaque12instance_mut:
 1193|  1.27k|    pub fn instance_mut(&mut self, id: InstanceId) -> &mut InstanceHandle {
 1194|  1.27k|        &mut self.instances[id.0].handle
 1195|  1.27k|    }

_RNvXs0_NtNtCsaCHOb31h0oq_8wasmtime5store7contextINtB7_5StoreuENtB5_12AsContextMut14as_context_mutCskJihg1y13m7_3fvm:
  134|  1.27k|    fn as_context_mut(&mut self) -> StoreContextMut<'_, T> {
  135|  1.27k|        StoreContextMut(&mut self.inner)
  136|  1.27k|    }
_RNvXs9_NtNtCsaCHOb31h0oq_8wasmtime5store7contextQINtB7_5StoreuENtB5_12AsContextMut14as_context_mutCskJihg1y13m7_3fvm:
  214|  1.27k|    fn as_context_mut(&mut self) -> StoreContextMut<'_, T::Data> {
  215|  1.27k|        T::as_context_mut(*self)
  216|  1.27k|    }

_RNvXsf_NtNtCsaCHOb31h0oq_8wasmtime5store4dataNtNtCslvZ9xuS3Qdd_16wasmtime_runtime6export12ExportGlobalNtB5_10StoredData8list_mut:
   38|    636|            fn list_mut(data: &mut StoreData) -> &mut Vec<Self> { &mut data.$field }
_RNvMs5_NtNtCsaCHOb31h0oq_8wasmtime5store4dataNtB5_7StoreId8allocate:
  200|    636|    fn allocate() -> StoreId {
  201|    636|        static NEXT_ID: AtomicU64 = AtomicU64::new(0);
  202|    636|
  203|    636|        // Only allow 2^63 stores at which point we start panicking to prevent
  204|    636|        // overflow.
  205|    636|        //
  206|    636|        // If a store is created once per microsecond then this will last the
  207|    636|        // current process for 584,540 years before overflowing.
  208|    636|        //
  209|    636|        // Also note the usage of `Relaxed` ordering here which should be ok
  210|    636|        // since we're only looking for atomicity on this counter and this
  211|    636|        // otherwise isn't used to synchronize memory stored anywhere else.
  212|    636|        let id = NEXT_ID.fetch_add(1, Relaxed);
  213|    636|        if id & (1 << 63) != 0 {
  214|      0|            NEXT_ID.store(1 << 63, Relaxed);
  215|      0|            panic!("store id allocator overflow");
  216|    636|        }
  217|    636|
  218|    636|        StoreId(NonZeroU64::new(id + 1).unwrap())
  219|    636|    }
_RINvMNtNtCsaCHOb31h0oq_8wasmtime5store4dataNtB3_9StoreData6insertNtNtCslvZ9xuS3Qdd_16wasmtime_runtime6export12ExportMemoryEB7_:
   69|    636|    pub fn insert<T>(&mut self, data: T) -> Stored<T>
   70|    636|    where
   71|    636|        T: StoredData,
   72|    636|    {
   73|    636|        let list = T::list_mut(self);
   74|    636|        let index = list.len();
   75|    636|        list.push(data);
   76|    636|        Stored::new(self.id, index)
   77|    636|    }
_RNvMNtNtCsaCHOb31h0oq_8wasmtime5store4dataNtB2_9StoreData3new:
   52|    636|    pub fn new() -> StoreData {
   53|    636|        StoreData {
   54|    636|            id: StoreId::allocate(),
   55|    636|            funcs: Vec::new(),
   56|    636|            tables: Vec::new(),
   57|    636|            globals: Vec::new(),
   58|    636|            instances: Vec::new(),
   59|    636|            memories: Vec::new(),
   60|    636|            #[cfg(feature = "component-model")]
   61|    636|            components: Default::default(),
   62|    636|        }
   63|    636|    }
_RNvMs6_NtNtCsaCHOb31h0oq_8wasmtime5store4dataINtB5_6StoredNtNtCslvZ9xuS3Qdd_16wasmtime_runtime6export12ExportMemoryE3newB9_:
  238|    636|    fn new(store_id: StoreId, index: usize) -> Stored<T> {
  239|    636|        Stored {
  240|    636|            store_id,
  241|    636|            index,
  242|    636|            _marker: marker::PhantomData,
  243|    636|        }
  244|    636|    }
_RNvXsh_NtNtCsaCHOb31h0oq_8wasmtime5store4dataNtNtCslvZ9xuS3Qdd_16wasmtime_runtime6export12ExportMemoryNtB5_10StoredData8list_mut:
   38|    636|            fn list_mut(data: &mut StoreData) -> &mut Vec<Self> { &mut data.$field }
_RINvMNtNtCsaCHOb31h0oq_8wasmtime5store4dataNtB3_9StoreData6insertNtNtCslvZ9xuS3Qdd_16wasmtime_runtime6export12ExportGlobalEB7_:
   69|    636|    pub fn insert<T>(&mut self, data: T) -> Stored<T>
   70|    636|    where
   71|    636|        T: StoredData,
   72|    636|    {
   73|    636|        let list = T::list_mut(self);
   74|    636|        let index = list.len();
   75|    636|        list.push(data);
   76|    636|        Stored::new(self.id, index)
   77|    636|    }
_RNvMs6_NtNtCsaCHOb31h0oq_8wasmtime5store4dataINtB5_6StoredNtNtCslvZ9xuS3Qdd_16wasmtime_runtime6export12ExportGlobalE3newB9_:
  238|    636|    fn new(store_id: StoreId, index: usize) -> Stored<T> {
  239|    636|        Stored {
  240|    636|            store_id,
  241|    636|            index,
  242|    636|            _marker: marker::PhantomData,
  243|    636|        }
  244|    636|    }

_RNvNtCsaCHOb31h0oq_8wasmtime10trampoline22generate_memory_export:
   68|    636|pub fn generate_memory_export(
   69|    636|    store: &mut StoreOpaque,
   70|    636|    m: &MemoryType,
   71|    636|    preallocation: Option<SharedMemory>,
   72|    636|) -> Result<wasmtime_runtime::ExportMemory> {
   73|    636|    let instance = create_memory(store, m, preallocation)?;
   74|    636|    Ok(store
   75|    636|        .instance_mut(instance)
   76|    636|        .get_exported_memory(MemoryIndex::from_u32(0)))
   77|    636|}
_RNvNtCsaCHOb31h0oq_8wasmtime10trampoline13create_handle:
   26|    636|fn create_handle(
   27|    636|    module: Module,
   28|    636|    store: &mut StoreOpaque,
   29|    636|    host_state: Box<dyn Any + Send + Sync>,
   30|    636|    func_imports: &[VMFunctionImport],
   31|    636|    one_signature: Option<(SignatureIndex, VMSharedSignatureIndex)>,
   32|    636|) -> Result<InstanceId> {
   33|    636|    let mut imports = Imports::default();
   34|    636|    imports.functions = func_imports;
   35|    636|
   36|    636|    unsafe {
   37|    636|        let config = store.engine().config();
   38|    636|        // Use the on-demand allocator when creating handles associated with host objects
   39|    636|        // The configured instance allocator should only be used when creating module instances
   40|    636|        // as we don't want host objects to count towards instance limits.
   41|    636|        let module = Arc::new(module);
   42|    636|        let runtime_info =
   43|    636|            &BareModuleInfo::maybe_imported_func(module, one_signature).into_traitobj();
   44|    636|        let handle = OnDemandInstanceAllocator::new(config.mem_creator.clone(), 0).allocate(
   45|    636|            InstanceAllocationRequest {
   46|    636|                imports,
   47|    636|                host_state,
   48|    636|                store: StorePtr::new(store.traitobj()),
   49|    636|                runtime_info,
   50|    636|            },
   51|    636|        )?;
   52|       |
   53|    636|        Ok(store.add_instance(handle, true))
   54|       |    }
   55|    636|}
_RNvNtCsaCHOb31h0oq_8wasmtime10trampoline22generate_global_export:
   57|    636|pub fn generate_global_export(
   58|    636|    store: &mut StoreOpaque,
   59|    636|    gt: &GlobalType,
   60|    636|    val: Val,
   61|    636|) -> Result<wasmtime_runtime::ExportGlobal> {
   62|    636|    let instance = create_global(store, gt, val)?;
   63|    636|    Ok(store
   64|    636|        .instance_mut(instance)
   65|    636|        .get_exported_global(GlobalIndex::from_u32(0)))
   66|    636|}

_RNvNtNtCsaCHOb31h0oq_8wasmtime10trampoline6global13create_global:
   10|    636|pub fn create_global(store: &mut StoreOpaque, gt: &GlobalType, val: Val) -> Result<InstanceId> {
   11|    636|    let mut module = Module::new();
   12|    636|    let mut func_imports = Vec::new();
   13|    636|    let mut externref_init = None;
   14|    636|    let mut one_signature = None;
   15|       |
   16|    636|    let global = Global {
   17|    636|        wasm_ty: gt.content().to_wasm_type(),
   18|    636|        mutability: match gt.mutability() {
   19|      0|            Mutability::Const => false,
   20|    636|            Mutability::Var => true,
   21|       |        },
   22|      0|        initializer: match val {
   23|      0|            Val::I32(i) => GlobalInit::I32Const(i),
   24|    636|            Val::I64(i) => GlobalInit::I64Const(i),
   25|      0|            Val::F32(f) => GlobalInit::F32Const(f),
   26|      0|            Val::F64(f) => GlobalInit::F64Const(f),
   27|      0|            Val::V128(i) => GlobalInit::V128Const(i.into()),
   28|      0|            Val::ExternRef(None) | Val::FuncRef(None) => GlobalInit::RefNullConst,
   29|      0|            Val::ExternRef(Some(x)) => {
   30|      0|                // There is no `GlobalInit` variant for using an existing
   31|      0|                // `externref` that isn't an import (because Wasm can't create
   32|      0|                // an `externref` by itself). Therefore, initialize the global
   33|      0|                // as null, and then monkey patch it after instantiation below.
   34|      0|                externref_init = Some(x);
   35|      0|                GlobalInit::RefNullConst
   36|       |            }
   37|      0|            Val::FuncRef(Some(f)) => {
   38|      0|                // Add a function import to the stub module, and then initialize
   39|      0|                // our global with a `ref.func` to grab that imported function.
   40|      0|                let f = f.caller_checked_anyfunc(store);
   41|      0|                let f = unsafe { f.as_ref() };
   42|      0|                let sig_id = SignatureIndex::from_u32(u32::max_value() - 1);
   43|      0|                one_signature = Some((sig_id, f.type_index));
   44|      0|                module.types.push(ModuleType::Function(sig_id));
   45|      0|                let func_index = module.push_escaped_function(sig_id, AnyfuncIndex::from_u32(0));
   46|      0|                module.num_imported_funcs = 1;
   47|      0|                module.num_escaped_funcs = 1;
   48|      0|                module
   49|      0|                    .initializers
   50|      0|                    .push(wasmtime_environ::Initializer::Import {
   51|      0|                        name: "".into(),
   52|      0|                        field: "".into(),
   53|      0|                        index: EntityIndex::Function(func_index),
   54|      0|                    });
   55|      0|
   56|      0|                func_imports.push(VMFunctionImport {
   57|      0|                    body: f.func_ptr,
   58|      0|                    vmctx: f.vmctx,
   59|      0|                });
   60|      0|
   61|      0|                GlobalInit::RefFunc(func_index)
   62|       |            }
   63|       |        },
   64|       |    };
   65|       |
   66|    636|    let global_id = module.globals.push(global);
   67|    636|    module
   68|    636|        .exports
   69|    636|        .insert(String::new(), EntityIndex::Global(global_id));
   70|    636|    let id = create_handle(module, store, Box::new(()), &func_imports, one_signature)?;
   71|       |
   72|    636|    if let Some(x) = externref_init {
   73|      0|        let instance = store.instance_mut(id);
   74|      0|        let g = instance.get_exported_global(global_id);
   75|      0|        unsafe {
   76|      0|            *(*g.definition).as_externref_mut() = Some(x.inner);
   77|      0|        }
   78|    636|    }
   79|       |
   80|    636|    Ok(id)
   81|    636|}

_RNvNtNtCsaCHOb31h0oq_8wasmtime10trampoline6memory13create_memory:
   20|    636|pub fn create_memory(
   21|    636|    store: &mut StoreOpaque,
   22|    636|    memory_ty: &MemoryType,
   23|    636|    preallocation: Option<SharedMemory>,
   24|    636|) -> Result<InstanceId> {
   25|    636|    let mut module = Module::new();
   26|    636|
   27|    636|    // Create a memory plan for the memory, though it will never be used for
   28|    636|    // constructing a memory with an allocator: instead the memories are either
   29|    636|    // preallocated (i.e., shared memory) or allocated manually below.
   30|    636|    let plan = wasmtime_environ::MemoryPlan::for_memory(
   31|    636|        memory_ty.wasmtime_memory().clone(),
   32|    636|        &store.engine().config().tunables,
   33|    636|    );
   34|    636|    let memory_id = module.memory_plans.push(plan.clone());
   35|       |
   36|    636|    let memory = match &preallocation {
   37|       |        // If we are passing in a pre-allocated shared memory, we can clone its
   38|       |        // `Arc`. We know that a preallocated memory *must* be shared--it could
   39|       |        // be used by several instances.
   40|      0|        Some(shared_memory) => shared_memory.clone().as_memory(),
   41|       |        // If we do not have a pre-allocated memory, then we create it here and
   42|       |        // associate it with the "frankenstein" instance, which now owns it.
   43|       |        None => {
   44|    636|            let creator = &DefaultMemoryCreator;
   45|    636|            let store = unsafe {
   46|    636|                store
   47|    636|                    .traitobj()
   48|    636|                    .as_mut()
   49|    636|                    .expect("the store pointer cannot be null here")
   50|    636|            };
   51|    636|            Memory::new_dynamic(&plan, creator, store, None)
   52|    636|                .map_err(|err| InstantiationError::Resource(err.into()))?
   53|       |        }
   54|       |    };
   55|       |
   56|       |    // Since we have only associated a single memory with the "frankenstein"
   57|       |    // instance, it will be exported at index 0.
   58|    636|    debug_assert_eq!(memory_id.as_u32(), 0);
   59|    636|    module
   60|    636|        .exports
   61|    636|        .insert(String::new(), EntityIndex::Memory(memory_id));
   62|    636|
   63|    636|    // We create an instance in the on-demand allocator when creating handles
   64|    636|    // associated with external objects. The configured instance allocator
   65|    636|    // should only be used when creating module instances as we don't want host
   66|    636|    // objects to count towards instance limits.
   67|    636|    let runtime_info = &BareModuleInfo::maybe_imported_func(Arc::new(module), None).into_traitobj();
   68|    636|    let host_state = Box::new(());
   69|    636|    let imports = Imports::default();
   70|    636|    let request = InstanceAllocationRequest {
   71|    636|        imports,
   72|    636|        host_state,
   73|    636|        store: StorePtr::new(store.traitobj()),
   74|    636|        runtime_info,
   75|    636|    };
   76|       |
   77|       |    unsafe {
   78|    636|        let handle = allocate_single_memory_instance(request, memory)?;
   79|    636|        let instance_id = store.add_instance(handle.clone(), true);
   80|    636|        Ok(instance_id)
   81|       |    }
   82|    636|}

_RNvXsr_NtCsaCHOb31h0oq_8wasmtime5typesNtB5_7ValTypeNtNtCsiloedr2K6v7_4core3cmp9PartialEq2eq:
   22|    636|#[derive(Debug, Clone, Hash, Eq, PartialEq)]
_RNvMs6_NtCsaCHOb31h0oq_8wasmtime5typesNtB5_10GlobalType3new:
  247|    636|    pub fn new(content: ValType, mutability: Mutability) -> GlobalType {
  248|    636|        GlobalType {
  249|    636|            content,
  250|    636|            mutability,
  251|    636|        }
  252|    636|    }
_RNvMs6_NtCsaCHOb31h0oq_8wasmtime5typesNtB5_10GlobalType10mutability:
  260|    636|    pub fn mutability(&self) -> Mutability {
  261|    636|        self.mutability
  262|    636|    }
_RNCNvMs8_NtCsaCHOb31h0oq_8wasmtime5typesNtB7_10MemoryType3new0B9_:
  352|    636|                maximum: maximum.map(|i| i.into()),
_RNvMs8_NtCsaCHOb31h0oq_8wasmtime5typesNtB5_10MemoryType3new:
  346|    636|    pub fn new(minimum: u32, maximum: Option<u32>) -> MemoryType {
  347|    636|        MemoryType {
  348|    636|            ty: Memory {
  349|    636|                memory64: false,
  350|    636|                shared: false,
  351|    636|                minimum: minimum.into(),
  352|    636|                maximum: maximum.map(|i| i.into()),
  353|    636|            },
  354|    636|        }
  355|    636|    }
_RNvMs8_NtCsaCHOb31h0oq_8wasmtime5typesNtB5_10MemoryType15wasmtime_memory:
  434|    636|    pub(crate) fn wasmtime_memory(&self) -> &Memory {
  435|    636|        &self.ty
  436|    636|    }
_RNvMs6_NtCsaCHOb31h0oq_8wasmtime5typesNtB5_10GlobalType7content:
  255|  1.27k|    pub fn content(&self) -> &ValType {
  256|  1.27k|        &self.content
  257|  1.27k|    }
_RNvMs_NtCsaCHOb31h0oq_8wasmtime5typesNtB4_7ValType12to_wasm_type:
   74|    636|    pub(crate) fn to_wasm_type(&self) -> WasmType {
   75|    636|        match self {
   76|      0|            Self::I32 => WasmType::I32,
   77|    636|            Self::I64 => WasmType::I64,
   78|      0|            Self::F32 => WasmType::F32,
   79|      0|            Self::F64 => WasmType::F64,
   80|      0|            Self::V128 => WasmType::V128,
   81|      0|            Self::FuncRef => WasmType::FuncRef,
   82|      0|            Self::ExternRef => WasmType::ExternRef,
   83|       |        }
   84|    636|    }

_RNvMNtCsaCHOb31h0oq_8wasmtime6valuesNtB2_3Val2ty:
   86|    636|    pub fn ty(&self) -> ValType {
   87|    636|        match self {
   88|      0|            Val::I32(_) => ValType::I32,
   89|    636|            Val::I64(_) => ValType::I64,
   90|      0|            Val::F32(_) => ValType::F32,
   91|      0|            Val::F64(_) => ValType::F64,
   92|      0|            Val::ExternRef(_) => ValType::ExternRef,
   93|      0|            Val::FuncRef(_) => ValType::FuncRef,
   94|      0|            Val::V128(_) => ValType::V128,
   95|       |        }
   96|    636|    }
_RNvMNtCsaCHOb31h0oq_8wasmtime6valuesNtB2_3Val21comes_from_same_store:
  212|      0|        match self {
  213|      0|            Val::FuncRef(Some(f)) => f.comes_from_same_store(store),
  214|      0|            Val::FuncRef(None) => true,
  215|       |
  216|       |            // Integers, floats, vectors, and `externref`s have no association
  217|       |            // with any particular store, so they're always considered as "yes I
  218|       |            // came from that store",
  219|       |            Val::I32(_)
  220|       |            | Val::I64(_)
  221|       |            | Val::F32(_)
  222|       |            | Val::F64(_)
  223|       |            | Val::V128(_)
  224|    636|            | Val::ExternRef(_) => true,
  225|       |        }
  226|    636|    }

_RNvXNtCsZxITg7zOqh_18wasmtime_cranelift7builderNtB2_7BuilderNtNtCs4vXvIybW1e9_16wasmtime_environ11compilation15CompilerBuilder3set:
   65|  2.54k|    fn set(&mut self, name: &str, value: &str) -> Result<()> {
   66|  2.54k|        // Special wasmtime-cranelift-only settings first
   67|  2.54k|        if name == "wasmtime_linkopt_padding_between_functions" {
   68|      0|            self.linkopts.padding_between_functions = value.parse()?;
   69|      0|            return Ok(());
   70|  2.54k|        }
   71|  2.54k|        if name == "wasmtime_linkopt_force_jump_veneer" {
   72|      0|            self.linkopts.force_jump_veneers = value.parse()?;
   73|      0|            return Ok(());
   74|  2.54k|        }
   75|       |
   76|       |        // ... then forward this to Cranelift
   77|  2.54k|        if let Err(err) = self.flags.set(name, value) {
   78|      0|            match err {
   79|       |                SetError::BadName(_) => {
   80|       |                    // Try the target-specific flags.
   81|      0|                    self.isa_flags.set(name, value)?;
   82|       |                }
   83|      0|                _ => return Err(err.into()),
   84|       |            }
   85|  2.54k|        }
   86|  2.54k|        Ok(())
   87|  2.54k|    }
_RNvXs0_NtCsZxITg7zOqh_18wasmtime_cranelift7builderNtB5_11LinkOptionsNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
   20|    636|#[derive(Clone, Default)]
_RNvXs1_NtCsZxITg7zOqh_18wasmtime_cranelift7builderNtB5_11LinkOptionsNtNtCsiloedr2K6v7_4core7default7Default7default:
   20|    636|#[derive(Clone, Default)]
_RNvNtCsZxITg7zOqh_18wasmtime_cranelift7builder7builder:
   33|    636|pub fn builder() -> Box<dyn CompilerBuilder> {
   34|    636|    let mut flags = settings::builder();
   35|    636|
   36|    636|    // There are two possible traps for division, and this way
   37|    636|    // we get the proper one if code traps.
   38|    636|    flags
   39|    636|        .enable("avoid_div_traps")
   40|    636|        .expect("should be valid flag");
   41|    636|
   42|    636|    // We don't use probestack as a stack limit mechanism
   43|    636|    flags
   44|    636|        .set("enable_probestack", "false")
   45|    636|        .expect("should be valid flag");
   46|    636|
   47|    636|    Box::new(Builder {
   48|    636|        flags,
   49|    636|        isa_flags: cranelift_native::builder().expect("host machine is not a supported target"),
   50|    636|        linkopts: LinkOptions::default(),
   51|    636|        cache_store: None,
   52|    636|    })
   53|    636|}
_RNvXNtCsZxITg7zOqh_18wasmtime_cranelift7builderNtB2_7BuilderNtNtCs4vXvIybW1e9_16wasmtime_environ11compilation15CompilerBuilder5build:
  102|    636|    fn build(&self) -> Result<Box<dyn wasmtime_environ::Compiler>> {
  103|    636|        let isa = self
  104|    636|            .isa_flags
  105|    636|            .clone()
  106|    636|            .finish(settings::Flags::new(self.flags.clone()))?;
  107|    636|        Ok(Box::new(crate::compiler::Compiler::new(
  108|    636|            isa,
  109|    636|            self.cache_store.clone(),
  110|    636|            self.linkopts.clone(),
  111|    636|        )))
  112|    636|    }

_RNvMs0_NtCsZxITg7zOqh_18wasmtime_cranelift8compilerNtB5_8Compiler3new:
  104|    636|    pub(crate) fn new(
  105|    636|        isa: Box<dyn TargetIsa>,
  106|    636|        cache_store: Option<Arc<dyn CacheStore>>,
  107|    636|        linkopts: LinkOptions,
  108|    636|    ) -> Compiler {
  109|    636|        Compiler {
  110|    636|            contexts: Default::default(),
  111|    636|            isa,
  112|    636|            linkopts,
  113|    636|            cache_store,
  114|    636|        }
  115|    636|    }
_RNvXs_NtCsZxITg7zOqh_18wasmtime_cranelift8compilerNtB4_8CompilerNtNtNtCsiloedr2K6v7_4core3ops4drop4Drop4drop:
   76|    636|    fn drop(&mut self) {
   77|    636|        if self.cache_store.is_none() {
   78|    636|            return;
   79|      0|        }
   80|      0|
   81|      0|        let mut num_hits = 0;
   82|      0|        let mut num_cached = 0;
   83|      0|        for ctx in self.contexts.lock().unwrap().iter() {
   84|      0|            if let Some(ref cache_ctx) = ctx.incremental_cache_ctx {
   85|      0|                num_hits += cache_ctx.num_hits;
   86|      0|                num_cached += cache_ctx.num_cached;
   87|      0|            }
   88|       |        }
   89|       |
   90|      0|        let total = num_hits + num_cached;
   91|      0|        if num_hits + num_cached > 0 {
   92|      0|            log::trace!(
   93|      0|                "Incremental compilation cache stats: {}/{} = {}% (hits/lookup)\ncached: {}",
   94|      0|                num_hits,
   95|      0|                total,
   96|      0|                (num_hits as f32) / (total as f32) * 100.0,
   97|       |                num_cached
   98|       |            );
   99|      0|        }
  100|    636|    }

_RNvXsw_NtCs4vXvIybW1e9_16wasmtime_environ6moduleNtB5_6ModuleNtNtCsiloedr2K6v7_4core7default7Default7default:
  767|  1.90k|#[derive(Default, Debug, Serialize, Deserialize)]
_RNvXsa_NtCs4vXvIybW1e9_16wasmtime_environ6moduleNtB5_11MemoryStyleNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
   14|  1.27k|#[derive(Debug, Clone, Hash, Serialize, Deserialize)]
_RNvXsd_NtCs4vXvIybW1e9_16wasmtime_environ6moduleNtB5_10MemoryPlanNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
   73|  1.27k|#[derive(Debug, Clone, Hash, Serialize, Deserialize)]
_RNvMs7_NtCs4vXvIybW1e9_16wasmtime_environ6moduleNtB5_6Module20defined_memory_index:
  912|    636|    pub fn defined_memory_index(&self, memory: MemoryIndex) -> Option<DefinedMemoryIndex> {
  913|    636|        if memory.index() < self.num_imported_memories {
  914|      0|            None
  915|       |        } else {
  916|    636|            Some(DefinedMemoryIndex::new(
  917|    636|                memory.index() - self.num_imported_memories,
  918|    636|            ))
  919|       |        }
  920|    636|    }
_RNvMs7_NtCs4vXvIybW1e9_16wasmtime_environ6moduleNtB5_6Module20defined_global_index:
  959|  1.90k|    pub fn defined_global_index(&self, global: GlobalIndex) -> Option<DefinedGlobalIndex> {
  960|  1.90k|        if global.index() < self.num_imported_globals {
  961|      0|            None
  962|       |        } else {
  963|  1.90k|            Some(DefinedGlobalIndex::new(
  964|  1.90k|                global.index() - self.num_imported_globals,
  965|  1.90k|            ))
  966|       |        }
  967|  1.90k|    }
_RNvMs7_NtCs4vXvIybW1e9_16wasmtime_environ6moduleNtB5_6Module12memory_index:
  905|    636|    pub fn memory_index(&self, defined_memory: DefinedMemoryIndex) -> MemoryIndex {
  906|    636|        MemoryIndex::new(self.num_imported_memories + defined_memory.index())
  907|    636|    }
_RNvXs5_NtCs4vXvIybW1e9_16wasmtime_environ6moduleNtB5_19TableInitializationNtNtCsiloedr2K6v7_4core7default7Default7default:
  740|  1.90k|    fn default() -> Self {
  741|  1.90k|        TableInitialization::Segments { segments: vec![] }
  742|  1.90k|    }
_RNvMs7_NtCs4vXvIybW1e9_16wasmtime_environ6moduleNtB5_6Module3new:
  849|  1.27k|    pub fn new() -> Self {
  850|  1.27k|        Module::default()
  851|  1.27k|    }
_RNvMs_NtCs4vXvIybW1e9_16wasmtime_environ6moduleNtB4_10MemoryPlan10for_memory:
   87|    636|    pub fn for_memory(memory: Memory, tunables: &Tunables) -> Self {
   88|    636|        let (style, offset_guard_size) = MemoryStyle::for_memory(memory, tunables);
   89|    636|        Self {
   90|    636|            memory,
   91|    636|            style,
   92|    636|            offset_guard_size,
   93|    636|            pre_guard_size: if tunables.guard_before_linear_memory {
   94|    636|                offset_guard_size
   95|       |            } else {
   96|      0|                0
   97|       |            },
   98|       |        }
   99|    636|    }
_RNvMNtCs4vXvIybW1e9_16wasmtime_environ6moduleNtB2_11MemoryStyle10for_memory:
   30|    636|    pub fn for_memory(memory: Memory, tunables: &Tunables) -> (Self, u64) {
   31|       |        // A heap with a maximum that doesn't exceed the static memory bound specified by the
   32|       |        // tunables make it static.
   33|       |        //
   34|       |        // If the module doesn't declare an explicit maximum treat it as 4GiB when not
   35|       |        // requested to use the static memory bound itself as the maximum.
   36|    636|        let absolute_max_pages = if memory.memory64 {
   37|      0|            crate::WASM64_MAX_PAGES
   38|       |        } else {
   39|    636|            crate::WASM32_MAX_PAGES
   40|       |        };
   41|    636|        let maximum = std::cmp::min(
   42|    636|            memory.maximum.unwrap_or(absolute_max_pages),
   43|    636|            if tunables.static_memory_bound_is_maximum {
   44|    636|                std::cmp::min(tunables.static_memory_bound, absolute_max_pages)
   45|       |            } else {
   46|      0|                absolute_max_pages
   47|       |            },
   48|       |        );
   49|       |
   50|       |        // Ensure the minimum is less than the maximum; the minimum might exceed the maximum
   51|       |        // when the memory is artificially bounded via `static_memory_bound_is_maximum` above
   52|    636|        if memory.minimum <= maximum && maximum <= tunables.static_memory_bound {
   53|    636|            return (
   54|    636|                Self::Static {
   55|    636|                    bound: tunables.static_memory_bound,
   56|    636|                },
   57|    636|                tunables.static_memory_offset_guard_size,
   58|    636|            );
   59|      0|        }
   60|      0|
   61|      0|        // Otherwise, make it dynamic.
   62|      0|        (
   63|      0|            Self::Dynamic {
   64|      0|                reserve: tunables.dynamic_memory_growth_reserve,
   65|      0|            },
   66|      0|            tunables.dynamic_memory_offset_guard_size,
   67|      0|        )
   68|    636|    }
_RNvXs1_NtCs4vXvIybW1e9_16wasmtime_environ6moduleNtB5_20MemoryInitializationNtNtCsiloedr2K6v7_4core7default7Default7default:
  481|  1.90k|    fn default() -> Self {
  482|  1.90k|        Self::Segmented(Vec::new())
  483|  1.90k|    }

_RNvXs_NtCs4vXvIybW1e9_16wasmtime_environ8tunablesNtB4_8TunablesNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
    4|    636|#[derive(Clone, Hash, Serialize, Deserialize)]
_RNvXNtCs4vXvIybW1e9_16wasmtime_environ8tunablesNtB2_8TunablesNtNtCsiloedr2K6v7_4core7default7Default7default:
   51|    636|    fn default() -> Self {
   52|    636|        let (static_memory_bound, static_memory_offset_guard_size) =
   53|    636|            if cfg!(target_pointer_width = "64") {
   54|       |                // 64-bit has tons of address space to static memories can have 4gb
   55|       |                // address space reservations liberally by default, allowing us to
   56|       |                // help eliminate bounds checks.
   57|       |                //
   58|       |                // Coupled with a 2 GiB address space guard it lets us translate
   59|       |                // wasm offsets into x86 offsets as aggressively as we can.
   60|    636|                (0x1_0000, 0x8000_0000)
   61|      0|            } else if cfg!(target_pointer_width = "32") {
   62|       |                // For 32-bit we scale way down to 10MB of reserved memory. This
   63|       |                // impacts performance severely but allows us to have more than a
   64|       |                // few instances running around.
   65|      0|                ((10 * (1 << 20)) / crate::WASM_PAGE_SIZE as u64, 0x1_0000)
   66|       |            } else {
   67|      0|                panic!("unsupported target_pointer_width");
   68|       |            };
   69|    636|        Self {
   70|    636|            static_memory_bound,
   71|    636|            static_memory_offset_guard_size,
   72|    636|
   73|    636|            // Size in bytes of the offset guard for dynamic memories.
   74|    636|            //
   75|    636|            // Allocate a small guard to optimize common cases but without
   76|    636|            // wasting too much memory.
   77|    636|            dynamic_memory_offset_guard_size: 0x1_0000,
   78|    636|
   79|    636|            // We've got lots of address space on 64-bit so use a larger
   80|    636|            // grow-into-this area, but on 32-bit we aren't as lucky.
   81|    636|            #[cfg(target_pointer_width = "64")]
   82|    636|            dynamic_memory_growth_reserve: 2 << 30, // 2GB
   83|    636|            #[cfg(target_pointer_width = "32")]
   84|    636|            dynamic_memory_growth_reserve: 1 << 20, // 1MB
   85|    636|
   86|    636|            generate_native_debuginfo: false,
   87|    636|            parse_wasm_debuginfo: true,
   88|    636|            consume_fuel: false,
   89|    636|            epoch_interruption: false,
   90|    636|            static_memory_bound_is_maximum: false,
   91|    636|            guard_before_linear_memory: true,
   92|    636|            generate_address_map: true,
   93|    636|            debug_adapter_modules: false,
   94|    636|        }
   95|    636|    }

_RNvMs9_NtCs4vXvIybW1e9_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE11vmctx_storeCsaCHOb31h0oq_8wasmtime:
  616|  1.90k|    pub fn vmctx_store(&self) -> u32 {
  617|  1.90k|        self.store
  618|  1.90k|    }
_RNvNvXs1_NtCs4vXvIybW1e9_16wasmtime_environ9vmoffsetsINtB7_9VMOffsetspEINtNtCsiloedr2K6v7_4core7convert4FromINtB7_15VMOffsetsFieldspEE4from4cmul:
  388|  17.1k|        fn cmul(count: u32, size: u8) -> u32 {
  389|  17.1k|            count.checked_mul(u32::from(size)).unwrap()
  390|  17.1k|        }
_RNvNvXs1_NtCs4vXvIybW1e9_16wasmtime_environ9vmoffsetsINtB7_9VMOffsetspEINtNtCsiloedr2K6v7_4core7convert4FromINtB7_15VMOffsetsFieldspEE4from4cadd:
  383|  32.4k|        fn cadd(count: u32, size: u32) -> u32 {
  384|  32.4k|            count.checked_add(size).unwrap()
  385|  32.4k|        }
_RNvNtCs4vXvIybW1e9_16wasmtime_environ9vmoffsets5align:
   50|  3.81k|fn align(offset: u32, width: u32) -> u32 {
   51|  3.81k|    (offset + (width - 1)) / width * width
   52|  3.81k|}
_RNvMs9_NtCs4vXvIybW1e9_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE15vmctx_epoch_ptrCslvZ9xuS3Qdd_16wasmtime_runtime:
  604|  2.54k|    pub fn vmctx_epoch_ptr(&self) -> u32 {
  605|  2.54k|        self.epoch_ptr
  606|  2.54k|    }
_RNvMs9_NtCs4vXvIybW1e9_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE18vmctx_tables_beginCslvZ9xuS3Qdd_16wasmtime_runtime:
  654|  1.90k|    pub fn vmctx_tables_begin(&self) -> u32 {
  655|  1.90k|        self.defined_tables
  656|  1.90k|    }
_RNvYNtNtCs4vXvIybW1e9_16wasmtime_environ9vmoffsets7HostPtrNtB4_7PtrSize32size_of_vmcaller_checked_anyfuncCslvZ9xuS3Qdd_16wasmtime_runtime:
  128|  1.90k|    fn size_of_vmcaller_checked_anyfunc(&self) -> u8 {
  129|  1.90k|        3 * self.size()
  130|  1.90k|    }
_RNvMs9_NtCs4vXvIybW1e9_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE33vmctx_externref_activations_tableCslvZ9xuS3Qdd_16wasmtime_runtime:
  610|  2.54k|    pub fn vmctx_externref_activations_table(&self) -> u32 {
  611|  2.54k|        self.externref_activations_table
  612|  2.54k|    }
_RNvYNtNtCs4vXvIybW1e9_16wasmtime_environ9vmoffsets7HostPtrNtB4_7PtrSize27size_of_vmglobal_definitionCslvZ9xuS3Qdd_16wasmtime_runtime:
  135|  3.18k|    fn size_of_vmglobal_definition(&self) -> u8 {
  136|  3.18k|        16
  137|  3.18k|    }
_RNvYNtNtCs4vXvIybW1e9_16wasmtime_environ9vmoffsets7HostPtrNtB4_7PtrSize24size_of_vmmemory_pointerCslvZ9xuS3Qdd_16wasmtime_runtime:
  198|  2.54k|    fn size_of_vmmemory_pointer(&self) -> u8 {
  199|  2.54k|        self.size()
  200|  2.54k|    }
_RNCNvMs0_NtCs4vXvIybW1e9_16wasmtime_environ9vmoffsetsINtB7_9VMOffsetsNtB7_7HostPtrE3new0CslvZ9xuS3Qdd_16wasmtime_runtime:
  253|    636|            .filter(|p| !p.1.memory.shared)
_RNvMs9_NtCs4vXvIybW1e9_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE25vmctx_vmglobal_definitionCslvZ9xuS3Qdd_16wasmtime_runtime:
  751|  1.27k|    pub fn vmctx_vmglobal_definition(&self, index: DefinedGlobalIndex) -> u32 {
  752|  1.27k|        assert!(index.as_u32() < self.num_defined_globals);
  753|  1.27k|        self.vmctx_globals_begin()
  754|  1.27k|            + index.as_u32() * u32::from(self.ptr.size_of_vmglobal_definition())
  755|  1.27k|    }
_RNvMs0_NtCs4vXvIybW1e9_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE12pointer_sizeCslvZ9xuS3Qdd_16wasmtime_runtime:
  275|  11.4k|    pub fn pointer_size(&self) -> u8 {
  276|  11.4k|        self.ptr.size()
  277|  11.4k|    }
_RNvXNtCs4vXvIybW1e9_16wasmtime_environ9vmoffsetsNtB2_7HostPtrNtB2_7PtrSize4size:
  208|  31.1k|    fn size(&self) -> u8 {
  209|  31.1k|        std::mem::size_of::<usize>() as u8
  210|  31.1k|    }
_RNvMs9_NtCs4vXvIybW1e9_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE29vmctx_imported_memories_beginCslvZ9xuS3Qdd_16wasmtime_runtime:
  642|  1.90k|    pub fn vmctx_imported_memories_begin(&self) -> u32 {
  643|  1.90k|        self.imported_memories
  644|  1.90k|    }
_RNvMs9_NtCs4vXvIybW1e9_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE12vmctx_calleeCslvZ9xuS3Qdd_16wasmtime_runtime:
  597|  1.90k|    pub fn vmctx_callee(&self) -> u32 {
  598|  1.90k|        self.callee
  599|  1.90k|    }
_RNvMs9_NtCs4vXvIybW1e9_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE26vmctx_owned_memories_beginCslvZ9xuS3Qdd_16wasmtime_runtime:
  666|  1.90k|    pub fn vmctx_owned_memories_begin(&self) -> u32 {
  667|  1.90k|        self.owned_memories
  668|  1.90k|    }
_RNvMs5_NtCs4vXvIybW1e9_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE26size_of_vmtable_definitionCslvZ9xuS3Qdd_16wasmtime_runtime:
  528|  1.90k|    pub fn size_of_vmtable_definition(&self) -> u8 {
  529|  1.90k|        2 * self.pointer_size()
  530|  1.90k|    }
_RNvYNtNtCs4vXvIybW1e9_16wasmtime_environ9vmoffsets7HostPtrNtB4_7PtrSize27size_of_vmmemory_definitionCslvZ9xuS3Qdd_16wasmtime_runtime:
  192|  1.90k|    fn size_of_vmmemory_definition(&self) -> u8 {
  193|  1.90k|        2 * self.size()
  194|  1.90k|    }
_RNvXs1_NtCs4vXvIybW1e9_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrEINtNtCsiloedr2K6v7_4core7convert4FromINtB5_15VMOffsetsFieldsB13_EE4fromCslvZ9xuS3Qdd_16wasmtime_runtime:
  346|  1.90k|    fn from(fields: VMOffsetsFields<P>) -> VMOffsets<P> {
  347|  1.90k|        let mut ret = Self {
  348|  1.90k|            ptr: fields.ptr,
  349|  1.90k|            num_imported_functions: fields.num_imported_functions,
  350|  1.90k|            num_imported_tables: fields.num_imported_tables,
  351|  1.90k|            num_imported_memories: fields.num_imported_memories,
  352|  1.90k|            num_imported_globals: fields.num_imported_globals,
  353|  1.90k|            num_defined_tables: fields.num_defined_tables,
  354|  1.90k|            num_defined_memories: fields.num_defined_memories,
  355|  1.90k|            num_owned_memories: fields.num_owned_memories,
  356|  1.90k|            num_defined_globals: fields.num_defined_globals,
  357|  1.90k|            num_escaped_funcs: fields.num_escaped_funcs,
  358|  1.90k|            magic: 0,
  359|  1.90k|            runtime_limits: 0,
  360|  1.90k|            callee: 0,
  361|  1.90k|            epoch_ptr: 0,
  362|  1.90k|            externref_activations_table: 0,
  363|  1.90k|            store: 0,
  364|  1.90k|            builtin_functions: 0,
  365|  1.90k|            signature_ids: 0,
  366|  1.90k|            imported_functions: 0,
  367|  1.90k|            imported_tables: 0,
  368|  1.90k|            imported_memories: 0,
  369|  1.90k|            imported_globals: 0,
  370|  1.90k|            defined_tables: 0,
  371|  1.90k|            defined_memories: 0,
  372|  1.90k|            owned_memories: 0,
  373|  1.90k|            defined_globals: 0,
  374|  1.90k|            defined_anyfuncs: 0,
  375|  1.90k|            size: 0,
  376|  1.90k|        };
  377|  1.90k|
  378|  1.90k|        // Convenience functions for checked addition and multiplication.
  379|  1.90k|        // As side effect this reduces binary size by using only a single
  380|  1.90k|        // `#[track_caller]` location for each function instead of one for
  381|  1.90k|        // each individual invocation.
  382|  1.90k|        #[inline]
  383|  1.90k|        fn cadd(count: u32, size: u32) -> u32 {
  384|  1.90k|            count.checked_add(size).unwrap()
  385|  1.90k|        }
  386|  1.90k|
  387|  1.90k|        #[inline]
  388|  1.90k|        fn cmul(count: u32, size: u8) -> u32 {
  389|  1.90k|            count.checked_mul(u32::from(size)).unwrap()
  390|  1.90k|        }
  391|  1.90k|
  392|  1.90k|        let mut next_field_offset = 0;
  393|  1.90k|
  394|  1.90k|        macro_rules! fields {
  395|  1.90k|            (size($field:ident) = $size:expr, $($rest:tt)*) => {
  396|  1.90k|                ret.$field = next_field_offset;
  397|  1.90k|                next_field_offset = cadd(next_field_offset, u32::from($size));
  398|  1.90k|                fields!($($rest)*);
  399|  1.90k|            };
  400|  1.90k|            (align($align:expr), $($rest:tt)*) => {
  401|  1.90k|                next_field_offset = align(next_field_offset, $align);
  402|  1.90k|                fields!($($rest)*);
  403|  1.90k|            };
  404|  1.90k|            () => {};
  405|  1.90k|        }
  406|  1.90k|
  407|  1.90k|        fields! {
  408|  1.90k|            size(magic) = 4u32,
  409|  1.90k|            align(u32::from(ret.ptr.size())),
  410|  1.90k|            size(runtime_limits) = ret.ptr.size(),
  411|  1.90k|            size(callee) = ret.ptr.size(),
  412|  1.90k|            size(epoch_ptr) = ret.ptr.size(),
  413|  1.90k|            size(externref_activations_table) = ret.ptr.size(),
  414|  1.90k|            size(store) = ret.ptr.size() * 2,
  415|  1.90k|            size(builtin_functions) = ret.pointer_size(),
  416|  1.90k|            size(signature_ids) = ret.ptr.size(),
  417|  1.90k|            size(imported_functions)
  418|  1.90k|                = cmul(ret.num_imported_functions, ret.size_of_vmfunction_import()),
  419|  1.90k|            size(imported_tables)
  420|  1.90k|                = cmul(ret.num_imported_tables, ret.size_of_vmtable_import()),
  421|  1.90k|            size(imported_memories)
  422|  1.90k|                = cmul(ret.num_imported_memories, ret.size_of_vmmemory_import()),
  423|  1.90k|            size(imported_globals)
  424|  1.90k|                = cmul(ret.num_imported_globals, ret.size_of_vmglobal_import()),
  425|  1.90k|            size(defined_tables)
  426|  1.90k|                = cmul(ret.num_defined_tables, ret.size_of_vmtable_definition()),
  427|  1.90k|            size(defined_memories)
  428|  1.90k|                = cmul(ret.num_defined_memories, ret.ptr.size_of_vmmemory_pointer()),
  429|  1.90k|            size(owned_memories)
  430|  1.90k|                = cmul(ret.num_owned_memories, ret.ptr.size_of_vmmemory_definition()),
  431|  1.90k|            align(16),
  432|  1.90k|            size(defined_globals)
  433|  1.90k|                = cmul(ret.num_defined_globals, ret.ptr.size_of_vmglobal_definition()),
  434|  1.90k|            size(defined_anyfuncs) = cmul(
  435|  1.90k|                ret.num_escaped_funcs,
  436|  1.90k|                ret.ptr.size_of_vmcaller_checked_anyfunc(),
  437|  1.90k|            ),
  438|  1.90k|        }
  439|  1.90k|
  440|  1.90k|        ret.size = next_field_offset;
  441|  1.90k|
  442|  1.90k|        // This is required by the implementation of `VMContext::instance` and
  443|  1.90k|        // `VMContext::instance_mut`. If this value changes then those locations
  444|  1.90k|        // need to be updated.
  445|  1.90k|        assert_eq!(ret.magic, 0);
  446|       |
  447|  1.90k|        return ret;
  448|  1.90k|    }
_RNvMs9_NtCs4vXvIybW1e9_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE19vmctx_globals_beginCslvZ9xuS3Qdd_16wasmtime_runtime:
  672|  1.27k|    pub fn vmctx_globals_begin(&self) -> u32 {
  673|  1.27k|        self.defined_globals
  674|  1.27k|    }
_RNvMs0_NtCs4vXvIybW1e9_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE3newCslvZ9xuS3Qdd_16wasmtime_runtime:
  248|  1.90k|    pub fn new(ptr: P, module: &Module) -> Self {
  249|  1.90k|        let num_owned_memories = module
  250|  1.90k|            .memory_plans
  251|  1.90k|            .iter()
  252|  1.90k|            .skip(module.num_imported_memories)
  253|  1.90k|            .filter(|p| !p.1.memory.shared)
  254|  1.90k|            .count()
  255|  1.90k|            .try_into()
  256|  1.90k|            .unwrap();
  257|  1.90k|        VMOffsets::from(VMOffsetsFields {
  258|  1.90k|            ptr,
  259|  1.90k|            num_imported_functions: cast_to_u32(module.num_imported_funcs),
  260|  1.90k|            num_imported_tables: cast_to_u32(module.num_imported_tables),
  261|  1.90k|            num_imported_memories: cast_to_u32(module.num_imported_memories),
  262|  1.90k|            num_imported_globals: cast_to_u32(module.num_imported_globals),
  263|  1.90k|            num_defined_tables: cast_to_u32(module.table_plans.len() - module.num_imported_tables),
  264|  1.90k|            num_defined_memories: cast_to_u32(
  265|  1.90k|                module.memory_plans.len() - module.num_imported_memories,
  266|  1.90k|            ),
  267|  1.90k|            num_owned_memories,
  268|  1.90k|            num_defined_globals: cast_to_u32(module.globals.len() - module.num_imported_globals),
  269|  1.90k|            num_escaped_funcs: cast_to_u32(module.num_escaped_funcs),
  270|  1.90k|        })
  271|  1.90k|    }
_RNvMs9_NtCs4vXvIybW1e9_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE30vmctx_imported_functions_beginCslvZ9xuS3Qdd_16wasmtime_runtime:
  629|  1.90k|    pub fn vmctx_imported_functions_begin(&self) -> u32 {
  630|  1.90k|        self.imported_functions
  631|  1.90k|    }
_RNvMs4_NtCs4vXvIybW1e9_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE22size_of_vmtable_importCslvZ9xuS3Qdd_16wasmtime_runtime:
  500|  1.90k|    pub fn size_of_vmtable_import(&self) -> u8 {
  501|  1.90k|        2 * self.pointer_size()
  502|  1.90k|    }
_RNvMs9_NtCs4vXvIybW1e9_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE27vmctx_imported_tables_beginCslvZ9xuS3Qdd_16wasmtime_runtime:
  636|  1.90k|    pub fn vmctx_imported_tables_begin(&self) -> u32 {
  637|  1.90k|        self.imported_tables
  638|  1.90k|    }
_RNvMs9_NtCs4vXvIybW1e9_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE20vmctx_memories_beginCslvZ9xuS3Qdd_16wasmtime_runtime:
  660|  2.54k|    pub fn vmctx_memories_begin(&self) -> u32 {
  661|  2.54k|        self.defined_memories
  662|  2.54k|    }
_RNvMs6_NtCs4vXvIybW1e9_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE23size_of_vmmemory_importCslvZ9xuS3Qdd_16wasmtime_runtime:
  551|  1.90k|    pub fn size_of_vmmemory_import(&self) -> u8 {
  552|  1.90k|        3 * self.pointer_size()
  553|  1.90k|    }
_RNvMs9_NtCs4vXvIybW1e9_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE11vmctx_storeCslvZ9xuS3Qdd_16wasmtime_runtime:
  616|  2.54k|    pub fn vmctx_store(&self) -> u32 {
  617|  2.54k|        self.store
  618|  2.54k|    }
_RNvMs9_NtCs4vXvIybW1e9_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE11vmctx_magicCslvZ9xuS3Qdd_16wasmtime_runtime:
  586|  1.90k|    pub fn vmctx_magic(&self) -> u32 {
  587|  1.90k|        self.magic
  588|  1.90k|    }
_RNvMs9_NtCs4vXvIybW1e9_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE25vmctx_signature_ids_arrayCslvZ9xuS3Qdd_16wasmtime_runtime:
  622|  1.90k|    pub fn vmctx_signature_ids_array(&self) -> u32 {
  623|  1.90k|        self.signature_ids
  624|  1.90k|    }
_RNvMs9_NtCs4vXvIybW1e9_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE22vmctx_vmmemory_pointerCslvZ9xuS3Qdd_16wasmtime_runtime:
  735|    636|    pub fn vmctx_vmmemory_pointer(&self, index: DefinedMemoryIndex) -> u32 {
  736|    636|        assert!(index.as_u32() < self.num_defined_memories);
  737|    636|        self.vmctx_memories_begin()
  738|    636|            + index.as_u32() * u32::from(self.ptr.size_of_vmmemory_pointer())
  739|    636|    }
_RNvMs9_NtCs4vXvIybW1e9_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE20vmctx_runtime_limitsCslvZ9xuS3Qdd_16wasmtime_runtime:
  592|  2.54k|    pub fn vmctx_runtime_limits(&self) -> u32 {
  593|  2.54k|        self.runtime_limits
  594|  2.54k|    }
_RNvMs9_NtCs4vXvIybW1e9_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE23vmctx_builtin_functionsCslvZ9xuS3Qdd_16wasmtime_runtime:
  684|  1.90k|    pub fn vmctx_builtin_functions(&self) -> u32 {
  685|  1.90k|        self.builtin_functions
  686|  1.90k|    }
_RNvMs7_NtCs4vXvIybW1e9_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE23size_of_vmglobal_importCslvZ9xuS3Qdd_16wasmtime_runtime:
  568|  1.90k|    pub fn size_of_vmglobal_import(&self) -> u8 {
  569|  1.90k|        1 * self.pointer_size()
  570|  1.90k|    }
_RNvMs9_NtCs4vXvIybW1e9_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE13size_of_vmctxCslvZ9xuS3Qdd_16wasmtime_runtime:
  690|  5.72k|    pub fn size_of_vmctx(&self) -> u32 {
  691|  5.72k|        self.size
  692|  5.72k|    }
_RNvMs9_NtCs4vXvIybW1e9_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE28vmctx_imported_globals_beginCslvZ9xuS3Qdd_16wasmtime_runtime:
  648|  1.90k|    pub fn vmctx_imported_globals_begin(&self) -> u32 {
  649|  1.90k|        self.imported_globals
  650|  1.90k|    }
_RNvMs2_NtCs4vXvIybW1e9_16wasmtime_environ9vmoffsetsINtB5_9VMOffsetsNtB5_7HostPtrE25size_of_vmfunction_importCslvZ9xuS3Qdd_16wasmtime_runtime:
  468|  1.90k|    pub fn size_of_vmfunction_import(&self) -> u8 {
  469|  1.90k|        2 * self.pointer_size()
  470|  1.90k|    }
_RNvNtCs4vXvIybW1e9_16wasmtime_environ9vmoffsets11cast_to_u32:
   44|  15.2k|fn cast_to_u32(sz: usize) -> u32 {
   45|  15.2k|    u32::try_from(sz).expect("overflow in cast from usize to u32")
   46|  15.2k|}

_RNvNtCslvZ9xuS3Qdd_16wasmtime_runtime14debug_builtins15ensure_exported:
   47|    636|pub fn ensure_exported() {
   48|    636|    unsafe {
   49|    636|        std::ptr::read_volatile(resolve_vmctx_memory_ptr as *const u8);
   50|    636|        std::ptr::read_volatile(set_vmctx_memory as *const u8);
   51|    636|        std::ptr::read_volatile(resolve_vmctx_memory as *const u8);
   52|    636|    }
   53|    636|}

_RNvMsc_NtCslvZ9xuS3Qdd_16wasmtime_runtime9externrefNtB5_27VMExternRefActivationsTable3new:
  576|    636|    pub fn new() -> Self {
  577|    636|        // Start with an empty chunk in case this activations table isn't used.
  578|    636|        // This means that there's no space in the bump-allocation area which
  579|    636|        // will force any path trying to use this to the slow gc path. The first
  580|    636|        // time this happens, though, the slow gc path will allocate a new chunk
  581|    636|        // for actual fast-bumping.
  582|    636|        let mut chunk: Box<[TableElem]> = Box::new([]);
  583|    636|        let next = chunk.as_mut_ptr();
  584|    636|        let end = unsafe { next.add(chunk.len()) };
  585|    636|
  586|    636|        VMExternRefActivationsTable {
  587|    636|            alloc: VMExternRefTableAlloc {
  588|    636|                next: UnsafeCell::new(NonNull::new(next).unwrap()),
  589|    636|                end: NonNull::new(end).unwrap(),
  590|    636|                chunk,
  591|    636|            },
  592|    636|            over_approximated_stack_roots: HashSet::new(),
  593|    636|            precise_stack_roots: HashSet::new(),
  594|    636|            #[cfg(debug_assertions)]
  595|    636|            gc_okay: true,
  596|    636|        }
  597|    636|    }

_RNvXNtCslvZ9xuS3Qdd_16wasmtime_runtime7importsNtB2_7ImportsNtNtCsiloedr2K6v7_4core7default7Default7default:
   14|  1.90k|#[derive(Default)]

_RNvMNtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB2_8Instance5vmctx:
  300|  35.6k|    pub fn vmctx(&self) -> &VMContext {
  301|  35.6k|        &self.vmctx
  302|  35.6k|    }
_RNvMNtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB2_8Instance5store:
  267|  1.90k|    pub fn store(&self) -> *mut dyn Store {
  268|  1.90k|        let ptr = unsafe { *self.vmctx_plus_offset::<*mut dyn Store>(self.offsets.vmctx_store()) };
  269|  1.90k|        assert!(!ptr.is_null());
  270|  1.90k|        ptr
  271|  1.90k|    }
_RNvMNtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB2_8Instance9vmctx_ptr:
  306|  35.6k|    pub fn vmctx_ptr(&self) -> *mut VMContext {
  307|  35.6k|        self.vmctx() as *const VMContext as *mut VMContext
  308|  35.6k|    }
_RNvMs2_NtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB5_14InstanceHandle5store:
 1168|  1.90k|    pub fn store(&self) -> *mut dyn Store {
 1169|  1.90k|        self.instance().store()
 1170|  1.90k|    }
_RNvMs2_NtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB5_14InstanceHandle8instance:
 1158|  3.81k|    pub(crate) fn instance(&self) -> &Instance {
 1159|  3.81k|        unsafe { &*(self.instance as *const Instance) }
 1160|  3.81k|    }
_RINvMNtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetODNtB5_5StoreEL_ECsaCHOb31h0oq_8wasmtime:
  141|  1.90k|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|  1.90k|        (self.vmctx_ptr().cast::<u8>())
  143|  1.90k|            .add(usize::try_from(offset).unwrap())
  144|  1.90k|            .cast()
  145|  1.90k|    }
_RNvMs2_NtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB5_14InstanceHandle5clone:
 1187|  1.90k|    pub unsafe fn clone(&self) -> InstanceHandle {
 1188|  1.90k|        InstanceHandle {
 1189|  1.90k|            instance: self.instance,
 1190|  1.90k|        }
 1191|  1.90k|    }
_RINvMNtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetNtNtB5_9vmcontext14VMMemoryImportEB5_:
  141|  1.90k|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|  1.90k|        (self.vmctx_ptr().cast::<u8>())
  143|  1.90k|            .add(usize::try_from(offset).unwrap())
  144|  1.90k|            .cast()
  145|  1.90k|    }
_RINvMNtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetNtNtB5_9vmcontext18VMGlobalDefinitionEB5_:
  141|  1.27k|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|  1.27k|        (self.vmctx_ptr().cast::<u8>())
  143|  1.27k|            .add(usize::try_from(offset).unwrap())
  144|  1.27k|            .cast()
  145|  1.27k|    }
_RINvMNtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetPNtNtB5_9vmcontext15VMRuntimeLimitsEB5_:
  141|  2.54k|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|  2.54k|        (self.vmctx_ptr().cast::<u8>())
  143|  2.54k|            .add(usize::try_from(offset).unwrap())
  144|  2.54k|            .cast()
  145|  2.54k|    }
_RNvMNtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB2_8Instance19get_exported_memory:
  331|    636|    fn get_exported_memory(&mut self, index: MemoryIndex) -> ExportMemory {
  332|    636|        let (definition, vmctx, def_index) =
  333|    636|            if let Some(def_index) = self.module().defined_memory_index(index) {
  334|    636|                (self.memory_ptr(def_index), self.vmctx_ptr(), def_index)
  335|       |            } else {
  336|      0|                let import = self.imported_memory(index);
  337|      0|                (import.from, import.vmctx, import.index)
  338|       |            };
  339|    636|        ExportMemory {
  340|    636|            definition,
  341|    636|            vmctx,
  342|    636|            memory: self.module().memory_plans[index].clone(),
  343|    636|            index: def_index,
  344|    636|        }
  345|    636|    }
_RINvMNtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetNtNtB5_9vmcontext13VMTableImportEB5_:
  141|  1.90k|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|  1.90k|        (self.vmctx_ptr().cast::<u8>())
  143|  1.90k|            .add(usize::try_from(offset).unwrap())
  144|  1.90k|            .cast()
  145|  1.90k|    }
_RINvMNtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetPNtNtNtCsiloedr2K6v7_4core4sync6atomic9AtomicU64EB5_:
  141|  2.54k|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|  2.54k|        (self.vmctx_ptr().cast::<u8>())
  143|  2.54k|            .add(usize::try_from(offset).unwrap())
  144|  2.54k|            .cast()
  145|  2.54k|    }
_RINvMNtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetNtNtB5_9vmcontext17VMTableDefinitionEB5_:
  141|  1.90k|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|  1.90k|        (self.vmctx_ptr().cast::<u8>())
  143|  1.90k|            .add(usize::try_from(offset).unwrap())
  144|  1.90k|            .cast()
  145|  1.90k|    }
_RNvMNtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB2_8Instance16initialize_vmctx:
  890|  1.90k|    unsafe fn initialize_vmctx(&mut self, module: &Module, store: StorePtr, imports: Imports) {
  891|  1.90k|        assert!(std::ptr::eq(module, self.module().as_ref()));
  892|       |
  893|  1.90k|        *self.vmctx_plus_offset(self.offsets.vmctx_magic()) = VMCONTEXT_MAGIC;
  894|  1.90k|        self.set_callee(None);
  895|  1.90k|        self.set_store(store.as_raw());
  896|  1.90k|
  897|  1.90k|        // Initialize shared signatures
  898|  1.90k|        let signatures = self.runtime_info.signature_ids();
  899|  1.90k|        *self.vmctx_plus_offset(self.offsets.vmctx_signature_ids_array()) = signatures.as_ptr();
  900|  1.90k|
  901|  1.90k|        // Initialize the built-in functions
  902|  1.90k|        *self.vmctx_plus_offset(self.offsets.vmctx_builtin_functions()) =
  903|  1.90k|            &VMBuiltinFunctionsArray::INIT;
  904|       |
  905|       |        // Initialize the imports
  906|  1.90k|        debug_assert_eq!(imports.functions.len(), module.num_imported_funcs);
  907|  1.90k|        ptr::copy_nonoverlapping(
  908|  1.90k|            imports.functions.as_ptr(),
  909|  1.90k|            self.vmctx_plus_offset(self.offsets.vmctx_imported_functions_begin()),
  910|  1.90k|            imports.functions.len(),
  911|  1.90k|        );
  912|  1.90k|        debug_assert_eq!(imports.tables.len(), module.num_imported_tables);
  913|  1.90k|        ptr::copy_nonoverlapping(
  914|  1.90k|            imports.tables.as_ptr(),
  915|  1.90k|            self.vmctx_plus_offset(self.offsets.vmctx_imported_tables_begin()),
  916|  1.90k|            imports.tables.len(),
  917|  1.90k|        );
  918|  1.90k|        debug_assert_eq!(imports.memories.len(), module.num_imported_memories);
  919|  1.90k|        ptr::copy_nonoverlapping(
  920|  1.90k|            imports.memories.as_ptr(),
  921|  1.90k|            self.vmctx_plus_offset(self.offsets.vmctx_imported_memories_begin()),
  922|  1.90k|            imports.memories.len(),
  923|  1.90k|        );
  924|  1.90k|        debug_assert_eq!(imports.globals.len(), module.num_imported_globals);
  925|  1.90k|        ptr::copy_nonoverlapping(
  926|  1.90k|            imports.globals.as_ptr(),
  927|  1.90k|            self.vmctx_plus_offset(self.offsets.vmctx_imported_globals_begin()),
  928|  1.90k|            imports.globals.len(),
  929|  1.90k|        );
  930|  1.90k|
  931|  1.90k|        // N.B.: there is no need to initialize the anyfuncs array because
  932|  1.90k|        // we eagerly construct each element in it whenever asked for a
  933|  1.90k|        // reference to that element. In other words, there is no state
  934|  1.90k|        // needed to track the lazy-init, so we don't need to initialize
  935|  1.90k|        // any state now.
  936|  1.90k|
  937|  1.90k|        // Initialize the defined tables
  938|  1.90k|        let mut ptr = self.vmctx_plus_offset(self.offsets.vmctx_tables_begin());
  939|  1.90k|        for i in 0..module.table_plans.len() - module.num_imported_tables {
  940|      0|            ptr::write(ptr, self.tables[DefinedTableIndex::new(i)].vmtable());
  941|      0|            ptr = ptr.add(1);
  942|      0|        }
  943|       |
  944|       |        // Initialize the defined memories. This fills in both the
  945|       |        // `defined_memories` table and the `owned_memories` table at the same
  946|       |        // time. Entries in `defined_memories` hold a pointer to a definition
  947|       |        // (all memories) whereas the `owned_memories` hold the actual
  948|       |        // definitions of memories owned (not shared) in the module.
  949|  1.90k|        let mut ptr = self.vmctx_plus_offset(self.offsets.vmctx_memories_begin());
  950|  1.90k|        let mut owned_ptr = self.vmctx_plus_offset(self.offsets.vmctx_owned_memories_begin());
  951|  1.90k|        for i in 0..module.memory_plans.len() - module.num_imported_memories {
  952|    636|            let defined_memory_index = DefinedMemoryIndex::new(i);
  953|    636|            let memory_index = module.memory_index(defined_memory_index);
  954|    636|            if module.memory_plans[memory_index].memory.shared {
  955|      0|                let def_ptr = self.memories[defined_memory_index]
  956|      0|                    .as_shared_memory()
  957|      0|                    .unwrap()
  958|      0|                    .vmmemory_ptr_mut();
  959|      0|                ptr::write(ptr, def_ptr);
  960|    636|            } else {
  961|    636|                ptr::write(owned_ptr, self.memories[defined_memory_index].vmmemory());
  962|    636|                ptr::write(ptr, owned_ptr);
  963|    636|                owned_ptr = owned_ptr.add(1);
  964|    636|            }
  965|    636|            ptr = ptr.add(1);
  966|       |        }
  967|       |
  968|       |        // Initialize the defined globals
  969|  1.90k|        self.initialize_vmctx_globals(module);
  970|  1.90k|    }
_RNvMNtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB2_8Instance27externref_activations_table:
  252|  2.54k|    pub fn externref_activations_table(&self) -> *mut *mut VMExternRefActivationsTable {
  253|  2.54k|        unsafe { self.vmctx_plus_offset(self.offsets.vmctx_externref_activations_table()) }
  254|  2.54k|    }
_RINvMNtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetRNtNtB5_9vmcontext23VMBuiltinFunctionsArrayEB5_:
  141|  1.90k|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|  1.90k|        (self.vmctx_ptr().cast::<u8>())
  143|  1.90k|            .add(usize::try_from(offset).unwrap())
  144|  1.90k|            .cast()
  145|  1.90k|    }
_RNvMNtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB2_8Instance9set_store:
  273|  2.54k|    pub unsafe fn set_store(&mut self, store: Option<*mut dyn Store>) {
  274|  2.54k|        if let Some(store) = store {
  275|  1.90k|            *self.vmctx_plus_offset(self.offsets.vmctx_store()) = store;
  276|  1.90k|            *self.runtime_limits() = (*store).vmruntime_limits();
  277|  1.90k|            *self.epoch_ptr() = (*store).epoch_ptr();
  278|  1.90k|            *self.externref_activations_table() = (*store).externref_activations_table().0;
  279|  1.90k|        } else {
  280|    636|            assert_eq!(
  281|    636|                mem::size_of::<*mut dyn Store>(),
  282|    636|                mem::size_of::<[*mut (); 2]>()
  283|    636|            );
  284|    636|            *self.vmctx_plus_offset::<[*mut (); 2]>(self.offsets.vmctx_store()) =
  285|    636|                [ptr::null_mut(), ptr::null_mut()];
  286|    636|
  287|    636|            *self.runtime_limits() = ptr::null_mut();
  288|    636|            *self.epoch_ptr() = ptr::null_mut();
  289|    636|            *self.externref_activations_table() = ptr::null_mut();
  290|       |        }
  291|  2.54k|    }
_RNvMs2_NtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB5_14InstanceHandle19get_exported_memory:
 1097|    636|    pub fn get_exported_memory(&mut self, export: MemoryIndex) -> ExportMemory {
 1098|    636|        self.instance_mut().get_exported_memory(export)
 1099|    636|    }
_RNvMNtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB2_8Instance6new_at:
  105|  1.90k|    unsafe fn new_at(
  106|  1.90k|        ptr: *mut Instance,
  107|  1.90k|        alloc_size: usize,
  108|  1.90k|        offsets: VMOffsets<HostPtr>,
  109|  1.90k|        req: InstanceAllocationRequest,
  110|  1.90k|        memories: PrimaryMap<DefinedMemoryIndex, Memory>,
  111|  1.90k|        tables: PrimaryMap<DefinedTableIndex, Table>,
  112|  1.90k|    ) {
  113|  1.90k|        // The allocation must be *at least* the size required of `Instance`.
  114|  1.90k|        assert!(alloc_size >= Self::alloc_layout(&offsets).size());
  115|       |
  116|  1.90k|        let module = req.runtime_info.module();
  117|  1.90k|        let dropped_elements = EntitySet::with_capacity(module.passive_elements.len());
  118|  1.90k|        let dropped_data = EntitySet::with_capacity(module.passive_data_map.len());
  119|  1.90k|
  120|  1.90k|        ptr::write(
  121|  1.90k|            ptr,
  122|  1.90k|            Instance {
  123|  1.90k|                runtime_info: req.runtime_info.clone(),
  124|  1.90k|                offsets,
  125|  1.90k|                memories,
  126|  1.90k|                tables,
  127|  1.90k|                dropped_elements,
  128|  1.90k|                dropped_data,
  129|  1.90k|                host_state: req.host_state,
  130|  1.90k|                vmctx: VMContext {
  131|  1.90k|                    _marker: std::marker::PhantomPinned,
  132|  1.90k|                },
  133|  1.90k|            },
  134|  1.90k|        );
  135|  1.90k|
  136|  1.90k|        (*ptr).initialize_vmctx(module, req.store, req.imports);
  137|  1.90k|    }
_RNvMNtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB2_8Instance9epoch_ptr:
  247|  2.54k|    pub fn epoch_ptr(&self) -> *mut *const AtomicU64 {
  248|  2.54k|        unsafe { self.vmctx_plus_offset(self.offsets.vmctx_epoch_ptr()) }
  249|  2.54k|    }
_RNvMNtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB2_8Instance10memory_ptr:
  212|    636|    fn memory_ptr(&self, index: DefinedMemoryIndex) -> *mut VMMemoryDefinition {
  213|    636|        unsafe { *self.vmctx_plus_offset(self.offsets.vmctx_vmmemory_pointer(index)) }
  214|    636|    }
_RNvMNtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB2_8Instance19get_exported_global:
  347|    636|    fn get_exported_global(&mut self, index: GlobalIndex) -> ExportGlobal {
  348|       |        ExportGlobal {
  349|    636|            definition: if let Some(def_index) = self.module().defined_global_index(index) {
  350|    636|                self.global_ptr(def_index)
  351|       |            } else {
  352|      0|                self.imported_global(index).from
  353|       |            },
  354|    636|            global: self.module().globals[index],
  355|    636|        }
  356|    636|    }
_RNvMNtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB2_8Instance10set_callee:
  293|  1.90k|    pub(crate) unsafe fn set_callee(&mut self, callee: Option<NonNull<VMFunctionBody>>) {
  294|  1.90k|        *self.vmctx_plus_offset(self.offsets.vmctx_callee()) =
  295|  1.90k|            callee.map_or(ptr::null_mut(), |c| c.as_ptr());
  296|  1.90k|    }
_RNvMNtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB2_8Instance24initialize_vmctx_globals:
  972|  1.90k|    unsafe fn initialize_vmctx_globals(&mut self, module: &Module) {
  973|  1.90k|        let num_imports = module.num_imported_globals;
  974|  1.90k|        for (index, global) in module.globals.iter().skip(num_imports) {
  975|    636|            let def_index = module.defined_global_index(index).unwrap();
  976|    636|            let to = self.global_ptr(def_index);
  977|    636|
  978|    636|            // Initialize the global before writing to it
  979|    636|            ptr::write(to, VMGlobalDefinition::new());
  980|    636|
  981|    636|            match global.initializer {
  982|      0|                GlobalInit::I32Const(x) => *(*to).as_i32_mut() = x,
  983|    636|                GlobalInit::I64Const(x) => *(*to).as_i64_mut() = x,
  984|      0|                GlobalInit::F32Const(x) => *(*to).as_f32_bits_mut() = x,
  985|      0|                GlobalInit::F64Const(x) => *(*to).as_f64_bits_mut() = x,
  986|      0|                GlobalInit::V128Const(x) => *(*to).as_u128_mut() = x,
  987|      0|                GlobalInit::GetGlobal(x) => {
  988|      0|                    let from = if let Some(def_x) = module.defined_global_index(x) {
  989|      0|                        self.global(def_x)
  990|       |                    } else {
  991|      0|                        &*self.imported_global(x).from
  992|       |                    };
  993|       |                    // Globals of type `externref` need to manage the reference
  994|       |                    // count as values move between globals, everything else is just
  995|       |                    // copy-able bits.
  996|      0|                    match global.wasm_ty {
  997|       |                        WasmType::ExternRef => {
  998|      0|                            *(*to).as_externref_mut() = from.as_externref().clone()
  999|       |                        }
 1000|      0|                        _ => ptr::copy_nonoverlapping(from, to, 1),
 1001|       |                    }
 1002|       |                }
 1003|      0|                GlobalInit::RefFunc(f) => {
 1004|      0|                    *(*to).as_anyfunc_mut() = self.get_caller_checked_anyfunc(f).unwrap()
 1005|      0|                        as *const VMCallerCheckedAnyfunc;
 1006|      0|                }
 1007|      0|                GlobalInit::RefNullConst => match global.wasm_ty {
 1008|       |                    // `VMGlobalDefinition::new()` already zeroed out the bits
 1009|      0|                    WasmType::FuncRef => {}
 1010|      0|                    WasmType::ExternRef => {}
 1011|      0|                    ty => panic!("unsupported reference type for global: {:?}", ty),
 1012|       |                },
 1013|      0|                GlobalInit::Import => panic!("locally-defined global initialized as import"),
 1014|       |            }
 1015|       |        }
 1016|  1.90k|    }
_RINvMNtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetmEB5_:
  141|  1.90k|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|  1.90k|        (self.vmctx_ptr().cast::<u8>())
  143|  1.90k|            .add(usize::try_from(offset).unwrap())
  144|  1.90k|            .cast()
  145|  1.90k|    }
_RNvMs2_NtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB5_14InstanceHandle19get_exported_global:
 1092|    636|    pub fn get_exported_global(&mut self, export: GlobalIndex) -> ExportGlobal {
 1093|    636|        self.instance_mut().get_exported_global(export)
 1094|    636|    }
_RNvMNtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB2_8Instance6module:
  147|  6.99k|    pub(crate) fn module(&self) -> &Arc<Module> {
  148|  6.99k|        self.runtime_info.module()
  149|  6.99k|    }
_RNvMNtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB2_8Instance12alloc_layout:
  468|  5.72k|    fn alloc_layout(offsets: &VMOffsets<HostPtr>) -> Layout {
  469|  5.72k|        let size = mem::size_of::<Self>()
  470|  5.72k|            .checked_add(usize::try_from(offsets.size_of_vmctx()).unwrap())
  471|  5.72k|            .unwrap();
  472|  5.72k|        let align = mem::align_of::<Self>();
  473|  5.72k|        Layout::from_size_align(size, align).unwrap()
  474|  5.72k|    }
_RNvMs2_NtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB5_14InstanceHandle9set_store:
 1176|    636|    pub unsafe fn set_store(&mut self, store: *mut dyn Store) {
 1177|    636|        self.instance_mut().set_store(Some(store));
 1178|    636|    }
_RINvMNtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetPNtNtB5_9vmcontext22VMSharedSignatureIndexEB5_:
  141|  1.90k|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|  1.90k|        (self.vmctx_ptr().cast::<u8>())
  143|  1.90k|            .add(usize::try_from(offset).unwrap())
  144|  1.90k|            .cast()
  145|  1.90k|    }
_RINvMNtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetNtNtB5_9vmcontext18VMMemoryDefinitionEB5_:
  141|  1.90k|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|  1.90k|        (self.vmctx_ptr().cast::<u8>())
  143|  1.90k|            .add(usize::try_from(offset).unwrap())
  144|  1.90k|            .cast()
  145|  1.90k|    }
_RNvMNtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB2_8Instance14runtime_limits:
  242|  2.54k|    pub fn runtime_limits(&self) -> *mut *const VMRuntimeLimits {
  243|  2.54k|        unsafe { self.vmctx_plus_offset(self.offsets.vmctx_runtime_limits()) }
  244|  2.54k|    }
_RNvMs2_NtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB5_14InstanceHandle12instance_mut:
 1162|  1.90k|    pub(crate) fn instance_mut(&mut self) -> &mut Instance {
 1163|  1.90k|        unsafe { &mut *self.instance }
 1164|  1.90k|    }
_RNvXs_NtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB4_8InstanceNtNtNtCsiloedr2K6v7_4core3ops4drop4Drop4drop:
 1020|  1.90k|    fn drop(&mut self) {
 1021|       |        // Drop any defined globals
 1022|  1.90k|        for (idx, global) in self.module().globals.iter() {
 1023|    636|            let idx = match self.module().defined_global_index(idx) {
 1024|    636|                Some(idx) => idx,
 1025|      0|                None => continue,
 1026|       |            };
 1027|    636|            match global.wasm_ty {
 1028|       |                // For now only externref globals need to get destroyed
 1029|      0|                WasmType::ExternRef => {}
 1030|    636|                _ => continue,
 1031|       |            }
 1032|      0|            unsafe {
 1033|      0|                drop((*self.global_ptr(idx)).as_externref_mut().take());
 1034|      0|            }
 1035|       |        }
 1036|  1.90k|    }
_RINvMNtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetONtNtB5_9vmcontext18VMMemoryDefinitionEB5_:
  141|  2.54k|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|  2.54k|        (self.vmctx_ptr().cast::<u8>())
  143|  2.54k|            .add(usize::try_from(offset).unwrap())
  144|  2.54k|            .cast()
  145|  2.54k|    }
_RINvMNtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetNtNtB5_9vmcontext14VMGlobalImportEB5_:
  141|  1.90k|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|  1.90k|        (self.vmctx_ptr().cast::<u8>())
  143|  1.90k|            .add(usize::try_from(offset).unwrap())
  144|  1.90k|            .cast()
  145|  1.90k|    }
_RINvMNtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetONtNtB5_9externref27VMExternRefActivationsTableEB5_:
  141|  2.54k|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|  2.54k|        (self.vmctx_ptr().cast::<u8>())
  143|  2.54k|            .add(usize::try_from(offset).unwrap())
  144|  2.54k|            .cast()
  145|  2.54k|    }
_RINvMNtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetODNtB5_5StoreEL_EB5_:
  141|  1.90k|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|  1.90k|        (self.vmctx_ptr().cast::<u8>())
  143|  1.90k|            .add(usize::try_from(offset).unwrap())
  144|  1.90k|            .cast()
  145|  1.90k|    }
_RNvMNtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB2_8Instance10global_ptr:
  222|  1.27k|    fn global_ptr(&self, index: DefinedGlobalIndex) -> *mut VMGlobalDefinition {
  223|  1.27k|        unsafe { self.vmctx_plus_offset(self.offsets.vmctx_vmglobal_definition(index)) }
  224|  1.27k|    }
_RINvMNtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetAOuj2_EB5_:
  141|    636|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|    636|        (self.vmctx_ptr().cast::<u8>())
  143|    636|            .add(usize::try_from(offset).unwrap())
  144|    636|            .cast()
  145|    636|    }
_RINvMNtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetNtNtB5_9vmcontext16VMFunctionImportEB5_:
  141|  1.90k|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|  1.90k|        (self.vmctx_ptr().cast::<u8>())
  143|  1.90k|            .add(usize::try_from(offset).unwrap())
  144|  1.90k|            .cast()
  145|  1.90k|    }
_RINvMNtCslvZ9xuS3Qdd_16wasmtime_runtime8instanceNtB3_8Instance17vmctx_plus_offsetONtNtB5_9vmcontext14VMFunctionBodyEB5_:
  141|  1.90k|    unsafe fn vmctx_plus_offset<T>(&self, offset: u32) -> *mut T {
  142|  1.90k|        (self.vmctx_ptr().cast::<u8>())
  143|  1.90k|            .add(usize::try_from(offset).unwrap())
  144|  1.90k|            .cast()
  145|  1.90k|    }

_RNvMs_NtNtCslvZ9xuS3Qdd_16wasmtime_runtime8instance9allocatorNtB4_25OnDemandInstanceAllocator15create_memories:
  468|  1.27k|    fn create_memories(
  469|  1.27k|        &self,
  470|  1.27k|        store: &mut StorePtr,
  471|  1.27k|        runtime_info: &Arc<dyn ModuleRuntimeInfo>,
  472|  1.27k|    ) -> Result<PrimaryMap<DefinedMemoryIndex, Memory>, InstantiationError> {
  473|  1.27k|        let module = runtime_info.module();
  474|  1.27k|        let creator = self
  475|  1.27k|            .mem_creator
  476|  1.27k|            .as_deref()
  477|  1.27k|            .unwrap_or_else(|| &DefaultMemoryCreator);
  478|  1.27k|        let num_imports = module.num_imported_memories;
  479|  1.27k|        let mut memories: PrimaryMap<DefinedMemoryIndex, _> =
  480|  1.27k|            PrimaryMap::with_capacity(module.memory_plans.len() - num_imports);
  481|  1.27k|        for (memory_idx, plan) in module.memory_plans.iter().skip(num_imports) {
  482|      0|            let defined_memory_idx = module
  483|      0|                .defined_memory_index(memory_idx)
  484|      0|                .expect("Skipped imports, should never be None");
  485|      0|            let image = runtime_info
  486|      0|                .memory_image(defined_memory_idx)
  487|      0|                .map_err(|err| InstantiationError::Resource(err.into()))?;
  488|       |
  489|       |            memories.push(
  490|      0|                Memory::new_dynamic(
  491|      0|                    plan,
  492|      0|                    creator,
  493|      0|                    unsafe {
  494|      0|                        store
  495|      0|                            .get()
  496|      0|                            .expect("if module has memory plans, store is not empty")
  497|      0|                    },
  498|      0|                    image,
  499|      0|                )
  500|      0|                .map_err(InstantiationError::Resource)?,
  501|       |            );
  502|       |        }
  503|  1.27k|        Ok(memories)
  504|  1.27k|    }
_RNvNtNtCslvZ9xuS3Qdd_16wasmtime_runtime8instance9allocator31allocate_single_memory_instance:
  523|    636|pub unsafe fn allocate_single_memory_instance(
  524|    636|    req: InstanceAllocationRequest,
  525|    636|    memory: Memory,
  526|    636|) -> Result<InstanceHandle, InstantiationError> {
  527|    636|    let mut memories = PrimaryMap::default();
  528|    636|    memories.push(memory);
  529|    636|    let tables = PrimaryMap::default();
  530|    636|    let module = req.runtime_info.module();
  531|    636|    let offsets = VMOffsets::new(HostPtr, module);
  532|    636|    let layout = Instance::alloc_layout(&offsets);
  533|    636|    let instance = alloc::alloc(layout) as *mut Instance;
  534|    636|    Instance::new_at(instance, layout.size(), offsets, req, memories, tables);
  535|    636|    Ok(InstanceHandle { instance })
  536|    636|}
_RNvMNtNtCslvZ9xuS3Qdd_16wasmtime_runtime8instance9allocatorNtB2_8StorePtr6as_raw:
   74|  1.90k|    pub fn as_raw(&self) -> Option<*mut dyn Store> {
   75|  1.90k|        self.0.clone()
   76|  1.90k|    }
_RNvXs1_NtNtCslvZ9xuS3Qdd_16wasmtime_runtime8instance9allocatorNtB5_25OnDemandInstanceAllocatorNtB5_17InstanceAllocator8allocate:
  548|  1.27k|    unsafe fn allocate(
  549|  1.27k|        &self,
  550|  1.27k|        mut req: InstanceAllocationRequest,
  551|  1.27k|    ) -> Result<InstanceHandle, InstantiationError> {
  552|  1.27k|        let memories = self.create_memories(&mut req.store, &req.runtime_info)?;
  553|  1.27k|        let tables = Self::create_tables(&mut req.store, &req.runtime_info)?;
  554|  1.27k|        let module = req.runtime_info.module();
  555|  1.27k|        let offsets = VMOffsets::new(HostPtr, module);
  556|  1.27k|        let layout = Instance::alloc_layout(&offsets);
  557|  1.27k|        let instance_ptr = alloc::alloc(layout) as *mut Instance;
  558|  1.27k|
  559|  1.27k|        Instance::new_at(instance_ptr, layout.size(), offsets, req, memories, tables);
  560|  1.27k|
  561|  1.27k|        Ok(InstanceHandle {
  562|  1.27k|            instance: instance_ptr,
  563|  1.27k|        })
  564|  1.27k|    }
_RNvMs_NtNtCslvZ9xuS3Qdd_16wasmtime_runtime8instance9allocatorNtB4_25OnDemandInstanceAllocator13create_tables:
  447|  1.27k|    fn create_tables(
  448|  1.27k|        store: &mut StorePtr,
  449|  1.27k|        runtime_info: &Arc<dyn ModuleRuntimeInfo>,
  450|  1.27k|    ) -> Result<PrimaryMap<DefinedTableIndex, Table>, InstantiationError> {
  451|  1.27k|        let module = runtime_info.module();
  452|  1.27k|        let num_imports = module.num_imported_tables;
  453|  1.27k|        let mut tables: PrimaryMap<DefinedTableIndex, _> =
  454|  1.27k|            PrimaryMap::with_capacity(module.table_plans.len() - num_imports);
  455|  1.27k|        for (_, table) in module.table_plans.iter().skip(num_imports) {
  456|       |            tables.push(
  457|      0|                Table::new_dynamic(table, unsafe {
  458|      0|                    store
  459|      0|                        .get()
  460|      0|                        .expect("if module has table plans, store is not empty")
  461|      0|                })
  462|      0|                .map_err(InstantiationError::Resource)?,
  463|       |            );
  464|       |        }
  465|  1.27k|        Ok(tables)
  466|  1.27k|    }
_RNvMNtNtCslvZ9xuS3Qdd_16wasmtime_runtime8instance9allocatorNtB2_8StorePtr5empty:
   66|    636|    pub fn empty() -> Self {
   67|    636|        Self(None)
   68|    636|    }
_RNvXs1_NtNtCslvZ9xuS3Qdd_16wasmtime_runtime8instance9allocatorNtB5_25OnDemandInstanceAllocatorNtB5_17InstanceAllocator10deallocate:
  575|  1.90k|    unsafe fn deallocate(&self, handle: &InstanceHandle) {
  576|  1.90k|        deallocate(handle)
  577|  1.90k|    }
_RNvXs0_NtNtCslvZ9xuS3Qdd_16wasmtime_runtime8instance9allocatorNtB5_25OnDemandInstanceAllocatorNtNtCsiloedr2K6v7_4core7default7Default7default:
  508|  1.27k|    fn default() -> Self {
  509|  1.27k|        Self {
  510|  1.27k|            mem_creator: None,
  511|  1.27k|            #[cfg(feature = "async")]
  512|  1.27k|            stack_size: 0,
  513|  1.27k|        }
  514|  1.27k|    }
_RNvNtNtCslvZ9xuS3Qdd_16wasmtime_runtime8instance9allocator10deallocate:
  541|  1.90k|pub unsafe fn deallocate(handle: &InstanceHandle) {
  542|  1.90k|    let layout = Instance::alloc_layout(&handle.instance().offsets);
  543|  1.90k|    ptr::drop_in_place(handle.instance);
  544|  1.90k|    alloc::dealloc(handle.instance.cast(), layout);
  545|  1.90k|}
_RNCNvMs_NtNtCslvZ9xuS3Qdd_16wasmtime_runtime8instance9allocatorNtB6_25OnDemandInstanceAllocator15create_memories0Ba_:
  477|  1.27k|            .unwrap_or_else(|| &DefaultMemoryCreator);
_RNvMNtNtCslvZ9xuS3Qdd_16wasmtime_runtime8instance9allocatorNtB2_8StorePtr3new:
   70|  1.27k|    pub fn new(ptr: *mut dyn Store) -> Self {
   71|  1.27k|        Self(Some(ptr))
   72|  1.27k|    }
_RNvMs_NtNtCslvZ9xuS3Qdd_16wasmtime_runtime8instance9allocatorNtB4_25OnDemandInstanceAllocator3new:
  438|    636|    pub fn new(mem_creator: Option<Arc<dyn RuntimeMemoryCreator>>, stack_size: usize) -> Self {
  439|    636|        drop(stack_size); // suppress unused warnings w/o async feature
  440|    636|        Self {
  441|    636|            mem_creator,
  442|    636|            #[cfg(feature = "async")]
  443|    636|            stack_size,
  444|    636|        }
  445|    636|    }

_RNvXs8_NtNtNtCslvZ9xuS3Qdd_16wasmtime_runtime8instance9allocator7poolingNtB5_14InstanceLimitsNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
   54|    636|#[derive(Debug, Copy, Clone)]
_RNvXsa_NtNtNtCslvZ9xuS3Qdd_16wasmtime_runtime8instance9allocator7poolingNtB5_25PoolingAllocationStrategyNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
  173|    636|#[derive(Debug, Clone, Copy, PartialEq, Eq)]
_RNCNvMs1_NtNtNtCslvZ9xuS3Qdd_16wasmtime_runtime8instance9allocator7poolingNtB7_10MemoryPool3news2_0Bd_:
  753|   651k|        let image_slots: Vec<_> = std::iter::repeat_with(|| Mutex::new(None))
_RNvMs0_NtNtNtCslvZ9xuS3Qdd_16wasmtime_runtime8instance9allocator7poolingNtB5_12InstancePool3new:
  212|    636|    fn new(
  213|    636|        strategy: PoolingAllocationStrategy,
  214|    636|        instance_limits: &InstanceLimits,
  215|    636|        tunables: &Tunables,
  216|    636|    ) -> Result<Self> {
  217|    636|        let page_size = crate::page_size();
  218|    636|
  219|    636|        let instance_size = round_up_to_pow2(instance_limits.size, mem::align_of::<Instance>());
  220|    636|
  221|    636|        let max_instances = instance_limits.count as usize;
  222|       |
  223|    636|        let allocation_size = round_up_to_pow2(
  224|    636|            instance_size
  225|    636|                .checked_mul(max_instances)
  226|    636|                .ok_or_else(|| anyhow!("total size of instance data exceeds addressable memory"))?,
  227|    636|            page_size,
  228|       |        );
  229|       |
  230|    636|        let mapping = Mmap::accessible_reserved(allocation_size, allocation_size)
  231|    636|            .context("failed to create instance pool mapping")?;
  232|       |
  233|    636|        let pool = Self {
  234|    636|            mapping,
  235|    636|            instance_size,
  236|    636|            max_instances,
  237|    636|            index_allocator: Mutex::new(PoolingAllocationState::new(strategy, max_instances)),
  238|    636|            memories: MemoryPool::new(instance_limits, tunables)?,
  239|    636|            tables: TablePool::new(instance_limits)?,
  240|       |        };
  241|       |
  242|    636|        Ok(pool)
  243|    636|    }
_RNvXs5_NtNtNtCslvZ9xuS3Qdd_16wasmtime_runtime8instance9allocator7poolingNtB5_24PoolingInstanceAllocatorNtB7_17InstanceAllocator15adjust_tunables:
 1091|    636|    fn adjust_tunables(&self, tunables: &mut Tunables) {
 1092|    636|        // Treat the static memory bound as the maximum for unbounded Wasm memories
 1093|    636|        // Because we guarantee a module cannot compile unless it fits in the limits of
 1094|    636|        // the pool allocator, this ensures all memories are treated as static (i.e. immovable).
 1095|    636|        tunables.static_memory_bound_is_maximum = true;
 1096|    636|    }
_RNvMs1_NtNtNtCslvZ9xuS3Qdd_16wasmtime_runtime8instance9allocator7poolingNtB5_10MemoryPool3new:
  685|    636|    fn new(instance_limits: &InstanceLimits, tunables: &Tunables) -> Result<Self> {
  686|    636|        // The maximum module memory page count cannot exceed 65536 pages
  687|    636|        if instance_limits.memory_pages > 0x10000 {
  688|      0|            bail!(
  689|      0|                "module memory page limit of {} exceeds the maximum of 65536",
  690|      0|                instance_limits.memory_pages
  691|      0|            );
  692|    636|        }
  693|    636|
  694|    636|        // The maximum module memory page count cannot exceed the memory reservation size
  695|    636|        if u64::from(instance_limits.memory_pages) > tunables.static_memory_bound {
  696|      0|            bail!(
  697|      0|                "module memory page limit of {} pages exceeds maximum static memory limit of {} pages",
  698|      0|                instance_limits.memory_pages,
  699|      0|                tunables.static_memory_bound,
  700|      0|            );
  701|    636|        }
  702|    636|
  703|    636|        let static_memory_bound =
  704|    636|            u64::from(tunables.static_memory_bound) * u64::from(WASM_PAGE_SIZE);
  705|    636|        let memory_size =
  706|    636|            usize::try_from(static_memory_bound + tunables.static_memory_offset_guard_size)
  707|    636|                .map_err(|_| anyhow!("memory reservation size exceeds addressable memory"))?;
  708|       |
  709|    636|        assert!(
  710|    636|            memory_size % crate::page_size() == 0,
  711|      0|            "memory size {} is not a multiple of system page size",
  712|       |            memory_size
  713|       |        );
  714|       |
  715|    636|        let max_instances = instance_limits.count as usize;
  716|    636|        let max_memories = instance_limits.memories as usize;
  717|    636|        let initial_memory_offset = if tunables.guard_before_linear_memory {
  718|    636|            usize::try_from(tunables.static_memory_offset_guard_size).unwrap()
  719|       |        } else {
  720|      0|            0
  721|       |        };
  722|       |
  723|       |        // The entire allocation here is the size of each memory times the
  724|       |        // max memories per instance times the number of instances allowed in
  725|       |        // this pool, plus guard regions.
  726|       |        //
  727|       |        // Note, though, that guard regions are required to be after each linear
  728|       |        // memory. If the `guard_before_linear_memory` setting is specified,
  729|       |        // then due to the contiguous layout of linear memories the guard pages
  730|       |        // after one memory are also guard pages preceding the next linear
  731|       |        // memory. This means that we only need to handle pre-guard-page sizes
  732|       |        // specially for the first linear memory, hence the
  733|       |        // `initial_memory_offset` variable here. If guards aren't specified
  734|       |        // before linear memories this is set to `0`, otherwise it's set to
  735|       |        // the same size as guard regions for other memories.
  736|    636|        let allocation_size = memory_size
  737|    636|            .checked_mul(max_memories)
  738|    636|            .and_then(|c| c.checked_mul(max_instances))
  739|    636|            .and_then(|c| c.checked_add(initial_memory_offset))
  740|    636|            .ok_or_else(|| {
  741|       |                anyhow!("total size of memory reservation exceeds addressable memory")
  742|    636|            })?;
  743|       |
  744|       |        // Create a completely inaccessible region to start
  745|    636|        let mapping = Mmap::accessible_reserved(0, allocation_size)
  746|    636|            .context("failed to create memory pool mapping")?;
  747|       |
  748|    636|        let num_image_slots = if cfg!(memory_init_cow) {
  749|    636|            max_instances * max_memories
  750|       |        } else {
  751|      0|            0
  752|       |        };
  753|    636|        let image_slots: Vec<_> = std::iter::repeat_with(|| Mutex::new(None))
  754|    636|            .take(num_image_slots)
  755|    636|            .collect();
  756|    636|
  757|    636|        let pool = Self {
  758|    636|            mapping,
  759|    636|            image_slots,
  760|    636|            memory_reservation_size: memory_size,
  761|    636|            initial_memory_offset,
  762|    636|            max_memories,
  763|    636|            max_instances,
  764|    636|            max_memory_size: (instance_limits.memory_pages as usize) * (WASM_PAGE_SIZE as usize),
  765|    636|            static_memory_bound,
  766|    636|        };
  767|    636|
  768|    636|        Ok(pool)
  769|    636|    }
_RNCNvMs3_NtNtNtCslvZ9xuS3Qdd_16wasmtime_runtime8instance9allocator7poolingNtB7_9TablePool3news_0Bd_:
  861|    636|            .and_then(|c| c.checked_mul(max_instances))
_RNvNtNtNtCslvZ9xuS3Qdd_16wasmtime_runtime8instance9allocator7pooling16round_up_to_pow2:
   47|  1.90k|fn round_up_to_pow2(n: usize, to: usize) -> usize {
   48|  1.90k|    debug_assert!(to > 0);
   49|  1.90k|    debug_assert!(to.is_power_of_two());
   50|  1.90k|    (n + to - 1) & !(to - 1)
   51|  1.90k|}
_RNvMs4_NtNtNtCslvZ9xuS3Qdd_16wasmtime_runtime8instance9allocator7poolingNtB5_24PoolingInstanceAllocator3new:
 1049|    636|    pub fn new(
 1050|    636|        strategy: PoolingAllocationStrategy,
 1051|    636|        instance_limits: InstanceLimits,
 1052|    636|        stack_size: usize,
 1053|    636|        tunables: &Tunables,
 1054|    636|        async_stack_zeroing: bool,
 1055|    636|    ) -> Result<Self> {
 1056|    636|        if instance_limits.count == 0 {
 1057|      0|            bail!("the instance count limit cannot be zero");
 1058|    636|        }
 1059|       |
 1060|    636|        let instances = InstancePool::new(strategy, &instance_limits, tunables)?;
 1061|       |
 1062|    636|        drop(stack_size); // suppress unused warnings w/o async feature
 1063|    636|        drop(async_stack_zeroing); // suppress unused warnings w/o async feature
 1064|    636|
 1065|    636|        Ok(Self {
 1066|    636|            instances: instances,
 1067|    636|            #[cfg(all(feature = "async", unix))]
 1068|    636|            stacks: StackPool::new(&instance_limits, stack_size, async_stack_zeroing)?,
 1069|    636|            #[cfg(all(feature = "async", windows))]
 1070|    636|            stack_size,
 1071|    636|        })
 1072|    636|    }
_RNvXs2_NtNtNtCslvZ9xuS3Qdd_16wasmtime_runtime8instance9allocator7poolingNtB5_10MemoryPoolNtNtNtCsiloedr2K6v7_4core3ops4drop4Drop4drop:
  818|    636|    fn drop(&mut self) {
  819|       |        // Clear the `clear_no_drop` flag (i.e., ask to *not* clear on
  820|       |        // drop) for all slots, and then drop them here. This is
  821|       |        // valid because the one `Mmap` that covers the whole region
  822|       |        // can just do its one munmap.
  823|   651k|        for mut slot in std::mem::take(&mut self.image_slots) {
  824|   651k|            if let Some(slot) = slot.get_mut().unwrap() {
  825|      0|                slot.no_clear_on_drop();
  826|   651k|            }
  827|       |        }
  828|    636|    }
_RNvMs3_NtNtNtCslvZ9xuS3Qdd_16wasmtime_runtime8instance9allocator7poolingNtB5_9TablePool3new:
  846|    636|    fn new(instance_limits: &InstanceLimits) -> Result<Self> {
  847|    636|        let page_size = crate::page_size();
  848|       |
  849|    636|        let table_size = round_up_to_pow2(
  850|    636|            mem::size_of::<*mut u8>()
  851|    636|                .checked_mul(instance_limits.table_elements as usize)
  852|    636|                .ok_or_else(|| anyhow!("table size exceeds addressable memory"))?,
  853|    636|            page_size,
  854|    636|        );
  855|    636|
  856|    636|        let max_instances = instance_limits.count as usize;
  857|    636|        let max_tables = instance_limits.tables as usize;
  858|       |
  859|    636|        let allocation_size = table_size
  860|    636|            .checked_mul(max_tables)
  861|    636|            .and_then(|c| c.checked_mul(max_instances))
  862|    636|            .ok_or_else(|| anyhow!("total size of instance tables exceeds addressable memory"))?;
  863|       |
  864|    636|        let mapping = Mmap::accessible_reserved(allocation_size, allocation_size)
  865|    636|            .context("failed to create table pool mapping")?;
  866|       |
  867|    636|        Ok(Self {
  868|    636|            mapping,
  869|    636|            table_size,
  870|    636|            max_tables,
  871|    636|            max_instances,
  872|    636|            page_size,
  873|    636|            max_elements: instance_limits.table_elements,
  874|    636|        })
  875|    636|    }
_RNCNvMs1_NtNtNtCslvZ9xuS3Qdd_16wasmtime_runtime8instance9allocator7poolingNtB7_10MemoryPool3news0_0Bd_:
  739|    636|            .and_then(|c| c.checked_add(initial_memory_offset))
_RNCNvMs1_NtNtNtCslvZ9xuS3Qdd_16wasmtime_runtime8instance9allocator7poolingNtB7_10MemoryPool3news_0Bd_:
  738|    636|            .and_then(|c| c.checked_mul(max_instances))
_RNvXNtNtNtCslvZ9xuS3Qdd_16wasmtime_runtime8instance9allocator7poolingNtB2_14InstanceLimitsNtNtCsiloedr2K6v7_4core7default7Default7default:
  159|    636|    fn default() -> Self {
  160|    636|        // See doc comments for `wasmtime::InstanceLimits` for these default values
  161|    636|        Self {
  162|    636|            count: 1000,
  163|    636|            size: 1 << 20, // 1 MB
  164|    636|            tables: 1,
  165|    636|            table_elements: 10_000,
  166|    636|            memories: 1,
  167|    636|            memory_pages: 160,
  168|    636|        }
  169|    636|    }

_RNCNvMs3_NtNtNtNtCslvZ9xuS3Qdd_16wasmtime_runtime8instance9allocator7pooling15index_allocatorNtB7_22PoolingAllocationState3news_0Bf_:
  260|   651k|                    .map(|i| {
  261|   651k|                        SlotState::Free(FreeSlotState::NoAffinity {
  262|   651k|                            free_list_index: GlobalFreeListIndex(i),
  263|   651k|                        })
  264|   651k|                    })
_RNvMs3_NtNtNtNtCslvZ9xuS3Qdd_16wasmtime_runtime8instance9allocator7pooling15index_allocatorNtB5_22PoolingAllocationState3new:
  251|    636|    pub(crate) fn new(strategy: PoolingAllocationStrategy, max_instances: usize) -> Self {
  252|    636|        let ids = (0..max_instances).map(|i| SlotId(i)).collect::<Vec<_>>();
  253|    636|        match strategy {
  254|      0|            PoolingAllocationStrategy::NextAvailable => PoolingAllocationState::NextAvailable(ids),
  255|      0|            PoolingAllocationStrategy::Random => PoolingAllocationState::Random(ids),
  256|    636|            PoolingAllocationStrategy::ReuseAffinity => PoolingAllocationState::ReuseAffinity {
  257|    636|                free_list: ids,
  258|    636|                per_module: HashMap::new(),
  259|    636|                slot_state: (0..max_instances)
  260|    636|                    .map(|i| {
  261|       |                        SlotState::Free(FreeSlotState::NoAffinity {
  262|       |                            free_list_index: GlobalFreeListIndex(i),
  263|       |                        })
  264|    636|                    })
  265|    636|                    .collect(),
  266|    636|            },
  267|       |        }
  268|    636|    }
_RNCNvMs3_NtNtNtNtCslvZ9xuS3Qdd_16wasmtime_runtime8instance9allocator7pooling15index_allocatorNtB7_22PoolingAllocationState3new0Bf_:
  252|   651k|        let ids = (0..max_instances).map(|i| SlotId(i)).collect::<Vec<_>>();

_RNvCslvZ9xuS3Qdd_16wasmtime_runtime9page_size:
  207|  4.45k|pub fn page_size() -> usize {
  208|  4.45k|    static PAGE_SIZE: AtomicUsize = AtomicUsize::new(0);
  209|  4.45k|
  210|  4.45k|    return match PAGE_SIZE.load(Ordering::Relaxed) {
  211|       |        0 => {
  212|      1|            let size = get_page_size();
  213|      1|            assert!(size != 0);
  214|      1|            PAGE_SIZE.store(size, Ordering::Relaxed);
  215|      1|            size
  216|       |        }
  217|  4.45k|        n => n,
  218|       |    };
  219|       |
  220|       |    #[cfg(windows)]
  221|       |    fn get_page_size() -> usize {
  222|       |        use std::mem::MaybeUninit;
  223|       |        use windows_sys::Win32::System::SystemInformation::*;
  224|       |
  225|       |        unsafe {
  226|       |            let mut info = MaybeUninit::uninit();
  227|       |            GetSystemInfo(info.as_mut_ptr());
  228|       |            info.assume_init_ref().dwPageSize as usize
  229|       |        }
  230|       |    }
  231|       |
  232|       |    #[cfg(unix)]
  233|       |    fn get_page_size() -> usize {
  234|       |        unsafe { libc::sysconf(libc::_SC_PAGESIZE) as usize }
  235|       |    }
  236|  4.45k|}
_RNvNvCslvZ9xuS3Qdd_16wasmtime_runtime9page_size13get_page_size:
  233|      1|    fn get_page_size() -> usize {
  234|      1|        unsafe { libc::sysconf(libc::_SC_PAGESIZE) as usize }
  235|      1|    }

_RNvMs7_NtCslvZ9xuS3Qdd_16wasmtime_runtime6memoryNtB5_6Memory11new_dynamic:
  610|    636|    pub fn new_dynamic(
  611|    636|        plan: &MemoryPlan,
  612|    636|        creator: &dyn RuntimeMemoryCreator,
  613|    636|        store: &mut dyn Store,
  614|    636|        memory_image: Option<&Arc<MemoryImage>>,
  615|    636|    ) -> Result<Self> {
  616|    636|        let (minimum, maximum) = Self::limit_new(plan, Some(store))?;
  617|    636|        let allocation = creator.new_memory(plan, minimum, maximum, memory_image)?;
  618|    636|        let allocation = if plan.memory.shared {
  619|      0|            Box::new(SharedMemory::wrap(plan, allocation, plan.memory)?)
  620|       |        } else {
  621|    636|            allocation
  622|       |        };
  623|    636|        Ok(Memory(allocation))
  624|    636|    }
_RNCNvMs_NtCslvZ9xuS3Qdd_16wasmtime_runtime6memoryNtB6_10MmapMemory3news_0B8_:
  227|    636|            .and_then(|i| i.checked_add(offset_guard_bytes))
_RNvMs7_NtCslvZ9xuS3Qdd_16wasmtime_runtime6memoryNtB5_6Memory9limit_new:
  654|    636|    fn limit_new(
  655|    636|        plan: &MemoryPlan,
  656|    636|        store: Option<&mut dyn Store>,
  657|    636|    ) -> Result<(usize, Option<usize>)> {
  658|       |        // Sanity-check what should already be true from wasm module validation.
  659|    636|        let absolute_max = if plan.memory.memory64 {
  660|      0|            WASM64_MAX_PAGES
  661|       |        } else {
  662|    636|            WASM32_MAX_PAGES
  663|       |        };
  664|    636|        assert!(plan.memory.minimum <= absolute_max);
  665|    636|        assert!(plan.memory.maximum.is_none() || plan.memory.maximum.unwrap() <= absolute_max);
  666|       |
  667|       |        // This is the absolute possible maximum that the module can try to
  668|       |        // allocate, which is our entire address space minus a wasm page. That
  669|       |        // shouldn't ever actually work in terms of an allocation because
  670|       |        // presumably the kernel wants *something* for itself, but this is used
  671|       |        // to pass to the `store`'s limiter for a requested size
  672|       |        // to approximate the scale of the request that the wasm module is
  673|       |        // making. This is necessary because the limiter works on `usize` bytes
  674|       |        // whereas we're working with possibly-overflowing `u64` calculations
  675|       |        // here. To actually faithfully represent the byte requests of modules
  676|       |        // we'd have to represent things as `u128`, but that's kinda
  677|       |        // overkill for this purpose.
  678|    636|        let absolute_max = 0usize.wrapping_sub(WASM_PAGE_SIZE);
  679|    636|
  680|    636|        // If the minimum memory size overflows the size of our own address
  681|    636|        // space, then we can't satisfy this request, but defer the error to
  682|    636|        // later so the `store` can be informed that an effective oom is
  683|    636|        // happening.
  684|    636|        let minimum = plan
  685|    636|            .memory
  686|    636|            .minimum
  687|    636|            .checked_mul(WASM_PAGE_SIZE_U64)
  688|    636|            .and_then(|m| usize::try_from(m).ok());
  689|    636|
  690|    636|        // The plan stores the maximum size in units of wasm pages, but we
  691|    636|        // use units of bytes. Unlike for the `minimum` size we silently clamp
  692|    636|        // the effective maximum size to `absolute_max` above if the maximum is
  693|    636|        // too large. This should be ok since as a wasm runtime we get to
  694|    636|        // arbitrarily decide the actual maximum size of memory, regardless of
  695|    636|        // what's actually listed on the memory itself.
  696|    636|        let mut maximum = plan.memory.maximum.map(|max| {
  697|       |            usize::try_from(max)
  698|       |                .ok()
  699|       |                .and_then(|m| m.checked_mul(WASM_PAGE_SIZE))
  700|       |                .unwrap_or(absolute_max)
  701|    636|        });
  702|    636|
  703|    636|        // If this is a 32-bit memory and no maximum is otherwise listed then we
  704|    636|        // need to still specify a maximum size of 4GB. If the host platform is
  705|    636|        // 32-bit then there's no need to limit the maximum this way since no
  706|    636|        // allocation of 4GB can succeed, but for 64-bit platforms this is
  707|    636|        // required to limit memories to 4GB.
  708|    636|        if !plan.memory.memory64 && maximum.is_none() {
  709|      0|            maximum = usize::try_from(1u64 << 32).ok();
  710|    636|        }
  711|       |
  712|       |        // Inform the store's limiter what's about to happen. This will let the
  713|       |        // limiter reject anything if necessary, and this also guarantees that
  714|       |        // we should call the limiter for all requested memories, even if our
  715|       |        // `minimum` calculation overflowed. This means that the `minimum` we're
  716|       |        // informing the limiter is lossy and may not be 100% accurate, but for
  717|       |        // now the expected uses of limiter means that's ok.
  718|    636|        if let Some(store) = store {
  719|       |            // We ignore the store limits for shared memories since they are
  720|       |            // technically not created within a store (though, trickily, they
  721|       |            // may be associated with one in order to get a `vmctx`).
  722|    636|            if !plan.memory.shared {
  723|    636|                if !store.memory_growing(0, minimum.unwrap_or(absolute_max), maximum)? {
  724|      0|                    bail!(
  725|      0|                        "memory minimum size of {} pages exceeds memory limits",
  726|      0|                        plan.memory.minimum
  727|      0|                    );
  728|    636|                }
  729|      0|            }
  730|      0|        }
  731|       |
  732|       |        // At this point we need to actually handle overflows, so bail out with
  733|       |        // an error if we made it this far.
  734|    636|        let minimum = minimum.ok_or_else(|| {
  735|       |            format_err!(
  736|       |                "memory minimum size of {} pages exceeds memory limits",
  737|       |                plan.memory.minimum
  738|       |            )
  739|    636|        })?;
  740|    636|        Ok((minimum, maximum))
  741|    636|    }
_RNvMs_NtCslvZ9xuS3Qdd_16wasmtime_runtime6memoryNtB4_10MmapMemory3new:
  193|    636|    pub fn new(
  194|    636|        plan: &MemoryPlan,
  195|    636|        minimum: usize,
  196|    636|        mut maximum: Option<usize>,
  197|    636|        memory_image: Option<&Arc<MemoryImage>>,
  198|    636|    ) -> Result<Self> {
  199|    636|        // It's a programmer error for these two configuration values to exceed
  200|    636|        // the host available address space, so panic if such a configuration is
  201|    636|        // found (mostly an issue for hypothetical 32-bit hosts).
  202|    636|        let offset_guard_bytes = usize::try_from(plan.offset_guard_size).unwrap();
  203|    636|        let pre_guard_bytes = usize::try_from(plan.pre_guard_size).unwrap();
  204|       |
  205|    636|        let (alloc_bytes, extra_to_reserve_on_growth) = match plan.style {
  206|       |            // Dynamic memories start with the minimum size plus the `reserve`
  207|       |            // amount specified to grow into.
  208|      0|            MemoryStyle::Dynamic { reserve } => (minimum, usize::try_from(reserve).unwrap()),
  209|       |
  210|       |            // Static memories will never move in memory and consequently get
  211|       |            // their entire allocation up-front with no extra room to grow into.
  212|       |            // Note that the `maximum` is adjusted here to whatever the smaller
  213|       |            // of the two is, the `maximum` given or the `bound` specified for
  214|       |            // this memory.
  215|    636|            MemoryStyle::Static { bound } => {
  216|    636|                assert!(bound >= plan.memory.minimum);
  217|    636|                let bound_bytes =
  218|    636|                    usize::try_from(bound.checked_mul(WASM_PAGE_SIZE_U64).unwrap()).unwrap();
  219|    636|                maximum = Some(bound_bytes.min(maximum.unwrap_or(usize::MAX)));
  220|    636|                (bound_bytes, 0)
  221|       |            }
  222|       |        };
  223|       |
  224|    636|        let request_bytes = pre_guard_bytes
  225|    636|            .checked_add(alloc_bytes)
  226|    636|            .and_then(|i| i.checked_add(extra_to_reserve_on_growth))
  227|    636|            .and_then(|i| i.checked_add(offset_guard_bytes))
  228|    636|            .ok_or_else(|| format_err!("cannot allocate {} with guard regions", minimum))?;
  229|    636|        let mut mmap = Mmap::accessible_reserved(0, request_bytes)?;
  230|       |
  231|    636|        if minimum > 0 {
  232|      0|            mmap.make_accessible(pre_guard_bytes, minimum)?;
  233|    636|        }
  234|       |
  235|       |        // If a memory image was specified, try to create the MemoryImageSlot on
  236|       |        // top of our mmap.
  237|    636|        let memory_image = match memory_image {
  238|      0|            Some(image) => {
  239|      0|                let base = unsafe { mmap.as_mut_ptr().add(pre_guard_bytes) };
  240|      0|                let mut slot = MemoryImageSlot::create(
  241|      0|                    base.cast(),
  242|      0|                    minimum,
  243|      0|                    alloc_bytes + extra_to_reserve_on_growth,
  244|      0|                );
  245|      0|                slot.instantiate(minimum, Some(image))?;
  246|       |                // On drop, we will unmap our mmap'd range that this slot was
  247|       |                // mapped on top of, so there is no need for the slot to wipe
  248|       |                // it with an anonymous mapping first.
  249|      0|                slot.no_clear_on_drop();
  250|      0|                Some(slot)
  251|       |            }
  252|    636|            None => None,
  253|       |        };
  254|       |
  255|    636|        Ok(Self {
  256|    636|            mmap,
  257|    636|            accessible: minimum,
  258|    636|            maximum,
  259|    636|            pre_guard_size: pre_guard_bytes,
  260|    636|            offset_guard_size: offset_guard_bytes,
  261|    636|            extra_to_reserve_on_growth,
  262|    636|            memory_image,
  263|    636|        })
  264|    636|    }
_RNvMs7_NtCslvZ9xuS3Qdd_16wasmtime_runtime6memoryNtB5_6Memory8vmmemory:
  793|    636|    pub fn vmmemory(&mut self) -> VMMemoryDefinition {
  794|    636|        self.0.vmmemory()
  795|    636|    }
_RNCNvMs7_NtCslvZ9xuS3Qdd_16wasmtime_runtime6memoryNtB7_6Memory9limit_new0B9_:
  688|    636|            .and_then(|m| usize::try_from(m).ok());
_RNCNvMs7_NtCslvZ9xuS3Qdd_16wasmtime_runtime6memoryNtB7_6Memory9limit_news_0B9_:
  696|    636|        let mut maximum = plan.memory.maximum.map(|max| {
  697|    636|            usize::try_from(max)
  698|    636|                .ok()
  699|    636|                .and_then(|m| m.checked_mul(WASM_PAGE_SIZE))
  700|    636|                .unwrap_or(absolute_max)
  701|    636|        });
_RNvXs0_NtCslvZ9xuS3Qdd_16wasmtime_runtime6memoryNtB5_10MmapMemoryNtB5_19RuntimeLinearMemory8vmmemory:
  326|    636|    fn vmmemory(&mut self) -> VMMemoryDefinition {
  327|    636|        VMMemoryDefinition {
  328|    636|            base: unsafe { self.mmap.as_mut_ptr().add(self.pre_guard_size) },
  329|    636|            current_length: self.accessible.into(),
  330|    636|        }
  331|    636|    }
_RNCNCNvMs7_NtCslvZ9xuS3Qdd_16wasmtime_runtime6memoryNtB9_6Memory9limit_news_00Bb_:
  699|    636|                .and_then(|m| m.checked_mul(WASM_PAGE_SIZE))
_RNvXNtCslvZ9xuS3Qdd_16wasmtime_runtime6memoryNtB2_20DefaultMemoryCreatorNtB2_20RuntimeMemoryCreator10new_memory:
   38|    636|    fn new_memory(
   39|    636|        &self,
   40|    636|        plan: &MemoryPlan,
   41|    636|        minimum: usize,
   42|    636|        maximum: Option<usize>,
   43|    636|        memory_image: Option<&Arc<MemoryImage>>,
   44|    636|    ) -> Result<Box<dyn RuntimeLinearMemory>> {
   45|    636|        Ok(Box::new(MmapMemory::new(
   46|    636|            plan,
   47|    636|            minimum,
   48|    636|            maximum,
   49|    636|            memory_image,
   50|    636|        )?))
   51|    636|    }
_RNCNvMs_NtCslvZ9xuS3Qdd_16wasmtime_runtime6memoryNtB6_10MmapMemory3new0B8_:
  226|    636|            .and_then(|i| i.checked_add(extra_to_reserve_on_growth))

_RNvMNtCslvZ9xuS3Qdd_16wasmtime_runtime4mmapNtB2_4Mmap10as_mut_ptr:
  353|    636|    pub fn as_mut_ptr(&self) -> *mut u8 {
  354|    636|        self.ptr as *mut u8
  355|    636|    }
_RNvXs_NtCslvZ9xuS3Qdd_16wasmtime_runtime4mmapNtB4_4MmapNtNtNtCsiloedr2K6v7_4core3ops4drop4Drop4drop:
  454|  2.54k|    fn drop(&mut self) {
  455|  2.54k|        if self.len != 0 {
  456|  2.54k|            unsafe { rustix::mm::munmap(self.ptr as *mut std::ffi::c_void, self.len) }
  457|  2.54k|                .expect("munmap failed");
  458|  2.54k|        }
  459|  2.54k|    }
_RNvMNtCslvZ9xuS3Qdd_16wasmtime_runtime4mmapNtB2_4Mmap19accessible_reserved:
  160|  2.54k|    pub fn accessible_reserved(accessible_size: usize, mapping_size: usize) -> Result<Self> {
  161|  2.54k|        let page_size = crate::page_size();
  162|  2.54k|        assert!(accessible_size <= mapping_size);
  163|  2.54k|        assert_eq!(mapping_size & (page_size - 1), 0);
  164|  2.54k|        assert_eq!(accessible_size & (page_size - 1), 0);
  165|       |
  166|       |        // Mmap may return EINVAL if the size is zero, so just
  167|       |        // special-case that.
  168|  2.54k|        if mapping_size == 0 {
  169|      0|            return Ok(Self::new());
  170|  2.54k|        }
  171|  2.54k|
  172|  2.54k|        Ok(if accessible_size == mapping_size {
  173|       |            // Allocate a single read-write region at once.
  174|  1.27k|            let ptr = unsafe {
  175|  1.27k|                rustix::mm::mmap_anonymous(
  176|  1.27k|                    ptr::null_mut(),
  177|  1.27k|                    mapping_size,
  178|  1.27k|                    rustix::mm::ProtFlags::READ | rustix::mm::ProtFlags::WRITE,
  179|  1.27k|                    rustix::mm::MapFlags::PRIVATE,
  180|  1.27k|                )
  181|  1.27k|                .context(format!("mmap failed to allocate {:#x} bytes", mapping_size))?
  182|       |            };
  183|       |
  184|  1.27k|            Self {
  185|  1.27k|                ptr: ptr as usize,
  186|  1.27k|                len: mapping_size,
  187|  1.27k|                file: None,
  188|  1.27k|            }
  189|       |        } else {
  190|       |            // Reserve the mapping size.
  191|  1.27k|            let ptr = unsafe {
  192|  1.27k|                rustix::mm::mmap_anonymous(
  193|  1.27k|                    ptr::null_mut(),
  194|  1.27k|                    mapping_size,
  195|  1.27k|                    rustix::mm::ProtFlags::empty(),
  196|  1.27k|                    rustix::mm::MapFlags::PRIVATE,
  197|  1.27k|                )
  198|  1.27k|                .context(format!("mmap failed to allocate {:#x} bytes", mapping_size))?
  199|       |            };
  200|       |
  201|  1.27k|            let mut result = Self {
  202|  1.27k|                ptr: ptr as usize,
  203|  1.27k|                len: mapping_size,
  204|  1.27k|                file: None,
  205|  1.27k|            };
  206|  1.27k|
  207|  1.27k|            if accessible_size != 0 {
  208|       |                // Commit the accessible size.
  209|      0|                result.make_accessible(0, accessible_size)?;
  210|  1.27k|            }
  211|       |
  212|  1.27k|            result
  213|       |        })
  214|  2.54k|    }

_RNvMNtCslvZ9xuS3Qdd_16wasmtime_runtime9module_idNtB2_25CompiledModuleIdAllocator3new:
   20|    636|    pub fn new() -> Self {
   21|    636|        Self {
   22|    636|            next: AtomicU64::new(1),
   23|    636|        }
   24|    636|    }

_RNvNtCslvZ9xuS3Qdd_16wasmtime_runtime12traphandlers10init_traps:
   65|    636|pub fn init_traps(is_wasm_pc: fn(usize) -> bool) {
   66|    636|    static INIT: Once = Once::new();
   67|    636|    INIT.call_once(|| unsafe {
   68|       |        IS_WASM_PC = is_wasm_pc;
   69|       |        sys::platform_init();
   70|    636|    });
   71|    636|}
_RNCNvNtCslvZ9xuS3Qdd_16wasmtime_runtime12traphandlers10init_traps0B5_:
   67|      1|    INIT.call_once(|| unsafe {
   68|      1|        IS_WASM_PC = is_wasm_pc;
   69|      1|        sys::platform_init();
   70|      1|    });

_RNCNvNtNtCslvZ9xuS3Qdd_16wasmtime_runtime12traphandlers4unix13platform_init0B7_:
   17|      3|    let register = |slot: &mut MaybeUninit<libc::sigaction>, signal: i32| {
   18|      3|        let mut handler: libc::sigaction = mem::zeroed();
   19|      3|        // The flags here are relatively careful, and they are...
   20|      3|        //
   21|      3|        // SA_SIGINFO gives us access to information like the program
   22|      3|        // counter from where the fault happened.
   23|      3|        //
   24|      3|        // SA_ONSTACK allows us to handle signals on an alternate stack,
   25|      3|        // so that the handler can run in response to running out of
   26|      3|        // stack space on the main stack. Rust installs an alternate
   27|      3|        // stack with sigaltstack, so we rely on that.
   28|      3|        //
   29|      3|        // SA_NODEFER allows us to reenter the signal handler if we
   30|      3|        // crash while handling the signal, and fall through to the
   31|      3|        // Breakpad handler by testing handlingSegFault.
   32|      3|        handler.sa_flags = libc::SA_SIGINFO | libc::SA_NODEFER | libc::SA_ONSTACK;
   33|      3|        handler.sa_sigaction = trap_handler as usize;
   34|      3|        libc::sigemptyset(&mut handler.sa_mask);
   35|      3|        if libc::sigaction(signal, &handler, slot.as_mut_ptr()) != 0 {
   36|      0|            panic!(
   37|      0|                "unable to install signal handler: {}",
   38|      0|                io::Error::last_os_error(),
   39|      0|            );
   40|      3|        }
   41|      3|    };
_RNvNtNtCslvZ9xuS3Qdd_16wasmtime_runtime12traphandlers4unix13platform_init:
   16|      1|pub unsafe fn platform_init() {
   17|      1|    let register = |slot: &mut MaybeUninit<libc::sigaction>, signal: i32| {
   18|       |        let mut handler: libc::sigaction = mem::zeroed();
   19|       |        // The flags here are relatively careful, and they are...
   20|       |        //
   21|       |        // SA_SIGINFO gives us access to information like the program
   22|       |        // counter from where the fault happened.
   23|       |        //
   24|       |        // SA_ONSTACK allows us to handle signals on an alternate stack,
   25|       |        // so that the handler can run in response to running out of
   26|       |        // stack space on the main stack. Rust installs an alternate
   27|       |        // stack with sigaltstack, so we rely on that.
   28|       |        //
   29|       |        // SA_NODEFER allows us to reenter the signal handler if we
   30|       |        // crash while handling the signal, and fall through to the
   31|       |        // Breakpad handler by testing handlingSegFault.
   32|       |        handler.sa_flags = libc::SA_SIGINFO | libc::SA_NODEFER | libc::SA_ONSTACK;
   33|       |        handler.sa_sigaction = trap_handler as usize;
   34|       |        libc::sigemptyset(&mut handler.sa_mask);
   35|       |        if libc::sigaction(signal, &handler, slot.as_mut_ptr()) != 0 {
   36|       |            panic!(
   37|       |                "unable to install signal handler: {}",
   38|       |                io::Error::last_os_error(),
   39|       |            );
   40|       |        }
   41|       |    };
   42|       |
   43|       |    // Allow handling OOB with signals on all architectures
   44|      1|    register(&mut PREV_SIGSEGV, libc::SIGSEGV);
   45|      1|
   46|      1|    // Handle `unreachable` instructions which execute `ud2` right now
   47|      1|    register(&mut PREV_SIGILL, libc::SIGILL);
   48|       |
   49|       |    // x86 and s390x use SIGFPE to report division by zero
   50|      1|    if cfg!(target_arch = "x86") || cfg!(target_arch = "x86_64") || cfg!(target_arch = "s390x") {
   51|      1|        register(&mut PREV_SIGFPE, libc::SIGFPE);
   52|      1|    }
   53|       |
   54|       |    // Sometimes we need to handle SIGBUS too:
   55|       |    // - On ARM, handle Unaligned Accesses.
   56|       |    // - On Darwin, guard page accesses are raised as SIGBUS.
   57|      1|    if cfg!(target_arch = "arm") || cfg!(target_os = "macos") || cfg!(target_os = "freebsd") {
   58|      0|        register(&mut PREV_SIGBUS, libc::SIGBUS);
   59|      1|    }
   60|      1|}

_RNvMs7_NtCslvZ9xuS3Qdd_16wasmtime_runtime9vmcontextNtB5_18VMGlobalDefinition10as_i64_mut:
  411|    636|    pub unsafe fn as_i64_mut(&mut self) -> &mut i64 {
  412|    636|        &mut *(self.storage.as_mut().as_mut_ptr().cast::<i64>())
  413|    636|    }
_RNvMs7_NtCslvZ9xuS3Qdd_16wasmtime_runtime9vmcontextNtB5_18VMGlobalDefinition3new:
  375|    636|    pub fn new() -> Self {
  376|    636|        Self { storage: [0; 16] }
  377|    636|    }
_RNvXsf_NtCslvZ9xuS3Qdd_16wasmtime_runtime9vmcontextNtB5_15VMRuntimeLimitsNtNtCsiloedr2K6v7_4core7default7Default7default:
  777|    636|    fn default() -> VMRuntimeLimits {
  778|    636|        VMRuntimeLimits {
  779|    636|            stack_limit: UnsafeCell::new(usize::max_value()),
  780|    636|            fuel_consumed: UnsafeCell::new(0),
  781|    636|            epoch_deadline: UnsafeCell::new(0),
  782|    636|            last_wasm_exit_fp: UnsafeCell::new(0),
  783|    636|            last_wasm_exit_pc: UnsafeCell::new(0),
  784|    636|            last_wasm_entry_sp: UnsafeCell::new(0),
  785|    636|        }
  786|    636|    }

_RNvXs3X_Cs15iRE7yYizN_14wasmtime_typesNtB6_6MemoryNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
  347|  1.90k|#[derive(Debug, Clone, Copy, Hash, Eq, PartialEq, Serialize, Deserialize)]

_RNvNvNvXs0_CscSNP6bGsstK_10env_loggerNtB9_6LoggerNtCsbIC4eNc6bgl_3log3Log3log9FORMATTER6___init:
  294|      1|            fn __init() -> $t { $init }
_RNvNvNvXs0_CscSNP6bGsstK_10env_loggerNtB9_6LoggerNtCsbIC4eNc6bgl_3log3Log3log9FORMATTER7___getit:
  319|    636|            unsafe fn __getit(
  320|    636|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
  321|    636|            ) -> $crate::option::Option<&'static $t> {
  322|    636|                #[cfg(all(target_family = "wasm", not(target_feature = "atomics")))]
  323|    636|                static __KEY: $crate::thread::__StaticLocalKeyInner<$t> =
  324|    636|                    $crate::thread::__StaticLocalKeyInner::new();
  325|    636|
  326|    636|                #[thread_local]
  327|    636|                #[cfg(all(
  328|    636|                    target_thread_local,
  329|    636|                    not(all(target_family = "wasm", not(target_feature = "atomics"))),
  330|    636|                ))]
  331|    636|                static __KEY: $crate::thread::__FastLocalKeyInner<$t> =
  332|    636|                    $crate::thread::__FastLocalKeyInner::new();
  333|    636|
  334|    636|                #[cfg(all(
  335|    636|                    not(target_thread_local),
  336|    636|                    not(all(target_family = "wasm", not(target_feature = "atomics"))),
  337|    636|                ))]
  338|    636|                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =
  339|    636|                    $crate::thread::__OsLocalKeyInner::new();
  340|    636|
  341|    636|                // FIXME: remove the #[allow(...)] marker when macros don't
  342|    636|                // raise warning for missing/extraneous unsafe blocks anymore.
  343|    636|                // See https://github.com/rust-lang/rust/issues/74838.
  344|    636|                #[allow(unused_unsafe)]
  345|    636|                unsafe {
  346|    636|                    __KEY.get(move || {
  347|       |                        if let $crate::option::Option::Some(init) = init {
  348|       |                            if let $crate::option::Option::Some(value) = init.take() {
  349|       |                                return value;
  350|       |                            } else if $crate::cfg!(debug_assertions) {
  351|       |                                $crate::unreachable!("missing default value");
  352|       |                            }
  353|       |                        }
  354|       |                        __init()
  355|    636|                    })
  356|    636|                }
  357|    636|            }
_RNvNvNtCsiDsdoxUJBlR_16futures_executor10local_pool21CURRENT_THREAD_NOTIFY7___getit:
  319|    318|            unsafe fn __getit(
  320|    318|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
  321|    318|            ) -> $crate::option::Option<&'static $t> {
  322|    318|                #[cfg(all(target_family = "wasm", not(target_feature = "atomics")))]
  323|    318|                static __KEY: $crate::thread::__StaticLocalKeyInner<$t> =
  324|    318|                    $crate::thread::__StaticLocalKeyInner::new();
  325|    318|
  326|    318|                #[thread_local]
  327|    318|                #[cfg(all(
  328|    318|                    target_thread_local,
  329|    318|                    not(all(target_family = "wasm", not(target_feature = "atomics"))),
  330|    318|                ))]
  331|    318|                static __KEY: $crate::thread::__FastLocalKeyInner<$t> =
  332|    318|                    $crate::thread::__FastLocalKeyInner::new();
  333|    318|
  334|    318|                #[cfg(all(
  335|    318|                    not(target_thread_local),
  336|    318|                    not(all(target_family = "wasm", not(target_feature = "atomics"))),
  337|    318|                ))]
  338|    318|                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =
  339|    318|                    $crate::thread::__OsLocalKeyInner::new();
  340|    318|
  341|    318|                // FIXME: remove the #[allow(...)] marker when macros don't
  342|    318|                // raise warning for missing/extraneous unsafe blocks anymore.
  343|    318|                // See https://github.com/rust-lang/rust/issues/74838.
  344|    318|                #[allow(unused_unsafe)]
  345|    318|                unsafe {
  346|    318|                    __KEY.get(move || {
  347|       |                        if let $crate::option::Option::Some(init) = init {
  348|       |                            if let $crate::option::Option::Some(value) = init.take() {
  349|       |                                return value;
  350|       |                            } else if $crate::cfg!(debug_assertions) {
  351|       |                                $crate::unreachable!("missing default value");
  352|       |                            }
  353|       |                        }
  354|       |                        __init()
  355|    318|                    })
  356|    318|                }
  357|    318|            }
_RNvNvNtCsiDsdoxUJBlR_16futures_executor10local_pool21CURRENT_THREAD_NOTIFY6___init:
  294|      1|            fn __init() -> $t { $init }
_RNvNvNtCsiDsdoxUJBlR_16futures_executor5enter7ENTERED6___init:
  294|      1|            fn __init() -> $t { $init }
_RNvNvNtCsiDsdoxUJBlR_16futures_executor5enter7ENTERED7___getit:
  319|    636|            unsafe fn __getit(
  320|    636|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
  321|    636|            ) -> $crate::option::Option<&'static $t> {
  322|    636|                #[cfg(all(target_family = "wasm", not(target_feature = "atomics")))]
  323|    636|                static __KEY: $crate::thread::__StaticLocalKeyInner<$t> =
  324|    636|                    $crate::thread::__StaticLocalKeyInner::new();
  325|    636|
  326|    636|                #[thread_local]
  327|    636|                #[cfg(all(
  328|    636|                    target_thread_local,
  329|    636|                    not(all(target_family = "wasm", not(target_feature = "atomics"))),
  330|    636|                ))]
  331|    636|                static __KEY: $crate::thread::__FastLocalKeyInner<$t> =
  332|    636|                    $crate::thread::__FastLocalKeyInner::new();
  333|    636|
  334|    636|                #[cfg(all(
  335|    636|                    not(target_thread_local),
  336|    636|                    not(all(target_family = "wasm", not(target_feature = "atomics"))),
  337|    636|                ))]
  338|    636|                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =
  339|    636|                    $crate::thread::__OsLocalKeyInner::new();
  340|    636|
  341|    636|                // FIXME: remove the #[allow(...)] marker when macros don't
  342|    636|                // raise warning for missing/extraneous unsafe blocks anymore.
  343|    636|                // See https://github.com/rust-lang/rust/issues/74838.
  344|    636|                #[allow(unused_unsafe)]
  345|    636|                unsafe {
  346|    636|                    __KEY.get(move || {
  347|       |                        if let $crate::option::Option::Some(init) = init {
  348|       |                            if let $crate::option::Option::Some(value) = init.take() {
  349|       |                                return value;
  350|       |                            } else if $crate::cfg!(debug_assertions) {
  351|       |                                $crate::unreachable!("missing default value");
  352|       |                            }
  353|       |                        }
  354|       |                        __init()
  355|    636|                    })
  356|    636|                }
  357|    636|            }
_RNvNvNtNtCsf3wFRFpNELZ_4rand4rngs6thread14THREAD_RNG_KEY7___getit:
  319|    318|            unsafe fn __getit(
  320|    318|                init: $crate::option::Option<&mut $crate::option::Option<$t>>,
  321|    318|            ) -> $crate::option::Option<&'static $t> {
  322|    318|                #[cfg(all(target_family = "wasm", not(target_feature = "atomics")))]
  323|    318|                static __KEY: $crate::thread::__StaticLocalKeyInner<$t> =
  324|    318|                    $crate::thread::__StaticLocalKeyInner::new();
  325|    318|
  326|    318|                #[thread_local]
  327|    318|                #[cfg(all(
  328|    318|                    target_thread_local,
  329|    318|                    not(all(target_family = "wasm", not(target_feature = "atomics"))),
  330|    318|                ))]
  331|    318|                static __KEY: $crate::thread::__FastLocalKeyInner<$t> =
  332|    318|                    $crate::thread::__FastLocalKeyInner::new();
  333|    318|
  334|    318|                #[cfg(all(
  335|    318|                    not(target_thread_local),
  336|    318|                    not(all(target_family = "wasm", not(target_feature = "atomics"))),
  337|    318|                ))]
  338|    318|                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =
  339|    318|                    $crate::thread::__OsLocalKeyInner::new();
  340|    318|
  341|    318|                // FIXME: remove the #[allow(...)] marker when macros don't
  342|    318|                // raise warning for missing/extraneous unsafe blocks anymore.
  343|    318|                // See https://github.com/rust-lang/rust/issues/74838.
  344|    318|                #[allow(unused_unsafe)]
  345|    318|                unsafe {
  346|    318|                    __KEY.get(move || {
  347|       |                        if let $crate::option::Option::Some(init) = init {
  348|       |                            if let $crate::option::Option::Some(value) = init.take() {
  349|       |                                return value;
  350|       |                            } else if $crate::cfg!(debug_assertions) {
  351|       |                                $crate::unreachable!("missing default value");
  352|       |                            }
  353|       |                        }
  354|       |                        __init()
  355|    318|                    })
  356|    318|                }
  357|    318|            }
_RNvNvNtNtCsf3wFRFpNELZ_4rand4rngs6thread14THREAD_RNG_KEY6___init:
  294|      1|            fn __init() -> $t { $init }

_RNvCsboUdcTbF1FS_15direct_syscalls15stress_syscalls:
   29|    318|pub fn stress_syscalls(data: &[u8]) {
   30|    318|    let _ = env_logger::try_init();
   31|    318|
   32|    318|    let nc = NetworkConfig::new(NetworkVersion::V18);
   33|    318|    let ec = EngineConfig::from(&nc);
   34|    318|
   35|    318|    let mut tester = get_tester();
   36|    318|    tester.instantiate_machine(DummyExterns).unwrap();
   37|    318|
   38|    318|    let mut u = Unstructured::new(data);
   39|    318|
   40|    318|    let mut cp: [u8; 100_000] = u.arbitrary().unwrap();
   41|    318|    let mem = fvm::syscalls::context::Memory::new(&mut cp);
   42|    318|
   43|    318|    let machine = tester.executor.unwrap().into_machine().unwrap();
   44|    318|
   45|    318|    let pool = EnginePool::new_default(ec).unwrap();
   46|    318|
   47|    318|    let engine = pool.acquire();
   48|    318|
   49|    318|    let _t1: [u32; 10] = u.arbitrary().unwrap();
   50|    318|    let bignumber: u128 = u.arbitrary().unwrap();
   51|    318|    let bigint = BigInt::from_str(&format!("{}", bignumber));
   52|    318|
   53|    318|    let call_manager = DefaultCallManager::new(
   54|    318|        machine,
   55|    318|        engine,
   56|    318|        u.arbitrary().unwrap(),
   57|    318|        u.arbitrary().unwrap(),
   58|    318|        Address::new_id(u.arbitrary().unwrap()),
   59|    318|        u.arbitrary().unwrap(),
   60|    318|        // Try different froms
   61|    318|        TokenAmount::from_atto(bigint.clone().unwrap()),
   62|    318|    );
   63|    318|
   64|    318|    let block_registry = BlockRegistry::default();
   65|    318|
   66|    318|    let mut default_kernel = DefaultKernel::new(
   67|    318|        call_manager,
   68|    318|        block_registry,
   69|    318|        // This should be the same as line 54?
   70|    318|        u.arbitrary().unwrap(),
   71|    318|        // TODO, get the ids from the builtin actors
   72|    318|        u.arbitrary().unwrap(),
   73|    318|        // In theory is always method number 0 ?
   74|    318|        u.arbitrary().unwrap(),
   75|    318|        TokenAmount::from_atto(bigint.unwrap()),
   76|    318|    );
   77|    318|
   78|    318|    // TODO, dice the syscalls
   79|    318|    let r = block_create(
   80|    318|        fvm::syscalls::context::Context {
   81|    318|            kernel: &mut default_kernel,
   82|    318|            memory: mem,
   83|    318|        },
   84|    318|        u.arbitrary().unwrap(),
   85|    318|        u.arbitrary().unwrap(),
   86|    318|        u.arbitrary().unwrap(),
   87|    318|    );
   88|    318|
   89|    318|    match r {
   90|      0|        Ok(r) => {
   91|      0|            log::debug!("Correct {:?}", r)
   92|       |        }
   93|    318|        Err(e) => {
   94|    318|            log::warn!("{:?}", e)
   95|       |        }
   96|       |    }
   97|    318|}

_RNvCs7AwuCMXPzRZ_8fvm_fuzz10get_tester:
  309|    318|pub fn get_tester() -> Tester<MemoryBlockstore, DummyExterns> {
  310|    318|    let bs = MemoryBlockstore::default();
  311|    318|    let bundle_root = import_bundle(&bs, actors_v10::BUNDLE_CAR).unwrap();
  312|    318|
  313|    318|    Tester::new(NetworkVersion::V18, StateTreeVersion::V5, bundle_root, bs).unwrap()
  314|    318|}

_RNvMs0_NtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x648settingsNtB5_5Flags10has_popcnt:
  181|    636|    pub fn has_popcnt(&self) -> bool {
  182|    636|        self.numbered_predicate(12)
  183|    636|    }
_RNvMs0_NtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x648settingsNtB5_5Flags9has_lzcnt:
  196|    636|    pub fn has_lzcnt(&self) -> bool {
  197|    636|        self.numbered_predicate(15)
  198|    636|    }
_RNvMs0_NtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x648settingsNtB5_5Flags8has_bmi1:
  186|    636|    pub fn has_bmi1(&self) -> bool {
  187|    636|        self.numbered_predicate(13)
  188|    636|    }
_RNvMs0_NtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x648settingsNtB5_5Flags9has_sse41:
  131|  1.27k|    pub fn has_sse41(&self) -> bool {
  132|  1.27k|        self.numbered_predicate(2)
  133|  1.27k|    }
_RNvMs0_NtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x648settingsNtB5_5Flags7has_avx:
  141|    636|    pub fn has_avx(&self) -> bool {
  142|    636|        self.numbered_predicate(4)
  143|    636|    }
_RNvMs0_NtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x648settingsNtB5_5Flags9has_sse42:
  136|  1.27k|    pub fn has_sse42(&self) -> bool {
  137|  1.27k|        self.numbered_predicate(3)
  138|  1.27k|    }
_RNvNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x648settings7builder:
  493|    636|pub fn builder() -> Builder {
  494|    636|    Builder::new(&TEMPLATE)
  495|    636|}
_RNvMs0_NtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x648settingsNtB5_5Flags18numbered_predicate:
  116|  6.36k|    fn numbered_predicate(&self, p: usize) -> bool {
  117|  6.36k|        self.bytes[0 + p / 8] & (1 << (p % 8)) != 0
  118|  6.36k|    }
_RNvMs0_NtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x648settingsNtB5_5Flags9has_ssse3:
  126|    636|    pub fn has_ssse3(&self) -> bool {
  127|    636|        self.numbered_predicate(1)
  128|    636|    }
_RNvMNtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x648settingsNtB2_5Flags3new:
    9|    636|    pub fn new(shared: &settings::Flags, builder: Builder) -> Self {
   10|    636|        let bvec = builder.state_for("x86");
   11|    636|        let mut x86 = Self { bytes: [0; 5] };
   12|    636|        debug_assert_eq!(bvec.len(), 2);
   13|    636|        x86.bytes[0..2].copy_from_slice(&bvec);
   14|    636|        // Precompute #16.
   15|    636|        if shared.is_pic() {
   16|      0|            x86.bytes[2] |= 1 << 0;
   17|    636|        }
   18|       |        // Precompute #17.
   19|    636|        if !(shared.is_pic()) {
   20|    636|            x86.bytes[2] |= 1 << 1;
   21|    636|        }
   22|       |        // Precompute #18.
   23|    636|        if shared.enable_simd() && x86.has_avx2() {
   24|      0|            x86.bytes[2] |= 1 << 2;
   25|    636|        }
   26|       |        // Precompute #19.
   27|    636|        if shared.enable_simd() && x86.has_avx512bitalg() {
   28|      0|            x86.bytes[2] |= 1 << 3;
   29|    636|        }
   30|       |        // Precompute #20.
   31|    636|        if shared.enable_simd() && x86.has_avx512dq() {
   32|      0|            x86.bytes[2] |= 1 << 4;
   33|    636|        }
   34|       |        // Precompute #21.
   35|    636|        if shared.enable_simd() && x86.has_avx512f() {
   36|      0|            x86.bytes[2] |= 1 << 5;
   37|    636|        }
   38|       |        // Precompute #22.
   39|    636|        if shared.enable_simd() && x86.has_avx512vbmi() {
   40|      0|            x86.bytes[2] |= 1 << 6;
   41|    636|        }
   42|       |        // Precompute #23.
   43|    636|        if shared.enable_simd() && x86.has_avx512vl() {
   44|      0|            x86.bytes[2] |= 1 << 7;
   45|    636|        }
   46|       |        // Precompute #24.
   47|    636|        if shared.enable_simd() && x86.has_avx() {
   48|      0|            x86.bytes[3] |= 1 << 0;
   49|    636|        }
   50|       |        // Precompute #25.
   51|    636|        if x86.has_bmi1() {
   52|    636|            x86.bytes[3] |= 1 << 1;
   53|    636|        }
   54|       |        // Precompute #26.
   55|    636|        if x86.has_avx() && x86.has_fma() {
   56|    636|            x86.bytes[3] |= 1 << 2;
   57|    636|        }
   58|       |        // Precompute #27.
   59|    636|        if x86.has_lzcnt() {
   60|    636|            x86.bytes[3] |= 1 << 3;
   61|    636|        }
   62|       |        // Precompute #28.
   63|    636|        if x86.has_popcnt() && x86.has_sse42() {
   64|    636|            x86.bytes[3] |= 1 << 4;
   65|    636|        }
   66|       |        // Precompute #29.
   67|    636|        if x86.has_sse41() {
   68|    636|            x86.bytes[3] |= 1 << 5;
   69|    636|        }
   70|       |        // Precompute #30.
   71|    636|        if shared.enable_simd() && x86.has_sse41() {
   72|      0|            x86.bytes[3] |= 1 << 6;
   73|    636|        }
   74|       |        // Precompute #31.
   75|    636|        if x86.has_sse41() && x86.has_sse42() {
   76|    636|            x86.bytes[3] |= 1 << 7;
   77|    636|        }
   78|       |        // Precompute #32.
   79|    636|        if shared.enable_simd() && x86.has_sse41() && x86.has_sse42() {
   80|      0|            x86.bytes[4] |= 1 << 0;
   81|    636|        }
   82|       |        // Precompute #33.
   83|    636|        if x86.has_ssse3() {
   84|    636|            x86.bytes[4] |= 1 << 1;
   85|    636|        }
   86|       |        // Precompute #34.
   87|    636|        if shared.enable_simd() && x86.has_ssse3() {
   88|      0|            x86.bytes[4] |= 1 << 2;
   89|    636|        }
   90|    636|        x86
   91|    636|    }
_RNvMs0_NtNtNtCs1uaCP4zf1x7_17cranelift_codegen3isa3x648settingsNtB5_5Flags7has_fma:
  151|    636|    pub fn has_fma(&self) -> bool {
  152|    636|        self.numbered_predicate(6)
  153|    636|    }

_RNvMsB_NtCs1uaCP4zf1x7_17cranelift_codegen8settingsNtB5_5Flags6is_pic:
  323|  1.27k|    pub fn is_pic(&self) -> bool {
  324|  1.27k|        self.numbered_predicate(4)
  325|  1.27k|    }
_RNvMsr_NtCs1uaCP4zf1x7_17cranelift_codegen8settingsNtB5_5Flags3new:
    9|    636|    pub fn new(builder: Builder) -> Self {
   10|    636|        let bvec = builder.state_for("shared");
   11|    636|        let mut shared = Self { bytes: [0; 8] };
   12|    636|        debug_assert_eq!(bvec.len(), 8);
   13|    636|        shared.bytes[0..8].copy_from_slice(&bvec);
   14|    636|        shared
   15|    636|    }
_RNvNtCs1uaCP4zf1x7_17cranelift_codegen8settings7builder:
  761|    636|pub fn builder() -> Builder {
  762|    636|    Builder::new(&TEMPLATE)
  763|    636|}
_RNvMsB_NtCs1uaCP4zf1x7_17cranelift_codegen8settingsNtB5_5Flags17enable_pinned_reg:
  363|    636|    pub fn enable_pinned_reg(&self) -> bool {
  364|    636|        self.numbered_predicate(9)
  365|    636|    }
_RNvMsB_NtCs1uaCP4zf1x7_17cranelift_codegen8settingsNtB5_5Flags11enable_simd:
  379|  6.99k|    pub fn enable_simd(&self) -> bool {
  380|  6.99k|        self.numbered_predicate(11)
  381|  6.99k|    }
_RNvMsB_NtCs1uaCP4zf1x7_17cranelift_codegen8settingsNtB5_5Flags18numbered_predicate:
  176|  8.90k|    fn numbered_predicate(&self, p: usize) -> bool {
  177|  8.90k|        self.bytes[5 + p / 8] & (1 << (p % 8)) != 0
  178|  8.90k|    }

_RNvMs3_NtCs2n9sFhuaVtJ_14target_lexicon4hostNtNtB7_6triple6Triple4host:
   64|    636|    pub const fn host() -> Self {
   65|    636|        Self {
   66|    636|            architecture: Architecture::X86_64,
   67|    636|            vendor: Vendor::Unknown,
   68|    636|            operating_system: OperatingSystem::Linux,
   69|    636|            environment: Environment::Gnu,
   70|    636|            binary_format: BinaryFormat::Elf,
   71|    636|        }
   72|    636|    }

_RNvXs0_NtNtCskJihg1y13m7_3fvm10blockstore8bufferedINtB5_18BufferedBlockstoreNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreENtB1g_10Blockstore3getCsboUdcTbF1FS_15direct_syscalls:
  235|  1.27k|    fn get(&self, cid: &Cid) -> Result<Option<Vec<u8>>> {
  236|  1.27k|        Ok(if let Some(data) = self.write.borrow().get(cid) {
  237|      0|            Some(data.clone())
  238|       |        } else {
  239|  1.27k|            self.base.get(cid)?
  240|       |        })
  241|  1.27k|    }
_RNvMNtNtCskJihg1y13m7_3fvm10blockstore8bufferedINtB2_18BufferedBlockstoreNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreE3newCsboUdcTbF1FS_15direct_syscalls:
   28|    318|    pub fn new(base: BS) -> Self {
   29|    318|        Self {
   30|    318|            base,
   31|    318|            write: Default::default(),
   32|    318|        }
   33|    318|    }

_RNvXs4_NtNtCskJihg1y13m7_3fvm12call_manager9backtraceNtB5_9BacktraceNtNtCsiloedr2K6v7_4core7default7Default7default:
   14|    318|#[derive(Debug, Default, Clone)]

_RNvXs0_NtNtCskJihg1y13m7_3fvm12call_manager7defaultINtB5_18DefaultCallManagerINtNtNtB9_7machine7default14DefaultMachineNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsh74LAqVwWKW_21fvm_integration_tests5dummy12DummyExternsEENtB7_11CallManager11gas_trackerCsboUdcTbF1FS_15direct_syscalls:
  280|    318|    fn gas_tracker(&self) -> &GasTracker {
  281|    318|        &self.gas_tracker
  282|    318|    }
_RNvXs0_NtNtCskJihg1y13m7_3fvm12call_manager7defaultINtB5_18DefaultCallManagerINtNtNtB9_7machine7default14DefaultMachineNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsh74LAqVwWKW_21fvm_integration_tests5dummy12DummyExternsEENtB7_11CallManager7machineCsboUdcTbF1FS_15direct_syscalls:
  268|    318|    fn machine(&self) -> &Self::Machine {
  269|    318|        &self.machine
  270|    318|    }
_RNvXs0_NtNtCskJihg1y13m7_3fvm12call_manager7defaultINtB5_18DefaultCallManagerINtNtNtB9_7machine7default14DefaultMachineNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsh74LAqVwWKW_21fvm_integration_tests5dummy12DummyExternsEENtB7_11CallManager3newCsboUdcTbF1FS_15direct_syscalls:
  103|    318|    fn new(
  104|    318|        machine: M,
  105|    318|        engine: Engine,
  106|    318|        gas_limit: i64,
  107|    318|        origin: ActorID,
  108|    318|        origin_address: Address,
  109|    318|        nonce: u64,
  110|    318|        gas_premium: TokenAmount,
  111|    318|    ) -> Self {
  112|    318|        let limits = machine.new_limiter();
  113|    318|        let gas_tracker =
  114|    318|            GasTracker::new(Gas::new(gas_limit), Gas::zero(), machine.context().tracing);
  115|    318|
  116|    318|        DefaultCallManager(Some(Box::new(InnerDefaultCallManager {
  117|    318|            engine: Rc::new(engine),
  118|    318|            machine,
  119|    318|            gas_tracker,
  120|    318|            gas_premium,
  121|    318|            origin,
  122|    318|            origin_address,
  123|    318|            nonce,
  124|    318|            num_actors_created: 0,
  125|    318|            call_stack_depth: 0,
  126|    318|            backtrace: Backtrace::default(),
  127|    318|            exec_trace: vec![],
  128|    318|            invocation_count: 0,
  129|    318|            limits,
  130|    318|            events: Default::default(),
  131|    318|        })))
  132|    318|    }
_RNvXNtNtCskJihg1y13m7_3fvm12call_manager7defaultINtB2_18DefaultCallManagerINtNtNtB6_7machine7default14DefaultMachineNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsh74LAqVwWKW_21fvm_integration_tests5dummy12DummyExternsEENtNtNtCsiloedr2K6v7_4core3ops5deref5Deref5derefCsboUdcTbF1FS_15direct_syscalls:
   85|    636|    fn deref(&self) -> &Self::Target {
   86|    636|        self.0.as_ref().expect("call manager is poisoned")
   87|    636|    }
_RNvXs5_NtNtCskJihg1y13m7_3fvm12call_manager7defaultNtB5_17EventsAccumulatorNtNtCsiloedr2K6v7_4core7default7Default7default:
  769|    318|#[derive(Default)]

_RNvYINtNtNtCskJihg1y13m7_3fvm12call_manager7default18DefaultCallManagerINtNtNtB9_7machine7default14DefaultMachineNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsh74LAqVwWKW_21fvm_integration_tests5dummy12DummyExternsEENtB7_11CallManager10charge_gasCsboUdcTbF1FS_15direct_syscalls:
  150|    318|    fn charge_gas(&self, charge: GasCharge) -> Result<GasTimer> {
  151|    318|        self.gas_tracker().apply_charge(charge)
  152|    318|    }
_RNvYINtNtNtCskJihg1y13m7_3fvm12call_manager7default18DefaultCallManagerINtNtNtB9_7machine7default14DefaultMachineNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsh74LAqVwWKW_21fvm_integration_tests5dummy12DummyExternsEENtB7_11CallManager10price_listCsboUdcTbF1FS_15direct_syscalls:
  120|    318|    fn price_list(&self) -> &PriceList {
  121|    318|        self.machine().context().price_list
  122|    318|    }

_RINvMs4_NtCskJihg1y13m7_3fvm6engineNtB6_6Engine7preloadRNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreRINtNtCs9pDt8l5wGDA_5alloc3vec3VecINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEECsboUdcTbF1FS_15direct_syscalls:
  358|    318|    pub fn preload<'a, BS, I>(&self, blockstore: BS, cids: I) -> anyhow::Result<usize>
  359|    318|    where
  360|    318|        BS: Blockstore,
  361|    318|        I: IntoIterator<Item = &'a Cid>,
  362|    318|    {
  363|    318|        let mut total_size = 0usize;
  364|    318|        for cid in cids {
  365|      0|            log::trace!("preloading code CID {cid}");
  366|      0|            let size = self.prepare_actor_code(cid, &blockstore).with_context(|| {
  367|       |                anyhow!("could not prepare actor with code CID {}", &cid.to_string())
  368|      0|            })?;
  369|      0|            total_size += size;
  370|       |        }
  371|    318|        Ok(total_size)
  372|    318|    }
_RNvXs3_NtCskJihg1y13m7_3fvm6engineNtB5_6EngineNtNtNtCsiloedr2K6v7_4core3ops4drop4Drop4drop:
  314|    636|    fn drop(&mut self) {
  315|    636|        let mut limit = self.0.limit.lock().unwrap();
  316|    636|        *limit += 1;
  317|    636|        self.0.condv.notify_one();
  318|    636|    }
_RNvXNtCskJihg1y13m7_3fvm6engineNtB2_12EngineConfigINtNtCsiloedr2K6v7_4core7convert4FromRNtNtB4_7machine13NetworkConfigE4from:
   55|    636|    fn from(nc: &NetworkConfig) -> Self {
   56|    636|        EngineConfig {
   57|    636|            max_call_depth: nc.max_call_depth,
   58|    636|            max_wasm_stack: nc.max_wasm_stack,
   59|    636|            max_inst_memory_bytes: nc.max_inst_memory_bytes,
   60|    636|            wasm_prices: &nc.price_list.wasm_rules,
   61|    636|            actor_redirect: nc.actor_redirect.clone(),
   62|    636|            concurrency: 1,
   63|    636|        }
   64|    636|    }
_RNvNtCskJihg1y13m7_3fvm6engine15wasmtime_config:
  102|    636|fn wasmtime_config(ec: &EngineConfig) -> anyhow::Result<wasmtime::Config> {
  103|    636|    let instance_count = (1 + ec.max_call_depth) * ec.concurrency;
  104|    636|    let instance_memory_maximum_size = ec.max_inst_memory_bytes;
  105|    636|    if instance_memory_maximum_size % wasmtime_environ::WASM_PAGE_SIZE as u64 != 0 {
  106|      0|        return Err(anyhow!(
  107|      0|            "requested memory limit {} not a multiple of the WASM_PAGE_SIZE {}",
  108|      0|            instance_memory_maximum_size,
  109|      0|            wasmtime_environ::WASM_PAGE_SIZE
  110|      0|        ));
  111|    636|    }
  112|    636|
  113|    636|    let mut c = wasmtime::Config::default();
  114|    636|
  115|    636|    // wasmtime default: OnDemand
  116|    636|    // We want to pre-allocate all permissible memory to support the maximum allowed recursion limit.
  117|    636|    c.allocation_strategy(InstanceAllocationStrategy::Pooling {
  118|    636|        strategy: PoolingAllocationStrategy::ReuseAffinity,
  119|    636|        instance_limits: InstanceLimits {
  120|    636|            count: instance_count,
  121|    636|            // Adjust the maximum amount of host memory that can be committed to an instance to
  122|    636|            // match the static linear memory size we reserve for each slot.
  123|    636|            memory_pages: instance_memory_maximum_size / (wasmtime_environ::WASM_PAGE_SIZE as u64),
  124|    636|            ..Default::default()
  125|    636|        },
  126|    636|    });
  127|    636|
  128|    636|    // wasmtime default: true
  129|    636|    // We disable this as we always charge for memory regardless and `memory_init_cow` can baloon compiled wasm modules.
  130|    636|    c.memory_init_cow(false);
  131|    636|
  132|    636|    // wasmtime default: 4GB
  133|    636|    c.static_memory_maximum_size(instance_memory_maximum_size);
  134|    636|
  135|    636|    // wasmtime default: false
  136|    636|    // We don't want threads, there is no way to ensure determisism
  137|    636|    c.wasm_threads(false);
  138|    636|
  139|    636|    // wasmtime default: true
  140|    636|    // simd isn't supported in wasm-instrument, but if we add support there, we can probably enable this.
  141|    636|    // Note: stack limits may need adjusting after this is enabled
  142|    636|    c.wasm_simd(false);
  143|    636|
  144|    636|    // wasmtime default: false
  145|    636|    c.wasm_multi_memory(false);
  146|    636|
  147|    636|    // wasmtime default: false
  148|    636|    c.wasm_memory64(false);
  149|    636|
  150|    636|    // wasmtime default: true
  151|    636|    // Note: wasm-instrument only supports this at a basic level, for M2 we will
  152|    636|    // need to add more advanced support
  153|    636|    c.wasm_bulk_memory(true);
  154|    636|
  155|    636|    // wasmtime default: true
  156|    636|    // we should be able to enable this for M2, just need to make sure that it's
  157|    636|    // handled correctly in wasm-instrument
  158|    636|    c.wasm_multi_value(false);
  159|    636|
  160|    636|    // wasmtime default: false
  161|    636|    //
  162|    636|    // from wasmtime docs:
  163|    636|    // > When Cranelift is used as a code generation backend this will
  164|    636|    // > configure it to replace NaNs with a single canonical value. This
  165|    636|    // > is useful for users requiring entirely deterministic WebAssembly
  166|    636|    // > computation. This is not required by the WebAssembly spec, so it is
  167|    636|    // > not enabled by default.
  168|    636|    c.cranelift_nan_canonicalization(true);
  169|    636|
  170|    636|    // wasmtime default: 512KiB
  171|    636|    // Set to something much higher than the instrumented limiter.
  172|    636|    // Note: This is in bytes, while the instrumented limit is in stack elements
  173|    636|    c.max_wasm_stack(4 << 20);
  174|    636|
  175|    636|    // Execution cost accouting is done through wasm instrumentation,
  176|    636|    c.consume_fuel(false);
  177|    636|    c.epoch_interruption(false);
  178|    636|
  179|    636|    // Disable debug-related things, wasm-instrument doesn't fix debug info
  180|    636|    // yet, so those aren't useful, just add overhead
  181|    636|    c.debug_info(false);
  182|    636|    c.generate_address_map(false);
  183|    636|    c.cranelift_debug_verifier(false);
  184|    636|    c.native_unwind_info(false);
  185|    636|    #[allow(deprecated)] // TODO https://github.com/bytecodealliance/wasmtime/issues/5037
  186|    636|    c.wasm_backtrace(false);
  187|    636|    c.wasm_reference_types(false);
  188|    636|
  189|    636|    // Reiterate some defaults
  190|    636|    c.guard_before_linear_memory(true);
  191|    636|    c.parallel_compilation(true);
  192|    636|
  193|    636|    #[cfg(feature = "wasmtime/async")]
  194|    636|    c.async_support(false);
  195|    636|
  196|    636|    // Doesn't seem to have significant impact on the time it takes to load code
  197|    636|    // todo(M2): make sure this is guaranteed to run in linear time.
  198|    636|    c.cranelift_opt_level(Speed);
  199|    636|
  200|    636|    Ok(c)
  201|    636|}
_RNvMs1_NtCskJihg1y13m7_3fvm6engineNtB5_10EnginePool3new:
  268|    636|    pub fn new(c: &wasmtime::Config, ec: EngineConfig) -> anyhow::Result<Self> {
  269|    636|        let engine = wasmtime::Engine::new(c)?;
  270|       |
  271|    636|        let mut dummy_store = wasmtime::Store::new(&engine, ());
  272|    636|        let gg_type = GlobalType::new(ValType::I64, Mutability::Var);
  273|    636|        let dummy_gg = Global::new(&mut dummy_store, gg_type, Val::I64(0))
  274|    636|            .expect("failed to create dummy gas global");
  275|    636|
  276|    636|        let dummy_memory = Memory::new(&mut dummy_store, MemoryType::new(0, Some(0)))
  277|    636|            .expect("failed to create dummy memory");
  278|    636|
  279|    636|        let actor_redirect = ec.actor_redirect.iter().cloned().collect();
  280|    636|
  281|    636|        Ok(EnginePool(Arc::new(EngineInner {
  282|    636|            limit: Mutex::new(ec.concurrency),
  283|    636|            condv: Condvar::new(),
  284|    636|            engine,
  285|    636|            dummy_memory,
  286|    636|            dummy_gas_global: dummy_gg,
  287|    636|            module_cache: Default::default(),
  288|    636|            instance_cache: Mutex::new(HashMap::new()),
  289|    636|            config: ec,
  290|    636|            actor_redirect,
  291|    636|        })))
  292|    636|    }
_RNvMs1_NtCskJihg1y13m7_3fvm6engineNtB5_10EnginePool11new_default:
  263|    636|    pub fn new_default(ec: EngineConfig) -> anyhow::Result<Self> {
  264|    636|        EnginePool::new(&wasmtime_config(&ec)?, ec)
  265|    636|    }
_RNCNvMs1_NtCskJihg1y13m7_3fvm6engineNtB7_10EnginePool7acquire0B9_:
  242|    636|            .wait_while(self.0.limit.lock().unwrap(), |limit| *limit == 0)
_RNvMs1_NtCskJihg1y13m7_3fvm6engineNtB5_10EnginePool7acquire:
  238|    636|    pub fn acquire(&self) -> Engine {
  239|    636|        *self
  240|    636|            .0
  241|    636|            .condv
  242|    636|            .wait_while(self.0.limit.lock().unwrap(), |limit| *limit == 0)
  243|    636|            .unwrap() -= 1;
  244|    636|        Engine(self.0.clone())
  245|    636|    }

_RNvMs1_NtNtCskJihg1y13m7_3fvm8executor7defaultINtB5_15DefaultExecutorINtNtNtB9_6kernel7default13DefaultKernelINtNtNtB9_12call_manager7default18DefaultCallManagerINtNtNtB9_7machine7default14DefaultMachineNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsh74LAqVwWKW_21fvm_integration_tests5dummy12DummyExternsEEEE12into_machineCsboUdcTbF1FS_15direct_syscalls:
  358|    318|    pub fn into_machine(self) -> Option<<K::CallManager as CallManager>::Machine> {
  359|    318|        self.machine
  360|    318|    }
_RNvMs1_NtNtCskJihg1y13m7_3fvm8executor7defaultINtB5_15DefaultExecutorINtNtNtB9_6kernel7default13DefaultKernelINtNtNtB9_12call_manager7default18DefaultCallManagerINtNtNtB9_7machine7default14DefaultMachineNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsh74LAqVwWKW_21fvm_integration_tests5dummy12DummyExternsEEEE3newCsboUdcTbF1FS_15direct_syscalls:
  334|    318|    pub fn new(
  335|    318|        engine_pool: EnginePool,
  336|    318|        machine: <K::CallManager as CallManager>::Machine,
  337|    318|    ) -> anyhow::Result<Self> {
  338|    318|        // Skip preloading all builtin actors when testing.
  339|    318|        #[cfg(not(any(test, feature = "testing")))]
  340|    318|        {
  341|    318|            // Preload any uncached modules.
  342|    318|            // This interface works for now because we know all actor CIDs
  343|    318|            // ahead of time, but with user-supplied code, we won't have that
  344|    318|            // guarantee.
  345|    318|            engine_pool.acquire().preload(
  346|    318|                machine.blockstore(),
  347|    318|                machine.builtin_actors().builtin_actor_codes(),
  348|    318|            )?;
  349|    318|        }
  350|    318|        Ok(Self {
  351|    318|            engine_pool,
  352|    318|            machine: Some(machine),
  353|    318|        })
  354|    318|    }

_RINvMNtNtCskJihg1y13m7_3fvm3gas6chargeNtB3_9GasCharge3newReECsboUdcTbF1FS_15direct_syscalls:
   24|    318|    pub fn new(name: impl Into<Cow<'static, str>>, compute_gas: Gas, storage_gas: Gas) -> Self {
   25|    318|        let name = name.into();
   26|    318|        Self {
   27|    318|            name,
   28|    318|            compute_gas,
   29|    318|            storage_gas,
   30|    318|            elapsed: GasDuration::default(),
   31|    318|        }
   32|    318|    }
_RNvMNtNtCskJihg1y13m7_3fvm3gas6chargeNtB2_9GasCharge5total:
   36|    318|    pub fn total(&self) -> Gas {
   37|    318|        self.compute_gas + self.storage_gas
   38|    318|    }

_RNvXs2_NtCskJihg1y13m7_3fvm3gasNtB5_3GasNtNtNtCsiloedr2K6v7_4core3ops5arith3Add3add:
  111|  1.27k|    fn add(self, rhs: Self) -> Self::Output {
  112|  1.27k|        Self(self.0.saturating_add(rhs.0))
  113|  1.27k|    }
_RNvXsa_NtCskJihg1y13m7_3fvm3gasNtB5_3GasINtNtNtCsiloedr2K6v7_4core3ops5arith3MuljE3mul:
  179|    636|    fn mul(self, rhs: usize) -> Self::Output {
  180|    636|        Self(self.0.saturating_mul(rhs.try_into().unwrap_or(i64::MAX)))
  181|    636|    }
_RNvMs0_NtCskJihg1y13m7_3fvm3gasNtB5_3Gas3new:
   69|    369|    pub const fn new(gas: i64) -> Gas {
   70|    369|        Gas(gas.saturating_mul(MILLIGAS_PRECISION))
   71|    369|    }
_RNvMs0_NtCskJihg1y13m7_3fvm3gasNtB5_3Gas13from_milligas:
   62|      1|    pub const fn from_milligas(milligas: i64) -> Gas {
   63|      1|        Gas(milligas)
   64|      1|    }
_RNvXsi_NtCskJihg1y13m7_3fvm3gasNtB5_3GasNtNtCsiloedr2K6v7_4core3cmp10PartialOrd11partial_cmp:
   30|    318|#[derive(Hash, Eq, PartialEq, Ord, PartialOrd, Copy, Clone, Default)]
_RNvXs1_NtCskJihg1y13m7_3fvm3gasNtB5_3GasNtNtCsaOMW4gJp9Em_10num_traits10identities4Zero4zero:
   98|    655|    fn zero() -> Self {
   99|    655|        Gas(0)
  100|    655|    }
_RNCNvMsb_NtCskJihg1y13m7_3fvm3gasNtB7_10GasTracker12apply_charge0B9_:
  237|    318|            res.map(|_| timer)
_RNvXs_NtCskJihg1y13m7_3fvm3gasNtB4_3GasNtNtCsiloedr2K6v7_4core3fmt7Display3fmt:
   48|    318|    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
   49|    318|        if self.0 == 0 {
   50|    318|            f.write_str("0")
   51|       |        } else {
   52|      0|            let integral = self.0 / MILLIGAS_PRECISION;
   53|      0|            let fractional = self.0 % MILLIGAS_PRECISION;
   54|      0|            write!(f, "{integral}.{fractional:03}")
   55|       |        }
   56|    318|    }
_RNvMsb_NtCskJihg1y13m7_3fvm3gasNtB5_10GasTracker12apply_charge:
  230|    318|    pub fn apply_charge(&self, mut charge: GasCharge) -> Result<GasTimer> {
  231|    318|        let to_use = charge.total();
  232|    318|        log::trace!("charging gas: {} {}", &charge.name, to_use);
  233|    318|        let res = self.charge_gas_inner(to_use);
  234|    318|        if let Some(trace) = &self.trace {
  235|    318|            let timer = GasTimer::new(&mut charge.elapsed);
  236|    318|            trace.borrow_mut().push(charge);
  237|    318|            res.map(|_| timer)
  238|       |        } else {
  239|      0|            res.map(|_| GasTimer::empty())
  240|       |        }
  241|    318|    }
_RNvMsb_NtCskJihg1y13m7_3fvm3gasNtB5_10GasTracker3new:
  193|    318|    pub fn new(gas_limit: Gas, gas_used: Gas, enable_tracing: bool) -> Self {
  194|    318|        Self {
  195|    318|            gas_limit,
  196|    318|            gas_used: Cell::new(gas_used),
  197|    318|            trace: enable_tracing.then_some(Default::default()),
  198|    318|        }
  199|    318|    }
_RNvMsb_NtCskJihg1y13m7_3fvm3gasNtB5_10GasTracker16charge_gas_inner:
  201|    318|    fn charge_gas_inner(&self, to_use: Gas) -> Result<()> {
  202|    318|        // The gas type uses saturating math.
  203|    318|        let gas_used = self.gas_used.get() + to_use;
  204|    318|        if gas_used > self.gas_limit {
  205|      0|            log::trace!("gas limit reached");
  206|      0|            self.gas_used.set(self.gas_limit);
  207|      0|            Err(ExecutionError::OutOfGas)
  208|       |        } else {
  209|    318|            self.gas_used.set(gas_used);
  210|    318|            Ok(())
  211|       |        }
  212|    318|    }

_RNvMs_NtNtCskJihg1y13m7_3fvm3gas10price_listNtB4_9PriceList15on_block_create:
  884|    318|    pub fn on_block_create(&self, data_size: usize) -> GasCharge {
  885|    318|        let mem_costs = (self.block_create_memret_per_byte_cost * data_size)
  886|    318|            + (self.block_memcpy_per_byte_cost * data_size);
  887|    318|        GasCharge::new(
  888|    318|            "OnBlockCreate",
  889|    318|            self.block_create_base + mem_costs,
  890|    318|            Zero::zero(),
  891|    318|        )
  892|    318|    }
_RNvNtNtCskJihg1y13m7_3fvm3gas10price_list29price_list_by_network_version:
 1045|    636|pub fn price_list_by_network_version(network_version: NetworkVersion) -> &'static PriceList {
 1046|    636|    match network_version {
 1047|      0|        NetworkVersion::V15 => &OH_SNAP_PRICES,
 1048|      0|        NetworkVersion::V16 | NetworkVersion::V17 => &SKYR_PRICES,
 1049|    636|        NetworkVersion::V18 => &HYGGE_PRICES,
 1050|      0|        _ => panic!("network version {nv} not supported", nv = network_version),
 1051|       |    }
 1052|    636|}
_RNvXse_NtNtCskJihg1y13m7_3fvm3gas10price_listNtB5_8StepCostNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
  472|      2|#[derive(Clone, Debug, PartialEq, Eq)]

_RNvXs0_NtNtCskJihg1y13m7_3fvm3gas5timerNtB5_11GasDurationNtNtCsiloedr2K6v7_4core7default7Default7default:
   16|    318|#[derive(Default, Debug, Clone)]
_RNvMs_NtNtCskJihg1y13m7_3fvm3gas5timerNtB4_8GasTimer5start:
   45|    318|    pub fn start() -> GasInstant {
   46|    318|        GasInstant::now()
   47|    318|    }
_RNvMNtNtCskJihg1y13m7_3fvm3gas5timerNtB2_11GasDuration3get:
   20|    318|    pub fn get(&self) -> Option<&Duration> {
   21|    318|        self.0.as_ref().and_then(|d| d.get())
   22|    318|    }
_RNvMs_NtNtCskJihg1y13m7_3fvm3gas5timerNtB4_8GasTimer3new:
   57|    318|    pub fn new(duration: &mut GasDuration) -> Self {
   58|    318|        assert!(duration.get().is_none(), "GasCharge::elapsed already set!");
   59|       |
   60|    318|        let cell = match &duration.0 {
   61|      0|            Some(cell) => cell.clone(),
   62|       |            None => {
   63|    318|                let cell = DurationCell::default();
   64|    318|                duration.0 = Some(cell.clone());
   65|    318|                cell
   66|       |            }
   67|       |        };
   68|       |
   69|    318|        Self(Some(GasTimerInner {
   70|    318|            start: Self::start(),
   71|    318|            elapsed: cell,
   72|    318|        }))
   73|    318|    }

_RINvXs0_NtCskJihg1y13m7_3fvm10init_actorNtB6_5StateNtNtCssVaLrL3Upj_5serde3ser9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECs7AwuCMXPzRZ_8fvm_fuzz:
   33|    318|#[derive(Serialize_tuple, Deserialize_tuple, Debug)]
_RINvMs_NtCskJihg1y13m7_3fvm10init_actorNtB5_5State8new_testNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreECs7AwuCMXPzRZ_8fvm_fuzz:
   48|    318|    pub fn new_test<B: Blockstore>(store: &B) -> Self {
   49|    318|        #[cfg(feature = "m2-native")]
   50|    318|        use cid::multihash::Code::Blake2b256;
   51|    318|
   52|    318|        // Empty hamt Cid used for testing
   53|    318|        let e_cid = Hamt::<_, String>::new_with_bit_width(&store, 5)
   54|    318|            .flush()
   55|    318|            .unwrap();
   56|    318|
   57|    318|        // Empty list Cid used for testing
   58|    318|        #[cfg(feature = "m2-native")]
   59|    318|        let el_cid = store.put_cbor(&Vec::<Cid>::new(), Blake2b256).unwrap();
   60|    318|
   61|    318|        State {
   62|    318|            address_map: e_cid,
   63|    318|            next_id: 100,
   64|    318|            network_name: "test".to_owned(),
   65|    318|            #[cfg(feature = "m2-native")]
   66|    318|            installed_actors: el_cid,
   67|    318|        }
   68|    318|    }
_RINvXNvNvXs0_NtCskJihg1y13m7_3fvm10init_actorNtBb_5StateNtNtCssVaLrL3Upj_5serde3ser9Serialize9serialize1__NtB5_5InnerBS_9serializeINtCscrDzOC3hEIR_11serde_tuple10SerializerQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEEECs7AwuCMXPzRZ_8fvm_fuzz:
   33|    318|#[derive(Serialize_tuple, Deserialize_tuple, Debug)]

_RNvXs5_NtNtCskJihg1y13m7_3fvm6kernel6blocksNtB5_13BlockRegistryNtNtCsiloedr2K6v7_4core7default7Default7default:
   13|    318|#[derive(Default)]
_RINvMNtNtCskJihg1y13m7_3fvm6kernel6blocksNtB3_5Block3newRShECsboUdcTbF1FS_15direct_syscalls:
   45|    318|    pub fn new(codec: u64, data: impl Into<Box<[u8]>>) -> Self {
   46|    318|        // This requires an extra allocation (ew) but no extra copy on send.
   47|    318|        // The extra allocation is basically nothing.
   48|    318|        Self {
   49|    318|            codec,
   50|    318|            data: Rc::new(data.into()),
   51|    318|        }
   52|    318|    }
_RNvMs4_NtNtCskJihg1y13m7_3fvm6kernel6blocksNtB5_13BlockRegistry7is_full:
  165|    318|    pub fn is_full(&self) -> bool {
  166|    318|        self.blocks.len() as u32 == MAX_BLOCKS
  167|    318|    }
_RNvXs_NtNtCskJihg1y13m7_3fvm6kernel6blocksNtNtB6_5error12SyscallErrorINtNtCsiloedr2K6v7_4core7convert4FromNtB4_13BlockPutErrorE4from:
   87|    318|    fn from(e: BlockPutError) -> Self {
   88|    318|        match e {
   89|      0|            BlockPutError::TooManyBlocks => syscall_error!(LimitExceeded; "{}", e),
   90|    318|            BlockPutError::InvalidCodec(_) => syscall_error!(IllegalCodec; "{}", e),
   91|       |        }
   92|    318|    }
_RNvXs0_NtNtCskJihg1y13m7_3fvm6kernel6blocksNtNtB7_5error14ExecutionErrorINtNtCsiloedr2K6v7_4core7convert4FromNtB5_13BlockPutErrorE4from:
   96|    318|    fn from(e: BlockPutError) -> Self {
   97|    318|        ExecutionError::Syscall(e.into())
   98|    318|    }
_RNvMs4_NtNtCskJihg1y13m7_3fvm6kernel6blocksNtB5_13BlockRegistry3put:
  125|    318|    pub fn put(&mut self, block: Block) -> Result<BlockId, BlockPutError> {
  126|    318|        if self.is_full() {
  127|      0|            return Err(BlockPutError::TooManyBlocks);
  128|    318|        }
  129|    318|
  130|    318|        if !ALLOWED_CODECS.contains(&block.codec) {
  131|    318|            return Err(BlockPutError::InvalidCodec(block.codec));
  132|      0|        }
  133|      0|
  134|      0|        let id = FIRST_ID + self.blocks.len() as u32;
  135|      0|        self.blocks.push(block);
  136|      0|        Ok(id)
  137|    318|    }
_RNvXsc_NtNtCskJihg1y13m7_3fvm6kernel6blocksNtB5_13BlockPutErrorNtNtCsiloedr2K6v7_4core3fmt7Display3fmt:
   78|    318|#[derive(Error, Debug)]

_RNvXs1_NtNtCskJihg1y13m7_3fvm6kernel7defaultINtB5_13DefaultKernelINtNtNtB9_12call_manager7default18DefaultCallManagerINtNtNtB9_7machine7default14DefaultMachineNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsh74LAqVwWKW_21fvm_integration_tests5dummy12DummyExternsEEENtB7_12IpldBlockOps12block_createCsboUdcTbF1FS_15direct_syscalls:
  251|    318|    fn block_create(&mut self, codec: u64, data: &[u8]) -> Result<BlockId> {
  252|    318|        let t = self
  253|    318|            .call_manager
  254|    318|            .charge_gas(self.call_manager.price_list().on_block_create(data.len()))?;
  255|       |
  256|    318|        t.record(Ok(self.blocks.put(Block::new(codec, data))?))
  257|    318|    }
_RNvXNtNtCskJihg1y13m7_3fvm6kernel7defaultINtB2_13DefaultKernelINtNtNtB6_12call_manager7default18DefaultCallManagerINtNtNtB6_7machine7default14DefaultMachineNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsh74LAqVwWKW_21fvm_integration_tests5dummy12DummyExternsEEENtB4_6Kernel3newCsboUdcTbF1FS_15direct_syscalls:
   83|    318|    fn new(
   84|    318|        mgr: C,
   85|    318|        blocks: BlockRegistry,
   86|    318|        caller: ActorID,
   87|    318|        actor_id: ActorID,
   88|    318|        method: MethodNum,
   89|    318|        value_received: TokenAmount,
   90|    318|    ) -> Self {
   91|    318|        DefaultKernel {
   92|    318|            call_manager: mgr,
   93|    318|            blocks,
   94|    318|            caller,
   95|    318|            actor_id,
   96|    318|            method,
   97|    318|            value_received,
   98|    318|        }
   99|    318|    }

_RNvXs0_NtNtCskJihg1y13m7_3fvm6kernel5errorINtNtCsiloedr2K6v7_4core6result6ResultINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_ENtNtCslH3pn9Bu6yX_13fvm_ipld_hamt5error5ErrorENtB5_14ClassifyResult8or_fatalCsboUdcTbF1FS_15direct_syscalls:
  100|    318|    fn or_fatal(self) -> Result<Self::Value>
  101|    318|    where
  102|    318|        Self::Error: Into<anyhow::Error>,
  103|    318|    {
  104|    318|        self.map_err(|e| ExecutionError::Fatal(e.into()))
  105|    318|    }
_RNvXs0_NtNtCskJihg1y13m7_3fvm6kernel5errorINtNtCsiloedr2K6v7_4core6result6ResultINtNtCslH3pn9Bu6yX_13fvm_ipld_hamt4hamt4HamtINtNtNtB9_10blockstore8buffered18BufferedBlockstoreNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreENtNtB9_10state_tree10ActorStateENtCsbqblzDQlyxB_6anyhow5ErrorENtB5_14ClassifyResult8or_fatalCsboUdcTbF1FS_15direct_syscalls:
  100|    318|    fn or_fatal(self) -> Result<Self::Value>
  101|    318|    where
  102|    318|        Self::Error: Into<anyhow::Error>,
  103|    318|    {
  104|    318|        self.map_err(|e| ExecutionError::Fatal(e.into()))
  105|    318|    }
_RNvXs0_NtNtCskJihg1y13m7_3fvm6kernel5errorINtNtCsiloedr2K6v7_4core6result6ResultINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_ENtCsbqblzDQlyxB_6anyhow5ErrorENtB5_14ClassifyResult8or_fatalCsboUdcTbF1FS_15direct_syscalls:
  100|    318|    fn or_fatal(self) -> Result<Self::Value>
  101|    318|    where
  102|    318|        Self::Error: Into<anyhow::Error>,
  103|    318|    {
  104|    318|        self.map_err(|e| ExecutionError::Fatal(e.into()))
  105|    318|    }
_RNvXs0_NtNtCskJihg1y13m7_3fvm6kernel5errorINtNtCsiloedr2K6v7_4core6result6ResultINtNtBJ_6option6OptionNtNtB9_10state_tree10ActorStateENtNtCslH3pn9Bu6yX_13fvm_ipld_hamt5error5ErrorENtB5_14ClassifyResult8or_fatalCsboUdcTbF1FS_15direct_syscalls:
  100|    954|    fn or_fatal(self) -> Result<Self::Value>
  101|    954|    where
  102|    954|        Self::Error: Into<anyhow::Error>,
  103|    954|    {
  104|    954|        self.map_err(|e| ExecutionError::Fatal(e.into()))
  105|    954|    }
_RNvXs0_NtNtCskJihg1y13m7_3fvm6kernel5errorINtNtCsiloedr2K6v7_4core6result6ResultINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_ENtCsbqblzDQlyxB_6anyhow5ErrorENtB5_14ClassifyResult8or_fatalCs7AwuCMXPzRZ_8fvm_fuzz:
  100|    318|    fn or_fatal(self) -> Result<Self::Value>
  101|    318|    where
  102|    318|        Self::Error: Into<anyhow::Error>,
  103|    318|    {
  104|    318|        self.map_err(|e| ExecutionError::Fatal(e.into()))
  105|    318|    }
_RNvXs0_NtNtCskJihg1y13m7_3fvm6kernel5errorINtNtCsiloedr2K6v7_4core6result6ResultRNtNtB9_10state_tree14StateSnapLayerNtCsbqblzDQlyxB_6anyhow5ErrorENtB5_14ClassifyResult8or_fatalB9_:
  100|    954|    fn or_fatal(self) -> Result<Self::Value>
  101|    954|    where
  102|    954|        Self::Error: Into<anyhow::Error>,
  103|    954|    {
  104|    954|        self.map_err(|e| ExecutionError::Fatal(e.into()))
  105|    954|    }
_RINvMs4_NtNtCskJihg1y13m7_3fvm6kernel5errorNtB6_12SyscallError3newNtNtCsiloedr2K6v7_4core3fmt9ArgumentsEBa_:
  185|    318|    pub fn new<D: Display>(c: ErrorNumber, d: D) -> Self {
  186|    318|        SyscallError(d.to_string(), c)
  187|    318|    }
_RNvXs0_NtNtCskJihg1y13m7_3fvm6kernel5errorINtNtCsiloedr2K6v7_4core6result6ResultRShNtNtCs9pDt8l5wGDA_5alloc6string6StringENtB5_14ClassifyResult8or_errorB9_:
  106|    318|    fn or_error(self, code: ErrorNumber) -> Result<Self::Value>
  107|    318|    where
  108|    318|        Self::Error: Display,
  109|    318|    {
  110|    318|        self.map_err(|e| ExecutionError::Syscall(SyscallError(e.to_string(), code)))
  111|    318|    }

_RNvXs_NtNtCskJihg1y13m7_3fvm7machine7defaultINtB4_14DefaultMachineNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsh74LAqVwWKW_21fvm_integration_tests5dummy12DummyExternsENtB6_7Machine11new_limiterCsboUdcTbF1FS_15direct_syscalls:
  260|    318|    fn new_limiter(&self) -> Self::Limiter {
  261|    318|        ExecResourceLimiter::for_network(&self.context().network)
  262|    318|    }
_RNvXs_NtNtCskJihg1y13m7_3fvm7machine7defaultINtB4_14DefaultMachineNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsh74LAqVwWKW_21fvm_integration_tests5dummy12DummyExternsENtB6_7Machine7contextCsboUdcTbF1FS_15direct_syscalls:
  143|    954|    fn context(&self) -> &MachineContext {
  144|    954|        &self.context
  145|    954|    }
_RNvMNtNtCskJihg1y13m7_3fvm7machine7defaultINtB2_14DefaultMachineNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsh74LAqVwWKW_21fvm_integration_tests5dummy12DummyExternsE3newCsboUdcTbF1FS_15direct_syscalls:
   63|    318|    pub fn new(context: &MachineContext, blockstore: B, externs: E) -> anyhow::Result<Self> {
   64|    318|        const SUPPORTED_VERSIONS: RangeInclusive<NetworkVersion> =
   65|    318|            NetworkVersion::V18..=NetworkVersion::V18;
   66|    318|
   67|    318|        debug!(
   68|    318|            "initializing a new machine, epoch={}, base_fee={}, nv={:?}, root={}",
   69|    318|            context.epoch, &context.base_fee, context.network_version, context.initial_state_root
   70|       |        );
   71|       |
   72|    318|        if !SUPPORTED_VERSIONS.contains(&context.network_version) {
   73|      0|            return Err(anyhow!(
   74|      0|                "unsupported network version: {}",
   75|      0|                context.network_version
   76|      0|            ));
   77|    318|        }
   78|    318|
   79|    318|        // Sanity check that the blockstore contains the supplied state root.
   80|    318|        if !blockstore
   81|    318|            .has(&context.initial_state_root)
   82|    318|            .context("failed to load initial state-root")?
   83|       |        {
   84|      0|            return Err(anyhow!(
   85|      0|                "blockstore doesn't have the initial state-root {}",
   86|      0|                &context.initial_state_root
   87|      0|            ));
   88|    318|        }
   89|       |
   90|       |        // Create a new state tree from the supplied root.
   91|    318|        let state_tree = {
   92|    318|            let bstore = BufferedBlockstore::new(blockstore);
   93|    318|            StateTree::new_from_root(bstore, &context.initial_state_root)?
   94|       |        };
   95|       |
   96|       |        // Load the built-in actors manifest.
   97|    318|        let (builtin_actors_cid, manifest_version) = match context.builtin_actors_override {
   98|    318|            Some(manifest_cid) => {
   99|    318|                let (version, cid): (u32, Cid) = state_tree
  100|    318|                    .store()
  101|    318|                    .get_cbor(&manifest_cid)?
  102|    318|                    .context("failed to load actor manifest")?;
  103|    318|                (cid, version)
  104|       |            }
  105|       |            None => {
  106|      0|                let (state, _) = SystemActorState::load(&state_tree)?;
  107|      0|                (state.builtin_actors, 1)
  108|       |            }
  109|       |        };
  110|    318|        let builtin_actors =
  111|    318|            Manifest::load(state_tree.store(), &builtin_actors_cid, manifest_version)?;
  112|       |
  113|       |        // 16 bytes is random _enough_
  114|    318|        let randomness: [u8; 16] = rand::random();
  115|    318|
  116|    318|        Ok(DefaultMachine {
  117|    318|            context: context.clone(),
  118|    318|            externs,
  119|    318|            state_tree,
  120|    318|            builtin_actors,
  121|    318|            id: format!(
  122|    318|                "{}-{}",
  123|    318|                context.epoch,
  124|    318|                cid::multibase::encode(cid::multibase::Base::Base32Lower, randomness)
  125|    318|            ),
  126|    318|        })
  127|    318|    }

_RNvMNtNtCskJihg1y13m7_3fvm7machine7limiterNtB2_19ExecResourceLimiter11for_network:
   43|    318|    pub fn for_network(config: &NetworkConfig) -> Self {
   44|    318|        Self::new(
   45|    318|            config.max_inst_memory_bytes as usize,
   46|    318|            config.max_exec_memory_bytes as usize,
   47|    318|        )
   48|    318|    }
_RNvMNtNtCskJihg1y13m7_3fvm7machine7limiterNtB2_19ExecResourceLimiter3new:
   35|    318|    pub fn new(max_inst_memory_bytes: usize, max_exec_memory_bytes: usize) -> Self {
   36|    318|        Self {
   37|    318|            max_inst_memory_bytes,
   38|    318|            max_exec_memory_bytes,
   39|    318|            curr_exec_memory_bytes: 0,
   40|    318|        }
   41|    318|    }

_RINvMNtNtCskJihg1y13m7_3fvm7machine8manifestNtB3_8Manifest4loadINtNtNtB7_10blockstore8buffered18BufferedBlockstoreNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreEECsboUdcTbF1FS_15direct_syscalls:
   85|    318|    pub fn load<B: Blockstore>(bs: &B, root_cid: &Cid, ver: u32) -> anyhow::Result<Manifest> {
   86|    318|        if ver != 1 {
   87|      0|            return Err(anyhow!("unsupported manifest version {}", ver));
   88|    318|        }
   89|       |
   90|    318|        let vec: Vec<(String, Cid)> = match bs.get_cbor(root_cid)? {
   91|    318|            Some(vec) => vec,
   92|       |            None => {
   93|      0|                return Err(anyhow!("cannot find manifest root cid {}", root_cid));
   94|       |            }
   95|       |        };
   96|    318|        Manifest::new(vec)
   97|    318|    }
_RNCINvMNtNtCskJihg1y13m7_3fvm7machine8manifestNtB5_8Manifest3newNtNtCs9pDt8l5wGDA_5alloc6string6StringINtNtB14_3vec3VecTB10_INtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEEE0CsboUdcTbF1FS_15direct_syscalls:
  116|  2.54k|            .flat_map(|&k| by_name.get(k))
_RINvMNtNtCskJihg1y13m7_3fvm7machine8manifestNtB3_8Manifest3newNtNtCs9pDt8l5wGDA_5alloc6string6StringINtNtB12_3vec3VecTBY_INtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEEECsboUdcTbF1FS_15direct_syscalls:
  100|    318|    pub fn new(iter: impl IntoIterator<Item = (impl Into<String>, Cid)>) -> anyhow::Result<Self> {
  101|    318|        let mut by_name = HashMap::new();
  102|    318|        let mut by_id = HashMap::new();
  103|    318|        let mut by_code = HashMap::new();
  104|       |
  105|       |        // Actors are indexed sequentially, starting at 1, in the order in which they appear in the
  106|       |        // manifest. 0 is reserved for "everything else" (i.e., not a builtin actor).
  107|  4.77k|        for ((name, code_cid), id) in iter.into_iter().zip(1u32..) {
  108|  4.77k|            let name = name.into();
  109|  4.77k|            by_id.insert(id, code_cid);
  110|  4.77k|            by_code.insert(code_cid, id);
  111|  4.77k|            by_name.insert(name, code_cid);
  112|  4.77k|        }
  113|       |
  114|    318|        let singletons = SINGLETON_ACTOR_NAMES
  115|    318|            .iter()
  116|    318|            .flat_map(|&k| by_name.get(k))
  117|    318|            .copied()
  118|    318|            .collect();
  119|       |
  120|    318|        let account_code = *by_name
  121|    318|            .get(ACCOUNT_ACTOR_NAME)
  122|    318|            .context("manifest missing account actor")?;
  123|       |
  124|    318|        let system_code = *by_name
  125|    318|            .get(SYSTEM_ACTOR_NAME)
  126|    318|            .context("manifest missing system actor")?;
  127|       |
  128|    318|        let init_code = *by_name
  129|    318|            .get(INIT_ACTOR_NAME)
  130|    318|            .context("manifest missing init actor")?;
  131|       |
  132|    318|        let embryo_code = *by_name
  133|    318|            .get(EMBRYO_ACTOR_NAME)
  134|    318|            .context("manifest missing embryo actor")?;
  135|       |
  136|    318|        let eam_code = *by_name
  137|    318|            .get(EAM_ACTOR_NAME)
  138|    318|            .context("manifest missing eam actor")?;
  139|       |
  140|    318|        let ethaccount_code = *by_name
  141|    318|            .get(ETHACCOUNT_ACTOR_NAME)
  142|    318|            .context("manifest missing ethaccount actor")?;
  143|       |
  144|    318|        Ok(Self {
  145|    318|            account_code,
  146|    318|            system_code,
  147|    318|            init_code,
  148|    318|            embryo_code,
  149|    318|            eam_code,
  150|    318|            ethaccount_code,
  151|    318|            singletons,
  152|    318|            by_id,
  153|    318|            by_code,
  154|    318|        })
  155|    318|    }
_RNCINvMNtNtCskJihg1y13m7_3fvm7machine8manifestNtB5_8Manifest3newNtNtCs9pDt8l5wGDA_5alloc6string6StringINtNtB14_3vec3VecTB10_INtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEEE0Cs7AwuCMXPzRZ_8fvm_fuzz:
  116|  2.54k|            .flat_map(|&k| by_name.get(k))
_RINvMNtNtCskJihg1y13m7_3fvm7machine8manifestNtB3_8Manifest3newNtNtCs9pDt8l5wGDA_5alloc6string6StringINtNtB12_3vec3VecTBY_INtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEEECs7AwuCMXPzRZ_8fvm_fuzz:
  100|    318|    pub fn new(iter: impl IntoIterator<Item = (impl Into<String>, Cid)>) -> anyhow::Result<Self> {
  101|    318|        let mut by_name = HashMap::new();
  102|    318|        let mut by_id = HashMap::new();
  103|    318|        let mut by_code = HashMap::new();
  104|       |
  105|       |        // Actors are indexed sequentially, starting at 1, in the order in which they appear in the
  106|       |        // manifest. 0 is reserved for "everything else" (i.e., not a builtin actor).
  107|  4.77k|        for ((name, code_cid), id) in iter.into_iter().zip(1u32..) {
  108|  4.77k|            let name = name.into();
  109|  4.77k|            by_id.insert(id, code_cid);
  110|  4.77k|            by_code.insert(code_cid, id);
  111|  4.77k|            by_name.insert(name, code_cid);
  112|  4.77k|        }
  113|       |
  114|    318|        let singletons = SINGLETON_ACTOR_NAMES
  115|    318|            .iter()
  116|    318|            .flat_map(|&k| by_name.get(k))
  117|    318|            .copied()
  118|    318|            .collect();
  119|       |
  120|    318|        let account_code = *by_name
  121|    318|            .get(ACCOUNT_ACTOR_NAME)
  122|    318|            .context("manifest missing account actor")?;
  123|       |
  124|    318|        let system_code = *by_name
  125|    318|            .get(SYSTEM_ACTOR_NAME)
  126|    318|            .context("manifest missing system actor")?;
  127|       |
  128|    318|        let init_code = *by_name
  129|    318|            .get(INIT_ACTOR_NAME)
  130|    318|            .context("manifest missing init actor")?;
  131|       |
  132|    318|        let embryo_code = *by_name
  133|    318|            .get(EMBRYO_ACTOR_NAME)
  134|    318|            .context("manifest missing embryo actor")?;
  135|       |
  136|    318|        let eam_code = *by_name
  137|    318|            .get(EAM_ACTOR_NAME)
  138|    318|            .context("manifest missing eam actor")?;
  139|       |
  140|    318|        let ethaccount_code = *by_name
  141|    318|            .get(ETHACCOUNT_ACTOR_NAME)
  142|    318|            .context("manifest missing ethaccount actor")?;
  143|       |
  144|    318|        Ok(Self {
  145|    318|            account_code,
  146|    318|            system_code,
  147|    318|            init_code,
  148|    318|            embryo_code,
  149|    318|            eam_code,
  150|    318|            ethaccount_code,
  151|    318|            singletons,
  152|    318|            by_id,
  153|    318|            by_code,
  154|    318|        })
  155|    318|    }
_RINvMNtNtCskJihg1y13m7_3fvm7machine8manifestNtB3_8Manifest4loadNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreECs7AwuCMXPzRZ_8fvm_fuzz:
   85|    318|    pub fn load<B: Blockstore>(bs: &B, root_cid: &Cid, ver: u32) -> anyhow::Result<Manifest> {
   86|    318|        if ver != 1 {
   87|      0|            return Err(anyhow!("unsupported manifest version {}", ver));
   88|    318|        }
   89|       |
   90|    318|        let vec: Vec<(String, Cid)> = match bs.get_cbor(root_cid)? {
   91|    318|            Some(vec) => vec,
   92|       |            None => {
   93|      0|                return Err(anyhow!("cannot find manifest root cid {}", root_cid));
   94|       |            }
   95|       |        };
   96|    318|        Manifest::new(vec)
   97|    318|    }
_RNvMNtNtCskJihg1y13m7_3fvm7machine8manifestNtB2_8Manifest16get_account_code:
  192|    318|    pub fn get_account_code(&self) -> &Cid {
  193|    318|        &self.account_code
  194|    318|    }
_RNvMNtNtCskJihg1y13m7_3fvm7machine8manifestNtB2_8Manifest15get_system_code:
  202|    318|    pub fn get_system_code(&self) -> &Cid {
  203|    318|        &self.system_code
  204|    318|    }
_RNvMNtNtCskJihg1y13m7_3fvm7machine8manifestNtB2_8Manifest15get_embryo_code:
  212|    318|    pub fn get_embryo_code(&self) -> &Cid {
  213|    318|        &self.embryo_code
  214|    318|    }
_RNvMNtNtCskJihg1y13m7_3fvm7machine8manifestNtB2_8Manifest12get_eam_code:
  207|    318|    pub fn get_eam_code(&self) -> &Cid {
  208|    318|        &self.eam_code
  209|    318|    }
_RNvMNtNtCskJihg1y13m7_3fvm7machine8manifestNtB2_8Manifest13get_init_code:
  197|    318|    pub fn get_init_code(&self) -> &Cid {
  198|    318|        &self.init_code
  199|    318|    }

_RNvXs4_NtCskJihg1y13m7_3fvm7machineNtB5_14MachineContextNtNtNtCsiloedr2K6v7_4core3ops5deref5Deref5deref:
  216|  1.27k|#[derive(Clone, Debug, Deref, DerefMut)]
_RNvXs2_NtCskJihg1y13m7_3fvm7machineNtB5_14MachineContextNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
  216|    318|#[derive(Clone, Debug, Deref, DerefMut)]
_RNvXs1_NtCskJihg1y13m7_3fvm7machineNtB5_13NetworkConfigNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
  104|    954|#[derive(Debug, Clone)]
_RNvMNtCskJihg1y13m7_3fvm7machineNtB2_13NetworkConfig15override_actors:
  179|    318|    pub fn override_actors(&mut self, manifest: Cid) -> &mut Self {
  180|    318|        self.builtin_actors_override = Some(manifest);
  181|    318|        self
  182|    318|    }
_RNvMNtCskJihg1y13m7_3fvm7machineNtB2_13NetworkConfig22enable_actor_debugging:
  172|    318|    pub fn enable_actor_debugging(&mut self) -> &mut Self {
  173|    318|        self.actor_debugging = true;
  174|    318|        self
  175|    318|    }
_RNvMs_NtCskJihg1y13m7_3fvm7machineNtB4_14MachineContext12set_base_fee:
  255|    318|    pub fn set_base_fee(&mut self, amt: TokenAmount) -> &mut Self {
  256|    318|        self.base_fee = amt;
  257|    318|        self
  258|    318|    }
_RNvMs_NtCskJihg1y13m7_3fvm7machineNtB4_14MachineContext14enable_tracing:
  267|    318|    pub fn enable_tracing(&mut self) -> &mut Self {
  268|    318|        self.tracing = true;
  269|    318|        self
  270|    318|    }
_RNvMNtCskJihg1y13m7_3fvm7machineNtB2_13NetworkConfig3new:
  155|    636|    pub fn new(network_version: NetworkVersion) -> Self {
  156|    636|        NetworkConfig {
  157|    636|            chain_id: ChainID::from(0u64),
  158|    636|            network_version,
  159|    636|            max_call_depth: 1024,
  160|    636|            max_wasm_stack: 2048,
  161|    636|            max_inst_memory_bytes: 512 * (1 << 20),
  162|    636|            max_exec_memory_bytes: 2 * (1 << 30),
  163|    636|            actor_debugging: false,
  164|    636|            builtin_actors_override: None,
  165|    636|            price_list: price_list_by_network_version(network_version),
  166|    636|            actor_redirect: vec![],
  167|    636|        }
  168|    636|    }
_RNvMNtCskJihg1y13m7_3fvm7machineNtB2_13NetworkConfig9for_epoch:
  191|    318|    pub fn for_epoch(
  192|    318|        &self,
  193|    318|        epoch: ChainEpoch,
  194|    318|        timestamp: u64,
  195|    318|        initial_state: Cid,
  196|    318|    ) -> MachineContext {
  197|    318|        MachineContext {
  198|    318|            network: self.clone(),
  199|    318|            base_fee: TokenAmount::zero(),
  200|    318|            epoch,
  201|    318|            timestamp,
  202|    318|            initial_state_root: initial_state,
  203|    318|            circ_supply: fvm_shared::TOTAL_FILECOIN.clone(),
  204|    318|            tracing: false,
  205|    318|        }
  206|    318|    }

_RNvMs_NtCskJihg1y13m7_3fvm10state_treeINtB4_9StateTreeNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreE5flushCsboUdcTbF1FS_15direct_syscalls:
  444|    318|    pub fn flush(&mut self) -> Result<Cid> {
  445|    318|        if self.snaps.layers.len() != 1 {
  446|      0|            return Err(ExecutionError::Fatal(anyhow!(
  447|      0|                "tried to flush state tree with snapshots on the stack: {:?}",
  448|      0|                self.snaps.layers.len()
  449|      0|            )));
  450|    318|        }
  451|       |
  452|    954|        for (&id, sto) in self.snaps.layers[0].actors.borrow().iter() {
  453|    954|            let addr = Address::new_id(id);
  454|    954|            match sto {
  455|       |                None => {
  456|      0|                    self.hamt.delete(&addr.to_bytes()).or_fatal()?;
  457|       |                }
  458|    954|                Some(ref state) => {
  459|    954|                    self.hamt
  460|    954|                        .set(addr.to_bytes().into(), state.clone())
  461|    954|                        .or_fatal()?;
  462|       |                }
  463|       |            }
  464|       |        }
  465|       |
  466|    318|        let root = self.hamt.flush().or_fatal()?;
  467|       |
  468|    318|        match self.version {
  469|      0|            StateTreeVersion::V0 => Ok(root),
  470|       |            _ => {
  471|    318|                let cid = self
  472|    318|                    .info
  473|    318|                    .expect("malformed state tree, version 1+ require info");
  474|    318|                let obj = &StateRoot {
  475|    318|                    version: self.version,
  476|    318|                    actors: root,
  477|    318|                    info: cid,
  478|    318|                };
  479|    318|                let root = self
  480|    318|                    .store()
  481|    318|                    .put_cbor(obj, multihash::Code::Blake2b256)
  482|    318|                    .or_fatal()?;
  483|    318|                Ok(root)
  484|       |            }
  485|       |        }
  486|    318|    }
_RINvXNvXNvNvXsa_NtCskJihg1y13m7_3fvm10state_treeNtBe_10ActorStateNtNtCssVaLrL3Upj_5serde2de11Deserialize11deserialize1__NtB8_5InnerB11_11deserializeNtB3_9___VisitorNtB13_7Visitor9visit_seqQNtNtNtCs3TS9n28v4Rl_12libipld_core5serde2de15SeqDeserializerECsboUdcTbF1FS_15direct_syscalls:
  510|    954|#[derive(PartialEq, Eq, Clone, Debug, Serialize_tuple, Deserialize_tuple)]
_RNvXs7_NtCskJihg1y13m7_3fvm10state_treeNtB5_10ActorStateNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
  510|    954|#[derive(PartialEq, Eq, Clone, Debug, Serialize_tuple, Deserialize_tuple)]
_RNvMs_NtCskJihg1y13m7_3fvm10state_treeINtB4_9StateTreeNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreE10into_storeCsboUdcTbF1FS_15direct_syscalls:
  489|    318|    pub fn into_store(self) -> S {
  490|    318|        self.hamt.into_store()
  491|    318|    }
_RINvXsa_NtCskJihg1y13m7_3fvm10state_treeNtB6_10ActorStateNtNtCssVaLrL3Upj_5serde2de11Deserialize11deserializeNtNtCs3TS9n28v4Rl_12libipld_core4ipld4IpldECsboUdcTbF1FS_15direct_syscalls:
  510|    954|#[derive(PartialEq, Eq, Clone, Debug, Serialize_tuple, Deserialize_tuple)]
_RINvXNvNvXs9_NtCskJihg1y13m7_3fvm10state_treeNtBb_10ActorStateNtNtCssVaLrL3Upj_5serde3ser9Serialize9serialize1__NtB5_5InnerBY_9serializeINtCscrDzOC3hEIR_11serde_tuple10SerializerQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEEECsboUdcTbF1FS_15direct_syscalls:
  510|    954|#[derive(PartialEq, Eq, Clone, Debug, Serialize_tuple, Deserialize_tuple)]
_RINvXs9_NtCskJihg1y13m7_3fvm10state_treeNtB6_10ActorStateNtNtCssVaLrL3Upj_5serde3ser9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECsboUdcTbF1FS_15direct_syscalls:
  510|    954|#[derive(PartialEq, Eq, Clone, Debug, Serialize_tuple, Deserialize_tuple)]
_RNvMs_NtCskJihg1y13m7_3fvm10state_treeINtB4_9StateTreeNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreE5storeCsboUdcTbF1FS_15direct_syscalls:
  303|    318|    pub fn store(&self) -> &S {
  304|    318|        self.hamt.store()
  305|    318|    }
_RINvXNvNvXsa_NtCskJihg1y13m7_3fvm10state_treeNtBb_10ActorStateNtNtCssVaLrL3Upj_5serde2de11Deserialize11deserialize1__NtB5_5InnerBY_11deserializeINtCscrDzOC3hEIR_11serde_tuple12DeserializerNtNtCs3TS9n28v4Rl_12libipld_core4ipld4IpldEECsboUdcTbF1FS_15direct_syscalls:
  510|    954|#[derive(PartialEq, Eq, Clone, Debug, Serialize_tuple, Deserialize_tuple)]
_RNvMs_NtCskJihg1y13m7_3fvm10state_treeINtB4_9StateTreeINtNtNtB6_10blockstore8buffered18BufferedBlockstoreNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreEE5storeCsboUdcTbF1FS_15direct_syscalls:
  303|    636|    pub fn store(&self) -> &S {
  304|    636|        self.hamt.store()
  305|    636|    }
_RNvMs_NtCskJihg1y13m7_3fvm10state_treeINtB4_9StateTreeINtNtNtB6_10blockstore8buffered18BufferedBlockstoreNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreEE13new_from_rootCsboUdcTbF1FS_15direct_syscalls:
  254|    318|    pub fn new_from_root(store: S, c: &Cid) -> Result<Self> {
  255|       |        // Try to load state root, if versioned
  256|    318|        let (version, info, actors) = match store.get_cbor(c) {
  257|       |            Ok(Some(StateRoot {
  258|    318|                version,
  259|    318|                info,
  260|    318|                actors,
  261|    318|            })) => (version, Some(info), actors),
  262|       |            Ok(None) => {
  263|      0|                return Err(ExecutionError::Fatal(anyhow!(
  264|      0|                    "failed to find state tree {}",
  265|      0|                    c
  266|      0|                )))
  267|       |            }
  268|      0|            Err(e) => {
  269|      0|                return Err(ExecutionError::Fatal(anyhow!(
  270|      0|                    "failed to load state tree {}: {}",
  271|      0|                    c,
  272|      0|                    e
  273|      0|                )))
  274|       |            }
  275|       |        };
  276|       |
  277|    318|        match version {
  278|       |            StateTreeVersion::V0
  279|       |            | StateTreeVersion::V1
  280|       |            | StateTreeVersion::V2
  281|       |            | StateTreeVersion::V3
  282|      0|            | StateTreeVersion::V4 => Err(ExecutionError::Fatal(anyhow!(
  283|      0|                "unsupported state tree version: {:?}",
  284|      0|                version
  285|      0|            ))),
  286|       |
  287|       |            StateTreeVersion::V5 => {
  288|    318|                let hamt = Hamt::load_with_bit_width(&actors, store, HAMT_BIT_WIDTH)
  289|    318|                    .context("failed to load state tree")
  290|    318|                    .or_fatal()?;
  291|       |
  292|    318|                Ok(Self {
  293|    318|                    hamt,
  294|    318|                    version,
  295|    318|                    info,
  296|    318|                    snaps: StateSnapshots::new(),
  297|    318|                })
  298|       |            }
  299|       |        }
  300|    318|    }
_RNvMNtCskJihg1y13m7_3fvm10state_treeNtB2_14StateSnapshots12is_read_only:
  152|    954|    fn is_read_only(&self) -> bool {
  153|    954|        self.read_only_layers > 0
  154|    954|    }
_RNvMs_NtCskJihg1y13m7_3fvm10state_treeINtB4_9StateTreeNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreE9set_actorCs7AwuCMXPzRZ_8fvm_fuzz:
  344|    954|    pub fn set_actor(&mut self, id: ActorID, actor: ActorState) -> Result<()> {
  345|    954|        self.snaps.set_actor(id, actor)
  346|    954|    }
_RNvMs_NtCskJihg1y13m7_3fvm10state_treeINtB4_9StateTreeNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreE5storeCs7AwuCMXPzRZ_8fvm_fuzz:
  303|    954|    pub fn store(&self) -> &S {
  304|    954|        self.hamt.store()
  305|    954|    }
_RNvMs_NtCskJihg1y13m7_3fvm10state_treeINtB4_9StateTreeNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreE3newCs7AwuCMXPzRZ_8fvm_fuzz:
  222|    318|    pub fn new(store: S, version: StateTreeVersion) -> Result<Self> {
  223|    318|        let info = match version {
  224|       |            StateTreeVersion::V0
  225|       |            | StateTreeVersion::V1
  226|       |            | StateTreeVersion::V2
  227|       |            | StateTreeVersion::V3
  228|       |            | StateTreeVersion::V4 => {
  229|      0|                return Err(ExecutionError::Fatal(anyhow!(
  230|      0|                    "unsupported state tree version: {:?}",
  231|      0|                    version
  232|      0|                )))
  233|       |            }
  234|       |            StateTreeVersion::V5 => {
  235|    318|                let cid = store
  236|    318|                    .put_cbor(&StateInfo0::default(), multihash::Code::Blake2b256)
  237|    318|                    .context("failed to put state info")
  238|    318|                    .or_fatal()?;
  239|    318|                Some(cid)
  240|    318|            }
  241|    318|        };
  242|    318|
  243|    318|        // Both V3 and V4 use bitwidt=5.
  244|    318|        let hamt = Hamt::new_with_bit_width(store, HAMT_BIT_WIDTH);
  245|    318|        Ok(Self {
  246|    318|            hamt,
  247|    318|            version,
  248|    318|            info,
  249|    318|            snaps: StateSnapshots::new(),
  250|    318|        })
  251|    318|    }
_RNvMNtCskJihg1y13m7_3fvm10state_treeNtB2_14StateSnapshots9set_actor:
  200|    954|        self.assert_writable()?;
  201|       |
  202|    954|        self.top_layer()?
  203|       |            .actors
  204|    954|            .borrow_mut()
  205|    954|            .insert(id, Some(actor));
  206|    954|        Ok(())
  207|    954|    }
_RNvMNtCskJihg1y13m7_3fvm10state_treeNtB2_14StateSnapshots3new:
   65|    636|    fn new() -> Self {
   66|    636|        Self {
   67|    636|            layers: vec![StateSnapLayer::default()],
   68|    636|            read_only_layers: 0,
   69|    636|        }
   70|    636|    }
_RNvXs2_NtCskJihg1y13m7_3fvm10state_treeNtB5_14StateSnapLayerNtNtCsiloedr2K6v7_4core7default7Default7default:
   50|    636|#[derive(Debug, Default)]
_RNvMNtCskJihg1y13m7_3fvm10state_treeNtB2_14StateSnapshots9top_layer:
  144|    954|    fn top_layer(&self) -> Result<&StateSnapLayer> {
  145|    954|        self.layers
  146|    954|            .last()
  147|    954|            .context("state snapshots empty")
  148|    954|            .or_fatal()
  149|    954|    }
_RNvMNtCskJihg1y13m7_3fvm10state_treeNtB2_14StateSnapshots15assert_writable:
  156|    954|    fn assert_writable(&self) -> Result<()> {
  157|    954|        if self.is_read_only() {
  158|      0|            Err(syscall_error!(ReadOnly; "cannot mutate state while in read-only mode").into())
  159|       |        } else {
  160|    954|            Ok(())
  161|       |        }
  162|    954|    }

_RNvMs0_NtNtCskJihg1y13m7_3fvm8syscalls7contextNtB5_6Memory9try_slice:
   57|    318|    pub fn try_slice(&self, offset: u32, len: u32) -> Result<&[u8]> {
   58|    318|        self.get(offset as usize..)
   59|    318|            .and_then(|data| data.get(..len as usize))
   60|    318|            .ok_or_else(|| format!("buffer {} (length {}) out of bounds", offset, len))
   61|    318|            .or_error(ErrorNumber::IllegalArgument)
   62|    318|    }
_RNvMs0_NtNtCskJihg1y13m7_3fvm8syscalls7contextNtB5_6Memory3new:
   40|    318|    pub fn new<'a>(m: &'a mut [u8]) -> &'a mut Memory {
   41|    318|        // We explicitly specify the lifetimes here to ensure that the cast doesn't inadvertently
   42|    318|        // change them.
   43|    318|        unsafe { &mut *(m as *mut [u8] as *mut Memory) }
   44|    318|    }
_RNvXNtNtCskJihg1y13m7_3fvm8syscalls7contextNtB2_6MemoryNtNtNtCsiloedr2K6v7_4core3ops5deref5Deref5deref:
   27|    318|    fn deref(&self) -> &Self::Target {
   28|    318|        &self.0
   29|    318|    }
_RNCNvMs0_NtNtCskJihg1y13m7_3fvm8syscalls7contextNtB7_6Memory9try_slice0Bb_:
   59|    318|            .and_then(|data| data.get(..len as usize))

_RINvNtNtCskJihg1y13m7_3fvm8syscalls4ipld12block_createINtNtNtB6_6kernel7default13DefaultKernelINtNtNtB6_12call_manager7default18DefaultCallManagerINtNtNtB6_7machine7default14DefaultMachineNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsh74LAqVwWKW_21fvm_integration_tests5dummy12DummyExternsEEEECsboUdcTbF1FS_15direct_syscalls:
   27|    318|pub fn block_create(
   28|    318|    context: Context<'_, impl Kernel>,
   29|    318|    codec: u64,
   30|    318|    data_off: u32,
   31|    318|    data_len: u32,
   32|    318|) -> Result<u32> {
   33|       |    #[cfg(feature = "instrument-syscalls")]
   34|       |    unsafe { set_syscall_probe("syscall.ipld.block_create") };
   35|    318|    let data = context.memory.try_slice(data_off, data_len)?;
   36|    318|    context.kernel.block_create(codec, data)
   37|    318|}

_RINvXNvNvXs2_NtCskJihg1y13m7_3fvm12system_actorNtBb_5StateNtNtCssVaLrL3Upj_5serde3ser9Serialize9serialize1__NtB5_5InnerBU_9serializeINtCscrDzOC3hEIR_11serde_tuple10SerializerQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEEECs7AwuCMXPzRZ_8fvm_fuzz:
   15|    318|#[derive(Default, Deserialize_tuple, Serialize_tuple)]
_RINvXs2_NtCskJihg1y13m7_3fvm12system_actorNtB6_5StateNtNtCssVaLrL3Upj_5serde3ser9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECs7AwuCMXPzRZ_8fvm_fuzz:
   15|    318|#[derive(Default, Deserialize_tuple, Serialize_tuple)]

_RNvXs_NtCs23Y5vRLZE35_19fvm_ipld_blockstore5blockINtB4_5BlockRINtNtCs9pDt8l5wGDA_5alloc3vec3VechEEINtNtCsiloedr2K6v7_4core7convert5AsRefShE6as_refCsboUdcTbF1FS_15direct_syscalls:
   42|    636|    fn as_ref(&self) -> &[u8] {
   43|    636|        self.data.as_ref()
   44|    636|    }
_RNvMNtCs23Y5vRLZE35_19fvm_ipld_blockstore5blockINtB2_5BlockRINtNtCs9pDt8l5wGDA_5alloc3vec3VechEE3cidCsboUdcTbF1FS_15direct_syscalls:
   28|    636|    pub fn cid(&self, mh_code: multihash::Code) -> Cid {
   29|    636|        Cid::new_v1(self.codec, mh_code.digest(self.data.as_ref()))
   30|    636|    }
_RNvMNtCs23Y5vRLZE35_19fvm_ipld_blockstore5blockINtB2_5BlockRINtNtCs9pDt8l5wGDA_5alloc3vec3VechEE3cidCs7AwuCMXPzRZ_8fvm_fuzz:
   28|  1.59k|    pub fn cid(&self, mh_code: multihash::Code) -> Cid {
   29|  1.59k|        Cid::new_v1(self.codec, mh_code.digest(self.data.as_ref()))
   30|  1.59k|    }
_RNvXs_NtCs23Y5vRLZE35_19fvm_ipld_blockstore5blockINtB4_5BlockRINtNtCs9pDt8l5wGDA_5alloc3vec3VechEEINtNtCsiloedr2K6v7_4core7convert5AsRefShE6as_refCs7AwuCMXPzRZ_8fvm_fuzz:
   42|  1.59k|    fn as_ref(&self) -> &[u8] {
   43|  1.59k|        self.data.as_ref()
   44|  1.59k|    }

_RINvYNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtB7_10Blockstore3putRINtNtCs9pDt8l5wGDA_5alloc3vec3VechEECsboUdcTbF1FS_15direct_syscalls:
   39|    636|    fn put<D>(&self, mh_code: multihash::Code, block: &Block<D>) -> Result<Cid>
   40|    636|    where
   41|    636|        Self: Sized,
   42|    636|        D: AsRef<[u8]>,
   43|    636|    {
   44|    636|        let k = block.cid(mh_code);
   45|    636|        self.put_keyed(&k, block.as_ref())?;
   46|    636|        Ok(k)
   47|    636|    }
_RINvYNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtB7_10Blockstore3putRINtNtCs9pDt8l5wGDA_5alloc3vec3VechEECs7AwuCMXPzRZ_8fvm_fuzz:
   39|  1.59k|    fn put<D>(&self, mh_code: multihash::Code, block: &Block<D>) -> Result<Cid>
   40|  1.59k|    where
   41|  1.59k|        Self: Sized,
   42|  1.59k|        D: AsRef<[u8]>,
   43|  1.59k|    {
   44|  1.59k|        let k = block.cid(mh_code);
   45|  1.59k|        self.put_keyed(&k, block.as_ref())?;
   46|  1.59k|        Ok(k)
   47|  1.59k|    }
_RINvYNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtB7_10Blockstore14put_many_keyedRINtNtCs9pDt8l5wGDA_5alloc3vec3VechEINtNtNtNtCsiloedr2K6v7_4core4iter8adapters3map3MapINtNtNtB2l_5slice4iter4IterTINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EB1D_EENCNCINvCs7wiLZqa2F25_12fvm_ipld_car14load_car_innerRShB3_E0s0_0EECs7AwuCMXPzRZ_8fvm_fuzz:
   73|    318|    fn put_many_keyed<D, I>(&self, blocks: I) -> Result<()>
   74|    318|    where
   75|    318|        Self: Sized,
   76|    318|        D: AsRef<[u8]>,
   77|    318|        I: IntoIterator<Item = (Cid, D)>,
   78|    318|    {
   79|  5.72k|        for (c, b) in blocks {
   80|  5.40k|            self.put_keyed(&c, b.as_ref())?
   81|       |        }
   82|    318|        Ok(())
   83|    318|    }
_RINvXCs23Y5vRLZE35_19fvm_ipld_blockstoreRRNtNtB3_6memory16MemoryBlockstoreNtB3_10Blockstore3putRINtNtCs9pDt8l5wGDA_5alloc3vec3VechEECs7AwuCMXPzRZ_8fvm_fuzz:
  106|    318|    fn put<D>(&self, mh_code: multihash::Code, block: &Block<D>) -> Result<Cid>
  107|    318|    where
  108|    318|        Self: Sized,
  109|    318|        D: AsRef<[u8]>,
  110|    318|    {
  111|    318|        (*self).put(mh_code, block)
  112|    318|    }
_RINvXCs23Y5vRLZE35_19fvm_ipld_blockstoreRNtNtB3_6memory16MemoryBlockstoreNtB3_10Blockstore3putRINtNtCs9pDt8l5wGDA_5alloc3vec3VechEECs7AwuCMXPzRZ_8fvm_fuzz:
  106|    318|    fn put<D>(&self, mh_code: multihash::Code, block: &Block<D>) -> Result<Cid>
  107|    318|    where
  108|    318|        Self: Sized,
  109|    318|        D: AsRef<[u8]>,
  110|    318|    {
  111|    318|        (*self).put(mh_code, block)
  112|    318|    }

_RNvXs1_NtCs23Y5vRLZE35_19fvm_ipld_blockstore6memoryNtB5_16MemoryBlockstoreNtNtCsiloedr2K6v7_4core7default7Default7default:
   11|    318|#[derive(Debug, Default, Clone)]
_RNvXs_NtCs23Y5vRLZE35_19fvm_ipld_blockstore6memoryNtB4_16MemoryBlockstoreNtB6_10Blockstore9put_keyed:
   31|  7.63k|    fn put_keyed(&self, k: &Cid, block: &[u8]) -> Result<()> {
   32|  7.63k|        self.blocks.borrow_mut().insert(*k, block.into());
   33|  7.63k|        Ok(())
   34|  7.63k|    }
_RNvXs_NtCs23Y5vRLZE35_19fvm_ipld_blockstore6memoryNtB4_16MemoryBlockstoreNtB6_10Blockstore3get:
   27|  1.90k|    fn get(&self, k: &Cid) -> Result<Option<Vec<u8>>> {
   28|  1.90k|        Ok(self.blocks.borrow().get(k).cloned())
   29|  1.90k|    }
_RNvXs_NtCs23Y5vRLZE35_19fvm_ipld_blockstore6memoryNtB4_16MemoryBlockstoreNtB6_10Blockstore3has:
   23|    318|    fn has(&self, k: &Cid) -> Result<bool> {
   24|    318|        Ok(self.blocks.borrow().contains_key(k))
   25|    318|    }

_RNCINvCs7wiLZqa2F25_12fvm_ipld_car14load_car_innerRShNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreE0Cs7AwuCMXPzRZ_8fvm_fuzz:
  161|    318|    let mut car_reader = if verify {
  162|      0|        CarReader::new(reader).await
  163|       |    } else {
  164|    318|        CarReader::new_unchecked(reader).await
  165|      0|    }?;
  166|       |
  167|       |    // Batch write key value pairs from car file
  168|       |    // TODO: Stream the data once some of the stream APIs stabilize.
  169|    318|    let mut buf = Vec::with_capacity(100);
  170|  5.72k|    while let Some(block) = car_reader.next_block().await? {
  171|  5.40k|        buf.push((block.cid, block.data));
  172|  5.40k|        if buf.len() > 1000 {
  173|      0|            s.put_many_keyed(buf.iter().map(|(k, v)| (*k, v)))
  174|      0|                .map_err(|e| Error::Other(e.to_string()))?;
  175|      0|            buf.clear();
  176|  5.40k|        }
  177|       |    }
  178|    318|    s.put_many_keyed(buf.iter().map(|(k, v)| (*k, v)))
  179|    318|        .map_err(|e| Error::Other(e.to_string()))?;
  180|    318|    Ok(car_reader.header.roots)
  181|    318|}
_RNCNvMs0_Cs7wiLZqa2F25_12fvm_ipld_carINtB7_9CarReaderRShE3new0Cs7AwuCMXPzRZ_8fvm_fuzz:
   73|    318|        let buf = ld_read(&mut reader)
   74|      0|            .await?
   75|    318|            .ok_or_else(|| Error::ParsingError("failed to parse uvarint for header".to_string()))?;
   76|    318|        let header: CarHeader = from_slice(&buf).map_err(|e| Error::ParsingError(e.to_string()))?;
   77|    318|        if header.roots.is_empty() {
   78|      0|            return Err(Error::ParsingError("empty CAR file".to_owned()));
   79|    318|        }
   80|    318|        if header.version != 1 {
   81|      0|            return Err(Error::InvalidFile("CAR file version must be 1".to_owned()));
   82|    318|        }
   83|    318|        Ok(CarReader {
   84|    318|            reader,
   85|    318|            header,
   86|    318|            validate: true,
   87|    318|        })
   88|    318|    }
_RNCNCINvCs7wiLZqa2F25_12fvm_ipld_car14load_car_innerRShNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreE0s0_0Cs7AwuCMXPzRZ_8fvm_fuzz:
  178|  5.40k|    s.put_many_keyed(buf.iter().map(|(k, v)| (*k, v)))
_RINvXNvCs7wiLZqa2F25_12fvm_ipld_cars_1__NtB5_9CarHeaderNtNtCssVaLrL3Upj_5serde2de11Deserialize11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECs7AwuCMXPzRZ_8fvm_fuzz:
   19|    318|#[derive(Debug, Default, Serialize, Deserialize, PartialEq, Eq)]
_RINvXs0_NvXNvCs7wiLZqa2F25_12fvm_ipld_cars_1__NtBb_9CarHeaderNtNtCssVaLrL3Upj_5serde2de11Deserialize11deserializeNtB6_9___VisitorNtBZ_7Visitor9visit_mapINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECs7AwuCMXPzRZ_8fvm_fuzz:
   19|    954|#[derive(Debug, Default, Serialize, Deserialize, PartialEq, Eq)]
_RINvCs7wiLZqa2F25_12fvm_ipld_car14load_car_innerRShNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreECs7AwuCMXPzRZ_8fvm_fuzz:
  156|    318|async fn load_car_inner<R, B>(s: &B, reader: R, verify: bool) -> Result<Vec<Cid>, Error>
  157|    318|where
  158|    318|    B: Blockstore,
  159|    318|    R: AsyncRead + Send + Unpin,
  160|    318|{
_RNvMs0_Cs7wiLZqa2F25_12fvm_ipld_carINtB5_9CarReaderRShE3newCs7AwuCMXPzRZ_8fvm_fuzz:
   72|    318|    pub async fn new(mut reader: R) -> Result<Self, Error> {
_RNvMs0_Cs7wiLZqa2F25_12fvm_ipld_carINtB5_9CarReaderRShE13new_uncheckedCs7AwuCMXPzRZ_8fvm_fuzz:
   91|    318|    pub async fn new_unchecked(reader: R) -> Result<Self, Error> {
_RINvCs7wiLZqa2F25_12fvm_ipld_car18load_car_uncheckedRShNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreECs7AwuCMXPzRZ_8fvm_fuzz:
  148|    318|pub async fn load_car_unchecked<R, B>(s: &B, reader: R) -> Result<Vec<Cid>, Error>
  149|    318|where
  150|    318|    B: Blockstore,
  151|    318|    R: AsyncRead + Send + Unpin,
  152|    318|{
_RINvXNvXNvCs7wiLZqa2F25_12fvm_ipld_cars_1__NtB8_9CarHeaderNtNtCssVaLrL3Upj_5serde2de11Deserialize11deserializeNtB3_14___FieldVisitorNtBW_7Visitor9visit_strINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsiloedr2K6v7_4core7convert10InfallibleEECs7AwuCMXPzRZ_8fvm_fuzz:
   19|    636|#[derive(Debug, Default, Serialize, Deserialize, PartialEq, Eq)]
_RNCINvCs7wiLZqa2F25_12fvm_ipld_car18load_car_uncheckedRShNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreE0Cs7AwuCMXPzRZ_8fvm_fuzz:
  153|    318|    load_car_inner(s, reader, false).await
  154|    318|}
_RNCNvMs0_Cs7wiLZqa2F25_12fvm_ipld_carINtB7_9CarReaderRShE13new_unchecked0Cs7AwuCMXPzRZ_8fvm_fuzz:
   92|    318|        let mut reader = Self::new(reader).await?;
   93|    318|        reader.validate = false;
   94|    318|        Ok(reader)
   95|    318|    }
_RNvMs0_Cs7wiLZqa2F25_12fvm_ipld_carINtB5_9CarReaderRShE10next_blockCs7AwuCMXPzRZ_8fvm_fuzz:
   98|  5.72k|    pub async fn next_block(&mut self) -> Result<Option<Block>, Error> {
_RINvXs_NvXNvCs7wiLZqa2F25_12fvm_ipld_cars_1__NtBa_9CarHeaderNtNtCssVaLrL3Upj_5serde2de11Deserialize11deserializeNtB5_7___FieldBW_11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECs7AwuCMXPzRZ_8fvm_fuzz:
   19|    636|#[derive(Debug, Default, Serialize, Deserialize, PartialEq, Eq)]
_RNCNvMs0_Cs7wiLZqa2F25_12fvm_ipld_carINtB7_9CarReaderRShE10next_block0Cs7AwuCMXPzRZ_8fvm_fuzz:
  101|  5.72k|        if let Some((cid, data)) = read_node(&mut self.reader).await? {
  102|  5.40k|            if self.validate {
  103|      0|                match cid.hash().code() {
  104|       |                    0x0 => {
  105|      0|                        if cid.hash().digest() != data {
  106|      0|                            return Err(Error::InvalidFile(
  107|      0|                                "CAR has an identity CID that doesn't match the corresponding data"
  108|      0|                                    .into(),
  109|      0|                            ));
  110|      0|                        }
  111|       |                    }
  112|      0|                    code => {
  113|      0|                        let code = multihash::Code::try_from(code)?;
  114|      0|                        let actual = Cid::new_v1(cid.codec(), code.digest(&data));
  115|      0|                        if actual != cid {
  116|      0|                            return Err(Error::InvalidFile(format!(
  117|      0|                                "CAR has an incorrect CID: expected {}, found {}",
  118|      0|                                cid, actual,
  119|      0|                            )));
  120|      0|                        }
  121|       |                    }
  122|       |                }
  123|  5.40k|            }
  124|  5.40k|            Ok(Some(Block { cid, data }))
  125|       |        } else {
  126|    318|            Ok(None)
  127|       |        }
  128|  5.72k|    }

_RNCINvNtCs7wiLZqa2F25_12fvm_ipld_car4util7ld_readRShE0Cs7AwuCMXPzRZ_8fvm_fuzz:
   16|  6.04k|    let l: usize = match VarIntAsyncReader::read_varint_async(&mut reader).await {
   17|  5.72k|        Ok(len) => len,
   18|    318|        Err(e) => {
   19|    318|            if e.kind() == std::io::ErrorKind::UnexpectedEof {
   20|    318|                return Ok(None);
   21|      0|            }
   22|      0|            return Err(Error::Other(e.to_string()));
   23|       |        }
   24|       |    };
   25|  5.72k|    let mut buf = Vec::with_capacity(std::cmp::min(l as usize, MAX_ALLOC));
   26|  5.72k|    let bytes_read = reader
   27|  5.72k|        .take(l as u64)
   28|  5.72k|        .read_to_end(&mut buf)
   29|      0|        .await
   30|  5.72k|        .map_err(|e| Error::Other(e.to_string()))?;
   31|  5.72k|    if bytes_read != l {
   32|      0|        return Err(Error::Io(std::io::Error::new(
   33|      0|            std::io::ErrorKind::UnexpectedEof,
   34|      0|            format!(
   35|      0|                "expected to read at least {} bytes, but read {}",
   36|      0|                l, bytes_read
   37|      0|            ),
   38|      0|        )));
   39|  5.72k|    }
   40|  5.72k|    Ok(Some(buf))
   41|  6.04k|}
_RINvNtCs7wiLZqa2F25_12fvm_ipld_car4util9read_nodeRShECs7AwuCMXPzRZ_8fvm_fuzz:
   53|  5.72k|pub(crate) async fn read_node<R>(buf_reader: &mut R) -> Result<Option<(Cid, Vec<u8>)>, Error>
   54|  5.72k|where
   55|  5.72k|    R: AsyncRead + Send + Unpin,
   56|  5.72k|{
_RINvNtCs7wiLZqa2F25_12fvm_ipld_car4util7ld_readRShECs7AwuCMXPzRZ_8fvm_fuzz:
   11|  6.04k|pub(crate) async fn ld_read<R>(mut reader: &mut R) -> Result<Option<Vec<u8>>, Error>
   12|  6.04k|where
   13|  6.04k|    R: AsyncRead + Send + Unpin,
   14|  6.04k|{
_RNCINvNtCs7wiLZqa2F25_12fvm_ipld_car4util9read_nodeRShE0Cs7AwuCMXPzRZ_8fvm_fuzz:
   57|  5.72k|    match ld_read(buf_reader).await? {
   58|  5.40k|        Some(buf) => {
   59|  5.40k|            let mut cursor = std::io::Cursor::new(&buf);
   60|  5.40k|            let cid = Cid::read_bytes(&mut cursor)?;
   61|  5.40k|            Ok(Some((cid, buf[cursor.position() as usize..].to_vec())))
   62|       |        }
   63|    318|        None => Ok(None),
   64|       |    }
   65|  5.72k|}

_RINvXNtNtCsgVlqBW3KcNx_17fvm_ipld_encoding5bytes12strict_bytesShNtB3_9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECsboUdcTbF1FS_15direct_syscalls:
   35|    318|        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   36|    318|        where
   37|    318|            S: Serializer,
   38|    318|        {
   39|    318|            serializer.serialize_bytes(self.as_ref())
   40|    318|        }
_RINvXNtNtCsgVlqBW3KcNx_17fvm_ipld_encoding5bytes12strict_bytesINtNtCs9pDt8l5wGDA_5alloc3vec3VechENtB3_9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECsboUdcTbF1FS_15direct_syscalls:
   35|    954|        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   36|    954|        where
   37|    954|            S: Serializer,
   38|    954|        {
   39|    954|            serializer.serialize_bytes(self.as_ref())
   40|    954|        }
_RINvNtNtCsgVlqBW3KcNx_17fvm_ipld_encoding5bytes12strict_bytes11deserializeINtNtCs9pDt8l5wGDA_5alloc3vec3VechEQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECsboUdcTbF1FS_15direct_syscalls:
  162|    318|    pub fn deserialize<'de, T, D>(deserializer: D) -> Result<T, D::Error>
  163|    318|    where
  164|    318|        T: Deserialize<'de>,
  165|    318|        D: Deserializer<'de>,
  166|    318|    {
  167|    318|        Deserialize::deserialize(deserializer)
  168|    318|    }
_RNCINvXNvNtNtCsgVlqBW3KcNx_17fvm_ipld_encoding5bytes12strict_bytes1__NtB7_7ByteBufNtNtCssVaLrL3Upj_5serde2de11Deserialize11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEE0CsboUdcTbF1FS_15direct_syscalls:
  144|    318|    #[derive(serde::Deserialize, serde::Serialize, Debug, Eq, PartialEq, Clone)]
_RINvXNvXs0_NtNtCsgVlqBW3KcNx_17fvm_ipld_encoding5bytes12strict_bytesINtNtCs9pDt8l5wGDA_5alloc6borrow3CowShENtB9_11Deserialize11deserializeNtB3_10CowVisitorNtNtCssVaLrL3Upj_5serde2de7Visitor11visit_bytesNtNtCs3TS9n28v4Rl_12libipld_core5error10SerdeErrorECsboUdcTbF1FS_15direct_syscalls:
   96|    954|                fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>
   97|    954|                where
   98|    954|                    E: Error,
   99|    954|                {
  100|    954|                    Ok(Cow::Owned(v.to_vec()))
  101|    954|                }
_RINvXs_NtNtCsgVlqBW3KcNx_17fvm_ipld_encoding5bytes12strict_bytesINtNtCs9pDt8l5wGDA_5alloc3vec3VechENtB5_11Deserialize11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECsboUdcTbF1FS_15direct_syscalls:
   44|    318|        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
   45|    318|        where
   46|    318|            D: Deserializer<'de>,
   47|    318|        {
   48|    318|            struct VecVisitor;
   49|    318|
   50|    318|            impl<'de> Visitor<'de> for VecVisitor {
   51|    318|                type Value = Vec<u8>;
   52|    318|
   53|    318|                fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
   54|    318|                    formatter.write_str("byte array")
   55|    318|                }
   56|    318|
   57|    318|                fn visit_bytes<E>(self, v: &[u8]) -> Result<Vec<u8>, E>
   58|    318|                where
   59|    318|                    E: Error,
   60|    318|                {
   61|    318|                    Ok(v.into())
   62|    318|                }
   63|    318|
   64|    318|                fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<Vec<u8>, E>
   65|    318|                where
   66|    318|                    E: Error,
   67|    318|                {
   68|    318|                    Ok(v)
   69|    318|                }
   70|    318|            }
   71|    318|            deserializer.deserialize_byte_buf(VecVisitor)
   72|    318|        }
_RINvXs0_NtNtCsgVlqBW3KcNx_17fvm_ipld_encoding5bytes12strict_bytesINtNtCs9pDt8l5wGDA_5alloc6borrow3CowShENtB6_11Deserialize11deserializeNtNtCs3TS9n28v4Rl_12libipld_core4ipld4IpldECsboUdcTbF1FS_15direct_syscalls:
   76|    954|        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
   77|    954|        where
   78|    954|            D: Deserializer<'de>,
   79|    954|        {
   80|    954|            struct CowVisitor;
   81|    954|
   82|    954|            impl<'de> Visitor<'de> for CowVisitor {
   83|    954|                type Value = Cow<'de, [u8]>;
   84|    954|
   85|    954|                fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
   86|    954|                    formatter.write_str("a byte array")
   87|    954|                }
   88|    954|
   89|    954|                fn visit_borrowed_bytes<E>(self, v: &'de [u8]) -> Result<Self::Value, E>
   90|    954|                where
   91|    954|                    E: Error,
   92|    954|                {
   93|    954|                    Ok(Cow::Borrowed(v))
   94|    954|                }
   95|    954|
   96|    954|                fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>
   97|    954|                where
   98|    954|                    E: Error,
   99|    954|                {
  100|    954|                    Ok(Cow::Owned(v.to_vec()))
  101|    954|                }
  102|    954|
  103|    954|                fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<Self::Value, E>
  104|    954|                where
  105|    954|                    E: Error,
  106|    954|                {
  107|    954|                    Ok(Cow::Owned(v))
  108|    954|                }
  109|    954|            }
  110|    954|            deserializer.deserialize_bytes(CowVisitor)
  111|    954|        }
_RINvXNvXs_NtNtCsgVlqBW3KcNx_17fvm_ipld_encoding5bytes12strict_bytesINtNtCs9pDt8l5wGDA_5alloc3vec3VechENtB8_11Deserialize11deserializeNtB3_10VecVisitorNtNtCssVaLrL3Upj_5serde2de7Visitor11visit_bytesINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor5error11DecodeErrorNtNtCsiloedr2K6v7_4core7convert10InfallibleEECsboUdcTbF1FS_15direct_syscalls:
   57|    318|                fn visit_bytes<E>(self, v: &[u8]) -> Result<Vec<u8>, E>
   58|    318|                where
   59|    318|                    E: Error,
   60|    318|                {
   61|    318|                    Ok(v.into())
   62|    318|                }
_RINvXNvNtNtCsgVlqBW3KcNx_17fvm_ipld_encoding5bytes12strict_bytes1__NtB5_7ByteBufNtNtCssVaLrL3Upj_5serde2de11Deserialize11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECsboUdcTbF1FS_15direct_syscalls:
  144|    318|    #[derive(serde::Deserialize, serde::Serialize, Debug, Eq, PartialEq, Clone)]
_RINvXNtNtCsgVlqBW3KcNx_17fvm_ipld_encoding5bytes12strict_bytesShNtB3_9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECs7AwuCMXPzRZ_8fvm_fuzz:
   35|    318|        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   36|    318|        where
   37|    318|            S: Serializer,
   38|    318|        {
   39|    318|            serializer.serialize_bytes(self.as_ref())
   40|    318|        }
_RNvMs2_NtNtCsgVlqBW3KcNx_17fvm_ipld_encoding5bytes12strict_bytesNtB5_7ByteBuf8into_vec:
  149|    318|        pub fn into_vec(self) -> Vec<u8> {
  150|    318|            self.0
  151|    318|        }

_RINvYNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsgVlqBW3KcNx_17fvm_ipld_encoding10cbor_store9CborStore8put_cborINtNtCslH3pn9Bu6yX_13fvm_ipld_hamt4node4NodeNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtB2g_14hash_algorithm6Sha256EECsboUdcTbF1FS_15direct_syscalls:
   26|    318|    fn put_cbor<S>(&self, obj: &S, code: multihash::Code) -> anyhow::Result<Cid>
   27|    318|    where
   28|    318|        S: ser::Serialize,
   29|    318|    {
   30|    318|        let bytes = crate::to_vec(obj)?;
   31|    318|        self.put(
   32|    318|            code,
   33|    318|            &Block {
   34|    318|                codec: DAG_CBOR,
   35|    318|                data: &bytes,
   36|    318|            },
   37|    318|        )
   38|    318|    }
_RINvYINtNtNtCskJihg1y13m7_3fvm10blockstore8buffered18BufferedBlockstoreNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreENtNtCsgVlqBW3KcNx_17fvm_ipld_encoding10cbor_store9CborStore8get_cborTmINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEECsboUdcTbF1FS_15direct_syscalls:
   16|    318|        match self.get(cid)? {
   17|    318|            Some(bz) => {
   18|    318|                let res = crate::from_slice(&bz)?;
   19|    318|                Ok(Some(res))
   20|       |            }
   21|      0|            None => Ok(None),
   22|       |        }
   23|    318|    }
_RINvYINtNtNtCskJihg1y13m7_3fvm10blockstore8buffered18BufferedBlockstoreNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreENtNtCsgVlqBW3KcNx_17fvm_ipld_encoding10cbor_store9CborStore8get_cborINtNtCslH3pn9Bu6yX_13fvm_ipld_hamt4node4NodeNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtBa_10state_tree10ActorStateNtNtB3l_14hash_algorithm6Sha256EECsboUdcTbF1FS_15direct_syscalls:
   16|    318|        match self.get(cid)? {
   17|    318|            Some(bz) => {
   18|    318|                let res = crate::from_slice(&bz)?;
   19|    318|                Ok(Some(res))
   20|       |            }
   21|      0|            None => Ok(None),
   22|       |        }
   23|    318|    }
_RINvYINtNtNtCskJihg1y13m7_3fvm10blockstore8buffered18BufferedBlockstoreNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreENtNtCsgVlqBW3KcNx_17fvm_ipld_encoding10cbor_store9CborStore8get_cborNtNtCs83Z8YCK0meJ_10fvm_shared5state9StateRootECsboUdcTbF1FS_15direct_syscalls:
   16|    318|        match self.get(cid)? {
   17|    318|            Some(bz) => {
   18|    318|                let res = crate::from_slice(&bz)?;
   19|    318|                Ok(Some(res))
   20|       |            }
   21|      0|            None => Ok(None),
   22|       |        }
   23|    318|    }
_RINvYNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsgVlqBW3KcNx_17fvm_ipld_encoding10cbor_store9CborStore8put_cborNtNtCs83Z8YCK0meJ_10fvm_shared5state9StateRootECsboUdcTbF1FS_15direct_syscalls:
   26|    318|    fn put_cbor<S>(&self, obj: &S, code: multihash::Code) -> anyhow::Result<Cid>
   27|    318|    where
   28|    318|        S: ser::Serialize,
   29|    318|    {
   30|    318|        let bytes = crate::to_vec(obj)?;
   31|    318|        self.put(
   32|    318|            code,
   33|    318|            &Block {
   34|    318|                codec: DAG_CBOR,
   35|    318|                data: &bytes,
   36|    318|            },
   37|    318|        )
   38|    318|    }
_RINvYINtNtNtCskJihg1y13m7_3fvm10blockstore8buffered18BufferedBlockstoreNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreENtNtCsgVlqBW3KcNx_17fvm_ipld_encoding10cbor_store9CborStore8get_cborINtNtCs9pDt8l5wGDA_5alloc3vec3VecTNtNtB3l_6string6StringINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEEECsboUdcTbF1FS_15direct_syscalls:
   16|    318|        match self.get(cid)? {
   17|    318|            Some(bz) => {
   18|    318|                let res = crate::from_slice(&bz)?;
   19|    318|                Ok(Some(res))
   20|       |            }
   21|      0|            None => Ok(None),
   22|       |        }
   23|    318|    }
_RINvYNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsgVlqBW3KcNx_17fvm_ipld_encoding10cbor_store9CborStore8get_cborTmINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEECs7AwuCMXPzRZ_8fvm_fuzz:
   16|    318|        match self.get(cid)? {
   17|    318|            Some(bz) => {
   18|    318|                let res = crate::from_slice(&bz)?;
   19|    318|                Ok(Some(res))
   20|       |            }
   21|      0|            None => Ok(None),
   22|       |        }
   23|    318|    }
_RINvYNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsgVlqBW3KcNx_17fvm_ipld_encoding10cbor_store9CborStore8put_cborAuj0_ECs7AwuCMXPzRZ_8fvm_fuzz:
   26|    318|    fn put_cbor<S>(&self, obj: &S, code: multihash::Code) -> anyhow::Result<Cid>
   27|    318|    where
   28|    318|        S: ser::Serialize,
   29|    318|    {
   30|    318|        let bytes = crate::to_vec(obj)?;
   31|    318|        self.put(
   32|    318|            code,
   33|    318|            &Block {
   34|    318|                codec: DAG_CBOR,
   35|    318|                data: &bytes,
   36|    318|            },
   37|    318|        )
   38|    318|    }
_RINvYNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsgVlqBW3KcNx_17fvm_ipld_encoding10cbor_store9CborStore8put_cborNtNtCskJihg1y13m7_3fvm10init_actor5StateECs7AwuCMXPzRZ_8fvm_fuzz:
   26|    318|    fn put_cbor<S>(&self, obj: &S, code: multihash::Code) -> anyhow::Result<Cid>
   27|    318|    where
   28|    318|        S: ser::Serialize,
   29|    318|    {
   30|    318|        let bytes = crate::to_vec(obj)?;
   31|    318|        self.put(
   32|    318|            code,
   33|    318|            &Block {
   34|    318|                codec: DAG_CBOR,
   35|    318|                data: &bytes,
   36|    318|            },
   37|    318|        )
   38|    318|    }
_RINvYNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsgVlqBW3KcNx_17fvm_ipld_encoding10cbor_store9CborStore8put_cborNtNtCskJihg1y13m7_3fvm12system_actor5StateECs7AwuCMXPzRZ_8fvm_fuzz:
   26|    318|    fn put_cbor<S>(&self, obj: &S, code: multihash::Code) -> anyhow::Result<Cid>
   27|    318|    where
   28|    318|        S: ser::Serialize,
   29|    318|    {
   30|    318|        let bytes = crate::to_vec(obj)?;
   31|    318|        self.put(
   32|    318|            code,
   33|    318|            &Block {
   34|    318|                codec: DAG_CBOR,
   35|    318|                data: &bytes,
   36|    318|            },
   37|    318|        )
   38|    318|    }
_RINvYNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsgVlqBW3KcNx_17fvm_ipld_encoding10cbor_store9CborStore8get_cborINtNtCs9pDt8l5wGDA_5alloc3vec3VecTNtNtB2g_6string6StringINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEEECs7AwuCMXPzRZ_8fvm_fuzz:
   16|    318|        match self.get(cid)? {
   17|    318|            Some(bz) => {
   18|    318|                let res = crate::from_slice(&bz)?;
   19|    318|                Ok(Some(res))
   20|       |            }
   21|      0|            None => Ok(None),
   22|       |        }
   23|    318|    }
_RINvYNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsgVlqBW3KcNx_17fvm_ipld_encoding10cbor_store9CborStore8put_cborNtNtCs83Z8YCK0meJ_10fvm_shared5state10StateInfo0ECs7AwuCMXPzRZ_8fvm_fuzz:
   26|    318|    fn put_cbor<S>(&self, obj: &S, code: multihash::Code) -> anyhow::Result<Cid>
   27|    318|    where
   28|    318|        S: ser::Serialize,
   29|    318|    {
   30|    318|        let bytes = crate::to_vec(obj)?;
   31|    318|        self.put(
   32|    318|            code,
   33|    318|            &Block {
   34|    318|                codec: DAG_CBOR,
   35|    318|                data: &bytes,
   36|    318|            },
   37|    318|        )
   38|    318|    }
_RINvYRRNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCsgVlqBW3KcNx_17fvm_ipld_encoding10cbor_store9CborStore8put_cborINtNtCslH3pn9Bu6yX_13fvm_ipld_hamt4node4NodeNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCs9pDt8l5wGDA_5alloc6string6StringNtNtB2i_14hash_algorithm6Sha256EECs7AwuCMXPzRZ_8fvm_fuzz:
   26|    318|    fn put_cbor<S>(&self, obj: &S, code: multihash::Code) -> anyhow::Result<Cid>
   27|    318|    where
   28|    318|        S: ser::Serialize,
   29|    318|    {
   30|    318|        let bytes = crate::to_vec(obj)?;
   31|    318|        self.put(
   32|    318|            code,
   33|    318|            &Block {
   34|    318|                codec: DAG_CBOR,
   35|    318|                data: &bytes,
   36|    318|            },
   37|    318|        )
   38|    318|    }

_RINvCsgVlqBW3KcNx_17fvm_ipld_encoding6to_vecINtNtCslH3pn9Bu6yX_13fvm_ipld_hamt4node4NodeNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtBL_14hash_algorithm6Sha256EECsboUdcTbF1FS_15direct_syscalls:
   33|    318|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, Error>
   34|    318|where
   35|    318|    T: ser::Serialize + ?Sized,
   36|    318|{
   37|    318|    serde_ipld_dagcbor::to_vec(value).map_err(Into::into)
   38|    318|}
_RINvCsgVlqBW3KcNx_17fvm_ipld_encoding10from_sliceINtNtCslH3pn9Bu6yX_13fvm_ipld_hamt4node4NodeNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtBQ_14hash_algorithm6Sha256EECsboUdcTbF1FS_15direct_syscalls:
   50|    318|pub fn from_slice<'a, T>(slice: &'a [u8]) -> Result<T, Error>
   51|    318|where
   52|    318|    T: de::Deserialize<'a>,
   53|    318|{
   54|    318|    serde_ipld_dagcbor::from_slice(slice).map_err(Into::into)
   55|    318|}
_RINvCsgVlqBW3KcNx_17fvm_ipld_encoding10from_sliceTmINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEECsboUdcTbF1FS_15direct_syscalls:
   50|    318|pub fn from_slice<'a, T>(slice: &'a [u8]) -> Result<T, Error>
   51|    318|where
   52|    318|    T: de::Deserialize<'a>,
   53|    318|{
   54|    318|    serde_ipld_dagcbor::from_slice(slice).map_err(Into::into)
   55|    318|}
_RINvCsgVlqBW3KcNx_17fvm_ipld_encoding10from_sliceINtNtCs9pDt8l5wGDA_5alloc3vec3VecTNtNtBQ_6string6StringINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEEECsboUdcTbF1FS_15direct_syscalls:
   50|    318|pub fn from_slice<'a, T>(slice: &'a [u8]) -> Result<T, Error>
   51|    318|where
   52|    318|    T: de::Deserialize<'a>,
   53|    318|{
   54|    318|    serde_ipld_dagcbor::from_slice(slice).map_err(Into::into)
   55|    318|}
_RINvCsgVlqBW3KcNx_17fvm_ipld_encoding10from_sliceNtNtCs83Z8YCK0meJ_10fvm_shared5state9StateRootECsboUdcTbF1FS_15direct_syscalls:
   50|    318|pub fn from_slice<'a, T>(slice: &'a [u8]) -> Result<T, Error>
   51|    318|where
   52|    318|    T: de::Deserialize<'a>,
   53|    318|{
   54|    318|    serde_ipld_dagcbor::from_slice(slice).map_err(Into::into)
   55|    318|}
_RINvCsgVlqBW3KcNx_17fvm_ipld_encoding6to_vecNtNtCs83Z8YCK0meJ_10fvm_shared5state9StateRootECsboUdcTbF1FS_15direct_syscalls:
   33|    318|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, Error>
   34|    318|where
   35|    318|    T: ser::Serialize + ?Sized,
   36|    318|{
   37|    318|    serde_ipld_dagcbor::to_vec(value).map_err(Into::into)
   38|    318|}
_RINvCsgVlqBW3KcNx_17fvm_ipld_encoding6to_vecNtNtCskJihg1y13m7_3fvm12system_actor5StateECs7AwuCMXPzRZ_8fvm_fuzz:
   33|    318|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, Error>
   34|    318|where
   35|    318|    T: ser::Serialize + ?Sized,
   36|    318|{
   37|    318|    serde_ipld_dagcbor::to_vec(value).map_err(Into::into)
   38|    318|}
_RINvCsgVlqBW3KcNx_17fvm_ipld_encoding10from_sliceTmINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEECs7AwuCMXPzRZ_8fvm_fuzz:
   50|    318|pub fn from_slice<'a, T>(slice: &'a [u8]) -> Result<T, Error>
   51|    318|where
   52|    318|    T: de::Deserialize<'a>,
   53|    318|{
   54|    318|    serde_ipld_dagcbor::from_slice(slice).map_err(Into::into)
   55|    318|}
_RINvCsgVlqBW3KcNx_17fvm_ipld_encoding6to_vecAuj0_ECs7AwuCMXPzRZ_8fvm_fuzz:
   33|    318|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, Error>
   34|    318|where
   35|    318|    T: ser::Serialize + ?Sized,
   36|    318|{
   37|    318|    serde_ipld_dagcbor::to_vec(value).map_err(Into::into)
   38|    318|}
_RINvCsgVlqBW3KcNx_17fvm_ipld_encoding6to_vecINtNtCslH3pn9Bu6yX_13fvm_ipld_hamt4node4NodeNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCs9pDt8l5wGDA_5alloc6string6StringNtNtBL_14hash_algorithm6Sha256EECs7AwuCMXPzRZ_8fvm_fuzz:
   33|    318|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, Error>
   34|    318|where
   35|    318|    T: ser::Serialize + ?Sized,
   36|    318|{
   37|    318|    serde_ipld_dagcbor::to_vec(value).map_err(Into::into)
   38|    318|}
_RINvCsgVlqBW3KcNx_17fvm_ipld_encoding10from_sliceNtCs7wiLZqa2F25_12fvm_ipld_car9CarHeaderECs7AwuCMXPzRZ_8fvm_fuzz:
   50|    318|pub fn from_slice<'a, T>(slice: &'a [u8]) -> Result<T, Error>
   51|    318|where
   52|    318|    T: de::Deserialize<'a>,
   53|    318|{
   54|    318|    serde_ipld_dagcbor::from_slice(slice).map_err(Into::into)
   55|    318|}
_RINvCsgVlqBW3KcNx_17fvm_ipld_encoding6to_vecNtNtCskJihg1y13m7_3fvm10init_actor5StateECs7AwuCMXPzRZ_8fvm_fuzz:
   33|    318|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, Error>
   34|    318|where
   35|    318|    T: ser::Serialize + ?Sized,
   36|    318|{
   37|    318|    serde_ipld_dagcbor::to_vec(value).map_err(Into::into)
   38|    318|}
_RINvCsgVlqBW3KcNx_17fvm_ipld_encoding6to_vecNtNtCs83Z8YCK0meJ_10fvm_shared5state10StateInfo0ECs7AwuCMXPzRZ_8fvm_fuzz:
   33|    318|pub fn to_vec<T>(value: &T) -> Result<Vec<u8>, Error>
   34|    318|where
   35|    318|    T: ser::Serialize + ?Sized,
   36|    318|{
   37|    318|    serde_ipld_dagcbor::to_vec(value).map_err(Into::into)
   38|    318|}
_RINvCsgVlqBW3KcNx_17fvm_ipld_encoding10from_sliceINtNtCs9pDt8l5wGDA_5alloc3vec3VecTNtNtBQ_6string6StringINtNtCsl4cFeht4Yol_3cid3cid3CidKj40_EEEECs7AwuCMXPzRZ_8fvm_fuzz:
   50|    318|pub fn from_slice<'a, T>(slice: &'a [u8]) -> Result<T, Error>
   51|    318|where
   52|    318|    T: de::Deserialize<'a>,
   53|    318|{
   54|    318|    serde_ipld_dagcbor::from_slice(slice).map_err(Into::into)
   55|    318|}

_RINvXs_NtCslH3pn9Bu6yX_13fvm_ipld_hamt8bitfieldNtB5_8BitfieldNtNtCssVaLrL3Upj_5serde2de11Deserialize11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECsboUdcTbF1FS_15direct_syscalls:
   38|    318|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
   39|    318|    where
   40|    318|        D: Deserializer<'de>,
   41|    318|    {
   42|    318|        let mut res = Bitfield::zero();
   43|    318|        let bytes = strict_bytes::ByteBuf::deserialize(deserializer)?.into_vec();
   44|    318|
   45|    318|        let mut arr = [0u8; 4 * 8];
   46|    318|        let len = bytes.len();
   47|    954|        for (old, new) in bytes.iter().zip(arr[(32 - len)..].iter_mut()) {
   48|    954|            *new = *old;
   49|    954|        }
   50|    318|        res.0[3] = BigEndian::read_u64(&arr[..8]);
   51|    318|        res.0[2] = BigEndian::read_u64(&arr[8..16]);
   52|    318|        res.0[1] = BigEndian::read_u64(&arr[16..24]);
   53|    318|        res.0[0] = BigEndian::read_u64(&arr[24..]);
   54|    318|
   55|    318|        Ok(res)
   56|    318|    }
_RINvXNtCslH3pn9Bu6yX_13fvm_ipld_hamt8bitfieldNtB3_8BitfieldNtNtCssVaLrL3Upj_5serde3ser9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECsboUdcTbF1FS_15direct_syscalls:
   16|    318|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   17|    318|    where
   18|    318|        S: Serializer,
   19|    318|    {
   20|    318|        let mut v = [0u8; 4 * 8];
   21|    318|        // Big endian ordering, to match go
   22|    318|        BigEndian::write_u64(&mut v[..8], self.0[3]);
   23|    318|        BigEndian::write_u64(&mut v[8..16], self.0[2]);
   24|    318|        BigEndian::write_u64(&mut v[16..24], self.0[1]);
   25|    318|        BigEndian::write_u64(&mut v[24..], self.0[0]);
   26|       |
   27|  9.54k|        for i in 0..v.len() {
   28|  9.54k|            if v[i] != 0 {
   29|    318|                return strict_bytes::Serialize::serialize(&v[i..], serializer);
   30|  9.22k|            }
   31|       |        }
   32|       |
   33|      0|        <[u8] as strict_bytes::Serialize>::serialize(&[], serializer)
   34|    318|    }
_RINvXNtCslH3pn9Bu6yX_13fvm_ipld_hamt8bitfieldNtB3_8BitfieldNtNtCssVaLrL3Upj_5serde3ser9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECs7AwuCMXPzRZ_8fvm_fuzz:
   16|    318|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   17|    318|    where
   18|    318|        S: Serializer,
   19|    318|    {
   20|    318|        let mut v = [0u8; 4 * 8];
   21|    318|        // Big endian ordering, to match go
   22|    318|        BigEndian::write_u64(&mut v[..8], self.0[3]);
   23|    318|        BigEndian::write_u64(&mut v[8..16], self.0[2]);
   24|    318|        BigEndian::write_u64(&mut v[16..24], self.0[1]);
   25|    318|        BigEndian::write_u64(&mut v[24..], self.0[0]);
   26|       |
   27|  10.1k|        for i in 0..v.len() {
   28|  10.1k|            if v[i] != 0 {
   29|      0|                return strict_bytes::Serialize::serialize(&v[i..], serializer);
   30|  10.1k|            }
   31|       |        }
   32|       |
   33|    318|        <[u8] as strict_bytes::Serialize>::serialize(&[], serializer)
   34|    318|    }
_RNvMs1_NtCslH3pn9Bu6yX_13fvm_ipld_hamt8bitfieldNtB5_8Bitfield10count_ones:
   86|  1.90k|    pub fn count_ones(&self) -> usize {
   87|  1.90k|        self.0.iter().map(|a| a.count_ones() as usize).sum()
   88|  1.90k|    }
_RNvMs1_NtCslH3pn9Bu6yX_13fvm_ipld_hamt8bitfieldNtB5_8Bitfield11set_bits_le:
  103|    954|    pub fn set_bits_le(self, bit: u32) -> Self {
  104|    954|        if bit == 0 {
  105|      0|            return self;
  106|    954|        }
  107|    954|        self.set_bits_leq(bit - 1)
  108|    954|    }
_RNvMs1_NtCslH3pn9Bu6yX_13fvm_ipld_hamt8bitfieldNtB5_8Bitfield4zero:
   99|  1.90k|    pub fn zero() -> Self {
  100|  1.90k|        Bitfield([0, 0, 0, 0])
  101|  1.90k|    }
_RNCNvMs1_NtCslH3pn9Bu6yX_13fvm_ipld_hamt8bitfieldNtB7_8Bitfield10count_ones0B9_:
   87|  7.63k|        self.0.iter().map(|a| a.count_ones() as usize).sum()
_RNvMs1_NtCslH3pn9Bu6yX_13fvm_ipld_hamt8bitfieldNtB5_8Bitfield8test_bit:
   72|    954|    pub fn test_bit(&self, idx: u32) -> bool {
   73|    954|        let ai = idx / 64;
   74|    954|        let bi = idx % 64;
   75|    954|
   76|    954|        self.0[ai as usize] & (1 << bi as u32) != 0
   77|    954|    }
_RNvMs1_NtCslH3pn9Bu6yX_13fvm_ipld_hamt8bitfieldNtB5_8Bitfield3and:
   90|    954|    pub fn and(self, other: &Self) -> Self {
   91|    954|        Bitfield([
   92|    954|            self.0[0] & other.0[0],
   93|    954|            self.0[1] & other.0[1],
   94|    954|            self.0[2] & other.0[2],
   95|    954|            self.0[3] & other.0[3],
   96|    954|        ])
   97|    954|    }
_RNvNtCslH3pn9Bu6yX_13fvm_ipld_hamt8bitfield12set_bits_leq:
  132|    954|fn set_bits_leq(v: u64, bit: u32) -> u64 {
  133|    954|    (v as u128 | ((1u128 << (1 + bit)) - 1)) as u64
  134|    954|}
_RNvMs1_NtCslH3pn9Bu6yX_13fvm_ipld_hamt8bitfieldNtB5_8Bitfield12set_bits_leq:
  110|    954|    pub fn set_bits_leq(mut self, bit: u32) -> Self {
  111|    954|        if bit < 64 {
  112|    954|            self.0[0] = set_bits_leq(self.0[0], bit);
  113|    954|        } else if bit < 128 {
  114|      0|            self.0[0] = std::u64::MAX;
  115|      0|            self.0[1] = set_bits_leq(self.0[1], bit - 64);
  116|      0|        } else if bit < 192 {
  117|      0|            self.0[0] = std::u64::MAX;
  118|      0|            self.0[1] = std::u64::MAX;
  119|      0|            self.0[2] = set_bits_leq(self.0[2], bit - 128);
  120|      0|        } else {
  121|      0|            self.0[0] = std::u64::MAX;
  122|      0|            self.0[1] = std::u64::MAX;
  123|      0|            self.0[2] = std::u64::MAX;
  124|      0|            self.0[3] = set_bits_leq(self.0[3], bit - 192);
  125|      0|        }
  126|       |
  127|    954|        self
  128|    954|    }
_RNvMs1_NtCslH3pn9Bu6yX_13fvm_ipld_hamt8bitfieldNtB5_8Bitfield7set_bit:
   79|    954|    pub fn set_bit(&mut self, idx: u32) {
   80|    954|        let ai = idx / 64;
   81|    954|        let bi = idx % 64;
   82|    954|
   83|    954|        self.0[ai as usize] |= 1 << bi as u32;
   84|    954|    }

_RNvMs0_NtCslH3pn9Bu6yX_13fvm_ipld_hamt4hamtINtB5_4HamtNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateE5storeCsboUdcTbF1FS_15direct_syscalls:
  141|    318|    pub fn store(&self) -> &BS {
  142|    318|        &self.store
  143|    318|    }
_RNvMs0_NtCslH3pn9Bu6yX_13fvm_ipld_hamt4hamtINtB5_4HamtNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateE10into_storeCsboUdcTbF1FS_15direct_syscalls:
  366|    318|    pub fn into_store(self) -> BS {
  367|    318|        self.store
  368|    318|    }
_RNvMs0_NtCslH3pn9Bu6yX_13fvm_ipld_hamt4hamtINtB5_4HamtINtNtNtCskJihg1y13m7_3fvm10blockstore8buffered18BufferedBlockstoreNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreENtNtBX_10state_tree10ActorStateE16load_with_configCsboUdcTbF1FS_15direct_syscalls:
  104|    318|        match store.get_cbor(cid)? {
  105|    318|            Some(root) => Ok(Self {
  106|    318|                root,
  107|    318|                store,
  108|    318|                conf,
  109|    318|                hash: Default::default(),
  110|    318|                flushed_cid: Some(*cid),
  111|    318|            }),
  112|      0|            None => Err(Error::CidNotFound(cid.to_string())),
  113|       |        }
  114|    318|    }
_RNvMs0_NtCslH3pn9Bu6yX_13fvm_ipld_hamt4hamtINtB5_4HamtNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateE3setCsboUdcTbF1FS_15direct_syscalls:
  167|    954|    pub fn set(&mut self, key: K, value: V) -> Result<Option<V>, Error>
  168|    954|    where
  169|    954|        V: PartialEq,
  170|    954|    {
  171|    954|        let (old, modified) = self
  172|    954|            .root
  173|    954|            .set(key, value, self.store.borrow(), &self.conf, true)?;
  174|       |
  175|    954|        if modified {
  176|    954|            self.flushed_cid = None;
  177|    954|        }
  178|       |
  179|    954|        Ok(old)
  180|    954|    }
_RNvMs0_NtCslH3pn9Bu6yX_13fvm_ipld_hamt4hamtINtB5_4HamtINtNtNtCskJihg1y13m7_3fvm10blockstore8buffered18BufferedBlockstoreNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreENtNtBX_10state_tree10ActorStateE19load_with_bit_widthCsboUdcTbF1FS_15direct_syscalls:
  116|    318|    pub fn load_with_bit_width(cid: &Cid, store: BS, bit_width: u32) -> Result<Self, Error> {
  117|    318|        Self::load_with_config(
  118|    318|            cid,
  119|    318|            store,
  120|    318|            Config {
  121|    318|                bit_width,
  122|    318|                ..Default::default()
  123|    318|            },
  124|    318|        )
  125|    318|    }
_RNvMs0_NtCslH3pn9Bu6yX_13fvm_ipld_hamt4hamtINtB5_4HamtNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateE5flushCsboUdcTbF1FS_15direct_syscalls:
  320|    318|        if let Some(cid) = self.flushed_cid {
  321|      0|            return Ok(cid);
  322|    318|        }
  323|    318|        self.root.flush(self.store.borrow())?;
  324|    318|        let cid = self.store.put_cbor(&self.root, Code::Blake2b256)?;
  325|    318|        self.flushed_cid = Some(cid);
  326|    318|        Ok(cid)
  327|    318|    }
_RNvMs0_NtCslH3pn9Bu6yX_13fvm_ipld_hamt4hamtINtB5_4HamtINtNtNtCskJihg1y13m7_3fvm10blockstore8buffered18BufferedBlockstoreNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreENtNtBX_10state_tree10ActorStateE5storeCsboUdcTbF1FS_15direct_syscalls:
  141|    636|    pub fn store(&self) -> &BS {
  142|    636|        &self.store
  143|    636|    }
_RNvMs0_NtCslH3pn9Bu6yX_13fvm_ipld_hamt4hamtINtB5_4HamtRRNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs9pDt8l5wGDA_5alloc6string6StringE15new_with_configCs7AwuCMXPzRZ_8fvm_fuzz:
   76|    318|    pub fn new_with_config(store: BS, conf: Config) -> Self {
   77|    318|        Self {
   78|    318|            root: Node::default(),
   79|    318|            store,
   80|    318|            conf,
   81|    318|            hash: Default::default(),
   82|    318|            flushed_cid: None,
   83|    318|        }
   84|    318|    }
_RNvMs0_NtCslH3pn9Bu6yX_13fvm_ipld_hamt4hamtINtB5_4HamtNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateE18new_with_bit_widthCs7AwuCMXPzRZ_8fvm_fuzz:
   87|    318|    pub fn new_with_bit_width(store: BS, bit_width: u32) -> Self {
   88|    318|        Self::new_with_config(
   89|    318|            store,
   90|    318|            Config {
   91|    318|                bit_width,
   92|    318|                ..Default::default()
   93|    318|            },
   94|    318|        )
   95|    318|    }
_RNvMs0_NtCslH3pn9Bu6yX_13fvm_ipld_hamt4hamtINtB5_4HamtRRNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs9pDt8l5wGDA_5alloc6string6StringE18new_with_bit_widthCs7AwuCMXPzRZ_8fvm_fuzz:
   87|    318|    pub fn new_with_bit_width(store: BS, bit_width: u32) -> Self {
   88|    318|        Self::new_with_config(
   89|    318|            store,
   90|    318|            Config {
   91|    318|                bit_width,
   92|    318|                ..Default::default()
   93|    318|            },
   94|    318|        )
   95|    318|    }
_RNvMs0_NtCslH3pn9Bu6yX_13fvm_ipld_hamt4hamtINtB5_4HamtRRNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCs9pDt8l5wGDA_5alloc6string6StringE5flushCs7AwuCMXPzRZ_8fvm_fuzz:
  320|    318|        if let Some(cid) = self.flushed_cid {
  321|      0|            return Ok(cid);
  322|    318|        }
  323|    318|        self.root.flush(self.store.borrow())?;
  324|    318|        let cid = self.store.put_cbor(&self.root, Code::Blake2b256)?;
  325|    318|        self.flushed_cid = Some(cid);
  326|    318|        Ok(cid)
  327|    318|    }
_RNvMs0_NtCslH3pn9Bu6yX_13fvm_ipld_hamt4hamtINtB5_4HamtNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateE15new_with_configCs7AwuCMXPzRZ_8fvm_fuzz:
   76|    318|    pub fn new_with_config(store: BS, conf: Config) -> Self {
   77|    318|        Self {
   78|    318|            root: Node::default(),
   79|    318|            store,
   80|    318|            conf,
   81|    318|            hash: Default::default(),
   82|    318|            flushed_cid: None,
   83|    318|        }
   84|    318|    }
_RNvMs0_NtCslH3pn9Bu6yX_13fvm_ipld_hamt4hamtINtB5_4HamtNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateE5storeCs7AwuCMXPzRZ_8fvm_fuzz:
  141|    954|    pub fn store(&self) -> &BS {
  142|    954|        &self.store
  143|    954|    }

_RINvXs_NtCslH3pn9Bu6yX_13fvm_ipld_hamt14hash_algorithmNtB5_6Sha256NtB5_13HashAlgorithm4hashNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyECsboUdcTbF1FS_15direct_syscalls:
   38|    954|    fn hash<X: ?Sized>(key: &X) -> HashedKey
   39|    954|    where
   40|    954|        X: Hash,
   41|    954|    {
   42|    954|        let mut hasher = Sha2HasherWrapper::default();
   43|    954|        key.hash(&mut hasher);
   44|    954|        hasher.0.finalize().into()
   45|    954|    }
_RNvXs0_NtCslH3pn9Bu6yX_13fvm_ipld_hamt14hash_algorithmNtB5_17Sha2HasherWrapperNtNtCsiloedr2K6v7_4core7default7Default7default:
   19|    954|#[derive(Default)]
_RNvXNtCslH3pn9Bu6yX_13fvm_ipld_hamt14hash_algorithmNtB2_17Sha2HasherWrapperNtNtCsiloedr2K6v7_4core4hash6Hasher5write:
   28|    954|    fn write(&mut self, bytes: &[u8]) {
   29|    954|        self.0.update(bytes);
   30|    954|    }

_RNvNtCslH3pn9Bu6yX_13fvm_ipld_hamt9hash_bits6mkmask:
   20|  1.90k|pub(crate) fn mkmask(n: u32) -> u32 {
   21|  1.90k|    ((1u64 << n) - 1) as u32
   22|  1.90k|}
_RNvMNtCslH3pn9Bu6yX_13fvm_ipld_hamt9hash_bitsNtB2_8HashBits3new:
   25|    954|    pub fn new(hash_buffer: &'a HashedKey) -> HashBits<'a> {
   26|    954|        Self::new_at_index(hash_buffer, 0)
   27|    954|    }
_RNvMNtCslH3pn9Bu6yX_13fvm_ipld_hamt9hash_bitsNtB2_8HashBits9next_bits:
   52|    954|    fn next_bits(&mut self, i: u32) -> u32 {
   53|    954|        let curbi = self.consumed / 8;
   54|    954|        let leftb = 8 - (self.consumed % 8);
   55|    954|
   56|    954|        let curb = self.b[curbi as usize] as u32;
   57|    954|        match i.cmp(&leftb) {
   58|       |            Ordering::Equal => {
   59|       |                // bits to consume is equal to the bits remaining in the currently indexed byte
   60|      0|                let out = mkmask(i) & curb;
   61|      0|                self.consumed += i;
   62|      0|                out
   63|       |            }
   64|       |            Ordering::Less => {
   65|       |                // Consuming less than the remaining bits in the current byte
   66|    954|                let a = curb & mkmask(leftb);
   67|    954|                let b = a & !mkmask(leftb - i);
   68|    954|                let c = b >> (leftb - i);
   69|    954|                self.consumed += i;
   70|    954|                c
   71|       |            }
   72|       |            Ordering::Greater => {
   73|       |                // Consumes remaining bits and remaining bits from a recursive call
   74|      0|                let mut out = (mkmask(leftb) & curb) as u64;
   75|      0|                out <<= i - leftb;
   76|      0|                self.consumed += leftb;
   77|      0|                out += self.next_bits(i - leftb) as u64;
   78|      0|                out as u32
   79|       |            }
   80|       |        }
   81|    954|    }
_RNvMNtCslH3pn9Bu6yX_13fvm_ipld_hamt9hash_bitsNtB2_8HashBits4next:
   39|    954|    pub fn next(&mut self, i: u32) -> Result<u32, Error> {
   40|    954|        if i > 8 || i == 0 {
   41|      0|            return Err(Error::InvalidHashBitLen);
   42|    954|        }
   43|    954|        let maxi = (self.b.len() as u32) * 8 - self.consumed;
   44|    954|        if maxi == 0 {
   45|      0|            return Err(Error::MaxDepth);
   46|    954|        }
   47|    954|        // Only take what's left. If we consume 5 bits at a time from a 256 bit key,
   48|    954|        // there will be 1 bit left at the bottom.
   49|    954|        Ok(self.next_bits(std::cmp::min(i, maxi)))
   50|    954|    }
_RNvMNtCslH3pn9Bu6yX_13fvm_ipld_hamt9hash_bitsNtB2_8HashBits12new_at_index:
   30|    954|    pub fn new_at_index(hash_buffer: &'a HashedKey, consumed: u32) -> HashBits<'a> {
   31|    954|        Self {
   32|    954|            b: hash_buffer,
   33|    954|            consumed,
   34|    954|        }
   35|    954|    }

_RINvXNvCslH3pn9Bu6yX_13fvm_ipld_hamts_1__INtB5_12KeyValuePairNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateENtNtCssVaLrL3Upj_5serde2de11Deserialize11deserializeNtNtCs3TS9n28v4Rl_12libipld_core4ipld4IpldECsboUdcTbF1FS_15direct_syscalls:
   75|    954|#[derive(Debug, Serialize, Deserialize, PartialEq)]
_RNvMs0_CslH3pn9Bu6yX_13fvm_ipld_hamtINtB5_12KeyValuePairNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateE3newCsboUdcTbF1FS_15direct_syscalls:
   88|    954|    pub fn new(key: K, value: V) -> Self {
   89|    954|        KeyValuePair(key, value)
   90|    954|    }
_RINvXNvCslH3pn9Bu6yX_13fvm_ipld_hamt1__INtB5_12KeyValuePairNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateENtNtCssVaLrL3Upj_5serde3ser9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECsboUdcTbF1FS_15direct_syscalls:
   75|    954|#[derive(Debug, Serialize, Deserialize, PartialEq)]
_RINvXNvXNvCslH3pn9Bu6yX_13fvm_ipld_hamts_1__INtB8_12KeyValuePairppENtNtCssVaLrL3Upj_5serde2de11Deserialize11deserializeINtB3_9___VisitorNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateENtB15_7Visitor9visit_seqQNtNtNtCs3TS9n28v4Rl_12libipld_core5serde2de15SeqDeserializerECsboUdcTbF1FS_15direct_syscalls:
   75|    954|#[derive(Debug, Serialize, Deserialize, PartialEq)]
_RNvXCslH3pn9Bu6yX_13fvm_ipld_hamtNtB2_6ConfigNtNtCsiloedr2K6v7_4core7default7Default7default:
   64|    954|    fn default() -> Self {
   65|    954|        Self {
   66|    954|            bit_width: DEFAULT_BIT_WIDTH,
   67|    954|            min_data_depth: 0,
   68|    954|            max_array_width: 3,
   69|    954|        }
   70|    954|    }

_RINvMs2_NtCslH3pn9Bu6yX_13fvm_ipld_hamt4nodeINtB6_4NodeNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtB8_14hash_algorithm6Sha256E12modify_valueNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreECsboUdcTbF1FS_15direct_syscalls:
  246|    954|    fn modify_value<S: Blockstore>(
  247|    954|        &mut self,
  248|    954|        hashed_key: &mut HashBits,
  249|    954|        conf: &Config,
  250|    954|        depth: u32,
  251|    954|        key: K,
  252|    954|        value: V,
  253|    954|        store: &S,
  254|    954|        overwrite: bool,
  255|    954|    ) -> Result<(Option<V>, bool), Error>
  256|    954|    where
  257|    954|        V: PartialEq,
  258|    954|    {
  259|    954|        let idx = hashed_key.next(conf.bit_width)?;
  260|       |
  261|       |        // No existing values at this point.
  262|    954|        if !self.bitfield.test_bit(idx) {
  263|    954|            if depth >= conf.min_data_depth {
  264|    954|                self.insert_child(idx, key, value);
  265|    954|            } else {
  266|       |                // Need to insert some empty nodes reserved for links.
  267|      0|                let mut sub = Node::<K, V, H>::default();
  268|      0|                sub.modify_value(hashed_key, conf, depth + 1, key, value, store, overwrite)?;
  269|      0|                self.insert_child_dirty(idx, Box::new(sub));
  270|       |            }
  271|    954|            return Ok((None, true));
  272|      0|        }
  273|      0|
  274|      0|        let cindex = self.index_for_bit_pos(idx);
  275|      0|        let child = self.get_child_mut(cindex);
  276|      0|
  277|      0|        match child {
  278|      0|            Pointer::Link { cid, cache } => {
  279|      0|                cache.get_or_try_init(|| {
  280|       |                    store
  281|       |                        .get_cbor(cid)?
  282|       |                        .ok_or_else(|| Error::CidNotFound(cid.to_string()))
  283|      0|                })?;
  284|      0|                let child_node = cache.get_mut().expect("filled line above");
  285|       |
  286|      0|                let (old, modified) = child_node.modify_value(
  287|      0|                    hashed_key,
  288|      0|                    conf,
  289|      0|                    depth + 1,
  290|      0|                    key,
  291|      0|                    value,
  292|      0|                    store,
  293|      0|                    overwrite,
  294|      0|                )?;
  295|      0|                if modified {
  296|      0|                    *child = Pointer::Dirty(std::mem::take(child_node));
  297|      0|                }
  298|      0|                Ok((old, modified))
  299|       |            }
  300|      0|            Pointer::Dirty(node) => {
  301|      0|                node.modify_value(hashed_key, conf, depth + 1, key, value, store, overwrite)
  302|       |            }
  303|      0|            Pointer::Values(vals) => {
  304|       |                // Update, if the key already exists.
  305|      0|                if let Some(i) = vals.iter().position(|p| p.key() == &key) {
  306|      0|                    if overwrite {
  307|       |                        // If value changed, the parent nodes need to be marked as dirty.
  308|       |                        // ! The assumption here is that `PartialEq` is implemented correctly,
  309|       |                        // ! and that if that is true, the serialized bytes are equal.
  310|       |                        // ! To be absolutely sure, can serialize each value and compare or
  311|       |                        // ! refactor the Hamt to not be type safe and serialize on entry and
  312|       |                        // ! exit. These both come at costs, and this isn't a concern.
  313|      0|                        let value_changed = vals[i].value() != &value;
  314|      0|                        return Ok((
  315|      0|                            Some(std::mem::replace(&mut vals[i].1, value)),
  316|      0|                            value_changed,
  317|      0|                        ));
  318|       |                    } else {
  319|       |                        // Can't overwrite, return None and false that the Node was not modified.
  320|      0|                        return Ok((None, false));
  321|       |                    }
  322|      0|                }
  323|      0|
  324|      0|                // If the array is full, create a subshard and insert everything
  325|      0|                if vals.len() >= conf.max_array_width {
  326|      0|                    let kvs = std::mem::take(vals);
  327|      0|                    let hashed_kvs = kvs.into_iter().map(|KeyValuePair(k, v)| {
  328|       |                        let hash = H::hash(&k);
  329|       |                        (k, v, hash)
  330|      0|                    });
  331|      0|
  332|      0|                    let consumed = hashed_key.consumed;
  333|      0|                    let mut sub = Node::<K, V, H>::default();
  334|      0|                    let modified = sub.modify_value(
  335|      0|                        hashed_key,
  336|      0|                        conf,
  337|      0|                        depth + 1,
  338|      0|                        key,
  339|      0|                        value,
  340|      0|                        store,
  341|      0|                        overwrite,
  342|      0|                    )?;
  343|       |
  344|      0|                    for (k, v, hash) in hashed_kvs {
  345|      0|                        sub.modify_value(
  346|      0|                            &mut HashBits::new_at_index(&hash, consumed),
  347|      0|                            conf,
  348|      0|                            depth + 1,
  349|      0|                            k,
  350|      0|                            v,
  351|      0|                            store,
  352|      0|                            overwrite,
  353|      0|                        )?;
  354|       |                    }
  355|       |
  356|      0|                    *child = Pointer::Dirty(Box::new(sub));
  357|      0|
  358|      0|                    return Ok(modified);
  359|      0|                }
  360|      0|
  361|      0|                // Otherwise insert the element into the array in order.
  362|      0|                let max = vals.len();
  363|      0|                let idx = vals.iter().position(|c| c.key() > &key).unwrap_or(max);
  364|      0|
  365|      0|                let np = KeyValuePair::new(key, value);
  366|      0|                vals.insert(idx, np);
  367|      0|
  368|      0|                Ok((None, true))
  369|       |            }
  370|       |        }
  371|    954|    }
_RINvXs_NtCslH3pn9Bu6yX_13fvm_ipld_hamt4nodeINtB5_4NodeNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtB7_14hash_algorithm6Sha256ENtNtCssVaLrL3Upj_5serde3ser9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECsboUdcTbF1FS_15direct_syscalls:
   41|    318|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   42|    318|    where
   43|    318|        S: Serializer,
   44|    318|    {
   45|    318|        (&self.bitfield, &self.pointers).serialize(serializer)
   46|    318|    }
_RINvXs0_NtCslH3pn9Bu6yX_13fvm_ipld_hamt4nodeINtB6_4NodeNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtB8_14hash_algorithm6Sha256ENtNtCssVaLrL3Upj_5serde2de11Deserialize11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECsboUdcTbF1FS_15direct_syscalls:
   54|    318|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
   55|    318|    where
   56|    318|        D: Deserializer<'de>,
   57|    318|    {
   58|    318|        let (bitfield, pointers) = Deserialize::deserialize(deserializer)?;
   59|    318|        Ok(Node {
   60|    318|            bitfield,
   61|    318|            pointers,
   62|    318|            hash: Default::default(),
   63|    318|        })
   64|    318|    }
_RINvMs2_NtCslH3pn9Bu6yX_13fvm_ipld_hamt4nodeINtB6_4NodeNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtB8_14hash_algorithm6Sha256E5flushNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreECsboUdcTbF1FS_15direct_syscalls:
  448|    318|    pub fn flush<S: Blockstore>(&mut self, store: &S) -> Result<(), Error> {
  449|  1.27k|        for pointer in &mut self.pointers {
  450|    954|            if let Pointer::Dirty(node) = pointer {
  451|       |                // Flush cached sub node to clear it's cache
  452|      0|                node.flush(store)?;
  453|       |
  454|       |                // Put node in blockstore and retrieve Cid
  455|      0|                let cid = store.put_cbor(node, Code::Blake2b256)?;
  456|       |
  457|       |                // Can keep the flushed node in link cache
  458|      0|                let cache = OnceCell::from(std::mem::take(node));
  459|      0|
  460|      0|                // Replace cached node with Cid link
  461|      0|                *pointer = Pointer::Link { cid, cache };
  462|    954|            }
  463|       |        }
  464|       |
  465|    318|        Ok(())
  466|    318|    }
_RNvMs2_NtCslH3pn9Bu6yX_13fvm_ipld_hamt4nodeINtB5_4NodeNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtB7_14hash_algorithm6Sha256E12insert_childCsboUdcTbF1FS_15direct_syscalls:
  473|    954|    fn insert_child(&mut self, idx: u32, key: K, value: V) {
  474|    954|        let i = self.index_for_bit_pos(idx);
  475|    954|        self.bitfield.set_bit(idx);
  476|    954|        self.pointers.insert(i, Pointer::from_key_value(key, value))
  477|    954|    }
_RNvMs2_NtCslH3pn9Bu6yX_13fvm_ipld_hamt4nodeINtB5_4NodeNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtB7_14hash_algorithm6Sha256E17index_for_bit_posCsboUdcTbF1FS_15direct_syscalls:
  485|    954|    fn index_for_bit_pos(&self, bp: u32) -> usize {
  486|    954|        let mask = Bitfield::zero().set_bits_le(bp);
  487|    954|        assert_eq!(mask.count_ones(), bp as usize);
  488|    954|        mask.and(&self.bitfield).count_ones()
  489|    954|    }
_RINvMs2_NtCslH3pn9Bu6yX_13fvm_ipld_hamt4nodeINtB6_4NodeNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtB8_14hash_algorithm6Sha256E3setNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreECsboUdcTbF1FS_15direct_syscalls:
   83|    954|    pub fn set<S: Blockstore>(
   84|    954|        &mut self,
   85|    954|        key: K,
   86|    954|        value: V,
   87|    954|        store: &S,
   88|    954|        conf: &Config,
   89|    954|        overwrite: bool,
   90|    954|    ) -> Result<(Option<V>, bool), Error>
   91|    954|    where
   92|    954|        V: PartialEq,
   93|    954|    {
   94|    954|        let hash = H::hash(&key);
   95|    954|        self.modify_value(
   96|    954|            &mut HashBits::new(&hash),
   97|    954|            conf,
   98|    954|            0,
   99|    954|            key,
  100|    954|            value,
  101|    954|            store,
  102|    954|            overwrite,
  103|    954|        )
  104|    954|    }
_RNvXs1_NtCslH3pn9Bu6yX_13fvm_ipld_hamt4nodeINtB5_4NodeNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCs9pDt8l5wGDA_5alloc6string6StringNtNtB7_14hash_algorithm6Sha256ENtNtCsiloedr2K6v7_4core7default7Default7defaultCs7AwuCMXPzRZ_8fvm_fuzz:
   68|    318|    fn default() -> Self {
   69|    318|        Node {
   70|    318|            bitfield: Bitfield::zero(),
   71|    318|            pointers: Vec::new(),
   72|    318|            hash: Default::default(),
   73|    318|        }
   74|    318|    }
_RINvXs_NtCslH3pn9Bu6yX_13fvm_ipld_hamt4nodeINtB5_4NodeNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCs9pDt8l5wGDA_5alloc6string6StringNtNtB7_14hash_algorithm6Sha256ENtNtCssVaLrL3Upj_5serde3ser9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECs7AwuCMXPzRZ_8fvm_fuzz:
   41|    318|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   42|    318|    where
   43|    318|        S: Serializer,
   44|    318|    {
   45|    318|        (&self.bitfield, &self.pointers).serialize(serializer)
   46|    318|    }
_RINvMs2_NtCslH3pn9Bu6yX_13fvm_ipld_hamt4nodeINtB6_4NodeNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCs9pDt8l5wGDA_5alloc6string6StringNtNtB8_14hash_algorithm6Sha256E5flushRRNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreECs7AwuCMXPzRZ_8fvm_fuzz:
  448|    318|    pub fn flush<S: Blockstore>(&mut self, store: &S) -> Result<(), Error> {
  449|    318|        for pointer in &mut self.pointers {
  450|      0|            if let Pointer::Dirty(node) = pointer {
  451|       |                // Flush cached sub node to clear it's cache
  452|      0|                node.flush(store)?;
  453|       |
  454|       |                // Put node in blockstore and retrieve Cid
  455|      0|                let cid = store.put_cbor(node, Code::Blake2b256)?;
  456|       |
  457|       |                // Can keep the flushed node in link cache
  458|      0|                let cache = OnceCell::from(std::mem::take(node));
  459|      0|
  460|      0|                // Replace cached node with Cid link
  461|      0|                *pointer = Pointer::Link { cid, cache };
  462|      0|            }
  463|       |        }
  464|       |
  465|    318|        Ok(())
  466|    318|    }
_RNvXs1_NtCslH3pn9Bu6yX_13fvm_ipld_hamt4nodeINtB5_4NodeNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtB7_14hash_algorithm6Sha256ENtNtCsiloedr2K6v7_4core7default7Default7defaultCs7AwuCMXPzRZ_8fvm_fuzz:
   68|    318|    fn default() -> Self {
   69|    318|        Node {
   70|    318|            bitfield: Bitfield::zero(),
   71|    318|            pointers: Vec::new(),
   72|    318|            hash: Default::default(),
   73|    318|        }
   74|    318|    }

_RINvXs1_NtCslH3pn9Bu6yX_13fvm_ipld_hamt7pointerINtB6_7PointerNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtB8_14hash_algorithm6Sha256ENtNtCssVaLrL3Upj_5serde2de11Deserialize11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECsboUdcTbF1FS_15direct_syscalls:
   89|    954|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
   90|    954|    where
   91|    954|        D: Deserializer<'de>,
   92|    954|    {
   93|    954|        Ipld::deserialize(deserializer).and_then(|ipld| ipld.try_into().map_err(de::Error::custom))
   94|    954|    }
_RINvXs_NtCslH3pn9Bu6yX_13fvm_ipld_hamt7pointerINtB5_7PointerNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtB7_14hash_algorithm6Sha256ENtNtCssVaLrL3Upj_5serde3ser9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECsboUdcTbF1FS_15direct_syscalls:
   46|    954|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
   47|    954|    where
   48|    954|        S: Serializer,
   49|    954|    {
   50|    954|        match self {
   51|    954|            Pointer::Values(vals) => vals.serialize(serializer),
   52|      0|            Pointer::Link { cid, .. } => cid.serialize(serializer),
   53|      0|            Pointer::Dirty(_) => Err(ser::Error::custom("Cannot serialize cached values")),
   54|       |        }
   55|    954|    }
_RNCINvXs1_NtCslH3pn9Bu6yX_13fvm_ipld_hamt7pointerINtB8_7PointerNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtBa_14hash_algorithm6Sha256ENtNtCssVaLrL3Upj_5serde2de11Deserialize11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEE0CsboUdcTbF1FS_15direct_syscalls:
   93|    954|        Ipld::deserialize(deserializer).and_then(|ipld| ipld.try_into().map_err(de::Error::custom))
_RINvNtCslH3pn9Bu6yX_13fvm_ipld_hamt7pointer9from_ipldINtNtCs9pDt8l5wGDA_5alloc3vec3VecINtB4_12KeyValuePairNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateEEECsboUdcTbF1FS_15direct_syscalls:
  181|    954|fn from_ipld<T: DeserializeOwned>(ipld: Ipld) -> Result<T, String> {
  182|    954|    Deserialize::deserialize(ipld).map_err(|error| error.to_string())
  183|    954|}
_RNvXs0_NtCslH3pn9Bu6yX_13fvm_ipld_hamt7pointerINtB5_7PointerNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtB7_14hash_algorithm6Sha256EINtNtCsiloedr2K6v7_4core7convert7TryFromNtNtCs3TS9n28v4Rl_12libipld_core4ipld4IpldE8try_fromCsboUdcTbF1FS_15direct_syscalls:
   65|    954|    fn try_from(ipld: Ipld) -> Result<Self, Self::Error> {
   66|    954|        match ipld {
   67|    954|            ipld_list @ Ipld::List(_) => {
   68|    954|                let values: Vec<KeyValuePair<K, V>> = from_ipld(ipld_list)?;
   69|    954|                Ok(Self::Values(values))
   70|       |            }
   71|      0|            Ipld::Link(cid) => Ok(Self::Link {
   72|      0|                cid,
   73|      0|                cache: Default::default(),
   74|      0|            }),
   75|      0|            other => Err(format!(
   76|      0|                "Expected `Ipld::List` or `Ipld::Link`, got {:#?}",
   77|      0|                other
   78|      0|            )),
   79|       |        }
   80|    954|    }
_RNvMs3_NtCslH3pn9Bu6yX_13fvm_ipld_hamt7pointerINtB5_7PointerNtNtCsMEM5GKmsj7_17forest_hash_utils3key8BytesKeyNtNtCskJihg1y13m7_3fvm10state_tree10ActorStateNtNtB7_14hash_algorithm6Sha256E14from_key_valueCsboUdcTbF1FS_15direct_syscalls:
  109|    954|    pub(crate) fn from_key_value(key: K, value: V) -> Self {
  110|    954|        Pointer::Values(vec![KeyValuePair::new(key, value)])
  111|    954|    }

_RNvMs_NtCs83Z8YCK0meJ_10fvm_shared7addressNtB4_7Address8to_bytes:
  170|    954|    pub fn to_bytes(self) -> Vec<u8> {
  171|    954|        self.payload.to_bytes()
  172|    954|    }
_RNvMs_NtCs83Z8YCK0meJ_10fvm_shared7addressNtB4_7Address6new_id:
   98|  1.27k|    pub const fn new_id(id: u64) -> Self {
   99|  1.27k|        Self {
  100|  1.27k|            payload: Payload::ID(id),
  101|  1.27k|        }
  102|  1.27k|    }
_RNvNtCs83Z8YCK0meJ_10fvm_shared7address12to_leb_bytes:
  371|    954|pub(crate) fn to_leb_bytes(id: u64) -> Vec<u8> {
  372|    954|    // write id to buffer in leb128 format
  373|    954|    unsigned_varint::encode::u64(id, &mut unsigned_varint::encode::u64_buffer()).into()
  374|    954|}

_RNvMs_NtNtCs83Z8YCK0meJ_10fvm_shared7address7payloadNtB4_7Payload12to_raw_bytes:
  107|    954|    pub fn to_raw_bytes(self) -> Vec<u8> {
  108|    954|        use Payload::*;
  109|    954|        match self {
  110|    954|            ID(i) => to_leb_bytes(i),
  111|      0|            Secp256k1(arr) => arr.to_vec(),
  112|      0|            Actor(arr) => arr.to_vec(),
  113|      0|            BLS(arr) => arr.to_vec(),
  114|      0|            Delegated(addr) => {
  115|      0|                let mut buf = to_leb_bytes(addr.namespace());
  116|      0|                buf.extend(addr.subaddress());
  117|      0|                buf
  118|       |            }
  119|       |        }
  120|    954|    }
_RNvXs0_NtNtCs83Z8YCK0meJ_10fvm_shared7address7payloadNtNtB7_8protocol8ProtocolINtNtCsiloedr2K6v7_4core7convert4FromNtB5_7PayloadE4from:
  158|    954|    fn from(pl: Payload) -> Self {
  159|    954|        match pl {
  160|    954|            Payload::ID(_) => Self::ID,
  161|      0|            Payload::Secp256k1(_) => Self::Secp256k1,
  162|      0|            Payload::Actor(_) => Self::Actor,
  163|      0|            Payload::BLS(_) => Self::BLS,
  164|      0|            Payload::Delegated { .. } => Self::Delegated,
  165|       |        }
  166|    954|    }
_RNvMs_NtNtCs83Z8YCK0meJ_10fvm_shared7address7payloadNtB4_7Payload8to_bytes:
  123|    954|    pub fn to_bytes(self) -> Vec<u8> {
  124|    954|        let mut bz = self.to_raw_bytes();
  125|    954|        bz.insert(0, Protocol::from(self) as u8);
  126|    954|        bz
  127|    954|    }

_RINvNtNtCs83Z8YCK0meJ_10fvm_shared6bigint10bigint_ser9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECsboUdcTbF1FS_15direct_syscalls:
   24|    954|pub fn serialize<S>(int: &BigInt, serializer: S) -> Result<S::Ok, S::Error>
   25|    954|where
   26|    954|    S: serde::Serializer,
   27|    954|{
   28|    954|    let (sign, mut bz) = int.to_bytes_be();
   29|    954|
   30|    954|    // Insert sign byte at start of encoded bytes
   31|    954|    match sign {
   32|      0|        Sign::Minus => bz.insert(0, 1),
   33|      0|        Sign::Plus => bz.insert(0, 0),
   34|    954|        Sign::NoSign => bz = Vec::new(),
   35|       |    }
   36|       |
   37|    954|    if bz.len() > MAX_BIGINT_SIZE {
   38|      0|        return Err(<S::Error as serde::ser::Error>::custom("BigInt too large"));
   39|    954|    }
   40|    954|
   41|    954|    // Serialize as bytes
   42|    954|    strict_bytes::Serialize::serialize(&bz, serializer)
   43|    954|}
_RINvNtNtCs83Z8YCK0meJ_10fvm_shared6bigint10bigint_ser11deserializeNtNtCs3TS9n28v4Rl_12libipld_core4ipld4IpldECsboUdcTbF1FS_15direct_syscalls:
   46|    954|pub fn deserialize<'de, D>(deserializer: D) -> Result<BigInt, D::Error>
   47|    954|where
   48|    954|    D: serde::Deserializer<'de>,
   49|    954|{
   50|    954|    let bz: Cow<'de, [u8]> = strict_bytes::Deserialize::deserialize(deserializer)?;
   51|    954|    if bz.is_empty() {
   52|    954|        return Ok(BigInt::default());
   53|      0|    }
   54|      0|    let sign_byte = bz[0];
   55|      0|    let sign: Sign = match sign_byte {
   56|      0|        1 => Sign::Minus,
   57|      0|        0 => Sign::Plus,
   58|       |        _ => {
   59|      0|            return Err(serde::de::Error::custom(
   60|      0|                "First byte must be valid sign (0, 1)",
   61|      0|            ));
   62|       |        }
   63|       |    };
   64|       |
   65|      0|    if bz.len() > MAX_BIGINT_SIZE {
   66|      0|        return Err(<D::Error as serde::de::Error>::custom("BigInt too large"));
   67|      0|    }
   68|      0|
   69|      0|    Ok(BigInt::from_bytes_be(sign, &bz[1..]))
   70|    954|}

_RNvXs0_NtCs83Z8YCK0meJ_10fvm_shared7chainidNtB5_7ChainIDNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
    4|    954|#[derive(Clone, Copy, Debug, Eq, PartialEq)]
_RNvXNtCs83Z8YCK0meJ_10fvm_shared7chainidNtB2_7ChainIDINtNtCsiloedr2K6v7_4core7convert4FromyE4from:
    8|    636|    fn from(src: u64) -> Self {
    9|    636|        Self(src)
   10|    636|    }

_RINvMNtCs83Z8YCK0meJ_10fvm_shared4econNtB3_11TokenAmount9from_attoyECsboUdcTbF1FS_15direct_syscalls:
   35|    318|    pub fn from_atto(atto: impl Into<BigInt>) -> Self {
   36|    318|        Self { atto: atto.into() }
   37|    318|    }
_RINvXsh_NtCs83Z8YCK0meJ_10fvm_shared4econNtB6_11TokenAmountNtNtCssVaLrL3Upj_5serde3ser9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECsboUdcTbF1FS_15direct_syscalls:
  353|    954|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  354|    954|    where
  355|    954|        S: Serializer,
  356|    954|    {
  357|    954|        bigint_ser::serialize(&self.atto, serializer)
  358|    954|    }
_RNvXsj_NtCs83Z8YCK0meJ_10fvm_shared4econNtB5_11TokenAmountNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
   20|  1.90k|#[derive(Clone, PartialEq, Eq, Hash)]
_RINvMNtCs83Z8YCK0meJ_10fvm_shared4econNtB3_11TokenAmount9from_attoNtNtCs9v2qPOzmHo1_10num_bigint6bigint6BigIntECsboUdcTbF1FS_15direct_syscalls:
   35|    636|    pub fn from_atto(atto: impl Into<BigInt>) -> Self {
   36|    636|        Self { atto: atto.into() }
   37|    636|    }
_RNCINvXsi_NtCs83Z8YCK0meJ_10fvm_shared4econNtB8_11TokenAmountNtNtCssVaLrL3Upj_5serde2de11Deserialize11deserializeNtNtCs3TS9n28v4Rl_12libipld_core4ipld4IpldE0CsboUdcTbF1FS_15direct_syscalls:
  366|    954|        bigint_ser::deserialize(deserializer).map(|v| TokenAmount { atto: v })
_RINvXsi_NtCs83Z8YCK0meJ_10fvm_shared4econNtB6_11TokenAmountNtNtCssVaLrL3Upj_5serde2de11Deserialize11deserializeNtNtCs3TS9n28v4Rl_12libipld_core4ipld4IpldECsboUdcTbF1FS_15direct_syscalls:
  362|    954|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  363|    954|    where
  364|    954|        D: serde::Deserializer<'de>,
  365|    954|    {
  366|    954|        bigint_ser::deserialize(deserializer).map(|v| TokenAmount { atto: v })
  367|    954|    }
_RNvXs_NtCs83Z8YCK0meJ_10fvm_shared4econNtB4_11TokenAmountNtNtCsaOMW4gJp9Em_10num_traits10identities4Zero4zero:
   72|  1.27k|    fn zero() -> Self {
   73|  1.27k|        Self {
   74|  1.27k|            atto: BigInt::zero(),
   75|  1.27k|        }
   76|  1.27k|    }
_RNvXs2_NtCs83Z8YCK0meJ_10fvm_shared4econNtB5_11TokenAmountNtNtCsiloedr2K6v7_4core7default7Default7default:
  100|    954|    fn default() -> TokenAmount {
  101|    954|        TokenAmount::zero()
  102|    954|    }
_RINvMNtCs83Z8YCK0meJ_10fvm_shared4econNtB3_11TokenAmount9from_attoNtNtCs9v2qPOzmHo1_10num_bigint6bigint6BigIntEB5_:
   35|      1|    pub fn from_atto(atto: impl Into<BigInt>) -> Self {
   36|      1|        Self { atto: atto.into() }
   37|      1|    }
_RINvMNtCs83Z8YCK0meJ_10fvm_shared4econNtB3_11TokenAmount10from_wholexEB5_:
   48|      1|    pub fn from_whole(tokens: impl Into<BigInt>) -> Self {
   49|      1|        Self::from_atto(tokens.into() * Self::PRECISION)
   50|      1|    }
_RNvMNtCs83Z8YCK0meJ_10fvm_shared4econNtB2_11TokenAmount4atto:
   53|    318|    pub fn atto(&self) -> &BigInt {
   54|    318|        &self.atto
   55|    318|    }
_RNvXs4_NtCs83Z8YCK0meJ_10fvm_shared4econNtB5_11TokenAmountNtNtCsiloedr2K6v7_4core3fmt7Display3fmt:
  122|    318|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  123|    318|        // Implementation based on the bigdecimal library.
  124|    318|        let (q, r) = self.atto.div_rem(&BigInt::from(Self::PRECISION));
  125|    318|        let before_decimal = q.abs().to_str_radix(10);
  126|    318|        let after_decimal = if r.is_zero() {
  127|      0|            "0".to_string()
  128|       |        } else {
  129|    318|            let fraction_str = r.abs().to_str_radix(10);
  130|    318|            let render = "0".repeat(Self::DECIMALS - fraction_str.len()) + fraction_str.as_str();
  131|    318|            render.trim_end_matches('0').to_string()
  132|       |        };
  133|       |
  134|       |        // Alter precision after the decimal point
  135|    318|        let after_decimal = if let Some(precision) = f.precision() {
  136|      0|            let len = after_decimal.len();
  137|      0|            if len < precision {
  138|      0|                after_decimal + "0".repeat(precision - len).as_str()
  139|       |            } else {
  140|      0|                after_decimal[0..precision].to_string()
  141|       |            }
  142|       |        } else {
  143|    318|            after_decimal
  144|       |        };
  145|       |
  146|       |        // Always show the decimal point, even with ".0".
  147|    318|        let complete_without_sign = before_decimal + "." + after_decimal.as_str();
  148|    318|        // Padding works even though we have a decimal point.
  149|    318|        f.pad_integral(!self.atto().is_negative(), "", &complete_without_sign)
  150|    318|    }

_RNvXsj_NtNtCs83Z8YCK0meJ_10fvm_shared6sector16registered_proofNtB5_19RegisteredSealProofNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
   15|      2|#[derive(PartialEq, Eq, Copy, Clone, Debug, Hash)]
_RINvXsl_NtNtCs83Z8YCK0meJ_10fvm_shared6sector16registered_proofNtB6_19RegisteredSealProofNtNtCsiloedr2K6v7_4core4hash4Hash4hashNtNtNtNtCsdyNNmftaNAQ_3std11collections4hash3map13DefaultHasherECskJihg1y13m7_3fvm:
   15|      4|#[derive(PartialEq, Eq, Copy, Clone, Debug, Hash)]
_RINvXst_NtNtCs83Z8YCK0meJ_10fvm_shared6sector16registered_proofNtB6_19RegisteredPoStProofNtNtCsiloedr2K6v7_4core4hash4Hash4hashNtNtNtNtCsdyNNmftaNAQ_3std11collections4hash3map13DefaultHasherECskJihg1y13m7_3fvm:
   98|      3|#[derive(PartialEq, Eq, Copy, Clone, Debug, Hash)]

_RINvXNvXNvNvXs9_NtCs83Z8YCK0meJ_10fvm_shared5stateNtBe_9StateRootNtNtCssVaLrL3Upj_5serde2de11Deserialize11deserialize1__NtB8_5InnerB11_11deserializeNtB3_9___VisitorNtB13_7Visitor9visit_seqINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de8AccessorNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECsboUdcTbF1FS_15direct_syscalls:
   31|    318|#[derive(Deserialize_tuple, Serialize_tuple)]
_RINvXsa_NtCs83Z8YCK0meJ_10fvm_shared5stateNtB6_9StateRootNtNtCssVaLrL3Upj_5serde3ser9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECsboUdcTbF1FS_15direct_syscalls:
   31|    318|#[derive(Deserialize_tuple, Serialize_tuple)]
_RINvXs8_NtCs83Z8YCK0meJ_10fvm_shared5stateNtB6_16StateTreeVersionNtNtCssVaLrL3Upj_5serde2de11Deserialize11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECsboUdcTbF1FS_15direct_syscalls:
   12|    318|#[derive(Debug, PartialEq, Eq, Clone, Copy, PartialOrd, Serialize_repr, Deserialize_repr)]
_RINvXs9_NtCs83Z8YCK0meJ_10fvm_shared5stateNtB6_9StateRootNtNtCssVaLrL3Upj_5serde2de11Deserialize11deserializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEECsboUdcTbF1FS_15direct_syscalls:
   31|    318|#[derive(Deserialize_tuple, Serialize_tuple)]
_RINvXNvNvXsa_NtCs83Z8YCK0meJ_10fvm_shared5stateNtBb_9StateRootNtNtCssVaLrL3Upj_5serde3ser9Serialize9serialize1__NtB5_5InnerBY_9serializeINtCscrDzOC3hEIR_11serde_tuple10SerializerQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEEECsboUdcTbF1FS_15direct_syscalls:
   31|    318|#[derive(Deserialize_tuple, Serialize_tuple)]
_RINvXs7_NtCs83Z8YCK0meJ_10fvm_shared5stateNtB6_16StateTreeVersionNtNtCssVaLrL3Upj_5serde3ser9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECsboUdcTbF1FS_15direct_syscalls:
   12|    318|#[derive(Debug, PartialEq, Eq, Clone, Copy, PartialOrd, Serialize_repr, Deserialize_repr)]
_RINvXNvNvXs9_NtCs83Z8YCK0meJ_10fvm_shared5stateNtBb_9StateRootNtNtCssVaLrL3Upj_5serde2de11Deserialize11deserialize1__NtB5_5InnerBY_11deserializeINtCscrDzOC3hEIR_11serde_tuple12DeserializerQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor2de12DeserializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils11SliceReaderEEECsboUdcTbF1FS_15direct_syscalls:
   31|    318|#[derive(Deserialize_tuple, Serialize_tuple)]
_RINvXNvNtCs83Z8YCK0meJ_10fvm_shared5states_1__NtB5_10StateInfo0NtNtCssVaLrL3Upj_5serde3ser9Serialize9serializeQINtNtCshf5gyM0YXBy_18serde_ipld_dagcbor3ser10SerializerNtNtNtCs7tbBVnmGocF_7cbor4ii4core5utils9BufWriterEECs7AwuCMXPzRZ_8fvm_fuzz:
   46|    318|#[derive(Default, Deserialize, Serialize)]
_RNvXsb_NtCs83Z8YCK0meJ_10fvm_shared5stateNtB5_10StateInfo0NtNtCsiloedr2K6v7_4core7default7Default7default:
   46|    318|#[derive(Default, Deserialize, Serialize)]

_RNvXs8_NtCs83Z8YCK0meJ_10fvm_shared7versionNtB5_14NetworkVersionNtNtCsiloedr2K6v7_4core3cmp10PartialOrd11partial_cmp:
   10|    636|#[derive(Debug, Eq, PartialEq, Clone, Copy, Ord, PartialOrd, Serialize_repr)]
_RNvXs5_NtCs83Z8YCK0meJ_10fvm_shared7versionNtB5_14NetworkVersionNtNtCsiloedr2K6v7_4core5clone5Clone5clone:
   10|    954|#[derive(Debug, Eq, PartialEq, Clone, Copy, Ord, PartialOrd, Serialize_repr)]
_RNvXs0_NtCs83Z8YCK0meJ_10fvm_shared7versionNtB5_14NetworkVersionNtNtCsiloedr2K6v7_4core3fmt5Debug3fmt:
   10|    318|#[derive(Debug, Eq, PartialEq, Clone, Copy, Ord, PartialOrd, Serialize_repr)]

_RINvNtCsh74LAqVwWKW_21fvm_integration_tests7builtin13set_sys_actorNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreECs7AwuCMXPzRZ_8fvm_fuzz:
   31|    318|pub fn set_sys_actor(
   32|    318|    state_tree: &mut StateTree<impl Blockstore>,
   33|    318|    sys_state: system_actor::State,
   34|    318|    sys_code_cid: Cid,
   35|    318|) -> Result<()> {
   36|    318|    let sys_state_cid = state_tree
   37|    318|        .store()
   38|    318|        .put_cbor(&sys_state, Code::Blake2b256)
   39|    318|        .context(FailedToSetState("system actor".to_owned()))?;
   40|       |
   41|    318|    let sys_actor_state = ActorState {
   42|    318|        code: sys_code_cid,
   43|    318|        state: sys_state_cid,
   44|    318|        sequence: 0,
   45|    318|        balance: Default::default(),
   46|    318|        address: None,
   47|    318|    };
   48|    318|    state_tree
   49|    318|        .set_actor(system_actor::SYSTEM_ACTOR_ID, sys_actor_state)
   50|    318|        .map_err(anyhow::Error::from)
   51|    318|        .context(FailedToSetActor("system actor".to_owned()))
   52|    318|}
_RINvNtCsh74LAqVwWKW_21fvm_integration_tests7builtin22fetch_builtin_code_cidNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreECs7AwuCMXPzRZ_8fvm_fuzz:
   16|    318|pub fn fetch_builtin_code_cid(
   17|    318|    blockstore: &impl Blockstore,
   18|    318|    builtin_actors: &Cid,
   19|    318|    ver: u32,
   20|    318|) -> Result<(Cid, Cid, Cid, Cid, Cid)> {
   21|    318|    let manifest = Manifest::load(blockstore, builtin_actors, ver).context(FailedToLoadManifest)?;
   22|    318|    Ok((
   23|    318|        *manifest.get_system_code(),
   24|    318|        *manifest.get_init_code(),
   25|    318|        *manifest.get_account_code(),
   26|    318|        *manifest.get_embryo_code(),
   27|    318|        *manifest.get_eam_code(),
   28|    318|    ))
   29|    318|}
_RINvNtCsh74LAqVwWKW_21fvm_integration_tests7builtin14set_init_actorNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreECs7AwuCMXPzRZ_8fvm_fuzz:
   54|    318|pub fn set_init_actor(
   55|    318|    state_tree: &mut StateTree<impl Blockstore>,
   56|    318|    init_code_cid: Cid,
   57|    318|    init_state: init_actor::State,
   58|    318|) -> Result<()> {
   59|    318|    let init_state_cid = state_tree
   60|    318|        .store()
   61|    318|        .put_cbor(&init_state, Code::Blake2b256)
   62|    318|        .context(FailedToSetState("init actor".to_owned()))?;
   63|       |
   64|    318|    let init_actor_state = ActorState {
   65|    318|        code: init_code_cid,
   66|    318|        state: init_state_cid,
   67|    318|        sequence: 0,
   68|    318|        balance: Default::default(),
   69|    318|        address: None,
   70|    318|    };
   71|    318|
   72|    318|    state_tree
   73|    318|        .set_actor(init_actor::INIT_ACTOR_ID, init_actor_state)
   74|    318|        .map_err(anyhow::Error::from)
   75|    318|        .context(FailedToSetActor("init actor".to_owned()))
   76|    318|}
_RINvNtCsh74LAqVwWKW_21fvm_integration_tests7builtin13set_eam_actorNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreECs7AwuCMXPzRZ_8fvm_fuzz:
   78|    318|pub fn set_eam_actor(state_tree: &mut StateTree<impl Blockstore>, eam_code_cid: Cid) -> Result<()> {
   79|       |    const EAM_ACTOR_ID: ActorID = 10;
   80|       |
   81|    318|    let eam_state_cid = state_tree
   82|    318|        .store()
   83|    318|        .put_cbor(&[(); 0], Code::Blake2b256)
   84|    318|        .context(FailedToSetState("eam actor".to_owned()))?;
   85|       |
   86|    318|    let eam_actor_state = ActorState {
   87|    318|        code: eam_code_cid,
   88|    318|        state: eam_state_cid,
   89|    318|        sequence: 0,
   90|    318|        balance: Default::default(),
   91|    318|        address: None,
   92|    318|    };
   93|    318|
   94|    318|    state_tree
   95|    318|        .set_actor(EAM_ACTOR_ID, eam_actor_state)
   96|    318|        .map_err(anyhow::Error::from)
   97|    318|        .context(FailedToSetActor("eam actor".to_owned()))
   98|    318|}

_RINvNtCsh74LAqVwWKW_21fvm_integration_tests6bundle13import_bundleNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreECs7AwuCMXPzRZ_8fvm_fuzz:
   10|    318|pub fn import_bundle(blockstore: &impl Blockstore, bundle: &[u8]) -> anyhow::Result<Cid> {
   11|    318|    match &*block_on(async { load_car_unchecked(blockstore, bundle).await })? {
   12|    318|        [root] => Ok(*root),
   13|      0|        _ => Err(anyhow!("multiple root CIDs in bundle")),
   14|       |    }
   15|    318|}
_RNCINvNtCsh74LAqVwWKW_21fvm_integration_tests6bundle13import_bundleNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreE0Cs7AwuCMXPzRZ_8fvm_fuzz:
   11|    318|    match &*block_on(async { load_car_unchecked(blockstore, bundle).await })? {

_RNCNvMNtCsh74LAqVwWKW_21fvm_integration_tests6testerINtB4_6TesterNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtB6_5dummy12DummyExternsE19instantiate_machine0CsboUdcTbF1FS_15direct_syscalls:
  221|    318|        self.instantiate_machine_with_config(externs, |_| (), |_| ())
_RNvMNtCsh74LAqVwWKW_21fvm_integration_tests6testerINtB2_6TesterNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtB4_5dummy12DummyExternsE19instantiate_machineCsboUdcTbF1FS_15direct_syscalls:
  220|    318|    pub fn instantiate_machine(&mut self, externs: E) -> Result<()> {
  221|    318|        self.instantiate_machine_with_config(externs, |_| (), |_| ())
  222|    318|    }
_RINvMNtCsh74LAqVwWKW_21fvm_integration_tests6testerINtB3_6TesterNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtB5_5dummy12DummyExternsE31instantiate_machine_with_configNCNvB2_19instantiate_machine0NCB33_s_0ECsboUdcTbF1FS_15direct_syscalls:
  229|    318|    pub fn instantiate_machine_with_config<F, G>(
  230|    318|        &mut self,
  231|    318|        externs: E,
  232|    318|        configure_nc: F,
  233|    318|        configure_mc: G,
  234|    318|    ) -> Result<()>
  235|    318|    where
  236|    318|        F: FnOnce(&mut NetworkConfig),
  237|    318|        G: FnOnce(&mut MachineContext),
  238|    318|    {
  239|    318|        // Take the state tree and leave None behind.
  240|    318|        let mut state_tree = self.state_tree.take().unwrap();
  241|       |
  242|       |        // Calculate the state root.
  243|    318|        let state_root = state_tree
  244|    318|            .flush()
  245|    318|            .map_err(anyhow::Error::from)
  246|    318|            .context(FailedToFlushTree)?;
  247|       |
  248|       |        // Consume the state tree and take the blockstore.
  249|    318|        let blockstore = state_tree.into_store();
  250|    318|
  251|    318|        let mut nc = NetworkConfig::new(self.nv);
  252|    318|        nc.override_actors(self.builtin_actors);
  253|    318|        nc.enable_actor_debugging();
  254|    318|
  255|    318|        // Custom configuration.
  256|    318|        configure_nc(&mut nc);
  257|    318|
  258|    318|        let mut mc = nc.for_epoch(0, 0, state_root);
  259|    318|        mc.set_base_fee(TokenAmount::from_atto(DEFAULT_BASE_FEE))
  260|    318|            .enable_tracing();
  261|    318|
  262|    318|        // Custom configuration.
  263|    318|        configure_mc(&mut mc);
  264|       |
  265|    318|        let engine = EnginePool::new_default((&mc.network.clone()).into())?;
  266|    318|        engine.acquire().preload(&blockstore, &self.code_cids)?;
  267|       |
  268|    318|        let machine = DefaultMachine::new(&mc, blockstore, externs)?;
  269|       |
  270|    318|        let executor =
  271|    318|            DefaultExecutor::<DefaultKernel<DefaultCallManager<DefaultMachine<B, E>>>>::new(
  272|    318|                engine, machine,
  273|    318|            )?;
  274|       |
  275|    318|        self.executor = Some(executor);
  276|    318|
  277|    318|        Ok(())
  278|    318|    }
_RNCNvMNtCsh74LAqVwWKW_21fvm_integration_tests6testerINtB4_6TesterNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtB6_5dummy12DummyExternsE19instantiate_machines_0CsboUdcTbF1FS_15direct_syscalls:
  221|    318|        self.instantiate_machine_with_config(externs, |_| (), |_| ())
_RNvMNtCsh74LAqVwWKW_21fvm_integration_tests6testerINtB2_6TesterNtNtCs23Y5vRLZE35_19fvm_ipld_blockstore6memory16MemoryBlockstoreNtNtB4_5dummy12DummyExternsE3newCs7AwuCMXPzRZ_8fvm_fuzz:
   61|    318|    pub fn new(
   62|    318|        nv: NetworkVersion,
   63|    318|        stv: StateTreeVersion,
   64|    318|        builtin_actors: Cid,
   65|    318|        blockstore: B,
   66|    318|    ) -> Result<Self> {
   67|    318|        let (manifest_version, manifest_data_cid): (u32, Cid) =
   68|    318|            match blockstore.get_cbor(&builtin_actors)? {
   69|    318|                Some((manifest_version, manifest_data)) => (manifest_version, manifest_data),
   70|      0|                None => return Err(NoManifestInformation(builtin_actors).into()),
   71|       |            };
   72|       |
   73|       |        // Get sys and init actors code cid
   74|    318|        let (sys_code_cid, init_code_cid, accounts_code_cid, embryo_code_cid, eam_code_cid) =
   75|    318|            fetch_builtin_code_cid(&blockstore, &manifest_data_cid, manifest_version)?;
   76|       |
   77|       |        // Initialize state tree
   78|    318|        let init_state = init_actor::State::new_test(&blockstore);
   79|    318|        let mut state_tree = StateTree::new(blockstore, stv).map_err(anyhow::Error::from)?;
   80|       |
   81|       |        // Deploy init, sys, and eam actors
   82|    318|        let sys_state = system_actor::State { builtin_actors };
   83|    318|        set_sys_actor(&mut state_tree, sys_state, sys_code_cid)?;
   84|    318|        set_init_actor(&mut state_tree, init_code_cid, init_state)?;
   85|    318|        set_eam_actor(&mut state_tree, eam_code_cid)?;
   86|       |
   87|    318|        Ok(Tester {
   88|    318|            nv,
   89|    318|            builtin_actors,
   90|    318|            executor: None,
   91|    318|            code_cids: vec![],
   92|    318|            state_tree: Some(state_tree),
   93|    318|            accounts_code_cid,
   94|    318|            embryo_code_cid,
   95|    318|        })
   96|    318|    }

